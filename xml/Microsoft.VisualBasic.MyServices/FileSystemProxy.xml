<Type Name="FileSystemProxy" FullName="Microsoft.VisualBasic.MyServices.FileSystemProxy">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ba27410f95dfbff3025e7893ef9a1957ffd98cc4" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36299003" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemProxy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FileSystemProxy extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.MyServices.FileSystemProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemProxy" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemProxy" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Включает свойства и методы для работы с дисками, файлами и каталогами.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem` объекта.  
  
|Кому|См.|  
|--------|---------|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Чтение из файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла фиксированной ширины|[Практическое руководство. Чтение из текстовых файлов с полями фиксированного размера](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Чтение из двоичного файла|[Практическое руководство. Чтение из двоичных файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Чтение из текстового файла с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Запись в текстовый файл|[Практическое руководство. Запись текста в файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавьте в текстовый файл|[Практическое руководство. Дозапись в текстовый файл](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Запись в двоичный файл|[Практическое руководство. Запись в двоичные файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Запись текста в файлы **Мои документы** каталога|[Практическое руководство. Запись текста в файлы в каталоге "Мои документы"](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Запись в текстовый файл с `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Копирование файлов по конкретному шаблону|[Практическое руководство. Копирование файлов по заданному шаблону в каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Скопируйте файл в тот же каталог|[Практическое руководство. Создание копии файла в том же каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другом каталоге|[Практическое руководство. Создание копии файла в другом каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Создание файла|[Практическое руководство. Создание файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Удаление файла|[Практическое руководство. Удаление файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Поиск файлов по конкретному шаблону|[Практическое руководство. Поиск файлов по конкретному шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Перемещение файла|[Практическое руководство. Перемещение файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Переименовать файл|[Практическое руководство. Переименование файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Копирование каталога в другой каталог|[Практическое руководство. Копирование каталога в другой каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Создание каталога|[Практическое руководство. Создание каталога](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Поиск подкаталогов по заданному шаблону|[Практическое руководство. Поиск подкаталогов по шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Получение коллекции содержащихся в каталоге файлов|[Практическое руководство. Получение коллекции содержащихся в каталоге файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Чтение из **Мои документы** каталога|[Практическое руководство. Извлечение содержимого каталога "Мои документы"](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Синтаксический анализ пути к файлу|[Практическое руководство. Анализ путей к файлам](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В этом примере проверяется, чтобы определить, является ли папка `C:\backup\logs` существует и ее свойства.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
  </Docs>
  <Members>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" />. Первый путь, который необходимо объединить.</param>
        <param name="relativePath">
          <see langword="String" />. Второй путь, который необходимо объединить.</param>
        <summary>Объединяет два пути и возвращает правильно отформатированный путь.</summary>
        <returns>Сочетание заданных путей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод удаляет лишние косые черты, чтобы создать путь в правильном формате.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CombinePath` метод.  
  
|Кому|См.|  
|--------|---------|  
|Объединить путь и имя каталога|[Практическое руководство. Анализ путей к файлам](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В этом примере объединяются путь и имя каталога для создания путь в правильном формате.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 В этом примере объединяются два пути для создания путь в правильном формате.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Этот пример возвращает `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь <paramref name="baseDirectory" /> или <paramref name="relativePath" /> сформирован неправильно.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует каталог в другой каталог.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать каталог.</param>
        <summary>Копирует каталог в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует и содержимое каталога, и сам каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в месте назначения, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные определенного файла. При возникновении таких исключений, они объединяются в одно исключение которого `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и возникновения содержится в соответствующее значение. Используйте `For…Each` для перебора записей.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|--------|---------|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует каталог `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Копирует каталог в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует и содержимое каталога, и сам каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в месте назначения, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные определенного файла. При возникновении таких исключений, они объединяются в одно исключение которого `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и возникновения содержится в соответствующее значение. Используйте `For…Each` для перебора записей.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|--------|---------|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует каталог `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="ShowUI" /> имеет значение <see langword="UIOption.AllDialogs" />, а пользователь отменил операцию, или один или несколько файлов в каталоге не могут быть скопированы.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать каталог.</param>
        <param name="overwrite">Значение <see langword="True" /> для перезаписи существующих файлов; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Копирует каталог в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует и содержимое каталога, и сам каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в месте назначения, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные конкретного файла, например файл, существующий во время слияния при `overwrite` равно `False`. При возникновении таких исключений, они объединяются в одно исключение которого `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и возникновения содержится в соответствующее значение. Используйте `For…Each` для перебора записей.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|--------|---------|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует каталог `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Каталог, который необходимо скопировать.</param>
        <param name="destinationDirectoryName">Местоположение, в которое необходимо скопировать каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Определяет, что должно быть выполнено, если во время операции пользователь нажмет кнопку **Отмена**. Значение по умолчанию — <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Копирует каталог в другой каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод копирует и содержимое каталога, и сам каталог. Если целевой каталог не существует, он создается. Если каталог с тем же именем существует в месте назначения, содержимое двух каталогов объединяется. Во время операции можно указать новое имя для каталога.  
  
 При копировании файлов в каталоге, могут быть исключения, вызванные определенного файла. При возникновении таких исключений, они объединяются в одно исключение которого `Data` свойство содержит записи в виде <xref:System.Collections.IDictionary> путь к файлу или каталогу является ключом и возникновения содержится в соответствующее значение. Используйте `For…Each` для перебора записей.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyDirectory` метод.  
  
|Кому|См.|  
|--------|---------|  
|Копирование каталога|[Практическое руководство. Копирование каталога в другой каталог](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 Следующий пример копирует каталог `TestDirectory1` в `TestDirectory2`, перезаписывая существующие файлы.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Замените `C:\TestDirectory1` и `C:\TestDirectory2` путь и имя каталога, необходимо скопировать и расположение, к которому вы хотите скопировать его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> или <paramref name="sourceDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Исходный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Исходный и конечный пути совпадают.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя папки в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Конечный файл существует, но к нему нет доступа.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="ShowUI" /> имеет значение <see langword="UIOption.AllDialogs" />, а пользователь отменил операцию, или один или несколько файлов в каталоге не могут быть скопированы.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует файл в новое местоположение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет записи управления доступом (записи управления доступом). Вновь созданный файл наследует по умолчанию записи ACE из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другом каталоге.|[Практическое руководство. Создание копии файла в другом каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл в целевом каталоге с тем же именем уже используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет записи управления доступом (записи управления доступом). Вновь созданный файл наследует по умолчанию записи ACE из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другом каталоге.|[Практическое руководство. Создание копии файла в другом каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="overwrite">Значение <see langword="True" />, если нужно перезаписывать существующие файлы; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет записи управления доступом (записи управления доступом). Вновь созданный файл наследует по умолчанию записи ACE из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другом каталоге.|[Практическое руководство. Создание копии файла в другом каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Файл, который необходимо скопировать.</param>
        <param name="destinationFileName">Местоположение, в которое необходимо скопировать файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Определяет, что должно быть выполнено, если во время операции пользователь нажмет кнопку **Отмена**. Значение по умолчанию — <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Копирует файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` не сохраняет записи управления доступом (записи управления доступом). Вновь созданный файл наследует по умолчанию записи ACE из каталога, в котором он создан.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CopyFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Скопируйте файл в тот же каталог.|[Практическое руководство. Создание копии файла в том же каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Скопируйте файл в другом каталоге.|[Практическое руководство. Создание копии файла в другом каталоге](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` без перезаписи существующих файлов.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 Этот пример копирует файл `Test.txt` в каталог `TestFiles2` и переименовывает его `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Замените пути к файлам контуры, которые вы хотите использовать в коде.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> или <paramref name="sourceFileName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Конечный файл существует, а параметр <paramref name="overwrite" /> имеет значение <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> имеет значение <see langword="ThrowException" />, а пользователь отменил операцию, или возникла ошибка ввода-вывода.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDirectory(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Имя и местоположение каталога.</param>
        <summary>Создает каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог уже существует, исключение не возникает.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.CreateDirectory` метод.  
  
|Кому|См.|  
|--------|---------|  
|Создание каталога|[Практическое руководство. Создание каталога](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 В этом примере создается каталог `NewDirectory`в `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Неверное имя каталога. Например, оно содержит недопустимые символы или состоит только из пробелов.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Имя каталога имеет слишком большую длину.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога состоит только из двоеточия (:).</exception>
        <exception cref="T:System.IO.IOException">Родительский каталог создаваемого каталога доступен только для чтения.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет разрешения на создание каталога.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущий каталог.</summary>
        <value>Текущий каталог для файловых операций ввода-вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` — это переменная среды уровня системы.  
  
   
  
## Examples  
 Этот пример возвращает текущий каталог и отображает его в окне сообщения.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 В этом примере задает текущий каталог `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый путь.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет каталог.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="onDirectoryNotEmpty">Указывает, какие действия должны выполняться, когда удаляемый каталог содержит файлы или каталоги. Значение по умолчанию — <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В примере выполняется удаление каталога `OldDirectory` только в том случае, если она пуста.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое запросом на подтверждение удаления, но не отправляет содержимое в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое, направлять их в **корзины**, но не показан ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI` И `recycle` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
   
  
## Examples  
 В примере выполняется удаление каталога `OldDirectory` только в том случае, если она пуста.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое запросом на подтверждение удаления, но не отправляет содержимое в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое, направлять их в **корзины**, но не показан ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, который необходимо удалить.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Указывает, следует ли создавать исключение, если пользователь нажимает кнопку **Отмена**.</param>
        <summary>Удаляет каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI`, `recycle`, И `onUserCancel` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
   
  
## Examples  
 В примере выполняется удаление каталога `OldDirectory` только в том случае, если она пуста.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое запросом на подтверждение удаления, но не отправляет содержимое в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 В этом примере удаляется каталог `OldDirectory` и все ее содержимое, направлять их в **корзины**, но не показан ход выполнения операции.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является пустой строкой, некорректен, содержит только пробелы или содержит недопустимые символы (включая знаки подстановки). Путь является путем к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует или является файлом.</exception>
        <exception cref="T:System.IO.IOException">Файл в каталоге или подкаталоге используется.</exception>
        <exception cref="T:System.NotSupportedException">Имя каталога содержит двоеточие (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет необходимых разрешений.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменяет операцию, или не удается удалить каталог.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.DeleteFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтобы удалить файл|[Практическое руководство. Удаление файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 В этом примере удаляется файл `Test.txt` и предоставляет пользователю для подтверждения удаления файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере удаляется файл `Test.txt` и отправляет ее в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI` И `recycle` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.DeleteFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтобы удалить файл|[Практическое руководство. Удаление файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 В этом примере удаляется файл `Test.txt` и предоставляет пользователю для подтверждения удаления файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере удаляется файл `Test.txt` и отправляет ее в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Путь к удаляемому файлу и его имя.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Указывает, нужно ли перемещать удаленный файл в **Корзину**. Значение по умолчанию — <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Удаляет файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `showUI`, `recycle`, И `onUserCancel` параметры не поддерживаются в приложениях, которые не являются интерактивными, такие как службы Windows для пользователя.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.DeleteFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтобы удалить файл|[Практическое руководство. Удаление файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 В этом примере удаляется файл `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 В этом примере удаляется файл `Test.txt` и предоставляет пользователю для подтверждения удаления файла.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 В этом примере удаляется файл `Test.txt` и отправляет ее в **корзины**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо оканчивается косой чертой там, где должен быть указан файл, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет разрешения на удаление файла, или файл доступен только для чтения.</exception>
        <exception cref="T:System.OperationCanceledException">Пользователь отменил операцию, и для параметра <paramref name="onUserCancel" /> установлено значение <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DirectoryExists(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу.</param>
        <summary>Возвращает значение <see langword="True" />, если указанный каталог существует.</summary>
        <returns>Значение <see langword="True" />, если каталог существует; в противном случае — значение <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Этот пример определяет, является ли каталог `C:\backup\logs` существует и ее свойства.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает доступную только для чтения коллекцию имен всех доступных дисков.</summary>
        <value>Доступная только для чтения коллекция всех доступных дисков в виде объектов <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает все логические диски.  
  
   
  
## Examples  
 Этот пример отображает имена доступных дисков в окне сообщения.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FileExists(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к файлу и его имя.</param>
        <summary>Возвращает значение <see langword="True" />, если указанный файл существует.</summary>
        <returns>Возвращает значение <see langword="True" />, если файл существует; в противном случае возвращает значение <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если приложение не имеет достаточных полномочий на чтение заданного файла, `FileExists` возвращает `False`, независимо от наличия пути; метод не вызывает исключение.  
  
   
  
## Examples  
 В этом примере проверяется, чтобы увидеть ли файл `Check.txt` существует и предоставляет сведения в окне сообщения.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается обратной косой чертой (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="containsText">Текст, поиск которого необходимо выполнить.</param>
        <param name="ignoreCase">Значение <see langword="True" />, если при поиске следует учитывать регистр; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="True" />.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
        <returns>Доступная только для чтения коллекция имен файлов, содержащих указанный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.FindInFiles` метод.  
  
|Кому|См.|  
|--------|---------|  
|Поиск в каталоге файлов, содержащих определенную строку|[Пошаговое руководство. Операции с файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 В этом примере ищет в каталоге `C:\TestDir` для всех файлов, содержащих строку `"sample string"` и отображает результаты в `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Для работы, проект должен содержать `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он представляет собой строку нулевой длины, либо содержит только пробелы, либо содержит недопустимые знаки, либо представляет собой путь к устройству (начинается с символов <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Указанный путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="containsText">Текст, поиск которого необходимо выполнить.</param>
        <param name="ignoreCase">Значение <see langword="True" />, если при поиске следует учитывать регистр; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="True" />.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Шаблон, которому необходимо соответствовать.</param>
        <summary>Возвращает доступный только для чтения набор строк, представляющих собой имена файлов, которые содержат указанный текст.</summary>
        <returns>Доступная только для чтения коллекция имен файлов, содержащих указанный текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.FindInFiles` метод.  
  
|Кому|См.|  
|--------|---------|  
|Поиск в каталоге файлов, содержащих определенную строку|[Пошаговое руководство. Операции с файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 В этом примере ищет в каталоге `C:\TestDir` для всех файлов, содержащих строку `"sample string"` и отображает результаты в `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Для работы, проект должен содержать `ListBox` с именем `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он представляет собой строку нулевой длины, либо содержит только пробелы, либо содержит недопустимые знаки, либо представляет собой путь к устройству (начинается с символов <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Указанный путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу и его имя.</param>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
        <returns>Доступная только для чтения коллекция путей к подкаталогам в указанном каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.GetDirectories` метод.  
  
|Кому|См.|  
|--------|---------|  
|Список подкаталогов по заданному шаблону|[Практическое руководство. Поиск подкаталогов по шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Следующий пример возвращает все каталоги в структуре каталогов, которые содержат слово `Logs` в именах и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Путь к каталогу и его имя.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Шаблон, которому должны соответствовать имена.</param>
        <summary>Возвращает коллекцию строк, представляющих имена путей вложенных папок в каталоге.</summary>
        <returns>Доступная только для чтения коллекция путей к подкаталогам в указанном каталоге.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для указания определенного шаблона можно использовать параметр `wildcards` . Если требуется включить в поиск содержимое подкаталогов, присвойте параметру `searchType` значение `SearchAllSubDirectories`.  
  
 Если каталоги, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.GetDirectories` метод.  
  
|Кому|См.|  
|--------|---------|  
|Список подкаталогов по заданному шаблону|[Практическое руководство. Поиск подкаталогов по шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 Следующий пример возвращает все каталоги в структуре каталогов, которые содержат слово `Logs` в именах и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Один или несколько указанных подстановочных знаков являются <see langword="Nothing" />, пустой строкой или содержат только пробелы.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Заданный каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Заданный каталог указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" />. Путь к каталогу.</param>
        <summary>Возвращает объект <see cref="T:System.IO.DirectoryInfo" /> для указанного пути.</summary>
        <returns>Объект <see cref="T:System.IO.DirectoryInfo" /> для указанного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог не существует, исключение не создается до момента первого свойства для <xref:System.IO.DirectoryInfo> доступ к объекту.  
  
   
  
## Examples  
 В этом примере извлекаются <xref:System.IO.DirectoryInfo> для каталога `C:\Documents and Settings` и отображает каталог время создания последнего доступа и времени последнего времени записи.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directory" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Путь каталога содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Диск, который необходимо проверить.</param>
        <summary>Возвращает объект <see cref="T:System.IO.DriveInfo" /> для указанного диска.</summary>
        <returns>Объект <see cref="T:System.IO.DriveInfo" /> для указанного диска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DriveInfo> Класс моделирует диск и предоставляет методы и свойства для запроса сведений о диске. Используйте <xref:System.IO.DriveInfo> для определения того, какие диски доступны и являются тип дисков. Также можно запрашивать свойства для определения емкости и объема свободного места на диске.  
  
   
  
## Examples  
 Этот пример демонстрирует получение <xref:System.IO.DriveInfo> объект для диска C и использует его для отображения сведений о диске.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Сведения о дисках различных типов см. в разделе <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="drive" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Путь к файлу и его имя.</param>
        <summary>Возвращает объект <see cref="T:System.IO.FileInfo" /> для указанного файла.</summary>
        <returns>Объект <see cref="T:System.IO.FileInfo" /> для указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение не возникает, если файл не существует; Вместо этого они будут созданы при первом запуске доступа к свойствам объекта.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.GetFileInfo` метод.  
  
|Кому|См.|  
|--------|---------|  
|Определите путь и имя файла|[Практическое руководство. Анализ путей к файлам](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 В этом примере извлекается <xref:System.IO.FileInfo?displayProperty=nameWithType> для файла `MyLogFile.log` и использует его для полного имени файла, время последнего доступа и длины.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое имя пути Например, оно содержит недопустимые символы или состоит из пробела. В конце имени файла указана косая черта.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="file" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.NotSupportedException">Путь содержит двоеточие в середине строки.</exception>
        <exception cref="T:System.IO.PathTooLongException">Слишком длинный путь.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет доступа к списку управления доступом (ACL) файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
        <returns>Доступная только для чтения коллекция имен файлов из указанного каталога.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.GetFiles` метод.  
  
|Кому|См.|  
|--------|---------|  
|Получение коллекции содержащихся в каталоге файлов|[Практическое руководство. Получение коллекции содержащихся в каталоге файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Поиск файлов по заданному шаблону в каталог|[Практическое руководство. Поиск файлов по конкретному шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются и добавляются в список `ListBox1` все файлы, находящиеся в каталоге.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 В этом примере возвращаются все файлы в каталоге с расширением `.txt` и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="directory" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, где следует выполнить поиск, не существует.</exception>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="directory" /> указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Каталог, в котором необходимо выполнить поиск.</param>
        <param name="searchType">Указывает, нужно ли включать вложенные папки. Значение по умолчанию — <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Шаблон, которому необходимо соответствовать.</param>
        <summary>Возвращает коллекцию строк только для чтения, представляющих имена путей к файлам в папке.</summary>
        <returns>Доступная только для чтения коллекция имен файлов из указанного каталога.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файлы, соответствующие указанному шаблону, не найдены, возвращается пустая коллекция.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.GetFiles` метод.  
  
|Кому|См.|  
|--------|---------|  
|Получение коллекции содержащихся в каталоге файлов|[Практическое руководство. Получение коллекции содержащихся в каталоге файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Поиск файлов по заданному шаблону в каталог|[Практическое руководство. Поиск файлов по конкретному шаблону](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 В следующем примере возвращаются и добавляются в список `ListBox1` все файлы, находящиеся в каталоге.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 В этом примере возвращаются все файлы в каталоге с расширением `.txt` и добавляет их в `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 В этом примере требуется наличие `ListBox` с именем `ListBox1` в форме.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="directory" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог, где следует выполнить поиск, не существует.</exception>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="directory" /> указывает на существующий файл.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У пользователя нет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetName(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Обязательно. Путь, синтаксический анализ которого нужно выполнить. <see langword="String" />.</param>
        <summary>Анализирует имя файла без указанного пути.</summary>
        <returns>Имя файла из указанного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это строковая операция; `FileSystem` не проверяется.  
  
 `GetName` Метод игнорирует косую черту в конце пути.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.GetFileName` метод.  
  
|Кому|См.|  
|--------|---------|  
|Синтаксический анализ пути к файлу|[Практическое руководство. Анализ путей к файлам](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Следующий пример выполняет синтаксический анализ пути к файлу и возвращает имя файла.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Замените пути `C:\Testdirectory\Testfile` с путем, который необходимо проанализировать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetParentPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, который необходимо проверить.</param>
        <summary>Возвращает родительский путь предоставленного пути.</summary>
        <returns>Родительский путь для заданного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это строковая операция; файловая система не проверяется.  
  
   
  
## Examples  
 В этом примере извлекаются родительский путь для `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь не имеет родительского пути, так как это корневой путь.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTempFileName();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает на диске временный пустой файл с уникальным именем и возвращает полный путь этого файла.</summary>
        <returns>
          <see langword="String" />, содержащая полный путь к временному файлу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для создания временного файла.  
  
   
  
## Examples  
 В этом примере создается временный файл и возвращает путь к нему.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Источник является корневым каталогом, либо исходный путь совпадает с целевым.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Целевой каталог уже существует, а параметру <paramref name="overwrite" /> присвоено значение <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="overwrite">Значение <see langword="True" />, если нужно перезаписывать существующие каталоги; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Целевой каталог уже существует, а параметру <paramref name="overwrite" /> присвоено значение <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Путь к каталогу, который необходимо переместить.</param>
        <param name="destinationDirectoryName">Путь к каталогу, в который необходимо переместить исходный каталог.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Перемещает каталог из одного местоположения в другое.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если попытка переместить каталог в каталоге, который не существует, создается в целевой структуре.  
  
   
  
## Examples  
 В этом примере перемещает `Directory1` внутри `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 В этом примере перемещает `Directory1` внутри `Directory2`, перезапись каталога, если он уже существует.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как он либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> или <paramref name="destinationDirectoryName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, и подкаталог файла не может быть скопирован.</exception>
        <exception cref="T:System.OperationCanceledException">Параметр <paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, а пользователь отменяет операцию, или операция не может быть завершена.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.InvalidOperationException">Операция является циклической.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перемещает файл в новое местоположение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог назначения не существует, он создается.  
  
 `MoveFile` Метод сохраняет записи управления доступом (записи управления доступом) только при перемещении файла в тот же том. Это включает наследуемые ACE, которые становятся прямыми ACE при перемещении (прямые элементы управления доступом имеют приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Перемещение файла|[Практическое руководство. Перемещение файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог назначения не существует, он создается.  
  
 `MoveFile` Метод сохраняет записи управления доступом (записи управления доступом) только при перемещении файла в тот же том. Это включает наследуемые ACE, которые становятся прямыми ACE при перемещении (прямые элементы управления доступом имеют приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Перемещение файла|[Практическое руководство. Перемещение файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="overwrite">Значение <see langword="True" /> для перезаписи существующих файлов; в противном случае — значение <see langword="False" />. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог назначения не существует, он создается.  
  
 `MoveFile` Метод сохраняет записи управления доступом (записи управления доступом) только при перемещении файла в тот же том. Это включает наследуемые ACE, которые становятся прямыми ACE при перемещении (прямые элементы управления доступом имеют приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Перемещение файла|[Практическое руководство. Перемещение файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Путь к перемещаемому файлу.</param>
        <param name="destinationFileName">Путь к каталогу, в который необходимо переместить файл.</param>
        <param name="showUI">Указывает, следует ли отображать ход выполнения операции. Значение по умолчанию — <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Указывает, выдается ли исключение, когда пользователь отменяет операцию. Значение по умолчанию — <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Перемещает файл в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если каталог назначения не существует, он создается.  
  
 `MoveFile` Метод сохраняет записи управления доступом (записи управления доступом) только при перемещении файла в тот же том. Это включает наследуемые ACE, которые становятся прямыми ACE при перемещении (прямые элементы управления доступом имеют приоритет над наследуемые ACE). Если файл перемещается между томами, записи управления доступом не копируются.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.MoveFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Перемещение файла|[Практическое руководство. Перемещение файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 В этом примере перемещает файл `Test.txt` из `TestDir1` для `TestDir2` и переименовывает его `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="destinationFileName" /> имеет значение <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Исходный файл не является допустимым или не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> имеет значение <see langword="ThrowException" />, а пользователь отменил операцию, или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Управляет возможностью доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Управляет возможностью доступа к переменным реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Управляет разрешениями, относящимися к пользовательским интерфейсам и буферу обмена. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFieldParser` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтение из файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла фиксированной ширины|[Практическое руководство. Чтение из текстовых файлов с полями фиксированного размера](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 В этом примере открывается `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, примененных к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Значения ширины полей.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFieldParser` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтение из файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла фиксированной ширины|[Практическое руководство. Чтение из текстовых файлов с полями фиксированного размера](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 В этом примере открывается `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, примененных к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо открыть с помощью <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Разделители для полей.</param>
        <summary>Метод <see langword="OpenTextFieldParser" /> позволяет создать объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, который предоставляет простой и эффективный способ синтаксического анализа структурированных текстовых файлов, например журналов. Объект <see langword="TextFieldParser" /> может использоваться для чтения и файлов с разделителями, и файлов с полями фиксированного размера.</summary>
        <returns>Объект <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> для чтения указанного файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFieldParser` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтение из файла с разделителями|[Практическое руководство. Чтение из текстовых файлов с разделителями-запятыми](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Чтение из файла фиксированной ширины|[Практическое руководство. Чтение из текстовых файлов с полями фиксированного размера](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Чтение из текстового файла с несколькими форматами|[Практическое руководство. Чтение из текстовых файлов различных форматов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 В этом примере открывается `TextFieldParser.reader` и использует его для чтения из `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Строка не может быть проанализирована с использованием указанного формата. Сообщение исключения содержит строку, вызвавшую исключение, а свойство <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> содержит текст, который содержится в этой строке.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Описывает набор разрешений безопасности, примененных к коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
        <returns>Объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только текстовые файлы, которые могут быть прочитаны с <xref:System.IO.StreamReader>.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFileReader` метод.  
  
|Кому|См.|  
|--------|---------|  
|Откройте файл с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 В этом примере открывается файл `Testfile.txt`, считывает строку из него и отображает строку в `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений на чтение из файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <param name="encoding">Кодировка, используемая для содержимого файла. Кодировкой по умолчанию является ASCII.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</summary>
        <returns>Объект <see cref="T:System.IO.StreamReader" /> для чтения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только текстовые файлы, которые могут быть прочитаны с <xref:System.IO.StreamReader>.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.OpenTextFileReader` метод.  
  
|Кому|См.|  
|--------|---------|  
|Откройте файл с <xref:System.IO.StreamReader>|[Практическое руководство. Чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 В этом примере открывается файл `Testfile.txt`, считывает строку из него и отображает строку в `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя нет необходимых разрешений на чтение из файла.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="append">
          <see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
        <returns>Объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `OpenTextFileWriter` Метод открывает и инициализирует поток для файла и возвращает <xref:System.IO.StreamWriter> объект для этого потока. Можно записывать в поток необходимое число раз и закройте его завершении.  
  
> [!NOTE]
>  Необходимо вызвать <xref:System.IO.StreamWriter.Close%2A> метод <xref:System.IO.StreamWriter> объекта, чтобы убедиться в том, что все данные, правильно записываются в основной поток.  
  
 При написании лишь нескольких строк в файл, возможно, проще в использовании <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> метода.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.OpenTextFileWriter` метод.  
  
|Кому|См.|  
|--------|---------|  
|Запись текста в файл с `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 В этом примере открывается <xref:System.IO.StreamWriter> с `My.Computer.FileSystem.OpenTextFileWriter` метод и использует его для записи строки в текстовый файл с `WriteLine` метод `StreamWriter` класса.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается косой чертой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="append">
          <see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <param name="encoding">Кодировка, которую необходимо использовать для записи в файл. Кодировкой по умолчанию является ASCII.</param>
        <summary>Открывает объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</summary>
        <returns>Объект <see cref="T:System.IO.StreamWriter" /> для записи в указанный файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `OpenTextFileWriter` Метод открывает и инициализирует поток для файла и возвращает <xref:System.IO.StreamWriter> объект для этого потока. Можно записывать в поток необходимое число раз и закройте его завершении.  
  
> [!NOTE]
>  Необходимо вызвать <xref:System.IO.StreamWriter.Close%2A> метод <xref:System.IO.StreamWriter> объекта, чтобы убедиться в том, что все данные, правильно записываются в основной поток.  
  
 При написании лишь нескольких строк в файл, возможно, проще в использовании <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> метода.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.OpenTextFileWriter` метод.  
  
|Кому|См.|  
|--------|---------|  
|Запись текста в файл с `StreamWriter`|[Практическое руководство. Запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 В этом примере открывается <xref:System.IO.StreamWriter> с `My.Computer.FileSystem.OpenTextFileWriter` метод и использует его для записи строки в текстовый файл с `WriteLine` метод `StreamWriter` класса.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя файла заканчивается косой чертой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, чтение которого необходимо выполнить.</param>
        <summary>Возвращает содержимое файла в виде массива байтов.</summary>
        <returns>
          <see langword="Byte" /> массив с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReadAllBytes` Метод `My.Computer.FileSystem` объекта позволяет считывать из двоичного файла. Содержимое файла возвращается в виде массива байтов.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.ReadAllBytes` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтение из двоичного файла|[Практическое руководство. Чтение из двоичных файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Этот пример считывает из файла `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла и путь к файлу, чтение которого необходимо выполнить.</param>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `ReadAllText` объекта `My.Computer.FileSystem` позволяет считывать данные из текстового файла. Содержимое файла возвращается в виде строки.  
  
 Кодировка файла может быть указан, если содержимое файла используется кодировка как ASCII или UTF-8. При чтении из файла с символами национальных алфавитов, необходимо указать кодировку файла, используя другую перегрузку <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText%2A> метод.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.ReadAllText` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Этот пример считывает содержимое `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Этот пример считывает содержимое файла ASCII `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла и путь к файлу, чтение которого необходимо выполнить.</param>
        <param name="encoding">Кодировка, которую необходимо использовать при чтении файла. Значением по умолчанию является UTF-8.</param>
        <summary>Возвращает содержимое текстового файла как <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> с содержимым файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `ReadAllText` объекта `My.Computer.FileSystem` позволяет считывать данные из текстового файла. Содержимое файла возвращается в виде строки.  
  
 Кодировка файла может быть указан, если содержимое файла используется кодировка как ASCII или UTF-8. При чтении из файла с символами национальных алфавитов, необходимо указать кодировку файла.  
  
 По имени файла не всегда можно с уверенностью судить о его содержимом. Например, файл с именем Form1.vb может вовсе не быть исходным файлом Visual Basic. Следует проверять все входные данные перед использованием их в приложении.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.ReadAllText` метод.  
  
|Кому|См.|  
|--------|---------|  
|Чтение из текстового файла|[Практическое руководство. Чтение из текстовых файлов](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Этот пример считывает содержимое `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Этот пример считывает содержимое файла ASCII `Test.txt` в строку и затем отображается в окне сообщения.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Имя каталога, который необходимо переименовать, и путь к нему.</param>
        <param name="newName">Новое имя каталога.</param>
        <summary>Переименование каталога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не может использоваться для перемещения каталога; Используйте `MoveDirectory` метод, чтобы переместить и переименовать папку.  
  
   
  
## Examples  
 В этом примере переименовывает `Test` каталог `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> содержит сведения о пути.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="directory" /> имеет значение <see langword="Nothing" />.  -или-  <paramref name="newName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог не существует.</exception>
        <exception cref="T:System.IO.IOException">Имеется существующий файл или каталог с именем, указанным в <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Файл, который необходимо переименовать.</param>
        <param name="newName">Новое имя файла.</param>
        <summary>Переименование файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод нельзя использовать для перемещения файла. Для перемещения и переименования файла используется метод <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile%2A>.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.RenameFile` метод.  
  
|Кому|См.|  
|--------|---------|  
|Переименовать файл|[Практическое руководство. Переименование файла](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 В этом примере переименовывает файл `Test.txt` для `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Изменение "`C:\Test.txt`" путь и имя файла, который требуется переименовать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> содержит сведения о пути или оканчивается обратной косой чертой (\\).</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.  -или-  <paramref name="newName" /> равен <see langword="Nothing" /> или является пустой строкой.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Имеется существующий файл или каталог с именем, указанным в <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет необходимого разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SpecialDirectories">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpecialDirectories As SpecialDirectoriesProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ SpecialDirectories { Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, предоставляющий свойства для доступа к каталогам, на которые часто даются ссылки.</summary>
        <value>Это свойство возвращает объект <see cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" /> для компьютера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Этот пример возвращает путь к файлу для каталога рабочего стола пользователя и отображает его.  
  
 [!code-vb[VbVbcnMyFileSystem#80](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#80)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Имя файла, в который необходимо выполнить запись, и путь к нему.</param>
        <param name="data">Данные, которые необходимо записать в файл.</param>
        <param name="append">
          <see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает данные в двоичный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если по указанному пути, за исключением имени файла является недопустимым, <xref:System.IO.DirectoryNotFoundException> будет создано исключение. Если путь является допустимым, но файл не существует, файл будет создан.  
  
> [!NOTE]
>  `WriteAllBytes` Метод открывает файл, записывает в него и закрывает его. Код, использующий `WriteAllBytes` проще, чем код, использующий метод <xref:System.IO.BinaryWriter> объекта. Тем не менее, при добавлении данных в файл с помощью цикла, <xref:System.IO.BinaryWriter> объект может обеспечить лучшую производительность, поскольку имеется только для открытия и закрытия файл один раз.  
  
 В следующей таблице перечислены задачи с использованием пример `My.Computer.FileSystem.WriteAllBytes` метод.  
  
|Кому|См.|  
|--------|---------|  
|Запись в двоичный файл|[Практическое руководство. Запись в двоичные файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 Этот пример добавляет массив данных `CustomerData` в файл `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текст в файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="text">Текст, который необходимо записать в файл.</param>
        <param name="append">
          <see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает текст в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка UTF-8 используется для записи в файл. Чтобы указать другую кодировку, используйте другую перегрузку метода <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> метод.  
  
 Если заданный файл не существует, он будет создан.  
  
 Если указанной кодировки не соответствует существующей кодировку файла, то заданная кодировка игнорируется.  
  
> [!NOTE]
>  `WriteAllText` Метод открывает файл, записывает в него и закрывает его. Код, использующий `WriteAllText` проще, чем код, использующий метод <xref:System.IO.StreamWriter> объекта. Тем не менее, при добавлении строки в файл с помощью цикла, <xref:System.IO.StreamWriter> объект может обеспечить лучшую производительность, поскольку имеется только для открытия и закрытия файл один раз. Дополнительные сведения см. в описании метода <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.WriteAllText` метод.  
  
|Кому|См.|  
|--------|---------|  
|Запись текста в файл|[Практическое руководство. Запись текста в файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавление текста в файл|[Практическое руководство. Дозапись в текстовый файл](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Этот пример записывает строку `"This is new text to be added."` в файл `Test.txt`, перезаписывая существующий текст в файле.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 В этом примере записываются имена файлов в `Documents and Settings` папки `FileList.txt`, вставляется символ перевода строки возвращать между каждым для повышения удобочитаемости.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Файл, в который необходимо выполнить запись.</param>
        <param name="text">Текст, который необходимо записать в файл.</param>
        <param name="append">
          <see langword="True" /> для добавления содержимого файла; <see langword="False" /> для перезаписи содержимого файла. Значение по умолчанию — <see langword="False" />.</param>
        <param name="encoding">Кодировка, которую необходимо использовать для записи в файл. Значением по умолчанию является UTF-8.</param>
        <summary>Записывает текст в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если заданный файл не существует, он будет создан.  
  
 Если указанной кодировки не соответствует существующей кодировку файла, то заданная кодировка игнорируется.  
  
> [!NOTE]
>  `WriteAllText` Метод открывает файл, записывает в него и закрывает его. Код, использующий `WriteAllText` проще, чем код, использующий метод <xref:System.IO.StreamWriter> объекта. Тем не менее, при добавлении строки в файл с помощью цикла, <xref:System.IO.StreamWriter> объект может обеспечить лучшую производительность, поскольку имеется только для открытия и закрытия файл один раз. Дополнительные сведения см. в описании метода <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 В следующей таблице перечислены примеры задач, связанных с `My.Computer.FileSystem.WriteAllText` метод.  
  
|Кому|См.|  
|--------|---------|  
|Запись текста в файл|[Практическое руководство. Запись текста в файлы](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Добавление текста в файл|[Практическое руководство. Дозапись в текстовый файл](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Этот пример записывает строку `"This is new text to be added."` в файл `Test.txt`, перезаписывая существующий текст в файле.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 В этом примере записываются имена файлов в `Documents and Settings` папки `FileList.txt`, вставляется символ перевода строки возвращать между каждым для повышения удобочитаемости.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Путь является недопустимым, так как либо представляет собой строку нулевой длины (пустую строку), либо содержит только пробел, либо содержит недопустимые символы, либо представляет собой путь к устройству (начинается с символов \\\\.\\); заканчивается косой чертой.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="file" /> имеет значение <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <exception cref="T:System.IO.IOException">Файл уже используется другим процессом или возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.IO.PathTooLongException">Длина пути превышает максимальную длину, определенную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Имя файла или каталога в пути содержит двоеточие (:) или имеет недопустимый формат.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для записи строки в буфер.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют необходимые разрешения на просмотр пути.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Управляет возможностью доступа к файлам и папкам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>