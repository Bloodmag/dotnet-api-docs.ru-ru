<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="757b138ad08a57ad8a16b1f7210ead2e45005193" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36728100" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот модуль поддерживает ключевые слова языка Visual Basic и члены библиотеки времени выполнения, доступ к файлам и папкам.  
  
   
  
## Examples  
 В этом примере используется `GetAttr` функцию, чтобы определить атрибуты файла и папки или каталога.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder. <c>Path</c> may include the drive. If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</param>
        <summary>Changes the current directory or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` Функция меняет каталог по умолчанию, но не диск по умолчанию. Например, если диск по умолчанию — C, следующая инструкция изменяет каталог по умолчанию на диске D, но C остается диска по умолчанию:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Можно внести относительные изменения каталога является путем ввода двух точек, следующим образом:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и.  
  
   
  
## Examples  
 В этом примере используется `ChDir` функции для изменения текущей папки или каталога.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is empty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Changes the current drive.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере используется `ChDrive` функции для изменения текущего диска. Функция создает исключение, если диск не существует.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере используется `ChDrive` функции для изменения текущего диска. Функция создает исключение, если диск не существует.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `CurDir` функцию для получения текущего пути.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optional. <see langword="Char" /> expression that specifies an existing drive. If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</param>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `CurDir` функцию для получения текущего пути.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Функция поддерживает использование нескольких знаков (`*`) и одного знака (`?`) можно указать несколько файлов.  
  
 `VbVolume` Возвращает метку тома диска вместо определенное имя файла.  
  
 Необходимо указать `PathName` при первом вызове `Dir` функции. Для получения следующего элемента, можно выполнять последующие вызовы `Dir` функции без параметров.  
  
> [!IMPORTANT]
>  Для корректного, `Dir` функция требует <xref:System.Security.Permissions.FileIOPermissionAccess.Read> и <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> флаги из <xref:System.Security.Permissions.FileIOPermission> должны быть предоставлены в исполняемый код. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Используются значения перечисления аргументов следующим образом:  
  
|Значение|Константа|Описание:|  
|-|-|-|  
|`Normal`|`vbnormal`|По умолчанию. Указывает файлы без атрибутов.|  
|`ReadOnly`|`vbReadOnly`|Указывает файлы, доступные только для чтения, а также файлы без атрибутов.|  
|`Hidden`|`vbHidden`|Задает скрытые файлы, а также файлы без атрибутов.|  
|`System`|`vbSystem`|Указывает, системные файлы и файлы без атрибутов.|  
|`Volume`|`vbVolume`|Определяет метку тома. Если указано другого атрибута `vbVolume` учитывается.|  
|`Directory`|`vbDirectory`|Указывает каталоги или папки, а также файлы без атрибутов.|  
|`Archive`|`vbArchive`|Файл был изменен с момента последнего резервного копирования.|  
|`Alias`|`vbAlias`|Файл имеет другое имя.|  
  
> [!NOTE]
>  Эти перечисления указаны в языке Visual Basic и может использоваться в любом месте в коде вместо фактических значений.  
  
   
  
## Examples  
 В этом примере используется `Dir` функция для проверки существования определенных файлов и каталогов.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Optional. <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</param>
        <param name="Attributes">Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</param>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Функция поддерживает использование нескольких знаков (`*`) и одного знака (`?`) можно указать несколько файлов.  
  
 `VbVolume` Возвращает метку тома диска вместо определенное имя файла.  
  
 Необходимо указать `PathName` при первом вызове `Dir` функции. Для получения следующего элемента, можно выполнять последующие вызовы `Dir` функции без параметров.  
  
> [!IMPORTANT]
>  Для корректного, `Dir` функция требует <xref:System.Security.Permissions.FileIOPermissionAccess.Read> и <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> флаги из <xref:System.Security.Permissions.FileIOPermission> должны быть предоставлены в исполняемый код. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Используются значения перечисления аргументов следующим образом:  
  
|Значение|Константа|Описание:|  
|-|-|-|  
|`Normal`|`vbnormal`|По умолчанию. Указывает файлы без атрибутов.|  
|`ReadOnly`|`vbReadOnly`|Определяет файлы только для чтения в дополнение к файлам без атрибутов.|  
|`Hidden`|`vbHidden`|Задает скрытые файлы, кроме файлов без атрибутов.|  
|`System`|`vbSystem`|Определяет системные файлы, кроме файлов без атрибутов.|  
|`Volume`|`vbVolume`|Определяет метку тома. Если указано другого атрибута `vbVolume` учитывается.|  
|`Directory`|`vbDirectory`|Указывает каталоги или папки в дополнение к файлам без атрибутов.|  
|`Archive`|`vbArchive`|Файл был изменен с момента последнего резервного копирования.|  
|`Alias`|`vbAlias`|Файл имеет другое имя.|  
  
> [!NOTE]
>  Эти перечисления указаны в языке Visual Basic и может использоваться в любом месте в коде вместо фактических значений.  
  
   
  
## Examples  
 В этом примере используется `Dir` функция для проверки существования определенных файлов и каталогов.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains any valid file number.</param>
        <summary>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</summary>
        <returns>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `EOF` Чтобы избежать ошибки, возникающей при попытке прочитать данные за пределами файла.  
  
 `EOF` Возврата функцией `False` достигнут конец файла. В файлах, открытых для `Random` или `Binary` доступ, `EOF` возвращает `False` до последнего выполнения `FileGet` функции не удалось прочитать запись целиком.  
  
 В файлах, открытых для `Binary` доступа, попытка прочитать файл с помощью `Input` функции до `EOF` возвращает `True` приводит к ошибке. Используйте `LOF` и `Loc` функции вместо `EOF` при чтении двоичных файлов с `Input`, или используйте `Get` при использовании `EOF` функции. В файлах, открытых для `Output`, `EOF` всегда возвращает `True`.  
  
   
  
## Examples  
 В этом примере используется `EOF` функцию для определения конца файла. В этом примере предполагается, что `Testfile` — это текстовый файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. <see langword="Integer" />. Any valid file number.</param>
        <summary>Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</summary>
        <returns>The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта функция возвращает перечисление, представляющее режим файла для файлов, открытых с использованием `FileOpen` функции.  
  
   
  
## Examples  
 В этом примере используется `FileAttr` функция, возвращающая файловый режим открытого файла.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optional. Parameter array of 0 or more channels to be closed.</param>
        <summary>Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function. <see langword="My" /> gives you better productivity and performance in file I/O operations. See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [как: чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[как: запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), и [Пошаговое руководство: управление файлы и каталоги Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Если не указан `FileNumbers`, открываемые всех активных файлах `FileOpen` функция закрываются.  
  
 При закрытии файлов, открытых для `Output` или `Append`, последнее содержимое буфера вывода записывается в буфер операционной системы для этого файла. Все буферное пространство, связанное с закрытого файла освобождается.  
  
 Если `FileClose` функция выполняется, а связь файла с его файл заканчивается.  
  
   
  
## Examples  
 В этом примере используется `FileClose` функцию, чтобы закрыть файл открыт для `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Required. <see langword="String" /> expression that specifies the name of the file to be copied. <c>Source</c> may include the directory or folder, and drive, of the source file.</param>
        <param name="Destination">Required. <see langword="String" /> expression that specifies the destination file name. <c>Destination</c> may include the directory or folder, and drive, of the destination file.</param>
        <summary>Copies a file. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке использовать `FileCopy` работать в открытом файле, происходит ошибка.  
  
 `FileCopy` требуется полное доверие для работы на локальном диске.  
  
   
  
## Examples  
 В этом примере используется `FileCopy` функции для копирования одного файла в другой. Для этого примера, предположим, что `SrcFile` — это файл, содержащий данные.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</exception>
        <exception cref="T:System.IO.IOException">File is already open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Date" /> value that indicates the date and time a file was written to. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>
          <see langword="Date" /> value that indicates the date and time a file was created or last modified.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `FileDateTime` функции для определения даты и времени файла или его последнего изменения. Формат даты и времени, отображаемого зависит от региональных параметров системы.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью`FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется. А затем размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции`FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью`FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. При отсутствии `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функции (или, на который указывает последний `Seek` функция) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGet` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версиях поддерживают строки фиксированной длины; При записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, можно ли считать дескриптор с указанием размера и размерности массива. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, необходимо соответствовать способу его записи. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, переданные в `FileGet` определить, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (10 * 5 * 4).  
  
-   Если считываемая переменная является любого другого типа (не является строкой переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject` Функция используется вместо `FileGet` во избежание неоднозначности во время компиляции, если тип `Object` возвращается вместо другого типа, таких как `Integer`, `Long`, `Short`, и т. д.  
  
 Если требуется записать `Variant` типа `FileGetObject` является обязательным. Если вы сомневаетесь, при использовании объекта для второго параметра, всегда рекомендуется использовать `FilePutObject` и `FileGetObject`.  
  
 `FileGetObject` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGetObject` , обычно записываются с `FilePutObject`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, `FileGetObject` считывает запись или байт после последнего `FileGetObject` или `FilePutObject` функции (или, на который указывает последний `Seek` функции).  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина считываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FileGetObject` считывает последующие записи по границам записей. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку объем данных заполнения не может точно определить, рекомендуется длина записи соответствует длине считываемых данных.  
  
-   Если считываемая переменная представляет собой строку, по умолчанию `FileGetObject` считывает двухбайтовый дескриптор, содержащий длину строки, а затем считывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранних версий поддерживают строки фиксированной длины и при записи в файл дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если считываемая переменная является массивом, то длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: 2 + 8 * NumberOfDimensions.  
  
     Например, следующее объявление массива требуется 218 байтов при записи на диск:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 байт распределяются следующим образом: 18 байт для дескриптора (2 + 8 * 2) и 100 байтов для данных (5 * 10 * 4).  
  
-   `FileGetObject` считывает элементы структуры, как если бы чтения каждого по отдельности, за исключением того, без заполнения между элементами. На диске, динамического массива в определяемый пользователем тип (написанную `FilePutObject`) начинается дескриптора, длина которого равна 2 плюс 8, умноженное на количество измерений: 2 + 8 * NumberOfDimensions. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов, включая массивы и их дескрипторы. <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Класс может быть применен к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, все `Random` применяются правила, со следующими исключениями:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FileGetObject` Считывает все переменные с диска подряд, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FileGetObject` считывает только данные. Дескриптор не читается.  
  
 `FileGetObject` считывает строки переменной длины, которые не являются частью структуры, предполагая дескриптор длиной 2 байта. Число считанных байтов равно количеству знаков в строке.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
   
  
## Examples  
 В следующем примере выполняется запись в файл теста и затем извлекается.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the length of a file in bytes. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          <see langword="Long" /> value that specifies the length of a file in bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанный файл открыт, когда `FileLen` вызывается функция, возвращаемое значение представляет размер файла на момент его открытия.  
  
> [!NOTE]
>  Для получения текущей длины открытого файла используйте `LOF` функции.  
  
   
  
## Examples  
 В этом примере используется `FileLen` функция возвращает длину файла в байтах. Для этого примера, предположим, что `TestFile` — это файл, который содержит некоторые данные.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number. Use the <see langword="FreeFile" /> function to obtain the next available file number.</param>
        <param name="FileName">Required. <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</param>
        <param name="Mode">Required. Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Optional. Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />. Defaults to <see langword="ReadWrite" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Optional. Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />. Defaults to <see langword="Lock Read Write" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.</param>
        <summary>Opens a file for input or output. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Перед выполнением любой операции ввода-вывода на нем необходимо открыть файл. `FileOpen` выделяет буфер для ввода-вывода в файл и определяет режим доступа, используемый с буфером.  
  
> [!IMPORTANT]
>  При записи в файл приложения может потребоваться создать файл, если файл, к которому он пытается записать не существует. Для этого ему разрешения для каталога, в которой создан файл. Тем не менее если файл, указанный параметром `FileName` существует, приложение должно `Write` разрешение только на сам файл. Везде, где возможно, в целях повышения безопасности, создайте файл во время развертывания и предоставления `Write` разрешений к этому файлу только, а не для всего каталога. В целях повышения безопасности, записывают данные в каталоги пользователей, а не в корневой каталог или каталог Program Files.  
  
 Для открытия канала можно найти с помощью `FreeFile()` функции.  
  
> [!IMPORTANT]
>  `FileOpen` Функция требует `Read` доступ из `FileIOPermissionAccess` перечисления, который может повлиять на выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере показаны различные способы `FileOpen` функцией для включения ввод и вывод в файл.  
  
 Следующий код открывает файл `TestFile` в `Input` режиме.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 В этом примере открывается файл в `Binary` режиме для записи только операции.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 В следующем примере открывается файл в `Random` режиме. Файл содержит записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 В следующем примере открывается файл в `Output` режиме; любой процесс может прочитать или записать в файл.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 В следующем примере открывается файл в `Binary` режиме для чтения; другие процессы не удалось прочитать файл.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Record length is negative (and not equal to -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор`VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в`RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.  
  
-   Если строка, записываемая переменная `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка поля, содержащие больше байт, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длиной 2 байта. Число записанных байтов равно количеству знаков в строке. Например следующие инструкции записывают 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записать в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject` Функция используется вместо `FilePut` во избежание неоднозначности во время компиляции, если тип `Object` вместо передается другого типа, таких как `Integer`, `Long`, `Short`, и т. д.  
  
 `FilePutObject` Записывает и читает дескрипторы, которые описывают объект. Если требуется записать `Variant` типа `FilePutObject` является обязательным. Если вы сомневаетесь, при использовании объекта для второго параметра, рекомендуется всегда использовать `FilePutObject` и `FileGetObject`.  
  
 `FilePutObject` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePutObject`, обычно считываются с помощью `FileGetObject`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, `FilePutObject` записывает Далее запись или байт после последнего `FileGetObject` или `FilePutObject` функции (или запись или байт, на который указывает последний `Seek` функции).  
  
 `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePutObject` не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePutObject`, вы должны делать то же самое с `FileGetObject`, и Кроме того, необходимо убедиться, что строка инициализируется до длины ожидаемого.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для файлов, открытых в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePutObject` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку объем данных заполнения не может точно определить, рекомендуется обычно длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, вызывается исключение.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePutObject` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePutObject` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная является объектом, содержащим строку, `FilePutObject` записывает двухбайтовый `VarType(8)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, то длина записи, указанная с `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для файлов, открытых в `Binary` режиме все `Random` применяются правила режиме, за исключением:  
  
-   `RecordLength` Предложения в `FileOpen` функция не имеет эффекта. `FilePutObject` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
   
  
## Examples  
 В этом примере используется `FilePutObject` функции для записи строки в файл.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="RecordWidth">Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <c>RecordWidth</c> equals 0, there is no limit to the length of a line. The default value for <c>RecordWidth</c> is 0.</param>
        <summary>Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `FileWidth` функцию для задания ширины строки вывода для файла.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</summary>
        <returns>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `FreeFile` для номера файла, который уже не используется.  
  
   
  
## Examples  
 В этом примере используется `FreeFile` функция, возвращающая номер следующего файла доступны. Для вывода в цикле открывается пять файлов и образцами данных записывается для каждого.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">More than 255 files are in use.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file, directory, or folder name. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, какие атрибуты установлены, используйте `And` оператор для выполнения побитового сравнения значения, возвращенного `GetAttr` функцией и значения атрибута файла необходимо. Если результат не равен нулю, этот атрибут имеет значение для указанного файла. Например, возвращаемое значение из следующих `And` выражение является нуль, если `Archive` не задан атрибут:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Если возвращается ненулевое значение `Archive` атрибут имеет значение.  
  
   
  
## Examples  
 В этом примере используется `GetAttr` функцию, чтобы определить атрибуты файла и папки или каталога.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл с несколькими строками данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл с несколькими строками данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.  
  
|Данные|Значение, присвоенное переменной|  
|-|-|  
|Разделяющая запятая или пустая строка|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для чтения данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанный с помощью `Write` функции, каждая строка содержит строку в кавычках и число, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="CharCount">Required. Any valid numeric expression specifying the number of characters to read.</param>
        <summary>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `InputString` функции обычно записываются в файл с помощью `Print` или `FilePut`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
 В отличие от `Input` функции `InputString` функция возвращает все символы, он считывает. Сюда входят запятые, символы возврата каретки, перевода строки, кавычки и начальные пробелы.  
  
 В файлах, открытых для `Binary` доступа, попытка прочитать файл с помощью `InputString` функции до `EOF` возвращает `True` приводит к ошибке. Используйте `LOF` и `Loc` функции вместо `EOF` при чтении двоичных файлов с помощью `InputString`, или используйте `FileGet` при использовании `EOF` функции.  
  
> [!NOTE]
>  При чтении из файла не принятия решений по безопасности о содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
   
  
## Examples  
 В этом примере используется `InputString` функция для чтения символов из файла и вывода для `Output` окна. В этом примере предполагается, что `MyFile` — это текстовый файл, содержащий несколько строк образцов данных.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 or &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies one or more file names to be deleted. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Deletes files from a disk. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` поддерживает использование нескольких знаков (`*`) и одного знака (`?`) можно указать несколько файлов.  
  
 **Примечание по безопасности** для выполнения, `Kill` функция требует `Read` и `PathDiscovery` флаги из <xref:System.Security.Permissions.FileIOPermission> должны быть предоставлены в исполняемый код. Дополнительные сведения см. в разделе <xref:System.Security.SecurityException> [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 В этом примере используется `Kill` функции, чтобы удалить файл с диска.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Target file(s) open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file(s) not found.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</summary>
        <returns>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `LineInput` обычно записываются в файл с помощью `Print`.  
  
> [!IMPORTANT]
>  При чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.  
  
 `LineInput` Функция считывает строку символов, один файл во время, пока встретится символ возврата каретки (`Chr(13)`) или каретки и перевода строки веб-канала (`Chr(13) + Chr(10)`) последовательности. Веб-канала последовательностей каретки и перевода строки, добавляются в строку символов, вместо пропускаются.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `LineInput` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `LineInput` функция для чтения строки из последовательного файла и присвоить его переменной. В этом примере предполагается, что `TestFile` — это текстовый файл, содержащий несколько строк образцов данных.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">End of file reached.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid <see langword="Integer" /> file number.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</summary>
        <returns>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` Функции (с нуля); его использование для получения первого байта в файле возвратит 0.  
  
 `Loc` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Ниже описаны возвращаемое значение для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер последней записи, считывается или записывается в файл.|  
|`Sequential`|Текущая позиция байта в файле, деленная на 128. Тем не менее, возвращаются сведения по `Loc` для последовательных файлов не используется и не требуется.|  
|`Binary`|Позиция последнего байта чтения или записи.|  
  
   
  
## Examples  
 В этом примере используется `Loc` функция, возвращающая текущую позицию чтения или записи в файл. В этом примере предполагается, что `MyFile` — это текстовый файл, содержащий несколько строк образцов данных.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `FileLen` функции для получения длины файла, который не был открыт.  
  
   
  
## Examples  
 В этом примере используется `LOF` функцию для определения размера открытого файла. В этом примере предполагается, что `TestFile` — это текстовый файл, содержащий данные образца.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory to be created. The <c>Path</c> may include the drive. If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</param>
        <summary>Creates a new directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта функция создает новый каталог.  
  
   
  
## Examples  
 В этом примере используется `MkDir` функции для создания каталога. Если диск не указан, новый каталог создается на текущем диске.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <exception cref="T:System.IO.IOException">Directory already exists.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` И `PrintLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` не включает символ перевода строки в конце строки; Однако `PrintLine` содержит символ перевода строки.  
  
 Данные, записанные с `Print` обычно считываются из файла с помощью `LineInput` или `Input`.  
  
 Если не указан `Output` для `PrintLine`, выводит пустую строку в файл; для `Print`, ничего не будет записано. Несколько выражений, разделенных запятыми, будут выровнены по границам табуляции, но смешивание запятых и `TAB` может привести к непредсказуемым результатам.  
  
 Для `Boolean` данных, либо `True` или `False` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.  
  
 Дата данные записываются в файл с помощью стандартных короткого формата даты формата, распознаваемого системой. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.  
  
 Ничего не записывается в файл, если `Output` данных пуст. Однако если `Output` данные списка `DBNull`, `Null` записывается в файл.  
  
 Для `Error` данные, выходные данные отображаются в виде `Error errorcode`. `Error` Ключевое слово не переводится независимо от языкового стандарта.  
  
 Все данные, записанные в файл с помощью `Print` международный стандартам; т. е. данные правильно отформатированы с использованием соответствующего десятичного разделителя. Если пользователь хочет вывести данные для использования в нескольких языковых стандартов `Write` следует использовать.  
  
 Запись в файл с помощью `Print` или `PrintLine` функции требует `Write` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Print` и `PrintLine` функции для записи данных в файл.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` И `PrintLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` не включает символ перевода строки в конце строки; Однако`PrintLine` содержит символ перевода строки.  
  
 Данные, записанные с `Print` обычно считываются из файла с помощью `LineInput` или `Input`.  
  
 Если не указан `Output` для `PrintLine`, выводит пустую строку в файл; для `Print`, ничего не будет записано. Несколько выражений, разделенных запятыми, будут выровнены по границам табуляции, но смешивание запятых и `TAB` может привести к непредсказуемым результатам.  
  
 Для `Boolean` данных, либо `True` или `False` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.  
  
 Даты данные записываются в файл с помощью стандартных короткого формата даты формата, распознаваемого системой. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.  
  
 Ничего не записывается в файл, если `Output` данных пуст. Однако если `Output` данные списка `DBNull`, `Null` записывается в файл.  
  
 Для `Error` данные, выходные данные отображаются в виде `Error errorcode`. `Error` Ключевое слово не переводится независимо от языкового стандарта.  
  
 Все данные, записанные в файл с помощью `Print` международный стандартам; т. е. данные правильно отформатированы с использованием соответствующего десятичного разделителя. Если пользователь хочет вывести данные для использования в нескольких языковых стандартов `Write` следует использовать.  
  
 Запись в файл с помощью `Print` или `PrintLine` функции требует `Write` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Print` и `PrintLine` функции для записи данных в файл.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Required. <see langword="String" /> expression that specifies the existing file name and location. <c>OldPath</c> may include the directory, and drive, of the file.</param>
        <param name="NewPath">Required. <see langword="String" /> expression that specifies the new file name and location. <c>NewPath</c> may include directory and drive of the destination location. The file name specified by <c>NewPath</c> cannot already exist.</param>
        <summary>Renames a disk file or directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` Функция переименовывает файл и при необходимости перемещает его в другой каталог. `Rename` Функции можно переместить файл на дисках, но его можно только переименовать существующий каталог, когда оба `NewPath` и `OldPath` находятся на том же диске. `Rename` не удается создать новый файл или каталог.  
  
 С помощью `Rename` функции к открытому файлу приводит к ошибке. Необходимо закрыть открытый файл перед его переименованием. `Rename` аргументы не могут содержать нескольких знаков (*) и одного знака (?) подстановочные знаки.  
  
> [!IMPORTANT]
>  При использовании `Rename` для копирования файла из незащищенного расположения в защищенном месте, в файле сохраняются менее ограниченные права. Проверьте, что не представляете возможную угрозу безопасности.  
  
   
  
## Examples  
 В этом примере используется `Rename` функции для изменения имени файла. В целях в этом примере предполагается, что каталоги, заданные уже существуют.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Path is invalid.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> file does not exist.</exception>
        <exception cref="T:System.IO.IOException">Cannot rename to different device.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes all disk files opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset` Функция закрывает все активные файлы, открытые `FileOpen` функцией и имеет ту же функцию, что `FileClose()` без параметров.  
  
   
  
## Examples  
 В этом примере используется `Reset` функции, чтобы закрыть все открытые файлы и записывают содержимое всех буферов файлов на диск. Обратите внимание на использование `Object` переменной `FileNumber` как строки и номером.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory or folder to be removed. <c>Path</c> can include the drive. If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</param>
        <summary>Removes an existing directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />. For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Произошла ошибка при попытке использовать `RmDir` на каталог, содержащий файлы. Используйте `Kill` функции, чтобы удалить все файлы, прежде чем пытаться удалить каталог.  
  
   
  
## Examples  
 В этом примере используется `RmDir` функцию для удаления существующего каталога.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.IO.IOException">Target directory contains files.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Directory does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31 – 1) включительно.  
  
 Ниже описываются возвращаемые значения для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер следующей записи, чтение и запись|  
|`Binary`, `Input`, `Output`, `Append`|Позиция байта, с которой происходит следующей операции. Первый байт в файле находится в позиции 1, второй байт в позиции 2 и т. д.|  
  
   
  
## Examples  
 В этом примере используется `Seek` функция, возвращающая текущее положение в файле. В этом примере предполагается `TestFile` — это файл, содержащий записи структуры `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Для файлов, открытых в `Random` режиме `Seek` возвращает номер следующей записи.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` возвращает позицию байта, в которой следующей операции ввода-вывода. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 В этом примере используется `Seek` функции, чтобы установить позицию для следующей операции чтения или записи в файл.  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` устанавливает позицию байта, в которой следующей операции ввода-вывода. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <param name="Position">Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31 – 1) включительно.  
  
 Ниже описываются возвращаемые значения для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер следующей записи, чтение и запись|  
|`Binary`, `Input`, `Output`, `Append`|Позиция байта, с которой происходит следующей операции. Первый байт в файле находится в позиции 1, второй байт в позиции 2 и т. д.|  
  
   
  
## Examples  
 В этом примере используется `Seek` функция, возвращающая текущее положение в файле. В этом примере предполагается `TestFile` — это файл, содержащий записи структуры `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Для файлов, открытых в `Random` режиме `Seek` возвращает номер следующей записи.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` возвращает позицию байта, в которой следующей операции ввода-вывода. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 В этом примере используется `Seek` функции, чтобы установить позицию для следующей операции чтения или записи в файл.  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` устанавливает позицию байта, в которой следующей операции ввода-вывода. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> can include directory or folder, and drive.</param>
        <param name="Attributes">Required. Constant or numeric expression, whose sum specifies file attributes.</param>
        <summary>Sets attribute information for a file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ошибка во время выполнения происходит при попытке установить атрибуты для открытого файла.  
  
 `Attributes` Используются значения перечисления аргументов следующим образом:  
  
|Значение|Константа|Описание:|  
|-|-|-|  
|`Normal`|`vbNormal`|Обычный (по умолчанию).|  
|`ReadOnly`|`vbReadOnly`|Только для чтения.|  
|`Hidden`|`vbHidden`|Скрытый.|  
|`System`|`vbSystem`|Системный файл.|  
|`Volume`|`vbVolume`|Метка тома|  
|`Directory`|`vbDirectory`|Каталог или папку.|  
|`Archive`|`vbArchive`|Файл был изменен с момента последнего резервного копирования.|  
|`Alias`|`vbAlias`|Файл имеет другое имя.|  
  
> [!NOTE]
>  Эти перечисления указаны в языке Visual Basic. Имена можно использовать в любом месте в коде вместо фактических значений.  
  
   
  
## Examples  
 В этом примере используется `SetAttr` функцию для задания атрибутов файла.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> type is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Required. The number of spaces to insert before displaying or printing the next expression in a list.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Count` меньше ширины строки вывода, следующая позиция печати непосредственно следует за количество напечатанных пробелов. Если`Count` больше, чем длина выводимой строки `SPC` вычисляет следующую позицию печати по формуле:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Например, если текущая позиция печати равна 24, ширина строки вывода равна 80, и `SPC(90)`, следующая печать начнется с позиции 34 (текущая позиция печати + остаток от 90/80). Если разница между текущей позицией печати и шириной строки вывода меньше, чем `Count` (или `Count` `Mod` *ширина*), `SPC` функция переходит на начало следующей строки и создает пробелы, равные `Count` — (*ширина* — *текущая_позиция_печати*).  
  
> [!NOTE]
>  Убедитесь, что столбцы таблицы достаточно широки вместить длинные записи.  
  
   
  
## Examples  
 В этом примере используется `SPC` позиции вывода в файл в функции **вывода** окна.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая позиция печати в текущей строке больше, чем `Column`, `TAB` пропускает равно значению столбца `Column` на следующую строку. Если `Column` меньше 1 `TAB` перемещает позицию печати в столбец 1. Если `Column` больше, чем длина выводимой строки `TAB` вычисляет следующую позицию печати по формуле:  
  
 Mod ширины столбца  
  
 Например если *ширина* равна 80 и задано `TAB(90)`, следующая печать начнется со столбца 10 (остаток от 90/80). Если `Column` меньше, чем текущая позиция печати, печать начинается со следующей строки в рассчитанной позиции печати. Если рассчитанная позиция печати больше, чем текущая позиция печати, печать начинается в рассчитанной позиции печати в той же строке.  
  
 Крайняя левая позиция печати в строке вывода всегда равно 1. При использовании `Print` или `PrintLine` функции для печати файлов, позиция равна ширине выходного файла, который можно задать с помощью `FileWidth` функции.  
  
 `TAB` Функция также может использоваться с `WriteLine` функции. Не может использоваться с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> или <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Убедитесь, что столбцы таблицы достаточно широки вместить длинные записи.  
  
   
  
## Examples  
 В этом примере используется `TAB` позиции вывода в файл в функции **вывода** окна.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая позиция печати в текущей строке больше, чем `Column`, `TAB` пропускает равно значению столбца `Column` на следующую строку. Если `Column` меньше 1 `TAB` перемещает позицию печати в столбец 1. Если `Column` больше, чем длина выводимой строки `TAB` вычисляет следующую позицию печати по формуле:  
  
 Mod ширины столбца  
  
 Например если *ширина* равна 80 и задано `TAB(90)`, следующая печать начнется со столбца 10 (остаток от 90/80). Если `Column` меньше, чем текущая позиция печати, печать начинается со следующей строки в рассчитанной позиции печати. Если рассчитанная позиция печати больше, чем текущая позиция печати, печать начинается в рассчитанной позиции печати в той же строке.  
  
 Крайняя левая позиция печати в строке вывода всегда равно 1. При использовании `Print` или `PrintLine` функции для печати файлов, позиция равна ширине выходного файла, который можно задать с помощью `FileWidth` функции.  
  
 `TAB` Функция также может использоваться с `WriteLine` функции. Не может использоваться с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> или <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Убедитесь, что столбцы таблицы достаточно широки вместить длинные записи.  
  
   
  
## Examples  
 В этом примере используется `TAB` позиции вывода в файл в функции **вывода** окна.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` И `WriteLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Если не указан `Output`, выводит пустую строку в файл. Несколько выражений могут разделяться запятыми.  
  
 В отличие от `Print` функции `Write` функция вставляет запятые между элементами и заключается в кавычки строки, записываемые в файл. Не нужно вставлять в список явные ограничители. Когда `Write` используется для записи данных в файл только числовые `Boolean`, даты, null, и `Error` поддерживаются форматы данных. Следующие универсальные предположения а затем данные всегда могут быть прочитаны и правильно интерпретированы с помощью `Input`, независимо от языкового стандарта:  
  
-   Числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.  
  
-   Для `Boolean` данных, либо `#TRUE#` или `#FALSE#` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.  
  
-   Дата записывается в файл с помощью универсальный формат даты. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.  
  
-   Ничего не записывается в файл, если `Output` данных пуст. Однако для пустых данных `#NULL#` записывается.  
  
-   Для `Error` данные, выходные данные отображаются в виде `#ERROR errorcode#`. `Error` Ключевого слова не преобразуются, независимо от языкового стандарта.  
  
 `WriteLine` Вставляет символ новой строки (то есть, возврат каретки и строки веб-канал, или `Chr(13) + Chr(10)`), после записи последнего символа `Output` в файл.  
  
 Можно вставить кавычки в строке с помощью двойных кавычек, или «». Например, примененная к объекту директива  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Возвращает строку со значением `Double quotation marks aren't "difficult" to handle`.  
  
 Запись в файл с помощью `Write` или `WriteLine` функции требует `Append` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Write` функции для записи необработанных данных в последовательный файл.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` И `WriteLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Если не указан `Output`, выводит пустую строку в файл. Несколько выражений могут разделяться запятыми.  
  
 В отличие от `Print` функции `Write` функция вставляет запятые между элементами и заключается в кавычки строки, записываемые в файл. Не нужно вставлять в список явные ограничители. Когда `Write` используется для записи данных в файл только числовые `Boolean`, даты, null, и `Error` поддерживаются форматы данных. Следующие универсальные предположения а затем данные всегда могут быть прочитаны и правильно интерпретированы с помощью `Input`, независимо от языкового стандарта:  
  
-   Числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.  
  
-   Для `Boolean` данных, либо `#TRUE#` или `#FALSE#` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.  
  
-   Дата записывается в файл с помощью универсальный формат даты. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.  
  
-   Ничего не записывается в файл, если `Output` данных пуст. Однако для пустых данных `#NULL#` записывается.  
  
-   Для `Error` данные, выходные данные отображаются в виде `#ERROR errorcode#`. `Error` Ключевого слова не преобразуются, независимо от языкового стандарта.  
  
 `WriteLine` Вставляет символ новой строки (то есть, возврат каретки и строки веб-канал, или `Chr(13) + Chr(10)`), после записи последнего символа `Output` в файл.  
  
 Можно вставить кавычки в строке с помощью двойных кавычек, или «». Например, примененная к объекту директива  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Возвращает строку со значением `Double quotation marks aren't "difficult" to handle`.  
  
 Запись в файл с помощью `Write` или `WriteLine` функции требует `Append` доступ из `FileIOPermissionAccess` перечисления. Для получения дополнительной информации см. <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Write` функции для записи необработанных данных в последовательный файл.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>