<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cec0c607fc2b7dd375bd0d2fa79de046945ffe69" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174292" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>В модуле <see langword="Interaction" /> содержатся процедуры, используемые для взаимодействия с объектами, приложениями и системами.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот модуль поддерживает ключевые слова языка Visual Basic и члены библиотеки времени выполнения, запуска других программ, вызовите метод или свойство, звуковой сигнал из компьютера, предоставляют командную строку, управляют COM-объектами и диалоговых окнах элемента управления.  
  
   
  
## Examples  
 В следующем примере используется `Shell` функцию для выполнения приложения, указанного пользователем. Указание <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> как второй аргумент запускает приложение в нормального размера и передает ему фокус.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Активирует приложение, которое уже выполняется.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">Значение типа <see langword="Integer" />, задающее номер идентификатора процесса Win32, назначенного процессу. Можно использовать идентификатор, который возвращает <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />, если он не равен нулю.</param>
        <summary>Активирует приложение, которое уже выполняется.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы используете `AppActivate` для переноса фокуса в активное окно приложения. Не может иметь дескриптор или ссылка на активное окно или неизвестно, какое окно является активным в данный момент. В этом случае нельзя использовать <xref:System.Windows.Forms.Control.Focus%2A> метода.  
  
 `AppActivate` Функция Переход к заданному приложению или окну, но не влияет на свернуто или развернуто. Когда пользователь выполняет некоторые действия для изменения фокуса или закрыть окно, фокус перемещается в другое окно активного приложения. Можно использовать `Shell` функция для запуска приложения и задания стиля окна.  
  
 Если вы используете `Title` параметр `AppActivate` использует сравнение без учета регистра, но в противном случае требуется точное совпадение с содержимым строки заголовка. Он сначала выполняет поиск окна верхнего уровня, а затем к дочернему окну. Если соответствий не найдено, он выдает <xref:System.ArgumentException>.  
  
 Можно использовать `AppActivate` только с процессами, которые принадлежат windows. Большинство консольных приложений windows, это означает, что они не отображаются в списке процессов, которые не принадлежат `AppActivate` поиска. При работе в консольном приложении, система создает отдельный процесс для запуска приложения и возвращает выходные данные в процесс консоли. Следовательно при запросе текущего идентификатора процесса возвращается идентификатор процесса процесса, а не идентификатор процесса консольного приложения.  
  
 Во время выполнения `AppActivate` функция активирует любое запущенное приложение с заголовком, который соответствует `Title` или идентификатор процесса, который соответствует `ProcessId`. Если имеется точное совпадение отсутствует, функция активирует приложение, строка заголовка которого заканчивается `Title`. Если имеется несколько приложений с именем `Title`, `AppActivate` функция произвольно выбирает для активации одно.  
  
> [!NOTE]
>  `AppActivate` Функция требует `UIPermission` на <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> уровне, что может повлиять на его выполнение в случаях частичного доверия. Для получения дополнительной информации см. <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 В этом примере показаны различные способы `AppActivate` функцию для активации окна приложения. Если Блокнот не запущена, в примере возникают исключения <xref:System.ArgumentException>. `Shell` Процедура предполагает приложения находятся в указанных путей.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">Выражение типа <see langword="String" />, задающее заголовок для строки заголовка активируемого окна приложения. Можно использовать название, присваимое приложению при запуске.</param>
        <summary>Активирует приложение, которое уже выполняется.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы используете `AppActivate` для переноса фокуса в активное окно приложения. Не может иметь дескриптор или ссылка на активное окно или неизвестно, какое окно является активным в данный момент. В этом случае нельзя использовать <xref:System.Windows.Forms.Control.Focus%2A> метода.  
  
 `AppActivate` Функция Переход к заданному приложению или окну, но не влияет на свернуто или развернуто. Когда пользователь выполняет некоторые действия для изменения фокуса или закрыть окно, фокус перемещается в другое окно активного приложения. Можно использовать `Shell` функция для запуска приложения и задания стиля окна.  
  
 Если вы используете `Title` параметр `AppActivate` использует сравнение без учета регистра, но в противном случае требуется точное совпадение с содержимым строки заголовка. Он сначала выполняет поиск окна верхнего уровня, а затем к дочернему окну. Если соответствий не найдено, он выдает <xref:System.ArgumentException>.  
  
 Можно использовать `AppActivate` только с процессами, которые принадлежат windows. Большинство консольных приложений windows, это означает, что они не отображаются в списке процессов, которые не принадлежат `AppActivate` поиска. При работе в консольном приложении, система создает отдельный процесс для запуска приложения и возвращает выходные данные в процесс консоли. Следовательно при запросе текущего идентификатора процесса возвращается идентификатор процесса процесса, а не идентификатор процесса консольного приложения.  
  
 Во время выполнения `AppActivate` функция активирует любое запущенное приложение с заголовком, который соответствует `Title` или идентификатор процесса, который соответствует `ProcessId`. Если имеется точное совпадение отсутствует, функция активирует приложение, строка заголовка которого заканчивается `Title`. Если имеется несколько приложений с именем `Title`, `AppActivate` функция произвольно выбирает для активации одно.  
  
> [!NOTE]
>  `AppActivate` Функция требует `UIPermission` на <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> уровне, что может повлиять на его выполнение в случаях частичного доверия. Для получения дополнительной информации см. <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 В этом примере показаны различные способы `AppActivate` функцию для активации окна приложения. Если Блокнот не запущена, в примере возникают исключения <xref:System.ArgumentException>. `Shell` Процедура предполагает приложения находятся в указанных путей.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Издает звуковой сигнал с помощью встроенного динамика компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Высота и продолжительность сигнала зависят от вашего оборудования и программного обеспечения системы и различаться между компьютерами.  
  
> [!NOTE]
>  `Beep` Функция требует `UIPermission` на <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> уровне, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 В этом примере используется `Beep` функция звуковой сигнал через динамик компьютера.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Обязательно. <see langword="Object" />. Указатель на объект, к которому относится данное свойство или метод.</param>
        <param name="ProcName">Обязательно. <see langword="String" />. Строковое выражение, содержащее имя свойства или метода объекта.</param>
        <param name="UseCallType">Обязательно. Член перечисления типа <see cref="T:Microsoft.VisualBasic.CallType" />, представляющий тип вызываемой процедуры. Значением <see langword="CallType" /> может быть <see langword="Method" />, <see langword="Get" /> или <see langword="Set" />.</param>
        <param name="Args">Необязательный. <see langword="ParamArray" />. Массив параметров, который содержит аргументы, передаваемые в вызываемый метод или свойство.</param>
        <summary>Выполняет метод объекта или устанавливает/возвращает значение свойства объекта.</summary>
        <returns>Выполняет метод объекта или устанавливает/возвращает значение свойства объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CallByName` Функция используется во время выполнения для получения свойства, задайте для свойства или вызвать метод.  
  
   
  
## Examples  
 В следующем примере первая строка использует `CallByName` для задания `Text` свойства текстового поля, вторая строка получает значение `Text` свойства, а третья строка вызывает `Move` метод для перемещения текстового поля.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 В следующем примере используется `CallByName` вызываемую функцию `Add` и `Item` методы объекта коллекции.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое значение <paramref name="UseCallType" />; должно быть <see langword="Method" />, <see langword="Get" /> или <see langword="Set" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Обязательно. <see langword="Double" />. Числовое выражение, результатом которого является значение между 1 и числом элементов, переданных в аргументе <c>Choice</c>.</param>
        <param name="Choice">Обязательно. Массив параметров <see langword="Object" />. Можно передать либо одну переменную, либо выражение, которое вычисляется как выражение типа <see langword="Object" />, как список переменных типа <see langword="Object" /> или список выражений, разделенных запятыми, либо как одномерный массив элементов типа <see langword="Object" />.</param>
        <summary>Выбирает и возвращает значение из списка аргументов.</summary>
        <returns>Выбирает и возвращает значение из списка аргументов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Choose` Функция возвращает элемент из списка, переданного в `Choice()`, основываясь на значении `Index`. Первый элемент списка выбирается при `Index` -1. Последний элемент списка выбирается при `Index` — `UBound`(`Choice()`). Если `Index` выходит за эти пределы `Choose` возвращает `Nothing`.  
  
 Если `Index` не является целым числом, оно округляется до ближайшего целого числа перед вычислением.  
  
 Можно использовать `Choose` для поиска значения в списке возможных значений.  
  
> [!NOTE]
>  Выражения в списке аргументов можно включать вызовы функций. В процессе подготовки списка аргументов для вызова `Choose`, компилятор Visual Basic вызывает каждую функцию в каждом выражении. Это означает, что нельзя полагаться на определенную функцию, которая не будет вызвана, если другое выражение выбран по `Index`.  
  
   
  
## Examples  
 В этом примере используется `Choose` функции для отображения имени в зависимости от индекса, которые передавались в процедуру в `Ind` параметра.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает набор аргументов командной строки, которая используется для запуска Visual Basic или выполняемой программы, разработанной с помощью Visual Basic. Возможность <see langword="My" /> обеспечивает большую производительность и быстродействие, чем функция <see langword="Command" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>Возвращает набор аргументов командной строки, которая используется для запуска Visual Basic или выполняемой программы, разработанной с помощью Visual Basic.  Возможность <see langword="My" /> обеспечивает большую производительность и быстродействие, чем функция <see langword="Command" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После возвращения аргументов, можно выполнить поиск общепринятых разделителей, например пробелы, символы косой черты назад или вперед, дефисы или кавычки, чтобы разбить или искомая строка для отдельных параметров.  
  
 Для приложений, разработанных с помощью Visual Basic и скомпилирована в файл .exe `Command` функция возвращает все аргументы, которые отображаются после имени приложения в командной строке, в этой форме: `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 В этом примере используется `Command` функция, возвращающая аргументы командной строки в объект, содержащий массив.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">Обязательно. <see langword="String" />. Программный идентификатор создаваемого объекта.</param>
        <param name="ServerName">Необязательный. <see langword="String" />. Имя сетевого сервера, на котором будет создан объект. Если параметр <c>ServerName</c> равен пустой строке (""), то используется локальный компьютер.</param>
        <summary>Создает и возвращает ссылку на COM-объект. Функция <see langword="CreateObject" /> не может использоваться для создания экземпляров классов в Visual Basic, если эти классы явным образом не представлены как COM-компоненты.</summary>
        <returns>Создает и возвращает ссылку на COM-объект. Функция <see langword="CreateObject" /> не может использоваться для создания экземпляров классов в Visual Basic, если эти классы явным образом не представлены как COM-компоненты.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания экземпляра компонента COM присвойте объект, возвращаемый `CreateObject` объектной переменной:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 Тип переменной объекта, используемого для сохранения возвращаемого объекта может повлиять на производительность приложения. Объявление объектной переменной с `As Object` предложение создает переменную, которая может содержать ссылку на объект любого типа. Тем не менее, имеет доступ к объекту через эту переменную *позднего связывания*, то есть привязка происходит при выполнении программы. Существует множество причин, что следует избегать позднего связывания, в том числе снижение производительности приложения.  
  
 Можно создать объектную переменную, которая с ранним связыванием, то есть привязки при компиляции программы. Чтобы сделать это, добавьте ссылку на библиотеку типов для объекта из **COM** вкладке **добавить ссылку** диалоговое окно в **проекта** меню. Затем объявите переменную объекта определенного типа объекта. В большинстве случаев это более эффективно использовать `Dim` инструкции и основную сборку взаимодействия для создания объектов, чем использование `CreateObject` функции.  
  
## <a name="interacting-with-unmanaged-code"></a>Взаимодействие с неуправляемым кодом  
 Другой проблема заключается в том, что COM-объектов используются неуправляемого кода — без преимуществом общеязыковая среда выполнения кода. Несет удовлетворительные степень сложности смешение управляемого кода Visual Basic с неуправляемым кодом из COM. При добавлении ссылки на COM-объект Visual Basic ищет основную сборку взаимодействия (PIA) для этой библиотеки; Если он обнаруживается, он использует его. Если не удается найти сборку PIA, создает сборку взаимодействия, которая содержит локальные классы взаимодействия для каждого класса в библиотеку COM. Дополнительные сведения см. в разделе [COM-взаимодействие в приложениях .NET Framework](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 Как правило, следует использовать сильно связанные объекты и основные сборки взаимодействия, когда это возможно. Примеры ниже используйте `CreateObject` только в целях функция объектов Microsoft Office для демонстрационных целей. Тем не менее эти объекты являются проще и надежнее при использовании с соответствующую основную сборку взаимодействия.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Создание объекта на удаленном компьютере  
 Можно создать объект на удаленном сетевом компьютере путем передачи имени компьютера для `ServerName` аргумент `CreateObject` функции. Это имя является таким же, как имя машины часть имени общего ресурса: для общей папки с именем «\\\MyServer\Public, « `ServerName` имеет значение «MyServer».  
  
> [!NOTE]
>  Обратитесь к документации по COM (см. Microsoft Developer Network) Дополнительные сведения о доступности приложения на удаленном сетевом компьютере. Необходимо добавить раздел реестра для вашего приложения.  
  
 Следующий код возвращает номер версии экземпляра Excel, запущенного на удаленном компьютере с именем `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Если указано неверное имя удаленного сервера или если он недоступен, то во время выполнения возникает ошибка.  
  
> [!NOTE]
>  Используйте `CreateObject` при нет текущего экземпляра объекта. Если экземпляр объекта уже выполняется, запускается новый экземпляр и создается объект указанного типа. Для использования существующего экземпляра или для запуска приложения и загрузки файла, используйте `GetObject` функции. Если объект зарегистрировался в виде одного экземпляра объекта, только один экземпляр объекта, создается независимо от того, как много раз `CreateObject` выполняется.  
  
## <a name="creating-framework-objects"></a>Создание объектов .NET Framework  
 Можно использовать `CreateObject` функции только для создания COM-объекта. Несмотря на отсутствие не полностью эквивалентный механизм для создания объекта .NET Framework <xref:System.Activator> в <xref:System> пространство имен содержит методы для создания локальных и удаленных объектов. В частности <xref:System.Activator.CreateInstance%2A> метода или <xref:System.Activator.CreateInstanceFrom%2A> метод может оказаться полезным.  
  
> [!IMPORTANT]
>  `CreateObject` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В следующем примере используется `CreateObject` функцию, чтобы создать лист Microsoft Excel и сохраняет журнал в файл. Чтобы использовать этот пример, на компьютере, где выполняется эта программа должен быть установлен Excel. Кроме того, необходимо добавить ссылку на библиотеку типов из **COM** вкладке **добавить ссылку** диалоговое окно в **проекта** меню. Имя библиотеки типов зависит от версии Excel, установленной на компьютере. Например, имя библиотеки типов для Microsoft Excel 2002 **библиотека объектов Microsoft Excel 10.0**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Сервер недоступен.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Объект указанного типа не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Обязательно. Выражение типа <see langword="String" />, содержащее имя приложения или проекта, к которому применяется настройка раздела или параметра.</param>
        <param name="Section">Обязательно. Значение типа <see langword="String" />, содержащее имя раздела, из которого удаляется настройка параметра. Если заданы только параметры <c>AppName</c> и <c>Section</c>, указанный раздел удаляется вместе со всеми относящимися к нему параметрами.</param>
        <param name="Key">Необязательный. Выражение типа <see langword="String" />, содержащее имя удаляемой настройки параметра.</param>
        <summary>Удаляет раздел или настройку параметра из записи приложения в реестре Windows. Возможность <see langword="My" /> предоставляет большую производительность и быстродействие в операциях с реестром, чем функция <see langword="DeleteSetting" />. Для получения дополнительной информации см. <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указаны все аргументы, указанная Настройка удаляется. Ошибка во время выполнения возникает, если вы пытаетесь использовать `DeleteSetting` для несуществующего раздела или настройки ключа.  
  
 `DeleteSetting` требует входа в в, так как `HKEY_LOCAL_USER` раздел реестра, который становится активным.  
  
 Параметры реестра, которые должны быть доступны из неинтерактивного процесса (например, Mtx.exe) должны храниться в рамках одного `HKEY_LOCAL_MACHINE\Software\` или `HKEY_USER\DEFAULT\Software` разделов реестра.  
  
   
  
## Examples  
 В следующем примере сначала используется `SaveSetting` процедуры, чтобы внести записи в реестр Windows для `MyApp` приложения, а затем используется `DeleteSetting` функции, чтобы удалить их. Так как не `Key` аргумент указан, весь `Startup` раздел удаляется, включая имя раздела и все его параметры.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Пользователь не выполнил вход в систему.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, связанную с переменной среды операционной системы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Обязательно. Значение, которое вычисляется либо как строка, содержащая имя переменной среды, либо как целое число, соответствующее порядковому номеру строки в таблице строк среды.</param>
        <summary>Возвращает строку, связанную с переменной среды операционной системы.</summary>
        <returns>Возвращает строку, связанную с переменной среды операционной системы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Expression` содержит строку, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> функция возвращает текст, присвоенный строке указанную среду — то есть текст, следующий знак равенства (=) в таблице строк среды для этой переменной среды. Если строка в `Expression` не удается найти в таблице строк среды строку нулевой длины ("») возвращается.  
  
 Если `Expression` содержит целое число, строка, занимающих, возвращается номером в таблице строк среды. В этом случае <xref:Microsoft.VisualBasic.Interaction.Environ%2A> возвращает весь текст, включая имя переменной среды. Если строка отсутствует в указанной позиции <xref:Microsoft.VisualBasic.Interaction.Environ%2A> возвращает строку нулевой длины.  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Функция требует разрешения среде, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере используется <xref:Microsoft.VisualBasic.Interaction.Environ%2A> функция ввести номер записи и длина `PATH` оператора из таблицы строки среды.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> отсутствует.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Обязательно. Значение, которое вычисляется либо как строка, содержащая имя переменной среды, либо как целое число, соответствующее порядковому номеру строки в таблице строк среды.</param>
        <summary>Возвращает строку, связанную с переменной среды операционной системы.</summary>
        <returns>Возвращает строку, связанную с переменной среды операционной системы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Expression` содержит строку, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> функция возвращает текст, присвоенный строке указанную среду — то есть текст, следующий знак равенства (=) в таблице строк среды для этой переменной среды. Если строка в `Expression` не удается найти в таблице строк среды строку нулевой длины ("») возвращается.  
  
 Если `Expression` содержит целое число, строка, занимающих, возвращается номером в таблице строк среды. В этом случае <xref:Microsoft.VisualBasic.Interaction.Environ%2A> возвращает весь текст, включая имя переменной среды. Если строка отсутствует в указанной позиции <xref:Microsoft.VisualBasic.Interaction.Environ%2A> возвращает строку нулевой длины.  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Функция требует разрешения среде, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере используется <xref:Microsoft.VisualBasic.Interaction.Environ%2A> функция ввести номер записи и длина `PATH` оператора из таблицы строки среды.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> отсутствует.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Обязательно. Выражение типа <see langword="String" />, содержащее имя приложения или проекта, для которого запрашиваются настройки параметров.</param>
        <param name="Section">Обязательно. Выражение <see langword="String" />, содержащее имя раздела, параметры которого запрашиваются. Функция <see langword="GetAllSettings" /> возвращает объект, содержащий двухмерный массив строк. Строки содержат все настройки параметров в указанном разделе плюс соответствующие значения.</param>
        <summary>Возвращает список параметров разделов и соответствующих значений (первоначально созданных с помощью функции <see langword="SaveSetting" />) из записи приложения в реестре Windows. Использование возможности <see langword="My" /> предоставляет большие производительность и быстродействие в операциях файлового ввода-вывода, чем <see langword="GetAllSettings" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Возвращает список параметров разделов и соответствующих значений (первоначально созданных с помощью функции <see langword="SaveSetting" />) из записи приложения в реестре Windows.  Использование возможности <see langword="My" /> предоставляет большие производительность и быстродействие в операциях файлового ввода-вывода, чем <see langword="GetAllSettings" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Возвращает неинициализированный `Object` при любом `AppName` или `Section` не существует.  
  
 Так как `HKEY_LOCAL_USER` реестра, который не активен входе пользователя в систему, `GetAllSettings` требует входа пользователя в систему.  
  
 Параметры реестра, которые должны быть доступны из неинтерактивного процесса (например, Mtx.exe) должны храниться в рамках одного `HKEY_LOCAL_MACHINE\Software\` или `HKEY_USER\DEFAULT\Software` разделов реестра.  
  
   
  
## Examples  
 В этом примере сначала используется `SaveSetting` функции, чтобы сделать записи в реестре Windows для приложения, указанного как `AppName`, затем использует `GetAllSettings` функции для отображения параметров. Обратите внимание, что приложение имена и `Section` имена не могут быть получены с `GetAllSettings`. Наконец `DeleteSetting` функция удаляет записи приложения.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Пользователь не выполнил вход в систему.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Необязательный. <see langword="String" />. Полный путь и имя файла, в котором содержится извлекаемый объект. Если параметр <c>PathName</c> не указан, требуется параметр <c>Class</c>.</param>
        <param name="Class">Обязательный параметр, если отсутствует параметр <c>PathName</c>. <see langword="String" />. Строка, представляющая класс объекта. Аргумент <c>Класс</c> имеет следующий синтаксис и части:  <c>appname</c><c>.</c><c>objecttype</c>  [1|1] Параметр  [1|2] Описание  [2|1] <c>appname</c>  [2|2] Обязательно. <see langword="String" />. Имя приложения, предоставляющего объект.  [3|1] <c>objecttype</c>  [3|2] Обязательно. <see langword="String" />. Тип или класс создаваемого объекта.</param>
        <summary>Возвращает ссылку на объект, предоставленную COM-компонентом.</summary>
        <returns>Возвращает ссылку на объект, предоставленную COM-компонентом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `GetObject` функции для загрузки экземпляра компонента COM из файла. Это показано в следующем примере.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 При запуске этого кода приложения, связанный с заданным `PathName` запускается и активируется объект в указанном файле.  
  
## <a name="default-cases"></a>Стандартные ситуации  
 Если `PathName` представляет собой строку нулевой длины (`""`), `GetObject` возвращает новый экземпляр объекта указанного типа класса. Если `PathName` аргумент указан, `GetObject` возвращает текущий активный объект типа класса, указанного в `Class`. Если объект указанного типа не существует, возникает ошибка.  
  
## <a name="accessing-a-subobject"></a>Доступ к подчиненному объекту  
 Некоторые приложения позволяют активировать вложенные объекты, связанные с файлом. Чтобы сделать это, добавьте восклицательный знак (`!`) в конец имени файла и выполните его с строка, определяющая часть файла нужно активировать. Сведения о том, как создать такую строку, см. в документации для приложения, в котором был создан объект.  
  
 Например в графическом приложении может содержать несколько слоев для рисования, хранятся в файле. Можно использовать следующий код для активации слоя в рисунке с именем `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Указание класса  
 Если вы не укажете объекта `Class`, автоматизации определяет приложение и объект для активации на основе имени файла, указываемые. Тем не менее, некоторые файлы, может поддерживать более одного класса объекта. Например, рисунок может поддерживать три разных типа объектов: `Application` объекта, `Drawing` объекта и `Toolbar` объекта, которые являются частью того же файла. Чтобы указать, какой объект файла, которую требуется активировать, используется необязательный `Class` аргумент. Это показано в следующем примере.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 В приведенном выше примере `Figment` имя графического приложения и `Drawing` является одним из типов объектов, которые он поддерживает.  
  
## <a name="using-the-object"></a>С помощью объекта  
 После того как объект активирован, можно ссылаться на него в коде, используя объявленную переменную объекта. В предыдущем примере доступ к свойствам и методам нового объекта, с помощью переменной объекта `drawObj`. Это показано в следующем примере.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Используйте `GetObject` функции при наличии текущего экземпляра объекта или если вы хотите создать объект с помощью загруженного файла. Если нет текущего экземпляра, а объект не следует загрузить файл, используйте <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> функции.  
>   
>  Если объект зарегистрировался как объект ActiveX с единственным экземпляром, только один экземпляр объекта, создается независимо от того, как много раз `CreateObject` вызывается. С помощью одного экземпляра объекта `GetObject` всегда возвращает один и тот же экземпляр при вызове с пустой строкой (`""`) синтаксис, который вызывает ошибку, если `PathName` аргумент был опущен. Нельзя использовать `GetObject` для получения ссылки на класс, созданный в Visual Basic.  
  
> [!IMPORTANT]
>  `GetObject` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В следующем примере используется `GetObject` функции для получения ссылки на один лист Microsoft Excel (`excelObj`). Она использует лист `Application` свойство для отображения Excel, чтобы закрыть его и для выполнения других действий. С помощью двух вызовов API `detectExcel` процедура ищет Excel и если он выполняется вход в таблицу действующего объекта. Первый вызов `GetObject` вызывает ошибку, если Excel не запущена, в этом примере вызывает `excelWasNotRunning` флаг будет установлен `True`. Второй вызов `GetObject` Указывает открываемый файл. Если Excel не запущена, второй вызов запускает его и возвращает ссылку на рабочий лист, представленный в указанном файле, `test.xls`. Файл должен существовать в указанном расположении; в противном случае Visual Basic создает <xref:System.IO.FileNotFoundException>. Затем в примере кода делает Excel и окно, содержащее указанный лист видимым.  
  
 Для этого примера требуются `Option Strict Off` , так как она используется позднее связывание, где объекты назначаются переменным типа `Object`. Можно указать `Option Strict On` и объявить объекты конкретных типов объектов, при добавлении ссылки на библиотеку типов Excel из **COM** вкладке **добавить ссылку** диалоговое окно ** Проект** меню в Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 При вызове `getExcel` функция, проверяется, чтобы проверить, установлена ли уже Excel. Если это не так, создается экземпляр.  
  
> [!IMPORTANT]
>  Для простоты в предыдущем примере предполагается, что любое окно с именем `XLMAIN` принадлежит экземпляру Microsoft Excel. Если другой объект, возможно, запущенным по злому умыслу создан окна с таким именем, он получит все сообщения, предназначенные для Excel. В приложении для использования в рабочей среде, следует включить более тщательную проверку, чтобы убедиться, что `XLMAIN` действительно принадлежит Excel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Объект указанного класса не существует.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Объект с указанным путем и именем файла не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Обязательно. Выражение типа <see langword="String" />, содержащее имя приложения или проекта, для которого запрашиваются настройки параметров.</param>
        <param name="Section">Обязательно. Выражение типа <see langword="String" />, содержащее имя раздела, в котором обнаружена настройка параметра.</param>
        <param name="Key">Обязательно. Выражение <see langword="String" />, содержащее имя настройки ключа, которое следует вернуть.</param>
        <param name="Default">Необязательный. Выражение, содержащее значение, которое следует вернуть, если в параметре <c>Key</c> значение отсутствует. Если этот параметр не задан, то предполагается, что <c>Default</c> является строкой нулевой длины ("").</param>
        <summary>Возвращает значение настройки параметра из записи приложения в реестре Windows. Возможность <see langword="My" /> предоставляет большую производительность и быстродействие в операциях реестра, чем функция <see langword="GetAllSettings" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Возвращает значение настройки параметра из записи приложения в реестре Windows.  Возможность <see langword="My" /> предоставляет большую производительность и быстродействие в операциях реестра, чем функция <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если любой из элементов с именем в `GetSetting` аргументами не существуют, `GetSetting` возвращает значение `Default`.  
  
 Так как `HKEY_LOCAL_USER` реестра, который не активен входе пользователя в систему, `GetSetting` требует входа пользователя в систему.  
  
 Параметры реестра, которые должны быть доступны из неинтерактивного процесса (например, Mtx.exe) должны храниться в рамках одного `HKEY_LOCAL_MACHINE\Software\` или `HKEY_USER\DEFAULT\Software` разделов реестра.  
  
 `GetSetting` требуется `Read` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 В этом примере сначала используется `SaveSetting` функции, чтобы сделать записи в реестре Windows для приложения, указанного как `AppName`, а затем использует `GetSetting` функцию, чтобы открыть один из параметров. Поскольку `Default` аргумент указан, возвращается гарантированно какое-либо значение. Обратите внимание, что `Section` имена не могут быть получены с `GetSetting`. Наконец `DeleteSetting` функция удаляет записи приложения.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Один или несколько аргументов не являются выражениями <see langword="String" />, или пользователь не вошел в систему.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Обязательно. <see langword="Boolean" />. Вычисляемое выражение.</param>
        <param name="TruePart">Обязательно. <see langword="Object" />. Возвращается, если результатом вычисления <c>Expression</c> является <see langword="True" />.</param>
        <param name="FalsePart">Обязательно. <see langword="Object" />. Возвращается, если результатом вычисления <c>Expression</c> является <see langword="False" />.</param>
        <summary>Возвращает один из двух объектов, в зависимости от результата вычисления выражения.</summary>
        <returns>Возвращает один из двух объектов, в зависимости от результата вычисления выражения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IIf` Функция предоставляет эквивалент для троичный [условный оператор:?:](http://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) в Visual C++.  
  
   
  
## Examples  
 В этом примере используется `IIf` функция, оцениваемая `testMe` параметр `checkIt` процедуру и возвращает это слово «Большой» в том случае, если сумма больше 1000; в противном случае он возвращает слово «Small».  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Обратите внимание, что если `Option Strict` — `On`, необходимо использовать `CStr` ключевое слово для явного преобразования возвращаемого значения из `Object` для `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">Требуется выражение типа <see langword="String" />, отображаемое в диалоговом окне в виде сообщения. Максимальная длина параметра <c>Prompt</c> составляет примерно 1024 символов и зависит от ширины используемых символов. Если <c>Prompt</c> состоит из нескольких строк, то строки можно разделить с помощью знака возврата каретки (<see langword="Chr(" />13<see langword=")" />), знака перевода строки (<see langword="Chr(" />10<see langword=")" />) или сочетания возврата каретки и перевода строки (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) после каждой строки.</param>
        <param name="Title">Необязательный. Выражение типа <see langword="String" />, отображаемое в строке заголовка диалогового окна. Если параметр <c>Title</c> не указан, в строку заголовка помещается имя приложения.</param>
        <param name="DefaultResponse">Необязательный. Выражение типа <see langword="String" />, отображаемое в качестве ответного сообщения по умолчанию, если ничего другого не было введено. Если параметр <c>DefaultResponse</c> не задан, отображаемое текстовое поле будет пустым.</param>
        <param name="XPos">Необязательный. Числовое выражение, которое задает расстояние в твипах между левым краем диалогового окна и левым краем экрана. Если параметр <c>XPos</c> не указан, то диалоговое окно центрируется по горизонтали.</param>
        <param name="YPos">Необязательный. Числовое выражение, которое задает расстояние в твипах между верхним краем диалогового окна и верхним краем экрана. Если параметр <c>YPos</c> не указан, то диалоговое окно располагается на уровне, составляющем примерно треть высоты экрана.</param>
        <summary>Отображает приглашение в диалоговом окне, ожидает ввода текста или нажатия кнопки и возвращает строку, являющуюся содержимым текстового поля.</summary>
        <returns>Отображает приглашение в диалоговом окне, ожидает ввода текста или нажатия кнопки и возвращает строку, являющуюся содержимым текстового поля.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если пользователь нажимает кнопку **отменить**, возвращается строка нулевой длины.  
  
 Чтобы указать несколько первый аргумент, необходимо использовать `InputBox` функции в выражении. Если какие-либо аргументы опущен, необходимо сохранить соответствующие разделители-запятые.  
  
> [!NOTE]
>  `InputBox` Функция требует `UIPermission` на <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> уровне, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе и <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 В этом примере показаны различные способы использования `InputBox` функции, чтобы предложить пользователю ввести значение. Если x и y позиции опущены, диалоговое окно автоматически центрируется по соответствующим осям. Переменная `MyValue` содержит значение, введенное пользователем, если пользователь нажимает кнопку ОК или клавиши ВВОД.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">Обязательно. Выражение типа <see langword="String" />, отображаемое в диалоговом окне в виде сообщения. Максимальная длина параметра <c>Prompt</c> составляет примерно 1024 символов и зависит от ширины используемых символов. Если <c>Prompt</c> состоит из нескольких строк, то строки можно разделить с помощью знака возврата каретки (<see langword="Chr(" />13<see langword=")" />), знака перевода строки (<see langword="Chr(" />10<see langword=")" />) или сочетания возврата каретки и перевода строки (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) после каждой строки.</param>
        <param name="Buttons">Необязательный. Числовое выражение, являющееся суммой значений, задающих номер и тип отображаемых кнопок, стиль используемого значка, тип кнопки по умолчанию и признак модальности окна сообщения. Если параметр <c>Buttons</c> не указан, по умолчанию используется нулевое значение.</param>
        <param name="Title">Необязательный. Выражение типа <see langword="String" />, отображаемое в строке заголовка диалогового окна. Если параметр <c>Title</c> не указан, в строку заголовка помещается имя приложения.</param>
        <summary>Отображает сообщение в диалоговом окне, ожидает нажатия кнопки и возвращает целое число, показывающее, какая кнопка была нажата.</summary>
        <returns>
          <list type="table">
            <item>
              <term> Константа  </term>
              <description> Значение  </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1  </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2  </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3  </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4  </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5  </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6  </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7  </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если какие-либо аргументы опущен, необходимо сохранить соответствующие разделители-запятые.  
  
 Если диалоговое окно отображает **отменить** кнопки, нажатие клавиши ESC имеет тот же эффект, что и нажатие кнопки **Отмена**  
  
 Если диалоговое окно содержит **справки** кнопки, предоставляется контекстная справка для диалогового окна. Тем не менее значение не возвращается, пока не будет выбрано одно из этих кнопок. В приложениях Windows Form, выбрав **справки** кнопка выполняет <xref:System.Windows.Forms.Control.HelpRequested> событий для формы.  
  
> [!NOTE]
>  `MsgBox` Функция требует `UIPermission` на <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> уровне, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.UIPermission>.  
  
 `MsgBoxStyle` Значений перечисления, перечислены в следующей таблице.  
  
|Член|Значение|Описание:|  
|-|-|-|  
|Член|Значение|Описание:|  
|`OKOnly`|0|Отображается только кнопка OK.|  
|`OKCancel`|1|Кнопки "Отмена" и отображает ОК.|  
|`AbortRetryIgnore`|2|Отображает кнопки Abort, повторите попытку и пропустить.|  
|`YesNoCancel`|3|Да, нет и кнопки отмены.|  
|`YesNo`|4|Отображает кнопки Да и нет.|  
|`RetryCancel`|5|Отображаются кнопки "Повторить" и "Отмена".|  
|`Critical`|16|Отображается значок сообщения о критической ошибке.|  
|`Question`|32|Отображается значок предупреждения с запросом.|  
|`Exclamation`|48|Отображается значок предупреждения.|  
|`Information`|64|Отображается значок информационного сообщения.|  
|`DefaultButton1`|0|По умолчанию используется первая кнопка.|  
|`DefaultButton2`|256|По умолчанию используется вторая кнопка.|  
|`DefaultButton3`|512|По умолчанию используется третья кнопка.|  
|`ApplicationModal`|0|Приложение является модальным. Пользователь должен ответить на окно сообщения перед продолжением работы текущего приложения.|  
|`SystemModal`|4096|Система является модальным. Все приложения приостанавливаются, пока пользователь не ответит на окно сообщения.|  
|`MsgBoxSetForeground`|65536|Указывает окно сообщения отображается как окно переднего плана.|  
|`MsgBoxRight`|524288|Текст по правому краю.|  
|`MsgBoxRtlReading`|1048576|Указывает, что текст должен отображаться как справа налево чтения на иврит и арабский системы.|  
  
 Первая группа значений (0 – 5) описывает число и тип кнопок, отображаемых в диалоговом окне. Вторая группа (16, 32, 48, 64) описывает стиль значка. Третья группа (0, 256, 512) определяет, какая кнопка по умолчанию. Четвертая группа (0, 4096) определяет модальность окна сообщения и пятая группа определяет, является ли окно сообщения отображается поверх других окон, выравнивание текста и направление текста. При добавлении чисел для получения окончательного значения `Buttons` аргумент, используйте только одно число из каждой группы.  
  
   
  
## Examples  
 В этом примере используется `MsgBox` функции для отображения сообщений о критической ошибки в диалоговом окне с Да и нет. «Нет» определяется как ответ по умолчанию. Это делается путем объединения `MsgBox` значения констант в одно числовое выражение. В этом случае сложения 4 (сочетание кнопок Да/Нет) и 16 ( **критическое сообщение** окна) и 256 (вторая кнопка как кнопка по умолчанию) предоставляет общее значение 276. Значение, возвращаемое `MsgBox` функция зависит от выбранного пользователем кнопки: Да, возвращает значение 6; Не возвращает значение 7.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Либо <paramref name="Prompt" /> — это не выражение типа <see langword="String" />, либо параметр <paramref name="Title" /> имеет недопустимое значение.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс не выполняется в режиме интерактивного взаимодействия с пользователем.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Один или несколько параметров не являются членами перечислений <see langword="MsgBoxResult" /> или <see langword="MsgBoxStyle" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">Обязательно. <see langword="Long" />. Целое значение, которое нудно разместить в одном из вычисленных диапазонов.</param>
        <param name="Start">Обязательно. <see langword="Long" />. Целое значение, которое обозначает начало набора вычисленных диапазонов. Значение параметра <c>Start</c> не может быть меньше 0.</param>
        <param name="Stop">Обязательно. <see langword="Long" />. Целое значение, которое обозначает конец набора вычисленных диапазонов. Значение <c>Stop</c> не может быть меньше или равно значению <c>Start</c>.</param>
        <param name="Interval">Обязательно. <see langword="Long" />. Целое значение, которое определяет размер каждого вычисленного диапазона между значениями <c>Start</c> и <c>Stop</c>. Значение параметра <c>Interval</c> не может быть меньше 1.</param>
        <summary>Возвращает строку, предоставляющую вычисленный диапазон, содержащий число.</summary>
        <returns>Возвращает строку, предоставляющую вычисленный диапазон, содержащий число.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Partition` Функция вычисляет набор числовых диапазонов, каждый из которых содержит количество значений, указанное в `Interval`. Первый диапазон начинается с `Start`, а последний диапазон заканчивается на `Stop`. `Partition` Функция определяет, какой диапазон содержит `Number` и возвращает строку, описывающую этот диапазон. Диапазон представлен строкой в виде "*lowervalue*:*uppervalue*», где нижний предел диапазона (*lowervalue*) отделена от верхней границы (* upperValue*) с помощью символа двоеточия (:).  
  
 При необходимости `Partition` функция вставляет начальные пробелы перед *lowervalue* и *uppervalue* так, чтобы они имели число символов, как строковое представление (значение `Stop` + 1). Это гарантирует, что если использовать выходные данные `Partition` функция с несколькими значениями `Number`, полученный текст будет обрабатываться должным образом при всех последующих операций сортировки.  
  
 В следующей таблице показаны примеры строк для диапазонов, вычисленных с помощью трех наборов `Start`, `Stop`, и `Interval`. «Первый диапазон» и «Последнего диапазона» столбцы показывают нижний и верхний возможные диапазоны для данных значений `Start` и `Stop`. «Перед первым диапазоном» и «после последнего диапазона» показывают строки, возвращаемые для значений `Number` меньше, чем `Start` и больше `Stop`соответственно.  
  
|`Start`|`Stop`|`Interval`|Перед первым диапазоном|Первый интервал|Последний диапазон|После последнего диапазона|  
|-|-|-|-|-|-|-|  
|0|99|5|": -1»|"0: 4"|«95: 99»|«100:»|  
|20|199|10|": 19"|«20:29 "|"190:199"|«200:»|  
|100|1010|20|": 99"|«100: 119»|"1000:1010"|«1011:»|  
  
 В предыдущей таблице третья строка содержит результат при `Start` и `Stop` определяют набор чисел, который невозможно разделить равномерно по `Interval`. Последний диапазон заканчивается на `Stop`, сделав его только 11 цифр, даже если `Interval` — 20.  
  
 Если `Interval` -1, диапазон — от «`Number`:`Number`», независимо от `Start` и `Stop` аргументы. Например если `Number` — 267, `Stop` — 1 000, и `Interval` -1, `Partition` возвращает «267: 267».  
  
 `Partition` можно использовать при создании запросов к базе данных. Можно создать запрос SELECT, показывающий количество заказов, возникающих в различные диапазоны значений, например с накладной значения от 1 до 1000, 1001 и 2000 и т. д.  
  
   
  
## Examples  
 В следующем примере серия диапазонов для десятилетий с 1950-2049 года. Она выполняет поиск значения `year` в соответствующем диапазоне и возвращает `String` значение, отображающее диапазон. Если `year` имеет значение 1984, например, `Partition` возвращает «1980: 1989».  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" /> или <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Обязательно. Выражение типа <see langword="String" />, содержащее имя приложения или проекта, в котором применяется этот параметр.</param>
        <param name="Section">Обязательно. Выражение типа <see langword="String" />, содержащее имя раздела, в котором сохраняется настройка параметра реестра.</param>
        <param name="Key">Обязательно. Выражение типа <see langword="String" />, содержащее имя сохраняемой настройки параметра реестра.</param>
        <param name="Setting">Обязательно. Выражение, содержащее значение, которое устанавливается для параметра <c>Key</c>.</param>
        <summary>Сохраняет или создает запись приложения в реестре Windows. Возможность <see langword="My" /> предоставляет большую производительность и быстродействие в операциях реестра, чем функция <see langword="SaveSetting" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `SaveSetting` Функция добавляет ключ к `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Если для какой-либо причине не удалось сохранить настройки параметра, возникает ошибка.  
  
 `SaveSetting` требует входа в в, так как `HKEY_LOCAL_USER` раздел реестра, который становится активным.  
  
 Параметры реестра, которые должны быть доступны из неинтерактивного процесса (например, Mtx.exe) должны храниться в рамках одного `HKEY_LOCAL_MACHINE\Software\` или `HKEY_USER\DEFAULT\Software` разделов реестра.  
  
 `SaveSetting` требуется `Write` и `Create` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 В следующем примере сначала используется `SaveSetting` функции, чтобы сделать записи в реестре Windows для `MyApp` приложения, а затем используется `DeleteSetting` функции, чтобы удалить их.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Реестр ключа не может быть создан, или пользователь не выполнил вход в систему.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" />
        <Parameter Name="Wait" Type="System.Boolean" />
        <Parameter Name="Timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательно. <see langword="String" />. Имя программы для выполнения, а также все обязательные аргументы и параметры командной строки. <c>PathName</c> также может включать диск и путь к каталогу или папку.  Если путь к программе неизвестен, для ее поиска можно использовать <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />. Например, можно вызвать функцию <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>, которая возвращает полный путь для каждого файла с именем <c>testFile.txt</c> в любом месте на диске C:\\.</param>
        <param name="Style">Необязательный. <see langword="AppWinStyle" />. Значение, выбранное из перечисления <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> и задающее стиль окна, в котором запускается программа. Если параметр <c>Style</c> не задан, <see langword="Shell" /> использует стиль <see langword="AppWinStyle.MinimizedFocus" />, запуская программу в свернутом состоянии и с установленным фокусом.</param>
        <param name="Wait">Необязательный. <see langword="Boolean" />. Значение, показывающее должна ли функция <see langword="Shell" /> ожидать завершения программы. Если параметр <c>Wait</c> не задан, <see langword="Shell" /> использует значение <see langword="False" />.</param>
        <param name="Timeout">Необязательный. <see langword="Integer" />. Число миллисекунд ожидания завершения, если значение <c>Wait</c> равно <see langword="True" />. Если параметр <c>Timeout</c> не задан, функция <see langword="Shell" /> использует значение –1, которое означает, что время ожидания не используется и <see langword="Shell" /> ожидает завершения выполнения программы. Таким образом, если опустить параметр <c>Timeout</c> или установить его равным –1, существует возможность, что функция <see langword="Shell" /> никогда не вернет управление в программу.</param>
        <summary>Запускает исполняемую программу и возвращает целочисленное значение, содержащее идентификатор процесса программы, если программа в данный момент все еще выполняется.</summary>
        <returns>Запускает исполняемую программу и возвращает целочисленное значение, содержащее идентификатор процесса программы, если программа в данный момент все еще выполняется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение `Shell` функция зависит от того, является ли программа с именем в `PathName` по-прежнему выполняется при `Shell` возвращает. Если задать `Wait` для `True` и программа завершается до истечения времени ожидания, `Shell` возвращает ноль. Если время ожидания истекает или если не указан `Wait` или присвойте ей значение `False`, `Shell` возвращает идентификатор процесса программы. Идентификатор процесса — уникальный номер, определяющий запущенную программу.  
  
## <a name="failure-to-start"></a>Не удалось запустить  
 Если `Shell` функция не может выполнить указанную программу, <xref:System.IO.FileNotFoundException> возникает ошибка. Это может произойти, например, при попытке запуска 16-разрядные программы, такие как `command.com`, из приложения с помощью <xref:System.Windows.Forms?displayProperty=nameWithType>. Для обойти это ограничение можно запустить 32-разрядных программ, вызывающих требуемой 16-разрядное приложение. В случае использования `command.com`, можно выполнить `cmd.exe` в качестве альтернативы.  
  
## <a name="waiting-for-completion"></a>Ожидание завершения  
 По умолчанию `Shell` функция выполняет программу асинхронно. Это означает, что программа, запущенная с `Shell` функция может не завершиться до операторы, следующие `Shell` выполняются функции. Чтобы отложить программы для завершения, прежде чем продолжить, установите `Wait` для `True`.  
  
## <a name="determining-the-exit-code"></a>Определение кода выхода  
 Процесс может возвращать *код выхода* после его завершения. Тем не менее, нельзя использовать `Shell` для извлечения этого кода выхода, так как `Shell` возвращает нуль, если он ожидает завершения, а также потому, что процесс выполняется в другом объекте `Shell`.  
  
 Чтобы получить код выхода из процесса, необходимо написать собственный код для запуска процесса и ожидать завершения. В следующем примере показано, как инициировать процесс, дождаться его завершения и извлечь его код выхода.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>Защита спецификации файла  
 Следует всегда заключать весь путь и файл в кавычки, как показано в следующем примере.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Каждая пара соседних двойных кавычек (`" "`) в строке литерал интерпретируется как один символ двойных кавычек в строке. Таким образом, в предыдущем примере передается следующую строку, чтобы `Shell` функции:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Если отсутствует путь заключен в кавычки, Windows будет искать файл с именем `Program.exe` в каталоге C:\ вместо `display.exe` в каталоге C:\Program Files.  
  
> [!IMPORTANT]
>  Если вы не заключаете путь и файл в кавычки, есть риск безопасности, если имя файла или путь содержит пробелы. В предыдущем примере путь узла `\Program Files` содержит пробел. Если спецификация не были в кавычки и программа с именем `Program.exe` были установлены в C:\\, например по злому умыслу, Windows будет выполнять его вместо `display.exe`.  
  
> [!IMPORTANT]
>  `Shell` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В следующем примере используется `Shell` функцию для выполнения приложения, указанного пользователем. Указание <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> как второй аргумент запускает приложение в нормального размера и передает ему фокус.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> вне диапазона от 0 до 9 включительно.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> не удается найти файл <paramref name="PathName" />.</exception>
        <exception cref="T:System.NullReferenceException">Свойство <paramref name="PathName" /> имеет значение <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Обязательно. Массив параметров <see langword="Object" />. Должен содержать четное количество элементов. Можно передать список переменных типа <see langword="Object" /> или выражений, разделенных запятыми, либо одномерный массив элементов типа <see langword="Object" />.</param>
        <summary>Вычисляет значения выражений из списка и возвращает значение <see langword="Object" />, соответствующее первому выражению в списке, которое равно <see langword="True" />.</summary>
        <returns>Вычисляет значения выражений из списка и возвращает значение <see langword="Object" />, соответствующее первому выражению в списке, которое равно <see langword="True" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Аргумент для `VarExpr` состоит из пар выражений и значений. `Switch` Функция вычисляет нечетных выражений от нижнего до наибольшего индекса в `VarExpr`и возвращает четное значение, связанное с первым выражением, результатом которого является `True`. Например если `VarExpr(0)` — `True`, `Switch` возвращает `VarExpr(1)`и если `VarExpr(0)` — `False` , но `VarExpr(2)` — `True`, `Switch` возвращает `VarExpr(3)`, и т. д.  
  
 Если не указать `VarExpr` аргумент, `Switch` возвращает `Nothing`.  
  
> [!NOTE]
>  Выражения в списке аргументов можно включать вызовы функций. В процессе подготовки списка аргументов для вызова `Switch`, компилятор Visual Basic вызывает каждую функцию в каждом выражении. Это означает, что нельзя полагаться на определенную функцию, которая не будет вызвана, если предыдущее выражение в списке аргументов `True`.  
  
   
  
## Examples  
 В следующем примере используется `Switch` функция возвращает имя языка, соответствующего названию города. Необходимо, `Option Strict` быть `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Поскольку <xref:System.Diagnostics> пространство имен также содержит класс с именем <xref:System.Diagnostics.Switch>, вызов `Switch` функции должны быть дополнены <xref:Microsoft.VisualBasic> пространства имен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Число элементов нечетно.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>