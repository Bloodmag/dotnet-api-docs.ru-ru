<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8fb289e3db8f78e3c0d8ab3e407138cd550b88bd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30351178" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет объекты <see cref="T:Microsoft.Win32.RegistryKey" />, представляющие корневые разделы в реестре Windows, и методы <see langword="static" /> для доступа к парам "раздел-значение".</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс предоставляет набор стандартных корневых ключей, найденных в реестре компьютеров под управлением Windows. Реестр является средством хранения сведений о приложениях, пользователей и параметры системы по умолчанию. Например приложения используют реестр для хранения сведений, которые необходимо сохранить после закрытия приложения и доступа к этой информации при перезагрузке приложения. Например можно сохранять цветовые настройки, положение или размер окна. Можно управлять эти данные для каждого пользователя, сохраняя данные в другое расположение в реестре.  
  
 Базовое или корневое <xref:Microsoft.Win32.RegistryKey> экземпляров, предоставляемые `Registry` класс разграничения базовый механизм хранения подразделы и значения в реестре. Все ключи доступны только для чтения, так как реестр зависит от их существования. Ключи, предоставляемые `Registry` являются:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Хранит сведения о настройках пользователя.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Сохраняет сведения о конфигурации для локального компьютера.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Хранит сведения о типах (и классах) и их свойств.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Хранит сведения о пользовательских настроек по умолчанию.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Хранит сведения о производительности для компонентов программного обеспечения.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Хранит данные пользователя определенного оборудования.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Сохранение динамических данных.  
  
 После определения корневого ключа, из которой требуется для хранения или извлечения информации из реестра, можно использовать <xref:Microsoft.Win32.RegistryKey> класса, чтобы добавить или удалить подразделы и изменять значения для заданного ключа.  
  
 Устройства можно разместить сведения в реестр автоматически, используя интерфейс Plug and Play. Программное обеспечение для установки драйверов устройств можно поместить сведения в реестре, написав стандартным API-интерфейсам.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Статические методы для получения и задания значений  
 В .NET Framework версии 2.0 <xref:Microsoft.Win32.Registry> класс также содержит `static` <xref:Microsoft.Win32.Registry.GetValue%2A> и <xref:Microsoft.Win32.Registry.SetValue%2A> методов задания и получения значения из реестра. Эти методы откройте и закройте параметры реестра каждый раз, они используются, поэтому они не выполняют, а также аналогичные методы в <xref:Microsoft.Win32.RegistryKey> класса, при доступе к большое количество значений.  
  
 <xref:Microsoft.Win32.RegistryKey> Класс также предоставляет методы, которые позволяют задать безопасность управления доступом Windows для разделов реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано корневые ключи, а во втором примере показано `static` <xref:Microsoft.Win32.Registry.GetValue%2A> и <xref:Microsoft.Win32.Registry.SetValue%2A> методы.  
  
 Пример 1  
  
 В следующем примере кода показано, как получить подразделов для раздела HKEY_USERS и печати их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в `RegistryKey` для управления данным ключом.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода сохраняет значения некоторых типов данных реестра, создание ключа, как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (безымянные) имени и значения по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет типы (или классы) документов и свойства, связанные с этими типами. Это поле считывает базовый раздел реестра Windows HKEY_CLASSES_ROOT.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В стандартных приложениях и OLE-приложения используйте данные, хранящиеся в этом разделе. Этот ключ также обеспечивает обратную совместимость с базой данных регистрации Windows 3.1, сохраняя сведения для поддержки DDE и OLE. Средства просмотра файлов и расширения пользовательского интерфейса хранят свои идентификаторы класса OLE в этот ключ, и серверы обработки регистрируются в этом разделе.  
  
   
  
## Examples  
 Следующий пример демонстрирует процесс получения подразделов этого раздела и выводит их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления данным ключом.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о конфигурации, относящиеся к оборудованию, не связанному с конкретным пользователем. Это поле считывает базовый раздел реестра Windows HKEY_CURRENT_CONFIG.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член сопоставляется подраздел в <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Пример использования этого элемента — это приложение, которое сохраняет другое имя сервера для своих данных в зависимости от того, прикреплено ли система к сети.  
  
   
  
## Examples  
 Следующий пример демонстрирует процесс получения подразделов этого раздела и выводит их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления данным ключом.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о текущих пользовательских параметрах. Это поле считывает базовый раздел реестра Windows HKEY_CURRENT_USER.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения, сохраненные в этом разделе относятся настройки переменных среды и данные о группы программ, цвета, принтеры, сетевые подключения и параметры приложения. Этот ключ позволяет устанавливать параметры для текущего пользователя. В этом разделе поставщики программного обеспечения сохраняют текущий пользовательские параметры, которые должны использоваться в своих приложениях. Microsoft, например, создает ключ приведенный для их приложений для использования, причем каждое приложение создает свой собственный подразделом ключ Майкрософт.  
  
   
  
## Examples  
 Следующий пример демонстрирует процесс получения подразделов этого раздела и выводит их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления данным ключом.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит динамические данные реестра. Это поле считывает базовый раздел реестра Windows HKEY_DYN_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реестр Windows 98/Windows Me поддерживает статические данные (которые хранятся на диске в реестре) и динамических данных (которые часто изменяются, например Статистика производительности). Эта область динамических данных является механизм, позволяющий драйверы виртуальных устройств (VxD) для предоставления данных в режиме реального времени для приложений Win32, которые могут выполняться удаленно, как и локально. Она также позволяет системному монитору предоставлять статистику производительности для удаленных систем Windows 98/Windows Me.  
  
 Vxd не ограничены данными о производительности. Они могут предоставить любые данные, которые они хотят эффективно передать из кольца 0 в кольцо 3 без монополизации ресурсов ЦП. Реестр поддерживает динамические данные путем сохранения указателя на функцию, возвращающую значение (или много значений). Если вызов реестра запрашивает значения, связанные с динамическим ключом, эта функция вызывается для возврата необходимого значения или значений.  
  
> [!NOTE]
>  Динамические разделы появились в Microsoft Windows 95 для обработки динамических данных реестра. Они поддерживаются только в Windows 98 и Windows Me.  
  
   
  
## Examples  
 Следующий пример демонстрирует процесс получения подразделов этого раздела и выводит их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления данным ключом. Обратите внимание, что в этом примере можно результаты не возвращаются, поскольку может не иметься динамических данных или, возможно, вы не используете Windows 98 / ME. С помощью этого ключа может вызвать ошибку в других системах.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Операционная система не поддерживает платформу динамических данных, то есть она не может быть Windows 98, Windows 98 Second Edition или Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="defaultValue">Возвращаемое значение, если параметр <c>valueName</c> не существует.</param>
        <summary>Извлекает значение, связанное с указанным именем, в указанном разделе реестра. Если имя не найдено в указанном разделе, возвращает предоставленное значение по умолчанию или значение <see langword="null" />, если указанный раздел не существует.</summary>
        <returns>
          Значение <see langword="null" />, если вложенный раздел, заданный параметром <paramref name="keyName" />, не существует; в противном случае — значение, связанное с параметром <paramref name="valueName" />, или <paramref name="defaultValue" />, если значение параметра <paramref name="valueName" /> не найдено.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка `valueName` не учитывается регистр знаков.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, которое не связан с любым именем. Когда это безымянное значение отображается в редакторе реестра, строка «(Default)» отображается вместо имени. Для получения этого безымянного значения, укажите `null` или пустая строка ("») для `valuName`.  
  
 Действительный корневой, называются HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, раздел HKEY_PERFORMANCE_DATA HKEY_CURRENT_CONFIG и HKEY_DYN_DATA. Например в Visual Basic строка «HKEY_CURRENT_USER\MyTestKey» обращается к пары ключ значение для подраздела «MyTestKey» в корне HKEY_CURRENT_USER.  
  
 Когда <xref:Microsoft.Win32.RegistryKey.GetValue%2A> метод извлекает значения Расширяемая строка (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), он расширяет строк среды с использованием данных из локальной среды. Если значение содержит расширяемый ссылки на переменные среды, сохраненный в виде строки (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), а не как Расширяемая строка (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> не расширяет. Вы можете развернуть такой строки после получения путем вызова <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> метод.  
  
> [!NOTE]
>  Для получения данных из раздел HKEY_PERFORMANCE_DATA рекомендуется использовать <xref:System.Diagnostics.PerformanceCounter> класса вместо <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> метод.  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A> И <xref:Microsoft.Win32.Registry.SetValue%2A> методы откройте и закройте параметры реестра каждый раз, они используются, поэтому они не выполняют, а также методы <xref:Microsoft.Win32.RegistryKey> класса при доступе к большое количество значений.  
  
 <xref:Microsoft.Win32.RegistryKey> также предоставляет методы, позволяющие добавить список управления доступом (ACL) для раздела реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
   
  
## Examples  
 В следующем примере кода сохраняет значения некоторых типов данных реестра, создание ключа, как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (безымянные) имени и значения по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для чтения из раздела реестра.</exception>
        <exception cref="T:System.IO.IOException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" />, содержащий заданное значение, был помечен для удаления.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">чтение из реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Чтобы прочитать раздел реестра типа REG_EXPAND_SZ. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит данные о конфигурации для локального компьютера. Это поле считывает базовый раздел реестра Windows HKEY_LOCAL_MACHINE.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` содержит пять ключей.  
  
 Оборудование  
 Описывает способ использования драйверы устройств, оборудование и сопоставления и связанные данные, соединяющие драйверы режима ядра с кодом пользовательского режима физического оборудования на компьютере. Все данные в этом разделе создается заново при каждом запуске системы. Описание подраздел описывает фактические аппаратные. Раздел DeviceMap содержит различные данные в форматах конкретных классов драйверов. ResourceMap подраздел описывает, какие драйверы устройств аппаратным ресурсам. Программа диагностики Windows NT (Winmsdp.exe) может передавать данные в соответствии с содержимым в виде для чтения.  
  
 SAM  
 Базы данных служб каталогов, сведения о безопасности для пользователей и групп, а также для доменов в Windows 2000 Server (SAM — диспетчер учетных записей безопасности, известных как базы данных служб каталогов).  
  
 Безопасность  
 Содержит локальную политику безопасности, например особые права пользователя. Этот ключ используется только подсистемой безопасности Windows 2000.  
  
 Программное обеспечение  
 База данных, программного обеспечения на компьютере. Этот раздел содержит данные о программах, установленных на локальном компьютере, вместе с различными элементами разнообразных данных о конфигурации.  
  
 Система  
 Определяет время запуска системы, загрузкой драйвера устройств, службами Windows 2000 и поведение операционной системы.  
  
 По соглашению, если существует схожие данные в группе <xref:Microsoft.Win32.Registry.CurrentUser> и в разделе <xref:Microsoft.Win32.Registry.LocalMachine>, данные в <xref:Microsoft.Win32.Registry.CurrentUser> имеет более высокий приоритет. Тем не менее значения в этом разделе можно также расширить (а не заменять) данные в Registry.LocalMachine. Кроме того некоторые элементы (например, элементы загрузки драйвера устройства) не имеют смысла, если они возникают вне Registry.LocalMachine.  
  
   
  
## Examples  
 Следующий пример демонстрирует процесс получения подразделов этого раздела и выводит их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления данным ключом.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о производительности для компонентов программного обеспечения. Это поле считывает базовый раздел реестра Windows HKEY_PERFORMANCE_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый программный компонент создает ключи для своих объектов и счетчиков, если он установлен и записывает данные счетчиков в процессе выполнения. Доступ к этим данным, что и к другим данным реестра, с помощью <xref:Microsoft.Win32.RegistryKey> функции.  
  
 Несмотря на то, что реестр используется для сбора данных о производительности, данные не хранятся в базе данных реестра. Вместо этого при доступе к реестру с помощью этого параметра заставляет систему собирать данные из соответствующих системных диспетчеров объектов.  
  
 Чтобы получить данные о производительности из локальной системы, используйте <xref:Microsoft.Win32.RegistryKey.GetValue%2A> метод, с ключом Registry.PerformanceData. Первый вызов открывает ключ (вам не обязательно явно сначала открыть раздел). Тем не менее, обязательно используйте <xref:Microsoft.Win32.RegistryKey.Close%2A> метод, чтобы закрыть дескриптор ключ, когда вы закончите, получение данных о производительности. Пользователь не может установить или удалить программный компонент, данные о производительности во время использования.  
  
 Чтобы получить данные о производительности из удаленной системы, необходимо использовать <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> метод с именем компьютера удаленной системы и ключом Registry.PerformanceData. Этот вызов извлекает ключ, представляющий данные о производительности для удаленной системы. Для получения данных, вызовите <xref:Microsoft.Win32.RegistryKey.GetValue%2A> с помощью этого ключа, а не ключом Registry.PerformanceData.  
  
> [!NOTE]
>  В Windows Server 2003, пользователь должен хотя бы принадлежать к группе пользователей системного монитора для доступа к базовым подразделы.  
  
   
  
## Examples  
 Следующий пример демонстрирует процесс получения подразделов этого раздела и выводит их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления данным ключом. Обратите внимание, что в этом примере можно результаты не возвращаются, поскольку могут быть данные о производительности.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает значение пары "имя-значение" в разделе реестра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода сохраняет значения некоторых типов данных реестра, создание ключа, как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (безымянные) имени и значения по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="value">Сохраняемое значение.</param>
        <summary>Задает указанное значение пары "имя-значение" для указанного раздела реестра. Если указанный раздел не существует, он будет создан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` параметр больше не ограничены более 255 символов; Однако `keyName` параметр по-прежнему имеет ограничение длиной в 255 символов.  
  
 Поскольку многие значения могут храниться в каждый раздел реестра, необходимо использовать `valueName` для указания, нужно задать конкретное значение.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, которое не связан с любым именем. Когда это безымянное значение отображается в редакторе реестра, строка «(Default)» отображается вместо имени. Чтобы задать это безымянное значение, укажите `null` или пустая строка ("») для `valueName`.  
  
 Если `valueName` не существует в ключе, оно создается и ее значение равно `value`.  
  
 Если `keyName` указывает соответствующий раздел реестра, который не существует, создается подраздел, в указанный корневой. Например в Visual Basic строка «HKEY_CURRENT_USER\MyTestKey» создает подраздел «MyTestKey» в корне HKEY_CURRENT_USER. Строка «HKEY_CURRENT_USER\MyTestKey\Key2\Key3» создает вложенных раздела «MyTestKey», «MyTestKey\Key2» и «MyTestKey\Key2\Key3».  
  
 Допустимый корневой имена включают HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, раздел HKEY_PERFORMANCE_DATA HKEY_CURRENT_CONFIG и HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> Метод откроется раздел реестра, устанавливает значение и закрывает ключ при каждом вызове. Если необходимо изменить большое количество значений, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> метод может обеспечить более высокую производительность. <xref:Microsoft.Win32.RegistryKey> Класс также предоставляет методы, позволяющие добавить список управления доступом (ACL) для раздела реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
 Эта перегрузка <xref:Microsoft.Win32.Registry.SetValue%2A> хранятся 64-битовых целых чисел в виде строк (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Для хранения 64-разрядные числа как <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> значения, используйте <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> перегрузки метода.  
  
 Эта перегрузка <xref:Microsoft.Win32.Registry.SetValue%2A> хранятся все строковые значения как <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> объектов, даже если они содержат раскрывающиеся ссылки на переменные среды. Для сохранения строковых значений, как развернуть строки (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), используйте <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> перегрузки метода.  
  
 Эта перегрузка эквивалентно вызову <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> перегрузка метода с <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  В Windows 98 и Windows Millennium Edition (Windows Me) реестра не в Юникоде и не все символы Юникода допустимы для всех кодовых страниц. Знак Юникода, который является недопустимым для текущей кодовой страницы, заменяется наиболее подходящим соответствием. Исключение не возникает.  
  
   
  
## Examples  
 В следующем примере кода сохраняет значения некоторых типов данных реестра, создание ключа, как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (безымянные) имени и значения по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.  
  
 - или -  
  
 Значение параметра <paramref name="keyName" /> длиннее максимально допустимой длины (255 знаков).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" /> является разделом только для чтения и запись в него невозможна, например, если это узел корневого уровня.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для изменения разделов реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для изменения заданного раздела реестра, если он существует, или создайте раздел реестра, если он еще не существует. Связанные перечисления: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="value">Сохраняемое значение.</param>
        <param name="valueKind">Тип данных реестра, используемый при сохранении данных.</param>
        <summary>Задает пару "имя-значение" для указанного раздела реестра, используя указанный тип данных реестра. Если указанный раздел не существует, он будет создан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` параметр больше не ограничены более 255 символов; Однако `keyName` параметр по-прежнему иметь ограничение длиной в 255 символов.  
  
 Поскольку многие значения могут храниться в каждый раздел реестра, необходимо использовать `valueName` для указания, нужно задать конкретное значение.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, которое не связан с любым именем. Когда это безымянное значение отображается в редакторе реестра, строка «(Default)» отображается вместо имени. Чтобы задать это безымянное значение, укажите `null` или пустая строка ("») для `valueName`.  
  
 Если `valueName` не существует в ключе, оно создается и ее значение равно `value`.  
  
 Если `keyName` указывает соответствующий раздел реестра, который не существует, создается подраздел, в указанный корневой. Например в Visual Basic строка «HKEY_CURRENT_USER\MyTestKey» создает подраздел «MyTestKey» в корне HKEY_CURRENT_USER. Строка «HKEY_CURRENT_USER\MyTestKey\Key2\Key3» создает вложенных раздела «MyTestKey», «MyTestKey\Key2» и «MyTestKey\Key2\Key3».  
  
 Допустимый корневой имена включают HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, раздел HKEY_PERFORMANCE_DATA HKEY_CURRENT_CONFIG и HKEY_DYN_DATA.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> Метод откроется раздел реестра, устанавливает значение и закрывает ключ при каждом вызове. Если необходимо изменить большое количество значений, <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> метод может обеспечить более высокую производительность. <xref:Microsoft.Win32.RegistryKey> Класс также предоставляет методы, позволяющие добавить список управления доступом (ACL) для раздела реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.  
  
 Если тип указанного `value` не соответствует указанным `valueKind`, и данные не могут быть преобразованы, <xref:System.ArgumentException> возникает исключение. Например, можно хранить <xref:System.Int64?displayProperty=nameWithType> как <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, но только в том случае, если его значение меньше, чем максимальное значение <xref:System.Int32?displayProperty=nameWithType>. Не удается сохранить одно строковое значение как <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если процессор значения передаются <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> или <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, преобразование осуществляется с помощью инвариантного языка и региональных параметров.  
  
> [!NOTE]
>  В Windows 98 и Windows Millennium Edition (Windows Me) реестра не в Юникоде и не все символы Юникода допустимы для всех кодовых страниц. Знак Юникода, который является недопустимым для текущей кодовой страницы, заменяется наиболее подходящим соответствием. Исключение не возникает.  
  
   
  
## Examples  
 В следующем примере кода сохраняет значения некоторых типов данных реестра, создание ключа, как он делает это, а затем извлекает и отображает значения. В примере показано, хранения и извлечения пары (безымянные) имени и значения по умолчанию, а также использование `defaultValue` при пару имя значение не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.  
  
 - или -  
  
 Значение параметра <paramref name="keyName" /> длиннее максимально допустимой длины (255 знаков).  
  
 - или -  
  
 Тип параметра <paramref name="value" /> не соответствует типу данных реестра, заданному параметром <paramref name="valueKind" />, поэтому данные не удалось правильно преобразовать.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" /> доступен только для чтения, и, следовательно, запись в него невозможна (например, это узел корневого уровня или раздел не был открыт с доступом для записи).</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для изменения разделов реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для изменения заданного раздела реестра, если он существует, или создайте раздел реестра, если он еще не существует. Связанные перечисления: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о стандартной пользовательской конфигурации. Это поле считывает базовый раздел реестра Windows HKEY_USERS.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот раздел содержит ветвь для каждого пользователя компьютера. Конфигурация по умолчанию предоставляется для новых пользователей на локальном компьютере и для текущего пользователя по умолчанию, если пользователь не изменил параметры. Поскольку Windows 98 / ME также поддерживает Registry.Users, приложения могут обращаться к сведения о пользователе так же, как и в среде Windows 2000. Сведения о каждом пользователе хранятся в отдельном файле, который можно сохранить локально или на сетевом сервере. Windows 98 / ME можно скопировать этот файл в текущей системе пользователя, чтобы параметры можно переместить с одного компьютера на другой с пользователем.  
  
   
  
## Examples  
 Следующий пример демонстрирует процесс получения подразделов этого раздела и выводит их имен на экране. Используйте <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> метод для создания экземпляра определенного подраздела интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления данным ключом.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>