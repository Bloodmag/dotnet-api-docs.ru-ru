<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d99d25be1d24abd932081d3e03fd39286f0da69" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037645" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет доступ к уведомлениям о системных событиях. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.Win32.SystemEvents> Класс предоставляет также возможность реагировать на определенных типов событий системы.  
  
 При возникновении системных событий каких-либо делегатов, присоединенное к событию вызываются с помощью потока, который отслеживает системные события. Таким образом следует выполнить все вызовы из вашей событий обработчики потокобезопасной. Если необходимо вызвать системный элемент, который не представлен как член этого класса, можно использовать <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> метода.  
  
> [!CAUTION]
>  Не выполняет много времени обработки в потоке, который вызывает обработчик событий системы, так как он может помешать работе других приложений.  
  
> [!NOTE]
>  Некоторые системные события не вызываются на [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Обязательно убедитесь, что приложение работает ожидаемым образом [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Этот раздел содержит два примера. В первом примере показано, как использовать системные события в обычных приложениях, а во втором примере показано, как использовать системные события в службе Windows.  
  
 **Пример 1.**  
  
 В следующем примере кода регистрируется заинтересованность в некоторых системных событий и ждет любого из этих событий. Показанный результат возникает, если пользователь изменяет разрешение экрана.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода показано очень простое служба Windows, которая обрабатывает <xref:Microsoft.Win32.SystemEvents.TimeChanged> и <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> события. Пример содержит службу с именем `SimpleService`, форму с именем `HiddenForm`и установщик. Форма предоставляет цикл сообщений, необходимых для системных событий.  
  
> [!NOTE]
>  Службы не имеют циклы обработки сообщений, если они могут взаимодействовать с рабочим столом. Если цикл обработки сообщений не предоставляется скрытой формой, как в этом примере служба должна запускаться под учетной записью локальной системы и ручное вмешательство для взаимодействия с рабочим столом. То есть, администратор должен вручную проверить **Разрешить взаимодействие с рабочим столом** флажок на **вход в систему** свойства диалогового окна «службы». В этом случае цикл сообщений предоставляется автоматически. Этот параметр доступен только в том случае, если служба выполняется под учетной записью локальной системы. Взаимодействие с рабочим столом не удается разрешить программными средствами.  
  
 Служба в этом примере запускает поток, который выполняет экземпляр `HiddenForm`. События подключаются и обрабатываются в форме. События должны вызываться события load формы, чтобы убедиться в том, что форма является полной загрузки. в противном случае события не вызываются.  
  
> [!NOTE]
>  В примере приводится весь необходимый код, включая код инициализации, обычно создается в конструкторах Visual Studio. Если вы разрабатываете службу в Visual Studio, можно опустить втором разделяемом классе и использовать **свойства** окно, чтобы задать высоту и ширину формы скрытых до нуля, стиль границы для <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>и состояние окна <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Чтобы запустить пример:  
  
1.  Скомпилируйте код из командной строки. Имя, используемое для исходного файла не имеет значения.  
  
2.  Установка из командной строки с помощью службы [Installutil.exe (установщик)](~/docs/framework/tools/installutil-exe-installer-tool.md) программы. Например `InstallUtil example.exe` Если имя исходного файла `example.cs` или `example.vb`. Необходимо иметь права администратора для установки службы.  
  
3.  Используйте консоль служб для запуска службы.  
  
4.  Изменение системного времени, или пользовательские настройки, например свойства мыши.  
  
5.  Просмотр сообщений в **приложения** категории средства просмотра событий.  
  
6.  Используйте консоль служб для остановки службы.  
  
7.  Удалить службу из командной строки с помощью `/u` параметр. Например, `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">для полного доступа к системным ресурсам. Требовать значения: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Связанное состояние:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Определяет интервал между уведомлениями таймера, в миллисекундах.</param>
        <summary>Создает новый таймер окна, связанный с окном системных событий.</summary>
        <returns>Идентификатор нового таймера.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Интервал меньше или равен нулю.</exception>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий или попытка создания таймера закончилась неудачей.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь изменяет параметры дисплея.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода показано, как отслеживать <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> событий. Данный пример кода является частью большего примера, приведенного для <xref:Microsoft.Win32.SystemEvents> класса.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении параметров дисплея.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит перед завершением потока, прослушивающего системные события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие вызывается в поток, который ожидает передачи данных для системных событий является прервано. Делегаты системных событий вызываются с помощью потока, прослушивающего системные события.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь добавляет шрифты в систему или удаляет шрифты из системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Делегат, вызываемый с помощью потока, прослушивающего системные события.</param>
        <summary>Вызывает заданный делегат, используя поток, прослушивающий системные события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать каждый раз, когда необходимо обработать событие системы, в противном случае значение не предоставляется по <xref:Microsoft.Win32.SystemEvents> класса.  
  
 При вызове этого метода заданный делегат будет вызываться потоком, приложение использует для обработки системных событий.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Идентификатор таймера, работу которого нужно завершить.</param>
        <summary>Завершает работу таймера, заданного идентификатором.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий или попытка завершения работы таймера закончилась неудачей.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при недостатке оперативной памяти в системе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие служит оболочкой WM_COMPACTING сообщения. Это сообщение отправляется всем окнам верхнего уровня, когда система обнаруживает, что более 12,5 процентов системного времени в течение 30 - 60-секундного интервала тратится на сжатие памяти. Это означает, что недостаточно системной памяти.  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <block subset="none" type="usage">
          <para>Это сообщение предоставляется только для совместимости с 16-разрядных приложений на основе Windows.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь переходит к приложению, которое использует другую палитру.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода показано, как отслеживать <xref:Microsoft.Win32.SystemEvents.PaletteChanged> событий. Данный пример кода является частью большего примера, приведенного для <xref:Microsoft.Win32.SystemEvents> класса.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь приостанавливает или возобновляет работу системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь выходит из системы или завершает ее работу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь пытается выйти из системы или завершить ее работу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие является отменяемым. Установка <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> свойства `true` запросит сеанса продолжает выполняться. Он предоставляет гарантии, что сеанс не будет завершен.  
  
 Если вы используете <xref:Microsoft.Win32.SystemEvents.SessionEnding> в Windows form для обнаружения выхода из системы или перезагрузки, имеется однозначно установить ли <xref:System.Windows.Forms.Form.Closing> событие будет срабатывать до этого события.  
  
 Если вы хотите выполнять некоторые специальные задачи до <xref:System.Windows.Forms.Form.Closing> — запущено, необходимо убедиться, что <xref:Microsoft.Win32.SystemEvents.SessionEnding> срабатывает перед <xref:System.Windows.Forms.Form.Closing>. Для этого необходимо перехватывать `WM_QUERYENDSESSION` в форме, переопределив `WndProc` функции.  В этом примере показано, как это сделать.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Консольные приложения не вызывают <xref:Microsoft.Win32.SystemEvents.SessionEnding> событий.  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после смены текущего вошедшего в систему пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь изменяет время системных часов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда заканчивается интервал таймера Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения пользовательских параметров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении пользовательских параметров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это событие вызывается только в том случае, если выполняется цикл обработки сообщений. В службе Windows Если не используется скрытый форма или конвейер сообщений был запущен вручную, это событие не формируется. Пример кода, демонстрирующий способы обработки событий системы с помощью скрытой формы в службе Windows, см. в разделе <xref:Microsoft.Win32.SystemEvents> класса.  
  
> [!CAUTION]
>  Это статическое событие, необходимо отсоединить обработчики событий, при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода показано, как отслеживать <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> событий. Данный пример кода является частью большего примера, приведенного для <xref:Microsoft.Win32.SystemEvents> класса.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В текущем контексте уведомления о системных событиях не поддерживаются. Например, серверные процессы могут не поддерживать уведомлений о глобальных системных событиях.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Попытка создания потока окна системных событий завершилась неудачей.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>