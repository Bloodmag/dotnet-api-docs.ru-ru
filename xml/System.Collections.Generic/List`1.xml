<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="47ae3da1b2bf50d9dceb876a96986d68c4c2edf0" />
    <Meta Name="ms.sourcegitcommit" Value="9f18ecaf63382fa565dfaeb7274bc1a9e81c35e9" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/19/2018" />
    <Meta Name="ms.locfileid" Value="36208878" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Тип элементов в списке.</typeparam>
    <summary>Представляет строго типизированный список объектов, доступных по индексу. Поддерживает методы для поиска по списку, выполнения сортировки и других операций со списками.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Класса является универсальным, равное <xref:System.Collections.ArrayList> класса. Он реализует <xref:System.Collections.Generic.IList%601> универсальный интерфейс с помощью массива, размер которого динамически увеличивается по мере необходимости.  
  
 Можно добавить элементы к <xref:System.Collections.Generic.List%601> с помощью <xref:System.Collections.Generic.List%601.Add%2A> или <xref:System.Collections.Generic.List%601.AddRange%2A> методы.  
  
 <xref:System.Collections.Generic.List%601> Классе используется компаратор проверки на равенство и компаратор упорядочения.  
  
-   Такие методы, как <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, и <xref:System.Collections.Generic.Dictionary%602.Remove%2A> используют компаратор проверки на равенство для элементов списка. Компаратор проверки на равенство по умолчанию для типа `T` определяется следующим образом. Если тип `T` реализует <xref:System.IEquatable%601> универсальный интерфейс, то компаратор проверки на равенство является <xref:System.IEquatable%601.Equals%28%600%29> метод этого интерфейса; в противном случае сравнения по умолчанию является <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Такие методы, как <xref:System.Collections.Generic.List%601.BinarySearch%2A> и <xref:System.Collections.Generic.List%601.Sort%2A> используют компаратор упорядочения для элементов списка. Компаратор по умолчанию для типа `T` определяется следующим образом.  Если тип `T` реализует <xref:System.IComparable%601> универсальный интерфейс, то функция сравнения по умолчанию является <xref:System.IComparable%601.CompareTo%28%600%29> метод этого интерфейса; в противном случае, если тип `T` реализует неуниверсальный <xref:System.IComparable> интерфейс, то значение по умолчанию функция сравнения является <xref:System.IComparable.CompareTo%28System.Object%29> метода этого интерфейса. Если тип `T` реализует ни один из интерфейсов, то компаратор по умолчанию, и компаратор или делегат сравнения должен быть предоставлен явно.  
  
 <xref:System.Collections.Generic.List%601> Не обязательно быть отсортированы.  Сначала нужно отсортировать <xref:System.Collections.Generic.List%601> перед выполнением операций (таких как <xref:System.Collections.Generic.List%601.BinarySearch%2A>), требующих <xref:System.Collections.Generic.List%601> должны быть отсортированы.  
  
 Элементы в этой коллекции осуществляется с помощью целочисленного индекса.  Индексы в этой коллекции отсчитываются от нуля.  
  
 Для очень больших <xref:System.Collections.Generic.List%601> объектов Максимальная емкость 2 миллиардов элементы в 64-разрядной системе можно повысить, указав `enabled` атрибута элемента конфигурации для `true` в среде выполнения.  
  
 <xref:System.Collections.Generic.List%601> принимает `null` как допустимое значение для ссылки на типы и допускает наличие повторяющихся элементов.  
  
 Для неизменяемого версии <xref:System.Collections.Generic.List%601> см. в описании <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Особенности производительности  
 В определении того, следует ли использовать <xref:System.Collections.Generic.List%601> или <xref:System.Collections.ArrayList> класса, имеющих аналогичные функциональные возможности, следует помнить, что <xref:System.Collections.Generic.List%601> дает более высокую производительность, в большинстве случаев класс и является типобезопасным. При использовании ссылочного типа для типа `T` из <xref:System.Collections.Generic.List%601> класс, класс идентичен. Однако при использовании типа значения для типа `T`, необходимо учитывать проблемы Упаковка-преобразование и реализации.  
  
 При использовании типа значения для типа `T`, компилятор создает реализацию <xref:System.Collections.Generic.List%601> класс специально для этого типа значения. Это значит, элемент списка <xref:System.Collections.Generic.List%601> объект не имеет упаковываемого перед элемент может быть использован и после создания примерно 500 элементов списка памяти, сохранены не упаковка-преобразование списка элементов больше, чем объем памяти, используемый для создания реализации класса.  
  
 Убедитесь в тип значения, используемые для типа `T` реализует <xref:System.IEquatable%601> универсальный интерфейс. Если нет, методов, таких как <xref:System.Collections.Generic.List%601.Contains%2A> необходимо вызвать <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод, который упаковывается в элемент списка затронутых. Если реализует тип значения <xref:System.IComparable> интерфейс и вы владельцем исходного кода, также реализуют <xref:System.IComparable%601> универсальный интерфейс для предотвращения <xref:System.Collections.Generic.List%601.BinarySearch%2A> и <xref:System.Collections.Generic.List%601.Sort%2A> методов из упаковка элементов списка. Если вы не являетесь владельцем исходного кода, передайте <xref:System.Collections.Generic.IComparer%601> объект <xref:System.Collections.Generic.List%601.BinarySearch%2A> и <xref:System.Collections.Generic.List%601.Sort%2A> методов  
  
 Это полезно использовать реализацию определенного типа <xref:System.Collections.Generic.List%601> класса вместо использования <xref:System.Collections.ArrayList> класса или записи коллекции строго типизированную оболочку самостоятельно. Причина заключается в необходимо выполнять в реализации .NET Framework назначение автоматически уже и общеязыковая среда выполнения могут совместно использовать код MSIL и метаданных, которое не может быть вашей реализации.  
  
## <a name="f-considerations"></a>Рекомендации по F #  
 <xref:System.Collections.Generic.List%601> Класс редко используется в коде F #.  Вместо этого [перечислены](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), которые являются неизменяемыми, однонаправленных списков, предпочтительнее, обычно. Список F # предоставляет упорядоченная, неизменная ряд значений и поддерживается для использования при разработке функциональном стиле. При использовании F # <xref:System.Collections.Generic.List%601> класс обычно ссылается [ResizeArray\<'T >](https://msdn.microsoft.com/library/ee353447.aspx) -сокращенная форма, чтобы избежать конфликтов с F # список имен типа  
  
   
  
## Examples  
 В следующем примере показано, как добавлять, удалять и вставлять простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере показано несколько свойств и методов <xref:System.Collections.Generic.List%601> универсальный класс строкового типа. (Например, <xref:System.Collections.Generic.List%601> сложных типов. в разделе <xref:System.Collections.Generic.List%601.Contains%2A> метод.)  
  
 Конструктор по умолчанию используется для создания списка строк с емкостью по умолчанию. <xref:System.Collections.Generic.List%601.Capacity%2A> Свойство отображается и затем <xref:System.Collections.Generic.List%601.Add%2A> метод используется, чтобы добавить несколько элементов. Перечислены элементы и <xref:System.Collections.Generic.List%601.Capacity%2A> отображаются свойства, вместе с <xref:System.Collections.Generic.List%601.Count%2A> свойство, чтобы показать, что емкость увеличен при необходимости.  
  
 <xref:System.Collections.Generic.List%601.Contains%2A> Метод используется для проверки наличия элемента в списке <xref:System.Collections.Generic.List%601.Insert%2A> метод используется для вставки нового элемента в середине списка и снова отображается содержимое списка.  
  
 Значение по умолчанию <xref:System.Collections.Generic.List%601.Item%2A> свойство (индексатор в C#) используется для извлечения элемента <xref:System.Collections.Generic.List%601.Remove%2A> метод используется для удаления первого экземпляра повторяющийся элемент, добавленный ранее, и снова отображается содержимое. <xref:System.Collections.Generic.List%601.Remove%2A> Метод всегда удаляет он встречает первый экземпляр.  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A> Метод используется для уменьшения емкости для совпадает с количеством и <xref:System.Collections.Generic.List%601.Capacity%2A> и <xref:System.Collections.Generic.List%601.Count%2A> отображаются свойства. Если было неиспользуемого пространства менее 10% от общей емкости, список будет не изменились.  
  
 Наконец <xref:System.Collections.Generic.List%601.Clear%2A> метод используется для удаления всех элементов в списке и <xref:System.Collections.Generic.List%601.Capacity%2A> и <xref:System.Collections.Generic.List%601.Count%2A> отображаются свойства.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  Безопасно для выполнения нескольких операций чтения на <see cref="T:System.Collections.Generic.List`1" />, но проблемы могут возникнуть, если коллекция была изменена во время его чтения. Для обеспечения потокобезопасности, заблокировать коллекцию во время чтения или записи. Чтобы включить сбор должен осуществляться из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию. Коллекции с помощью встроенных синхронизации см <see cref="N:System.Collections.Concurrent" /> пространства имен. Альтернативу по своей природе поточно ориентированного см. в разделе <see cref="T:System.Collections.Immutable.ImmutableList`1" /> класса.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.Generic.List`1" />, который является пустым и имеет начальную емкость по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.List%601> — количество элементов, <xref:System.Collections.Generic.List%601> может содержать. При добавлении элементов к <xref:System.Collections.Generic.List%601>, емкость автоматически увеличивается, если это требуется перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, с помощью <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> конструктор и указав начальной емкостью избавляет от необходимости выполнять операции изменения размера при добавлении элементов в <xref:System.Collections.Generic.List%601>.  
  
 Емкость может быть уменьшена путем вызова <xref:System.Collections.Generic.List%601.TrimExcess%2A> метода или установив <xref:System.Collections.Generic.List%601.Capacity%2A> свойство явным образом. Уменьшение емкости перераспределяет память и копирует все элементы в <xref:System.Collections.Generic.List%601>.  
  
 Этот конструктор является операцией o(1).  
  
   
  
## Examples  
 В следующем примере демонстрируется конструктор по умолчанию для <xref:System.Collections.Generic.List%601> универсального класса. Конструктор по умолчанию создает список с емкостью по умолчанию, как показано отображение <xref:System.Collections.Generic.List%601.Capacity%2A> свойство.  
  
 В примере добавляет, добавляет и удаляет отображаются как емкость изменяется эти методы используются элементы.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Коллекция, элементы которой копируются в новый список.</param>
        <summary>Инициализирует новый экземпляр <see cref="T:System.Collections.Generic.List`1" />, который содержит элементы, скопированные из указанной коллекции, и имеет емкость, достаточную для размещения всех скопированных элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы копируются на <xref:System.Collections.Generic.List%601> в том же порядке, они доступны для чтения с помощью перечислителя коллекции.  
  
 Этот конструктор является операцией O (*n*) операции, где *n* — число элементов в `collection`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.%23ctor%2A> конструктора, а также различные методы <xref:System.Collections.Generic.List%601> класс, который будет действовать на диапазоны. Массив строк, которое передается конструктору, заполнение списка с элементами массива. <xref:System.Collections.Generic.List%601.Capacity%2A> Свойство отображается, и покажет, начальной емкостью является именно то, которое требуется для хранения входных элементов.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="collection" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Число элементов, которые может изначально вместить новый список.</param>
        <summary>Инициализирует новый пустой экземпляр класса <see cref="T:System.Collections.Generic.List`1" /> с указанной начальной емкостью.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Емкость <xref:System.Collections.Generic.List%601> — количество элементов, <xref:System.Collections.Generic.List%601> может содержать. При добавлении элементов к <xref:System.Collections.Generic.List%601>, емкость автоматически увеличивается, если это требуется перераспределения внутреннего массива.  
  
 Если размер коллекции можно оценить, целесообразно указать начальную емкость избавляет от необходимости выполнять операции изменения размера при добавлении элементов в <xref:System.Collections.Generic.List%601>.  
  
 Емкость может быть уменьшена путем вызова <xref:System.Collections.Generic.List%601.TrimExcess%2A> метода или установив <xref:System.Collections.Generic.List%601.Capacity%2A> свойство явным образом. Уменьшение емкости перераспределяет память и копирует все элементы в <xref:System.Collections.Generic.List%601>.  
  
 Этот конструктор является операцией O (*n*) операции, где *n* — `capacity`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> конструктор. Объект <xref:System.Collections.Generic.List%601> строк с емкостью 4 создается, так как максимальный размер списка известно только 4. Список заполняется четыре строки, и создается копия только для чтения с помощью <xref:System.Collections.Generic.List%601.AsReadOnly%2A> метод.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект, добавляемый в конец коллекции <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Добавляет объект в конец очереди <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> принимает `null` как допустимое значение для ссылки на типы и допускает наличие повторяющихся элементов.  
  
 Если <xref:System.Collections.Generic.List%601.Count%2A> равно <xref:System.Collections.Generic.List%601.Capacity%2A>, емкости из <xref:System.Collections.Generic.List%601> увеличивается на автоматического перераспределения внутреннего массива и существующие элементы копируются в новый массив перед добавлением нового элемента.  
  
 Если <xref:System.Collections.Generic.List%601.Count%2A> — меньше, чем <xref:System.Collections.Generic.List%601.Capacity%2A>, этот метод является операцией o(1). Если емкость требуется увеличить для размещения нового элемента, этот метод становится операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показано, как добавлять, удалять и вставлять простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере показано несколько свойств и методов <xref:System.Collections.Generic.List%601> универсального класса, включая <xref:System.Collections.Generic.List%601.Add%2A> метод. Конструктор по умолчанию используется для создания списка строк с емкостью 0. <xref:System.Collections.Generic.List%601.Capacity%2A> Отображается свойство, а затем <xref:System.Collections.Generic.List%601.Add%2A> метод используется, чтобы добавить несколько элементов. Перечислены элементы и <xref:System.Collections.Generic.List%601.Capacity%2A> отображаются свойства, вместе с <xref:System.Collections.Generic.List%601.Count%2A> свойство, чтобы показать, что емкость увеличен при необходимости.  
  
 Другие свойства и методы используются для поиска, вставки и удаления элементов из списка и, наконец, чтобы очистить список.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Коллекция, элементы которой добавляются в конец списка <see cref="T:System.Collections.Generic.List`1" />. Сама коллекция не может иметь значение <see langword="null" />, но может содержать элементы, имеющие значение <see langword="null" />, если тип <c>T</c> является ссылочным типом.</param>
        <summary>Добавляет элементы указанной коллекции в конец списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок элементов в коллекции, сохраняется в <xref:System.Collections.Generic.List%601>.  
  
 Если новый <xref:System.Collections.Generic.List%601.Count%2A> (текущего <xref:System.Collections.Generic.List%601.Count%2A> плюс размер коллекции) больше значения <xref:System.Collections.Generic.List%601.Capacity%2A>, емкости из <xref:System.Collections.Generic.List%601> увеличивается на автоматически перераспределения внутреннего массива для размещения новых элементов и существующие элементы копируются в новый массив перед добавлением новых элементов.  
  
 Если <xref:System.Collections.Generic.List%601> может вместить новые элементы без увеличения <xref:System.Collections.Generic.List%601.Capacity%2A>, этот метод является операцией O (*n*) операции, где *n* число добавляемых элементов. Если емкость требуется увеличить для размещения новых элементов, этот метод становится операцией O (*n* + *m*) операции, где *n* — количество элементов для добавления и *m* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.AddRange%2A> метод и различные методы класса <xref:System.Collections.Generic.List%601> класс, который будет действовать на диапазоны. Массив строк, которое передается конструктору, заполнение списка с элементами массива. <xref:System.Collections.Generic.List%601.AddRange%2A> Метод вызывается с список в качестве аргумента. Результатом является то, что текущие элементы списка добавляются в конец списка, дублирование все элементы.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="collection" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает для текущей коллекции оболочку <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, доступную только для чтения.</summary>
        <returns>Объект, который служит оболочкой, обеспечивающей доступность текущего списка <see cref="T:System.Collections.Generic.List`1" /> только для чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить любые изменения <xref:System.Collections.Generic.List%601> объекта, предоставляется только через эту оболочку. Объект <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> объект не предоставляет методы, позволяющие изменять коллекцию. Однако при внесении изменений в базовом <xref:System.Collections.Generic.List%601> объекта, эти изменения отражаются в коллекции только для чтения.  
  
 Этот метод является операцией o(1).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.AsReadOnly%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк с емкостью 4 создается, так как максимальный размер списка известно только 4. Список заполняется четыре строки и <xref:System.Collections.Generic.List%601.AsReadOnly%2A> метод используется для получения только для чтения <xref:System.Collections.Generic.IList%601> реализацию универсального интерфейса, который создает оболочку для исходного списка.  
  
 Исходный список имеет значение «Coelophysis» с помощью <xref:System.Collections.Generic.List%601.Item%2A> свойство (индексатор в C#) и содержимое только для чтения список снова отображаются для демонстрации того, что это просто оболочкой для исходного списка.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Использует алгоритм двоичного поиска для нахождения определенного элемента в отсортированном списке <see cref="T:System.Collections.Generic.List`1" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Искомый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Выполняет поиск элемента по всему отсортированному списку <see cref="T:System.Collections.Generic.List`1" />, используя компаратор по умолчанию, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Отсчитываемый от нуля индекс элемента <paramref name="item" /> в отсортированном списке <see cref="T:System.Collections.Generic.List`1" />, если элемент <paramref name="item" /> найден; в противном случае — отрицательное число, которое является поразрядным дополнением индекса следующего элемента, большего, чем <paramref name="item" />, или, если большего элемента не существует, поразрядным дополнением значения <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует функцию сравнения по умолчанию <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> для типа `T` для определения порядка элементов списка. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Ли проверки свойств введите `T` реализует <xref:System.IComparable%601> универсального интерфейса и использует эту реализацию в том случае, если он доступен.  В противном случае <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable> интерфейса.  Если тип `T` не реализует один из этих интерфейсов <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Уже должны быть отсортированы в соответствии с реализацией функции сравнения; в противном случае результат неверен.  
  
 Сравнение `null` с любого ссылочного типа может и не создает исключение при использовании <xref:System.IComparable%601> универсальный интерфейс. При сортировке, `null` считается меньше любого другого объекта.  
  
 Если <xref:System.Collections.Generic.List%601> содержит более одного элемента с тем же значением, метод возвращает только одно из вхождений и он может возвратить один элемент, не обязательно первый из них.  
  
 Если <xref:System.Collections.Generic.List%601> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить побитовую операцию дополнения (~) для этого отрицательное целое число, возвращается индекс первого элемента, большего, чем искомое значение. При вставке значения в <xref:System.Collections.Generic.List%601>, следует использовать этот индекс позиции для сохранения порядка сортировки.  
  
 Этот метод является операцией O (журнала *n*) операции, где *n* — количество элементов в диапазоне.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort> перегрузка метода и <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> перегрузки метода. Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется четырьмя строками в произвольном порядке. Список отображается, сортировки и отображаться в дальнейшем.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Перегрузка метода затем используется для поиска двух строк, которые не находятся в списке, и <xref:System.Collections.Generic.List%601.Insert%2A> метод используется для вставки узлов. Возвращаемое значение <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> метод отрицательное значение в каждом случае, так как строки не входят в список. Поразрядное дополнение (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) для этого отрицательного числа дает индекс первого элемента в списке, который больше, чем строка поиска и вставки в этом месте сохраняет порядок сортировки порядок. Вторая строка поиска превышает любой элемент в списке, поэтому позиция ввода находится в конец списка.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Искомый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="comparer">Реализация интерфейса <see cref="T:System.Collections.Generic.IComparer`1" />, которая используется при сравнении элементов.  -или-  <see langword="null" />, если необходимо использовать функцию сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Выполняет поиск элемента по всему отсортированному списку <see cref="T:System.Collections.Generic.List`1" />, используя указанный компаратор, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Отсчитываемый от нуля индекс элемента <paramref name="item" /> в отсортированном списке <see cref="T:System.Collections.Generic.List`1" />, если элемент <paramref name="item" /> найден; в противном случае — отрицательное число, которое является поразрядным дополнением индекса следующего элемента, большего, чем <paramref name="item" />, или, если большего элемента не существует, поразрядным дополнением значения <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция сравнения определяет способ сравнения элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer> экземпляр как компаратор, используемый для поиска строк без учета регистра.  
  
 Если `comparer` предоставляется элементы <xref:System.Collections.Generic.List%601> сравниваются с указанным значением, используя указанный <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` — `null`, компаратор по умолчанию <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable%601> универсального интерфейса и использует эту реализацию в том случае, если он доступен.  В противном случае <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable> интерфейса.  Если тип `T` не реализует один из этих интерфейсов <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Уже должны быть отсортированы в соответствии с реализацией функции сравнения; в противном случае результат неверен.  
  
 Сравнение `null` с любого ссылочного типа может и не создает исключение при использовании <xref:System.IComparable%601> универсальный интерфейс. При сортировке, `null` считается меньше любого другого объекта.  
  
 Если <xref:System.Collections.Generic.List%601> содержит более одного элемента с тем же значением, метод возвращает только одно из вхождений и он может возвратить один элемент, не обязательно первый из них.  
  
 Если <xref:System.Collections.Generic.List%601> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить побитовую операцию дополнения (~) для этого отрицательное целое число, возвращается индекс первого элемента, большего, чем искомое значение. При вставке значения в <xref:System.Collections.Generic.List%601>, следует использовать этот индекс позиции для сохранения порядка сортировки.  
  
 Этот метод является операцией O (журнала *n*) операции, где *n* — количество элементов в диапазоне.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода и <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузки метода.  
  
 В примере определяется компаратор альтернативные для строк с именем DinoCompare, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic `IComparer<String^>` в Visual C++) универсальный интерфейс. Компаратор действует следующим образом: во-первых, сравниваемых `null`, и указатель null считается меньше, чем отличное от null. Во-вторых сравниваются длины строк, и более длинная строка считается больше. В-третьих Если длины совпадают, используется обычное сравнение строк.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется четырьмя строками в произвольном порядке. Список выводится, сортируется с использованием альтернативного компаратора и отображать их снова.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Перегрузка метода используется для поиска нескольких строк, не в списке по внедрению альтернативного компаратора. <xref:System.Collections.Generic.List%601.Insert%2A> Метод используется для вставки строк. Эти два метода, находятся в функцию с именем `SearchAndInsert`, вместе с кодом, чтобы воспользоваться поразрядным дополнением (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) из отрицательное число, возвращенное <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> и использовать его как индекс для Вставка новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> имеет значение <see langword="null" />, а функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона поиска.</param>
        <param name="count">Длина диапазона поиска.</param>
        <param name="item">Искомый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="comparer">Реализация <see cref="T:System.Collections.Generic.IComparer`1" />, которую следует использовать при сравнении элементов, или <see langword="null" />, если должна использоваться функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Выполняет поиск элемента в диапазоне элементов отсортированного списка <see cref="T:System.Collections.Generic.List`1" />, используя указанную функцию сравнения, и возвращает индекс элемента, отсчитываемый от нуля.</summary>
        <returns>Отсчитываемый от нуля индекс элемента <paramref name="item" /> в отсортированном списке <see cref="T:System.Collections.Generic.List`1" />, если элемент <paramref name="item" /> найден; в противном случае — отрицательное число, которое является поразрядным дополнением индекса следующего элемента, большего, чем <paramref name="item" />, или, если большего элемента не существует, поразрядным дополнением значения <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция сравнения определяет способ сравнения элементов. Например, можно использовать <xref:System.Collections.CaseInsensitiveComparer> экземпляр как компаратор, используемый для поиска строк без учета регистра.  
  
 Если `comparer` предоставляется элементы <xref:System.Collections.Generic.List%601> сравниваются с указанным значением, используя указанный <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` — `null`, компаратор по умолчанию <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable%601> универсального интерфейса и использует эту реализацию в том случае, если он доступен.  В противном случае <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable> интерфейса.  Если тип `T` не реализует один из этих интерфейсов <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Уже должны быть отсортированы в соответствии с реализацией функции сравнения; в противном случае результат неверен.  
  
 Сравнение `null` с любого ссылочного типа может и не создает исключение при использовании <xref:System.IComparable%601> универсальный интерфейс. При сортировке, `null` считается меньше любого другого объекта.  
  
 Если <xref:System.Collections.Generic.List%601> содержит более одного элемента с тем же значением, метод возвращает только одно из вхождений и он может возвратить один элемент, не обязательно первый из них.  
  
 Если <xref:System.Collections.Generic.List%601> не содержит указанное значение, метод возвращает отрицательное целое число. Можно применить побитовую операцию дополнения (~) для этого отрицательное целое число, возвращается индекс первого элемента, большего, чем искомое значение. При вставке значения в <xref:System.Collections.Generic.List%601>, следует использовать этот индекс позиции для сохранения порядка сортировки.  
  
 Этот метод является операцией O (журнала *n*) операции, где *n* — количество элементов в диапазоне.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода и <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузки метода.  
  
 В примере определяется компаратор альтернативные для строк с именем DinoCompare, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic `IComparer<String^>` в Visual C++) универсальный интерфейс. Компаратор действует следующим образом: во-первых, сравниваемых `null`, и указатель null считается меньше, чем отличное от null. Во-вторых сравниваются длины строк, и более длинная строка считается больше. В-третьих Если длины совпадают, используется обычное сравнение строк.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется названиями пяти видов травоядных динозавров и трех плотоядных. В каждой из двух групп имена не любого определенного порядка сортировки. Отобразится список, травоядные сортируется с использованием альтернативного компаратора, и отобразится список.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Перегрузка метода затем используется для поиска в диапазоне травоядных «Brachiosaurus». Строка не найдена и поразрядного дополнения (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) из отрицательное число, возвращенное <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> метод используется как индекс для вставки новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> имеет значение <see langword="null" />, а функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает общее число элементов, которые может вместить внутренняя структура данных без изменения размера.</summary>
        <value>Число элементов, которые может вместить коллекция <see cref="T:System.Collections.Generic.List`1" />, прежде чем потребуется изменить ее размер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> число элементов, <xref:System.Collections.Generic.List%601> можно хранить до изменения размера не требуется, то время как <xref:System.Collections.Generic.List%601.Count%2A> — количество элементов, которые фактически являются <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> всегда равно, больше или равно <xref:System.Collections.Generic.List%601.Count%2A>. Если <xref:System.Collections.Generic.List%601.Count%2A> превышает <xref:System.Collections.Generic.List%601.Capacity%2A> при добавлении элементов, емкость увеличивается посредством автоматического перераспределения внутреннего массива перед копированием старых элементов и добавлением новых элементов.  
  
 Если емкость значительно больше, чем значение счетчика и вы хотите сократить объем памяти, используемой <xref:System.Collections.Generic.List%601>, уменьшения емкости <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод или установив <xref:System.Collections.Generic.List%601.Capacity%2A> свойство явным образом для более низкое значение. Если значение <xref:System.Collections.Generic.List%601.Capacity%2A> не задан явно, внутренний массив также перераспределяется в соответствии с указанной емкостью, и все элементы копируются.  
  
 Получение значения данного свойства является операцией o(1). Задание этого свойства является операцией O (*n*) операции, где *n* — новое значение емкости.  
  
   
  
## Examples  
 Следующий пример демонстрирует проверьте емкость и количество <xref:System.Collections.Generic.List%601> , содержащее простой бизнес-объект и иллюстрирует использование <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод для удаления дополнительная емкость.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 В следующем примере показан <xref:System.Collections.Generic.List%601.Capacity%2A> свойство в нескольких точках в жизни список. Конструктор по умолчанию используется для создания списка строк с емкостью 0 и <xref:System.Collections.Generic.List%601.Capacity%2A> отображается свойство, чтобы продемонстрировать это. После <xref:System.Collections.Generic.List%601.Add%2A> метод использовался, чтобы добавить несколько элементов, отображаются элементы, а затем <xref:System.Collections.Generic.List%601.Capacity%2A> свойство отображается снова, вместе с <xref:System.Collections.Generic.List%601.Count%2A> свойство, чтобы показать, что емкость увеличен при необходимости.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> Свойство отображается после <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод используется для уменьшения емкости для совпадает с количеством. Наконец <xref:System.Collections.Generic.List%601.Clear%2A> метод используется для удаления всех элементов в списке и <xref:System.Collections.Generic.List%601.Capacity%2A> и <xref:System.Collections.Generic.List%601.Count%2A> отображаются свойства.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для <see cref="P:System.Collections.Generic.List`1.Capacity" /> установлено значение, которое меньше <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти в системе.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из коллекции <see cref="T:System.Collections.Generic.List`1" /> все элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> имеет значение 0, и ссылки на другие объекты из элементов коллекции также освобождаются.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> остается без изменений. Чтобы сбросить емкость <xref:System.Collections.Generic.List%601>, вызовите <xref:System.Collections.Generic.List%601.TrimExcess%2A> метода или набора <xref:System.Collections.Generic.List%601.Capacity%2A> свойство напрямую. Уменьшение емкости перераспределяет память и копирует все элементы в <xref:System.Collections.Generic.List%601>. Удаление пустой <xref:System.Collections.Generic.List%601> задает емкость объекта <xref:System.Collections.Generic.List%601> емкость по умолчанию.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Clear%2A> метод и различных других свойств и методов <xref:System.Collections.Generic.List%601> универсального класса. <xref:System.Collections.Generic.List%601.Clear%2A> Метод используется в конце программы, чтобы удалить все элементы из списка и <xref:System.Collections.Generic.List%601.Capacity%2A> и <xref:System.Collections.Generic.List%601.Count%2A> отображаются свойства.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Определяет, входит ли элемент в коллекцию <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="item" /> найден в коллекции <see cref="T:System.Collections.Generic.List`1" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство, используя компаратор по умолчанию, в соответствии с определением реализацию объекта <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> метод `T` (тип значений в списке).  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Contains%2A> и <xref:System.Collections.Generic.List%601.Exists%2A> методы <xref:System.Collections.Generic.List%601> , содержащий простые бизнес-объект, реализующий <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Следующий пример содержит список сложных объектов типа `Cube`. `Cube` Класс реализует <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> метод, чтобы два куба, считаются равными, если совпадают их измерений. В этом примере <xref:System.Collections.Generic.List%601.Contains%2A> возвращает `true`, так как куб, который содержит заданные размеры уже присутствует в коллекции.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Тип элементов массива назначения.</typeparam>
        <param name="converter">Делегат <see cref="T:System.Converter`2" />, преобразующий каждый элемент из одного типа в другой.</param>
        <summary>Преобразует элементы текущего списка <see cref="T:System.Collections.Generic.List`1" /> в другой тип и возвращает список преобразованных элементов.</summary>
        <returns>Список <see cref="T:System.Collections.Generic.List`1" /> с элементами конечного типа, преобразованными из текущего списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> — Это делегат метода, который преобразует объект в целевой тип.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Converter%602> делегат и преобразованные элементы сохраняются в новом <xref:System.Collections.Generic.List%601>.  
  
 Текущий <xref:System.Collections.Generic.List%601> остается без изменений.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере определяется метод с именем `PointFToPoint` , преобразующий <xref:System.Drawing.PointF> структуру <xref:System.Drawing.Point> структуры. Затем пример создает <xref:System.Collections.Generic.List%601> из <xref:System.Drawing.PointF> структуры, создает `Converter\<PointF, Point>` делегата (`Converter(Of PointF, Point)` в Visual Basic) для представления `PointFToPoint` метода и передает делегат, <xref:System.Collections.Generic.List%601.ConvertAll%2A> метод. <xref:System.Collections.Generic.List%601.ConvertAll%2A> Метод передает каждый элемент списка ввода для `PointFToPoint` метод и помещает в новый список преобразованных элементов <xref:System.Drawing.Point> структуры. Для отображения обоих списков.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="converter" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует список <see cref="T:System.Collections.Generic.List`1" /> или его часть в массив.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.List`1" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <summary>Копирует весь список <see cref="T:System.Collections.Generic.List`1" /> в совместимый одномерный массив, начиная с первого элемента целевого массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> копируются элементы.  
  
 Элементы копируются в <xref:System.Array> в том же порядке, в котором перечислитель перемещается по <xref:System.Collections.Generic.List%601>.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.CopyTo%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется с 5 строк. Создается пустой массив строк 15 элементов и <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> перегрузка метода используется для копирования всех элементов списка в массив начиная с первого элемента массива. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Перегрузка метода используется для копирования всех элементов списка в массив, начиная с индекса массива 6 (Создание индекса 5 пусто). Наконец <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для копирования три элемента из списка, начиная с индексом 2, в массив, начиная с массива индекс 12 (Создание индекса 11 пусто). Затем отображаются содержимое массива.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Количество элементов в исходном списке <see cref="T:System.Collections.Generic.List`1" /> больше числа элементов, которое может храниться в конечном массиве <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.List`1" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в <c>массиве</c> с которого начинается копирование.</param>
        <summary>Копирует <see cref="T:System.Collections.Generic.List`1" /> целиком в совместимый одномерный массив, начиная с указанного индекса конечного массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> копируются элементы.  
  
 Элементы копируются в <xref:System.Array> в том же порядке, в котором перечислитель перемещается по <xref:System.Collections.Generic.List%601>.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.CopyTo%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется с 5 строк. Создается пустой массив строк 15 элементов и <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> перегрузка метода используется для копирования всех элементов списка в массив начиная с первого элемента массива. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Перегрузка метода используется для копирования всех элементов списка в массив, начиная с индекса массива 6 (Создание индекса 5 пусто). Наконец <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для копирования три элемента из списка, начиная с индексом 2, в массив, начиная с массива индекс 12 (Создание индекса 11 пусто). Затем отображаются содержимое массива.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Число элементов в исходной коллекции <see cref="T:System.Collections.Generic.List`1" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс исходного списка <see cref="T:System.Collections.Generic.List`1" />, с которого начинается копирование.</param>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.List`1" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в <c>массиве</c> с которого начинается копирование.</param>
        <param name="count">Число элементов для копирования.</param>
        <summary>Копирует диапазон элементов из списка <see cref="T:System.Collections.Generic.List`1" /> в совместимый одномерный массив, начиная с указанного индекса конечного массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Copy%2A?displayProperty=nameWithType> копируются элементы.  
  
 Элементы копируются в <xref:System.Array> в том же порядке, в котором перечислитель перемещается по <xref:System.Collections.Generic.List%601>.  
  
 Этот метод является операцией O (*n*) операции, где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.CopyTo%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется с 5 строк. Создается пустой массив строк 15 элементов и <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> перегрузка метода используется для копирования всех элементов списка в массив начиная с первого элемента массива. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Перегрузка метода используется для копирования всех элементов списка в массив, начиная с индекса массива 6 (Создание индекса 5 пусто). Наконец <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется для копирования три элемента из списка, начиная с индексом 2, в массив, начиная с массива индекс 12 (Создание индекса 11 пусто). Затем отображаются содержимое массива.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- <paramref name="arrayIndex" /> меньше 0.  -или- <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="index" /> больше или равно значению <see cref="P:System.Collections.Generic.List`1.Count" /> исходного списка <see cref="T:System.Collections.Generic.List`1" />.  -или-  Число элементов от <paramref name="index" /> до конца исходного списка <see cref="T:System.Collections.Generic.List`1" /> больше доступного места от положения, заданного значением параметра <paramref name="arrayIndex" />, до конца массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> число элементов, <xref:System.Collections.Generic.List%601> может хранить до изменения размера не требуется. <xref:System.Collections.Generic.List%601.Count%2A> число элементов, фактически <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> всегда равно, больше или равно <xref:System.Collections.Generic.List%601.Count%2A>. Если <xref:System.Collections.Generic.List%601.Count%2A> превышает <xref:System.Collections.Generic.List%601.Capacity%2A> при добавлении элементов, емкость увеличивается посредством автоматического перераспределения внутреннего массива перед копированием старых элементов и добавлением новых элементов.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 Следующий пример демонстрирует проверьте емкость и количество <xref:System.Collections.Generic.List%601> , содержащее простой бизнес-объект и иллюстрирует использование <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод для удаления дополнительная емкость.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 В следующем примере показано значение <xref:System.Collections.Generic.List%601.Count%2A> свойства на различных стадиях жизненного цикла список. После списка был создан и заполняется и отображения ее элементов, <xref:System.Collections.Generic.List%601.Capacity%2A> и <xref:System.Collections.Generic.List%601.Count%2A> отображаются свойства. Эти свойства отображаются после <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод был вызван и после содержимое списка очищаются.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Определяет, содержит ли <see cref="T:System.Collections.Generic.List`1" /> элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>
          <see langword="true" />, если <see cref="T:System.Collections.Generic.List`1" /> содержит один или несколько элементов, удовлетворяющих условиям указанного предиката, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегат и обработка останавливается при обнаружении совпадения.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Contains%2A> и <xref:System.Collections.Generic.List%601.Exists%2A> методы <xref:System.Collections.Generic.List%601> , содержащий простые бизнес-объект, реализующий <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Exists%2A> метод и несколько других методов, использующих <xref:System.Predicate%601> универсального метода-делегата.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается, содержащие 8 имена динозавров, два из которых (в позициях 1 и 5) заканчивается на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, И <xref:System.Collections.Generic.List%601.FindAll%2A> методы используются для поиска в списке с помощью метода предикатов поиска, а затем <xref:System.Collections.Generic.List%601.RemoveAll%2A> метод используется для удаления всех записей, заканчивающихся на «saurus».  
  
 Наконец <xref:System.Collections.Generic.List%601.Exists%2A> вызывается метод. Выполняется обход списка с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск прекращается и этот метод возвращает `true` Если `EndsWithSaurus` возвращает метод `true` для любого элемента. <xref:System.Collections.Generic.List%601.Exists%2A> Возвращает `false` , так как все элементы будут удалены.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегата (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки определить нужный делегат из контекста и создается автоматически.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает первое найденное вхождение в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Первый элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата продвижение вперед <xref:System.Collections.Generic.List%601>, начиная с первого элемента и заканчивая последним элементом.  Обработка останавливается при обнаружении совпадения.  
  
> [!IMPORTANT]
>  При поиске в список, содержащий типы значений, убедитесь, что значение по умолчанию для типа не удовлетворяет предикату поиска. В противном случае нет возможности для различения значение по умолчанию, указывающее, что соответствие не найдено и элемент списка, который имеет значение по умолчанию для типа. Если значение по умолчанию соответствует предикату поиска, используйте <xref:System.Collections.Generic.List%601.FindIndex%2A> метод вместо него.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Find%2A> метод <xref:System.Collections.Generic.List%601> , содержащий простое сложного объекта.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется методы find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класс содержит `book` объектов класса `Book`, используя данные из [пример XML-файла: книги (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Метод в этом примере используется [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для синтаксического анализа значений из XML в значения свойств из `book` объектов.  
  
 В следующей таблице описаны примеры, приведенные для методов поиска.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу с использованием идентификатора `IDToFind` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, из которого `Genre` свойство является «Компьютер» с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой книги компьютер использует `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней книги компьютер с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элементов.</param>
        <summary>Извлекает все элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Список <see cref="T:System.Collections.Generic.List`1" />, содержащий все элементы, удовлетворяющие условиям указанного предиката, если такие элементы найдены; в противном случае — пустой список <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегат и элементы, удовлетворяющие условиям, сохраняются в возвращенном <xref:System.Collections.Generic.List%601>.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется методы find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класс содержит `book` объектов класса `Book`, используя данные из [пример XML-файла: книги (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Метод в этом примере используется [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для синтаксического анализа значений из XML в значения свойств из `book` объектов.  
  
 В следующей таблице описаны примеры, приведенные для методов поиска.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу с использованием идентификатора `IDToFind` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, из которого `Genre` свойство является «Компьютер» с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой книги компьютер использует `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней книги компьютер с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" /> или его части. Этот метод возвращает значение -1, если соответствующий условию элемент не найден.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Осуществляется в прямом направлении, начиная с первого элемента и заканчивая последним элементом.  
  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата. Делегат имеет сигнатуру:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере определяется `Employee` класса с двумя полями `Name` и `Id`. Он также определяет `EmployeeSearch` класс с одним методом `StartsWith`, указывает ли `Employee.Name` поля начинается с указанной подстроки, которое передается `EmployeeSearch` конструктора класса. Обратите внимание, в сигнатуре этого метода  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 соответствует сигнатуре делегата, который может быть передан в <xref:System.Collections.Generic.List%601.FindIndex%2A> метод. В примере создается экземпляр `List<Employee>` , добавляет ряд `Employee` объектов для его, а затем вызывает <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> метод дважды, чтобы поиск по всей коллекции, в первый раз для первого `Employee` которого `Name` начинает поля с «J», а второй раз для первого `Employee` которого `Name` поля начинается с «МА».  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с заданного индекса и заканчивая последним элементом.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Выполняется от на `startIndex` и заканчивая последним элементом.  
  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата. Делегат имеет сигнатуру:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — количество элементов из `startIndex` в конец <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 В следующем примере определяется `Employee` класса с двумя полями `Name` и `Id`. Он также определяет `EmployeeSearch` класс с одним методом `StartsWith`, указывает ли `Employee.Name` поля начинается с указанной подстроки, которое передается `EmployeeSearch` конструктора класса. Обратите внимание, в сигнатуре этого метода  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 соответствует сигнатуре делегата, который может быть передан в <xref:System.Collections.Generic.List%601.FindIndex%2A> метод. В примере создается экземпляр `List<Employee>` , добавляет ряд `Employee` объектов для его, а затем вызывает <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> метод дважды для поиска в коллекции, начиная с ее пятого элемента (то есть элемент с индексом 4). Впервые, он выполняет поиск первого `Employee` которого `Name` поля начинается с «J»; второй раз, он выполняет поиск первого `Employee` которого `Name` поля начинается с «МА».  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="startIndex" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начальной позиции поиска.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начинающемся с заданного индекса и содержащем указанное число элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Выполняется от в `startIndex` и заканчивая `startIndex` , а также `count` минус 1, если `count` больше 0.  
  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата. Делегат имеет сигнатуру:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере определяется `Employee` класса с двумя полями `Name` и `Id`. Он также определяет `EmployeeSearch` класс с одним методом `StartsWith`, указывает ли `Employee.Name` поля начинается с указанной подстроки, которое передается `EmployeeSearch` конструктора класса. Обратите внимание, в сигнатуре этого метода  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 соответствует сигнатуре делегата, который может быть передан в <xref:System.Collections.Generic.List%601.FindIndex%2A> метод. В примере создается экземпляр `List<Employee>` , добавляет ряд `Employee` объектов для его, а затем вызывает <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> метод дважды, чтобы поиск по всей коллекции (то есть элементы с индекса 0 для индекса <xref:System.Collections.Generic.List%601.Count%2A> - 1). Впервые, он выполняет поиск первого `Employee` которого `Name` поля начинается с «J»; второй раз, он выполняет поиск первого `Employee` которого `Name` поля начинается с «МА».  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="startIndex" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.  -или- <paramref name="count" /> меньше 0.  -или-  <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает последнее найденное вхождение в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Последний элемент, удовлетворяющий условиям указанного предиката, если такой элемент найден; в противном случае — значение по умолчанию для типа <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата, перемещение назад <xref:System.Collections.Generic.List%601>, начиная с последнего элемента и заканчивая первым элементом.  Обработка останавливается при обнаружении совпадения.  
  
> [!IMPORTANT]
>  При поиске в список, содержащий типы значений, убедитесь, что значение по умолчанию для типа не удовлетворяет предикату поиска. В противном случае нет возможности для различения значение по умолчанию, указывающее, что соответствие не найдено и элемент списка, который имеет значение по умолчанию для типа. Если значение по умолчанию соответствует предикату поиска, используйте <xref:System.Collections.Generic.List%601.FindLastIndex%2A> метод вместо него.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется методы find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класс содержит `book` объектов класса `Book`, используя данные из [пример XML-файла: книги (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Метод в этом примере используется [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для синтаксического анализа значений из XML в значения свойств из `book` объектов.  
  
 В следующей таблице описаны примеры, приведенные для методов поиска.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу с использованием идентификатора `IDToFind` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, из которого `Genre` свойство является «Компьютер» с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой книги компьютер использует `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней книги компьютер с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" /> или его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего найденного вхождения в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Осуществляется в обратном направлении, начиная с последнего элемента и заканчивается на первом элементе.  
  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется методы find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класс содержит `book` объектов класса `Book`, используя данные из [пример XML-файла: книги (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Метод в этом примере используется [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для синтаксического анализа значений из XML в значения свойств из `book` объектов.  
  
 В следующей таблице описаны примеры, приведенные для методов поиска.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу с использованием идентификатора `IDToFind` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, из которого `Genre` свойство является «Компьютер» с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой книги компьютер использует `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней книги компьютер с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с первого элемента и заканчивая элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Поиска в обратном направлении от `startIndex` и заканчивается на первом элементе.  
  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — число элементов от начала <xref:System.Collections.Generic.List%601> для `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="startIndex" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия поиска элемента.</param>
        <summary>Выполняет поиск элемента, удовлетворяющего условиям указанного предиката, и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, содержащем указанное число элементов и заканчивающемся элементом с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента, удовлетворяющего условиям предиката <paramref name="match" />, если такой элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Поиска в обратном направлении от `startIndex` и заканчивая `startIndex` минус `count` плюс 1, если `count` больше 0.  
  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере демонстрируется методы find для <xref:System.Collections.Generic.List%601> класса. Пример для <xref:System.Collections.Generic.List%601> класс содержит `book` объектов класса `Book`, используя данные из [пример XML-файла: книги (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Метод в этом примере используется [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) для синтаксического анализа значений из XML в значения свойств из `book` объектов.  
  
 В следующей таблице описаны примеры, приведенные для методов поиска.  
  
|Метод|Пример|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Находит книгу с использованием идентификатора `IDToFind` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Найти все книги, из которого `Genre` свойство является «Компьютер» с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Находит последнюю книгу в коллекции с датой публикации до 2001, используя `PubBefore2001` делегат предиката.<br /><br /> Пример на C# используется анонимный делегат.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Находит индекс первой книги компьютер использует `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Находит индекс последней книги компьютер с помощью `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс первой компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Находит индекс последней компьютерной книги во второй половине коллекции, используя `FindComputer` делегат предиката.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="startIndex" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.  -или- <paramref name="count" /> меньше 0.  -или-  <paramref name="startIndex" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Делегат <see cref="T:System.Action`1" />, выполняемый для каждого элемента списка <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Выполняет указанное действие с каждым элементом списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Делегат метода, который выполняет действия на объект передается в него.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Action%601> делегата.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Изменение коллекции в теле <xref:System.Action%601> делегата не поддерживается и приводит к неопределенному поведению.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Action%601> делегат для печати содержимого <xref:System.Collections.Generic.List%601> объекта. В этом примере `Print` метод используется для отображения содержимого списка в консоль.  
  
> [!NOTE]
>  Помимо отображения содержимого с помощью `Print` метода, в примере C# показано использование для отображения результатов на консоль.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="action" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Элемент в коллекции изменен.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, осуществляющий перебор элементов списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Новый объект <see cref="T:System.Collections.Generic.List`1.Enumerator" /> для <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Инструкции языка C# (`for each` в C++ `For Each` в Visual Basic) позволяет скрыть сложный механизм перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. В этой позиции <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> свойство не определено. Поэтому необходимо вызвать метод <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> метод, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Свойство возвращает тот же объект, пока <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> вызывается. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> задает <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> проходит в конец коллекции, перечислитель помещается за последним элементом в коллекции и <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> также возвращают `false`. Если последний вызов метода <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> возвращается `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> не определено. Значение свойства <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> не может быть повторно задано первому элементу коллекции; вместо этого следует создать новый экземпляр перечислителя.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если изменения вносятся в коллекцию, такие как добавление, изменение, или удаление элементов, перечислитель становится необратимо недействительным, а при следующем вызове <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> или <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> вызывает <xref:System.InvalidOperationException>.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой. Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией o(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс списка <see cref="T:System.Collections.Generic.List`1" />, с которого начинается диапазон.</param>
        <param name="count">Число элементов в диапазоне.</param>
        <summary>Создает неполную копию диапазона элементов исходного списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Неполная копия диапазона элементов исходного списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неполная копия коллекции ссылочных типов или подмножества такой коллекции содержит только ссылки на элементы коллекции. Сами объекты не копируются. Ссылки в новом списке указывают на те же объекты, что и ссылки в исходном списке.  
  
 Неполная копия коллекции типов значений или подмножества такой коллекции содержит элементы коллекции. Тем не менее если элементы коллекции содержат ссылки на другие объекты, эти объекты не копируются. Ссылки в элементах новой коллекции указывают на те же объекты, что и ссылки в элементах исходной коллекции.  
  
 Напротив глубокую копию коллекции копирует элементы и все, что прямо или косвенно ссылаются элементы.  
  
 Этот метод является операцией O (*n*) операции, где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.GetRange%2A> метод и другие методы <xref:System.Collections.Generic.List%601> класс, который будет действовать на диапазоны. В конце примера <xref:System.Collections.Generic.List%601.GetRange%2A> метод используется для получения этих трех элементов в списке, начиная с индексом 2. <xref:System.Collections.Generic.List%601.ToArray%2A> Метод будет вызван на итоговый <xref:System.Collections.Generic.List%601>, создав массив из трех элементов. Отображаются элементы массива.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> определяют недопустимый диапазон элементов списка <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает отсчитываемый от нуля индекс первого вхождения значения в списке <see cref="T:System.Collections.Generic.List`1" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс первого вхождения, найденного в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента <paramref name="item" /> в пределах всей коллекции <see cref="T:System.Collections.Generic.List`1" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Осуществляется в прямом направлении, начиная с первого элемента и заканчивая последним элементом.  
  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.IndexOf%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается, с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Перегрузка метода выполняет поиск в списке с самого начала и находит первое вхождение строки. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Перегрузка метода используется для поиска списка, начиная с индексом 3 и до конца списка, а обнаруживается второе вхождение строки. Наконец <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется поиск в диапазоне двух записей, начинающемся с индексом два; возвращается значение – 1, так как отсутствуют экземпляры искомой строки в этом диапазоне.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом списке.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с заданного индекса и до последнего элемента.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения элемента <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с позиции <paramref name="index" /> и до конца списка, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Выполняется от на `index` и заканчивая последним элементом.  
  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — количество элементов из `index` в конец <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.IndexOf%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается, с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Перегрузка метода выполняет поиск в списке с самого начала и находит первое вхождение строки. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Перегрузка метода используется для поиска списка, начиная с индексом 3 и до конца списка, а обнаруживается второе вхождение строки. Наконец <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется поиск в диапазоне двух записей, начинающемся с индексом два; возвращается значение – 1, так как отсутствуют экземпляры искомой строки в этом диапазоне.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начальной позиции поиска. Значение 0 (ноль) действительно в пустом списке.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает отсчитываемый от нуля индекс первого вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начинающемся с заданного индекса и содержащем указанное число элементов.</summary>
        <returns>Отсчитываемый от нуля индекс первого вхождения <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, который начинается с позиции <paramref name="index" /> и содержит <paramref name="count" /> элементов, если искомый объект найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Выполняется от в `index` и заканчивая `index` , а также `count` минус 1, если `count` больше 0.  
  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.IndexOf%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается, с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Перегрузка метода выполняет поиск в списке с самого начала и находит первое вхождение строки. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Перегрузка метода используется для поиска списка, начиная с индексом 3 и до конца списка, а обнаруживается второе вхождение строки. Наконец <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегрузка метода используется поиск в диапазоне двух записей, начинающемся с индексом два; возвращается значение – 1, так как отсутствуют экземпляры искомой строки в этом диапазоне.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.  -или- <paramref name="count" /> меньше 0.  -или-  <paramref name="index" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить <c>элемент</c>.</param>
        <param name="item">Вставляемый объект. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Вставляет элемент в коллекцию <see cref="T:System.Collections.Generic.List`1" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> принимает `null` как допустимое значение для ссылки на типы и допускает наличие повторяющихся элементов.  
  
 Если <xref:System.Collections.Generic.List%601.Count%2A> равно <xref:System.Collections.Generic.List%601.Capacity%2A>, емкости из <xref:System.Collections.Generic.List%601> увеличивается на автоматического перераспределения внутреннего массива и существующие элементы копируются в новый массив перед добавлением нового элемента.  
  
 Если `index` равен <xref:System.Collections.Generic.List%601.Count%2A>, `item` добавляется в конец <xref:System.Collections.Generic.List%601>.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показано, как добавлять, удалять и вставлять простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Insert%2A> метода, а также различные свойства и методы <xref:System.Collections.Generic.List%601> универсального класса. После создания списка добавляются элементы. <xref:System.Collections.Generic.List%601.Insert%2A> Метод используется для вставки элемента в середине списка. Элемент вставлен является дубликатом, которая впоследствии удаляется с помощью <xref:System.Collections.Generic.List%601.Remove%2A> метод.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  - или-  Значение <paramref name="index" /> больше <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс места вставки новых элементов.</param>
        <param name="collection">Коллекция, элементы которой следует вставить в список <see cref="T:System.Collections.Generic.List`1" />. Сама коллекция не может иметь значение <see langword="null" />, но может содержать элементы, имеющие значение <see langword="null" />, если тип <c>T</c> является ссылочным типом.</param>
        <summary>Вставляет элементы коллекции в список <see cref="T:System.Collections.Generic.List`1" /> в позиции с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> принимает `null` как допустимое значение для ссылки на типы и допускает наличие повторяющихся элементов.  
  
 Если новый <xref:System.Collections.Generic.List%601.Count%2A> (текущего <xref:System.Collections.Generic.List%601.Count%2A> плюс размер коллекции) больше значения <xref:System.Collections.Generic.List%601.Capacity%2A>, емкости из <xref:System.Collections.Generic.List%601> увеличивается на автоматически перераспределения внутреннего массива для размещения новых элементов и существующие элементы копируются в новый массив перед добавлением новых элементов.  
  
 Если `index` равен <xref:System.Collections.Generic.List%601.Count%2A>, элементы добавляются в конец <xref:System.Collections.Generic.List%601>.  
  
 Порядок элементов в коллекции, сохраняется в <xref:System.Collections.Generic.List%601>.  
  
 Этот метод является операцией O (*n* * *m*) операции, где *n* — количество элементов для добавления и *m* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.InsertRange%2A> метод и различные методы класса <xref:System.Collections.Generic.List%601> класс, который будет действовать на диапазоны. После создания списка и заполняется имена нескольких мирным еды растение динозавров, <xref:System.Collections.Generic.List%601.InsertRange%2A> метод используется для вставки массив три ferocious динозавров еды Молоко в списке, начиная с индексом 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="collection" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  - или-  Значение <paramref name="index" /> больше <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс элемента, который требуется возвратить или задать.</param>
        <summary>Возвращает или задает элемент по указанному индексу.</summary>
        <value>Элемент, расположенный по указанному индексу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> принимает `null` как допустимое значение для ссылки на типы и допускает наличие повторяющихся элементов.  
  
 Это свойство предоставляет доступ к указанному элементу коллекции при использовании следующего синтаксиса: `myCollection[index]`.  
  
 Получение значения данного свойства является операцией o(1). Задание этого свойства также является операцией o(1).  
  
   
  
## Examples  
 В примере этого раздела показано <xref:System.Collections.Generic.List%601.Item%2A> свойство (индексатор в C#) и различных других свойств и методов <xref:System.Collections.Generic.List%601> универсального класса. После списка создается и заполняется с помощью <xref:System.Collections.Generic.List%601.Add%2A> метод элемента извлекается и отображается с помощью <xref:System.Collections.Generic.List%601.Item%2A> свойство. (Например, который использует <xref:System.Collections.Generic.List%601.Item%2A> свойство, чтобы задать значение элемента списка в разделе <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C# и C++ все имеют синтаксис для доступа к <xref:System.Collections.Generic.List%601.Item%2A> свойства без использования его имени. Вместо этого переменной содержащий <xref:System.Collections.Generic.List%601> используется, как если бы он был массивом.  
  
 Ключевое слово языка C# используется для определения индексаторов вместо реализации <xref:System.Collections.Generic.List%601.Item%2A> свойство. В языке Visual Basic в качестве свойства по умолчанию реализовано свойство <xref:System.Collections.Generic.List%601.Item%2A>, предоставляющее те же возможности индексирования.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает отсчитываемый от нуля индекс последнего вхождения значения в списке <see cref="T:System.Collections.Generic.List`1" /> или в его части.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс последнего вхождения, найденного в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="item" /> в пределах всего списка <see cref="T:System.Collections.Generic.List`1" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Осуществляется в обратном направлении, начиная с последнего элемента и заканчивается на первом элементе.  
  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.LastIndexOf%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается, с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Перегрузка метода выполняет по всему списку со стороны и обнаруживается второе вхождение строки. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Перегрузка метода используется для поиска в списке, обратно, начиная с индексом 3 и до начала списка, поэтому он находит первое вхождение строки в списке. Наконец <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод, используемый для поиска диапазон четыре записи, начиная с индексом 4 и расширение назад (то есть, будет произведен поиск элементов в расположениях, 4, 3, 2 и 1); этот поиск возвращает – 1, так как отсутствуют экземпляры поиска Строка в этом диапазоне.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <summary>Осуществляет поиск указанного объекта и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с первого элемента и до позиции с заданным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения элемента <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, начиная с первого элемента и до позиции <paramref name="index" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Поиска в обратном направлении от `index` и заканчивается на первом элементе.  
  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — число элементов от начала <xref:System.Collections.Generic.List%601> для `index`.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.LastIndexOf%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается, с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Перегрузка метода выполняет по всему списку со стороны и обнаруживается второе вхождение строки. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Перегрузка метода используется для поиска в списке, обратно, начиная с индексом 3 и до начала списка, поэтому он находит первое вхождение строки в списке. Наконец <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод, используемый для поиска диапазон четыре записи, начиная с индексом 4 и расширение назад (то есть, будет произведен поиск элементов в расположениях, 4, 3, 2 и 1); этот поиск возвращает – 1, так как отсутствуют экземпляры поиска Строка в этом диапазоне.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <param name="index">Индекс (с нуля) начала диапазона поиска в обратном направлении.</param>
        <param name="count">Число элементов в диапазоне, в котором выполняется поиск.</param>
        <summary>Выполняет поиск указанного объекта и возвращает отсчитываемый от нуля индекс последнего вхождения в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, содержащем указанное число элементов и заканчивающемся в позиции с указанным индексом.</summary>
        <returns>Отсчитываемый от нуля индекс последнего вхождения <paramref name="item" /> в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" />, состоящем из <paramref name="count" /> элементов и заканчивающемся в позиции <paramref name="index" />, если элемент найден; в противном случае — значение –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Поиска в обратном направлении от `index` и заканчивая `index` минус `count` плюс 1, если `count` больше 0.  
  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — `count`.  
  
   
  
## Examples  
 В следующем примере показано все три перегрузки <xref:System.Collections.Generic.List%601.LastIndexOf%2A> метод. Объект <xref:System.Collections.Generic.List%601> строк создается, с одной записью, повторяющейся дважды — по индексу 0 и 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Перегрузка метода выполняет по всему списку со стороны и обнаруживается второе вхождение строки. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Перегрузка метода используется для поиска в списке, обратно, начиная с индексом 3 и до начала списка, поэтому он находит первое вхождение строки в списке. Наконец <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод, используемый для поиска диапазон 4 записи, начиная с индексом 4 и расширение назад (то есть, будет произведен поиск элементов в расположениях, 4, 3, 2 и 1); этот поиск возвращает – 1, так как отсутствуют экземпляры поиска Строка в этом диапазоне.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" /> находится вне диапазона допустимых индексов для списка <see cref="T:System.Collections.Generic.List`1" />.  -или- <paramref name="count" /> меньше 0.  -или-  <paramref name="index" /> и <paramref name="count" /> не указывают допустимый раздел в <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Объект, который необходимо удалить из коллекции <see cref="T:System.Collections.Generic.List`1" />. Для ссылочных типов допускается значение <see langword="null" />.</param>
        <summary>Удаляет первое вхождение указанного объекта из коллекции <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Значение <see langword="true" />, если элемент <paramref name="item" /> успешно удален, в противном случае — значение <see langword="false" />.  Этот метод также возвращает <see langword="false" />, если элемент <paramref name="item" /> не найден в коллекции <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип `T` реализует <xref:System.IEquatable%601> универсального интерфейса, компаратор проверки на равенство является <xref:System.IEquatable%601.Equals%2A> метод этого интерфейса; в противном случае сравнения по умолчанию является <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере показано, как добавлять, удалять и вставлять простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Remove%2A> метод. Несколько свойств и методов <xref:System.Collections.Generic.List%601> универсального класса используются для добавления, вставки и поиска в списке. После завершения этих операций в списке содержит дубликат. <xref:System.Collections.Generic.List%601.Remove%2A> Метод используется для удаления повторяющихся элементов первого экземпляра и отображения. <xref:System.Collections.Generic.List%601.Remove%2A> Метод всегда удаляет он встречает первый экземпляр.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия удаления элемента.</param>
        <summary>Удаляет все элементы, удовлетворяющие условиям указанного предиката.</summary>
        <returns>Число элементов, удаляемых из списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегата и элементы, удовлетворяющие условиям, будут удалены из <xref:System.Collections.Generic.List%601>.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.RemoveAll%2A> метод и несколько других методов, использующих <xref:System.Predicate%601> универсального метода-делегата.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается, содержащие 8 имена динозавров, два из которых (в позициях 1 и 5) заканчивается на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, И <xref:System.Collections.Generic.List%601.FindAll%2A> методы используются для поиска в списке с помощью метода предикатов поиска.  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> Метод используется для удаления всех записей, заканчивающихся на «saurus». Выполняется обход списка с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Если удаляется элемент `EndsWithSaurus` возвращает `true`.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегата (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки определить нужный делегат из контекста и создается автоматически.  
  
 Наконец <xref:System.Collections.Generic.List%601.Exists%2A> метод проверяет, что отсутствуют в списке отсутствуют строки, которые заканчиваются на «saurus».  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) элемента, который требуется удалить.</param>
        <summary>Удаляет элемент списка <see cref="T:System.Collections.Generic.List`1" /> с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Collections.Generic.List%601.RemoveAt%2A> для удаления элемента, остальные элементы в списке нумеруются заменить удален элемент. Например если удалить элемент с индексом 3, элемент с индексом 4 перемещения 3 место. Кроме того, количество элементов в списке (представленные как <xref:System.Collections.Generic.List%601.Count%2A> свойство) уменьшается на 1.  
  
 Этот метод является операцией O (*n*) операции, где *n* — (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 В следующем примере показано, как добавлять, удалять и вставлять простой бизнес-объект в <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- Значение параметра <paramref name="index" /> больше или равно значению свойства <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона элементов, которые требуется удалить.</param>
        <param name="count">Число удаляемых элементов.</param>
        <summary>Удаляет диапазон элементов из списка <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы будут удалены и все элементы после их в <xref:System.Collections.Generic.List%601> иметь их уменьшении индексов `count`.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.RemoveRange%2A> метод и различные методы класса <xref:System.Collections.Generic.List%601> класс, который будет действовать на диапазоны. После создания и изменения списка <xref:System.Collections.Generic.List%601.RemoveRange%2A> метод используется для удаления двух элементов в списке, начиная с индексом 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> определяют недопустимый диапазон элементов списка <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Изменяет порядок элементов в списке <see cref="T:System.Collections.Generic.List`1" /> или в его части на обратный.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Изменяет порядок элементов во всем списке <see cref="T:System.Collections.Generic.List`1" /> на обратный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Reverse%2A?displayProperty=nameWithType> Чтобы изменить порядок элементов.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется обе перегрузки <xref:System.Collections.Generic.List%601.Reverse%2A> метод. В примере создается <xref:System.Collections.Generic.List%601> из строки и добавляет шесть строк. <xref:System.Collections.Generic.List%601.Reverse> Перегрузка метода позволяет список, а затем <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> перегрузка метода используется для отмены середины списка, начиная с 1 элемент и включающий четыре элемента.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс начала диапазона, порядок элементов которого требуется изменить.</param>
        <param name="count">Число элементов в диапазоне, порядок сортировки в котором требуется изменить.</param>
        <summary>Изменяет порядок элементов в указанном диапазоне.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует <xref:System.Array.Reverse%2A?displayProperty=nameWithType> Чтобы изменить порядок элементов.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется обе перегрузки <xref:System.Collections.Generic.List%601.Reverse%2A> метод. В примере создается <xref:System.Collections.Generic.List%601> из строки и добавляет шесть строк. <xref:System.Collections.Generic.List%601.Reverse> Перегрузка метода позволяет список, а затем <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> перегрузка метода используется для отмены середины списка, начиная с 1 элемент и включающий четыре элемента.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Параметры <paramref name="index" /> и <paramref name="count" /> определяют недопустимый диапазон элементов списка <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сортирует элементы в списке <see cref="T:System.Collections.Generic.List`1" /> или в его части.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>Синтаксис метода  
 <xref:System.Collections.Generic.List%601.Sort%2A> Методы позволяют сортировать с функцией по умолчанию для типа объекта в списке, или укажите метод сортировки клиента.  
  
 [Список\<T >. Sort()](xref:System.Collections.Generic.List`1.Sort*) сортирует элементы во всем списке, используя компаратор по умолчанию для типа объекта, которые содержатся в списке.  
  
 [Список\<T >. Сортировка M (сравнение\<T > сравнения)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29) сортирует элементы во всем списке, с помощью указанной функции сравнения.  
  
 [Список\<T >. Сортировка (IComparer\<T > comparer)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29) сортирует элементы во всем списке с помощью указанного <xref:System.Comparison%601?displayProperty=nameWithType>.  
  
 [Список\<T >. Сортировка (Int32 индекса, счетчик Int32 IComparer\<T > сравнения)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29) сортирует элементы в диапазоне элементов списка с помощью указанной функции сравнения.  
  
## <a name="parameters"></a>Параметры  
  
|Параметр|Тип|Описание:|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|Метод делегата, который будет использоваться при сравнении элементов|  
|comparer|<xref:System.Collections.Generic.IComparer%601>|<xref:System.Collections.Generic.IComparer%601> Реализации для использования при сравнении элементов, или значение null, следует использовать функцию сравнения по умолчанию <xref:System.Collections.Generic.Comparer%601.Default>.|  
|`index`|<xref:System.Int32>|Индекс (с нуля) начала диапазона, который требуется отсортировать.|  
|`count`|<xref:System.Int32>|Длина диапазона сортировки.|  
  
## <a name="exceptions"></a>Исключения  
  
|Исключение|Условие|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer` не указан или `null`и функцию сравнения по умолчанию <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> не может найти реализацию <xref:System.IComparable%601?displayProperty=nameWithType> универсального интерфейса или <xref:System.IComparable?displayProperty=nameWithType> интерфейса для типа T.|  
|<xref:System.ArgumentNullException>|Свойство `comparison` имеет значение `null`.|  
|<xref:System.ArgumentException>|Реализация `comparison` или `comparer` вызвала ошибку во время сортировки. Например, `comparison` может не возвратить 0 при сравнении элемента с самим собой.<br /><br /> - или -<br /><br /> `index` и `count` не указывают допустимый диапазон в <xref:System.Collections.Generic.List%601>.|  
|<xref:System.ArgumentOutOfRangeException>|`index` меньше 0 или `count` меньше 0.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.Generic.List`1" /> с помощью функции сравнения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует функцию сравнения по умолчанию <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> для типа `T` для определения порядка элементов списка. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Ли проверки свойств введите `T` реализует <xref:System.IComparable%601> универсального интерфейса и использует эту реализацию в том случае, если он доступен.  В противном случае <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable> интерфейса.  Если тип `T` не реализует один из этих интерфейсов <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает <xref:System.InvalidOperationException>.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType> метод, который применяется в разумной сортировки следующим образом:  
  
-   Если размер раздела меньше 16 элементов, он использует алгоритм сортировки вставки.  
  
-   Если количество секций превышает 2 журнала *n*, где *n* диапазон входного массива, в нем используется алгоритм Heapsort.  
  
-   В противном случае он использует алгоритм быстрой сортировки.  
  
 В этой реализации осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок могут не сохраняться. В отличие от этого строгой сортировке сохраняется порядок элементов, которые равны.  
  
 В среднем этот метод является операцией O (*n* журнала *n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае он является операцией O (*n* <sup>2</sup>) операции.  
  
   
  
## Examples  
 В следующем примере добавляется некоторые имена, чтобы `List<String>` вызывает объект, отображает список в порядке, не отсортированы, <xref:System.Collections.Generic.List%601.Sort%2A> метод и затем отображает отсортированного списка.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 В следующем коде показано <xref:System.Collections.Generic.List%601.Sort> и <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> перегруженных версий метода в простом бизнес-объекте. Вызов <xref:System.Collections.Generic.List%601.Sort> метод приводит к использованию компаратора по умолчанию для типа части и <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> метод реализуется с помощью анонимного метода.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort> перегрузка метода и <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> перегрузки метода. Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется четырьмя строками в произвольном порядке. Список отображается, сортировки и отображаться в дальнейшем.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Перегрузка метода затем используется для поиска двух строк, которые не находятся в списке, и <xref:System.Collections.Generic.List%601.Insert%2A> метод используется для вставки узлов. Возвращаемое значение <xref:System.Collections.Generic.List%601.BinarySearch%2A> метод отрицательное значение в каждом случае, так как строки не входят в список. Поразрядное дополнение (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) для этого отрицательного числа дает индекс первого элемента в списке, который больше, чем строка поиска и вставки в этом месте сохраняет порядок сортировки порядок. Вторая строка поиска превышает любой элемент в списке, поэтому позиция ввода находится в конец списка.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация <see cref="T:System.Collections.Generic.IComparer`1" />, которую следует использовать при сравнении элементов, или <see langword="null" />, если должна использоваться функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.Generic.List`1" /> с помощью указанной функции сравнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` предоставляется элементы <xref:System.Collections.Generic.List%601> сортируются с помощью указанного <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` — `null`, компаратор по умолчанию <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable%601> универсального интерфейса и использует эту реализацию в том случае, если он доступен.  В противном случае <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable> интерфейса.  Если тип `T` не реализует один из этих интерфейсов <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает <xref:System.InvalidOperationException>.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType> метод, который применяется в разумной сортировки следующим образом:  
  
-   Если размер раздела меньше 16 элементов, он использует алгоритм сортировки вставки.  
  
-   Если количество секций превышает 2 журнала *n*, где *n* диапазон входного массива, в нем используется алгоритм Heapsort.  
  
-   В противном случае он использует алгоритм быстрой сортировки.  
  
 В этой реализации осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок могут не сохраняться. В отличие от этого строгой сортировке сохраняется порядок элементов, которые равны.  
  
 В среднем этот метод является операцией O (*n* журнала *n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае он является операцией O (*n* <sup>2</sup>) операции.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода и <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузки метода.  
  
 В примере определяется компаратор альтернативные для строк с именем DinoCompare, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic `IComparer<String^>` в Visual C++) универсальный интерфейс. Компаратор действует следующим образом: во-первых, сравниваемых `null`, и указатель null считается меньше, чем отличное от null. Во-вторых сравниваются длины строк, и более длинная строка считается больше. В-третьих Если длины совпадают, используется обычное сравнение строк.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется четырьмя строками в произвольном порядке. Список выводится, сортируется с использованием альтернативного компаратора и отображать их снова.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Перегрузка метода используется для поиска нескольких строк, не в списке по внедрению альтернативного компаратора. <xref:System.Collections.Generic.List%601.Insert%2A> Метод используется для вставки строк. Эти два метода, находятся в функцию с именем `SearchAndInsert`, вместе с кодом, чтобы воспользоваться поразрядным дополнением (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) из отрицательное число, возвращенное <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> и использовать его как индекс для Вставка новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> является <see langword="null" />, и функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">
          <see cref="T:System.Comparison`1" />, используемый при сравнении элементов.</param>
        <summary>Сортирует элементы во всем списке <see cref="T:System.Collections.Generic.List`1" /> с использованием указанного <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparison` предоставляется элементы <xref:System.Collections.Generic.List%601> сортируются с помощью метода, представленному делегатом.  
  
 Если `comparison` — `null`, <xref:System.ArgumentNullException> возникает исключение.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType>, которая разумной сортировки применяется следующим образом:  
  
-   Если размер раздела меньше 16 элементов, он использует алгоритм сортировки вставки  
  
-   Если количество секций превышает 2 журнала *n*, где *n* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритма.  
  
-   В противном случае он использует алгоритм быстрой сортировки.  
  
 В этой реализации осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок могут не сохраняться. В отличие от этого строгой сортировке сохраняется порядок элементов, которые равны.  
  
 В среднем этот метод является операцией O (*n* журнала *n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае он является операцией O (*n* <sup>2</sup>) операции.  
  
   
  
## Examples  
 В следующем коде показано <xref:System.Collections.Generic.List%601.Sort%2A> и <xref:System.Collections.Generic.List%601.Sort%2A> перегруженных версий метода в простом бизнес-объекте. Вызов <xref:System.Collections.Generic.List%601.Sort%2A> метод приводит к использованию компаратора по умолчанию для типа части и <xref:System.Collections.Generic.List%601.Sort%2A> метод реализуется с помощью анонимного метода.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> перегрузки метода.  
  
 В примере определяется метод альтернативных сравнения для строк, с именем `CompareDinosByLength`. Этот метод работает следующим образом: во-первых, сравниваемых `null`, и указатель null считается меньше, чем отличное от null. Во-вторых сравниваются длины строк, и более длинная строка считается больше. В-третьих Если длины совпадают, используется обычное сравнение строк.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется четырьмя строками в произвольном порядке. Список также включает пустую строку и указатель null. Отобразится список, сортируются с помощью <xref:System.Comparison%601> универсальный делегат, представляющий `CompareDinosByLength` метода и отображается снова.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="comparison" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Реализация <paramref name="comparison" /> вызвала ошибку во время сортировки. Например, <paramref name="comparison" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <altmember cref="T:System.Comparison`1" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) начала диапазона, который требуется отсортировать.</param>
        <param name="count">Длина диапазона сортировки.</param>
        <param name="comparer">Реализация <see cref="T:System.Collections.Generic.IComparer`1" />, которую следует использовать при сравнении элементов, или <see langword="null" />, если должна использоваться функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Сортирует элементы в диапазоне элементов списка <see cref="T:System.Collections.Generic.List`1" /> с помощью указанной функции сравнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `comparer` предоставляется элементы <xref:System.Collections.Generic.List%601> сортируются с помощью указанного <xref:System.Collections.Generic.IComparer%601> реализации.  
  
 Если `comparer` — `null`, компаратор по умолчанию <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable%601> универсального интерфейса и использует эту реализацию в том случае, если он доступен.  В противном случае <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> проверяет, является ли введите `T` реализует <xref:System.IComparable> интерфейса.  Если тип `T` не реализует один из этих интерфейсов <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> вызывает <xref:System.InvalidOperationException>.  
  
 Этот метод использует <xref:System.Array.Sort%2A?displayProperty=nameWithType>, которая разумной сортировки применяется следующим образом:  
  
-   Если размер раздела меньше 16 элементов, он использует алгоритм сортировки вставки  
  
-   Если количество секций превышает 2 журнала *n*, где *n* диапазон входного массива, он использует [Heapsort](https://en.wikipedia.org/wiki/Heapsort) алгоритма.  
  
-   В противном случае он использует алгоритм быстрой сортировки.  
  
 В этой реализации осуществляется нестрогая Сортировка; то есть если два элемента равны, их порядок могут не сохраняться. В отличие от этого строгой сортировке сохраняется порядок элементов, которые равны.  
  
 В среднем этот метод является операцией O (*n* журнала *n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>; в худшем случае он является операцией O (*n* <sup>2</sup>) операции.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузка метода и <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> перегрузки метода.  
  
 В примере определяется компаратор альтернативные для строк с именем DinoCompare, который реализует `IComparer<string>` (`IComparer(Of String)` в Visual Basic `IComparer<String^>` в Visual C++) универсальный интерфейс. Компаратор действует следующим образом: во-первых, сравниваемых `null`, и указатель null считается меньше, чем отличное от null. Во-вторых сравниваются длины строк, и более длинная строка считается больше. В-третьих Если длины совпадают, используется обычное сравнение строк.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается и заполняется названиями пяти видов травоядных динозавров и трех плотоядных. В каждой из двух групп имена не любого определенного порядка сортировки. Отобразится список, травоядные сортируется с использованием альтернативного компаратора, и отобразится список.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Перегрузка метода затем используется для поиска в диапазоне травоядных «Brachiosaurus». Строка не найдена и поразрядного дополнения (~ оператор в C# и Visual C++, `Xor` -1 в Visual Basic) из отрицательное число, возвращенное <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> метод используется как индекс для вставки новой строки.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> меньше 0.  -или- <paramref name="count" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <see cref="T:System.Collections.Generic.List`1" />.  -или- Реализация <paramref name="comparer" /> вызвала ошибку во время сортировки. Например, <paramref name="comparer" /> может не возвратить 0 при сравнении элемента с самим собой.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> является <see langword="null" />, и функция сравнения по умолчанию <see cref="P:System.Collections.Generic.Comparer`1.Default" /> не может найти реализацию универсального интерфейса <see cref="T:System.IComparable`1" /> или интерфейса <see cref="T:System.IComparable" /> для типа <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли объект <see cref="T:System.Collections.Generic.ICollection`1" /> доступным только для чтения.</summary>
        <value>Значение <see langword="true" />, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1" /> доступен только для чтения; в противном случае — значение <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После создания коллекции, доступной только для чтения, не разрешается добавление элементов в коллекцию, их изменение или удаление.  
  
 Коллекции, доступной только для чтения является просто коллекцией с оболочкой, препятствующей изменению коллекции. Таким образом при внесении изменений в базовую коллекцию, доступную только для чтения коллекцию отражает эти изменения.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, который осуществляет итерацию по коллекции.</summary>
        <returns>Объект <see cref="T:System.Collections.Generic.IEnumerator`1" />, который может использоваться для итерации элементов коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Инструкции языка C# (`for each` в C++ `For Each` в Visual Basic) позволяет скрыть сложный механизм перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. В этой позиции <xref:System.Collections.Generic.IEnumerator%601.Current%2A> свойство не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A> метод, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Свойство возвращает тот же объект, пока <xref:System.Collections.IEnumerator.MoveNext%2A> вызывается. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.Generic.IEnumerator%601.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> проходит в конец коллекции, перечислитель помещается за последним элементом в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают `false`. Если последний вызов метода <xref:System.Collections.IEnumerator.MoveNext%2A> возвращается `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> не определено. Значение свойства <xref:System.Collections.Generic.IEnumerator%601.Current%2A> не может быть повторно задано первому элементу коллекции; вместо этого следует создать новый экземпляр перечислителя.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если изменения вносятся в коллекцию, такие как добавление, изменение, или удаление элементов, перечислитель становится необратимо недействительным, а при следующем вызове <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A> вызывает <xref:System.InvalidOperationException>.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой. Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией o(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Одномерный массив <see cref="T:System.Array" />, в который копируются элементы из интерфейса <see cref="T:System.Collections.ICollection" />. Массив <see cref="T:System.Array" /> должен иметь индексацию, начинающуюся с нуля.</param>
        <param name="arrayIndex">Отсчитываемый от нуля индекс в <c>массиве</c> с которого начинается копирование.</param>
        <summary>Копирует элементы коллекции <see cref="T:System.Collections.ICollection" /> в массив <see cref="T:System.Array" />, начиная с указанного индекса массива <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если тип источника <xref:System.Collections.ICollection> не может быть автоматически приведен к типу массива назначения `array`, неуниверсальных реализаций <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, тогда как универсальный реализации вызывают <xref:System.ArgumentException>.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">Массив <paramref name="array" /> является многомерным.  -или- <paramref name="array" /> не поддерживает индексацию, начинающуюся с нуля.  -или- Количество элементов в исходной коллекции <see cref="T:System.Collections.ICollection" /> превышает доступное место, начиная с индекса <paramref name="arrayIndex" /> до конца массива назначения <paramref name="array" />.  -или- Тип исходной коллекции <see cref="T:System.Collections.ICollection" /> нельзя автоматически привести к типу массива назначения <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли доступ к коллекции <see cref="T:System.Collections.ICollection" /> синхронизированным (потокобезопасным).</summary>
        <value>
          <see langword="true" />, если доступ к классу <see cref="T:System.Collections.ICollection" /> является синхронизированным (потокобезопасным); в противном случае — <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Перечисление коллекции не является потокобезопасной процедурой.  В редких случаях, когда при перечислении возможен конфликт с доступом для записи можно заблокировать коллекцию на все время перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Возвращает объект, который может использоваться для синхронизации доступа к <xref:System.Collections.ICollection>. Синхронизация действует только в том случае, если все потоки блокируют данный объект перед доступом к коллекции.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, с помощью которого можно синхронизировать доступ к коллекции <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Объект, который может использоваться для синхронизации доступа к <see cref="T:System.Collections.ICollection" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает текущий экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Возвращает объект, который может использоваться для синхронизации доступа к <xref:System.Collections.ICollection>. Синхронизация действует только в том случае, если все потоки блокируют данный объект перед доступом к коллекции. В следующем коде показано использование <xref:System.Collections.ICollection.SyncRoot%2A> свойство для C#, C++ и Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечислитель, который осуществляет итерацию по коллекции.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, который может использоваться для итерации элементов коллекции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Инструкции языка C# (`for each` в C++ `For Each` в Visual Basic) позволяет скрыть сложный механизм перечислителей. Поэтому рекомендуется вместо непосредственного использования перечислителя применять ключевое слово `foreach`.  
  
 Перечислители могут использоваться для чтения данных в коллекции, но не для ее изменения.  
  
 Изначально перечислитель располагается перед первым элементом коллекции. Метод <xref:System.Collections.IEnumerator.Reset%2A> также переводит перечислитель в эту позицию.  В этой позиции <xref:System.Collections.IEnumerator.Current%2A> свойство не определено. Поэтому необходимо вызвать метод <xref:System.Collections.IEnumerator.MoveNext%2A> метод, чтобы переместить перечислитель к первому элементу коллекции до считывания значения свойства <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> Свойство возвращает тот же объект, пока не <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A> вызывается. <xref:System.Collections.IEnumerator.MoveNext%2A> задает <xref:System.Collections.IEnumerator.Current%2A> в качестве значения для следующего элемента.  
  
 Если <xref:System.Collections.IEnumerator.MoveNext%2A> проходит в конец коллекции, перечислитель помещается за последним элементом в коллекции и <xref:System.Collections.IEnumerator.MoveNext%2A> возвращает `false`. Если перечислитель находится в этой позиции, последующие вызовы <xref:System.Collections.IEnumerator.MoveNext%2A> также возвращают `false`. Если последний вызов метода <xref:System.Collections.IEnumerator.MoveNext%2A> возвращается `false`, <xref:System.Collections.IEnumerator.Current%2A> не определено. Чтобы снова задать в качестве значения свойства <xref:System.Collections.IEnumerator.Current%2A> первый элемент коллекции, можно последовательно вызвать методы <xref:System.Collections.IEnumerator.Reset%2A> и<xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Перечислитель остается действительным, пока коллекция не изменяется. Если изменения вносятся в коллекцию, такие как добавление, изменение, или удаление элементов, перечислитель становится необратимо недействительным, а при следующем вызове <xref:System.Collections.IEnumerator.MoveNext%2A> или <xref:System.Collections.IEnumerator.Reset%2A> вызывает <xref:System.InvalidOperationException>.  
  
 У перечислителя нет эксклюзивного доступа к коллекции, поэтому перечисление коллекции не является потокобезопасной процедурой.  Чтобы гарантировать потокобезопасность, можно заблокировать коллекцию на время всего перечисления.  Чтобы разрешить доступ к коллекции из нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.  
  
 Используемые по умолчанию реализации коллекций в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> не синхронизированы.  
  
 Этот метод является операцией o(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект <see cref="T:System.Object" />, добавляемый в список <see cref="T:System.Collections.IList" />.</param>
        <summary>Добавляет элемент в коллекцию <see cref="T:System.Collections.IList" />.</summary>
        <returns>Позиция, на которую вставлен новый элемент.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Collections.Generic.List%601.Count%2A> — меньше, чем <xref:System.Collections.Generic.List%601.Capacity%2A>, этот метод является операцией o(1). Если емкость требуется увеличить для размещения нового элемента, этот метод становится операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект <see cref="T:System.Object" />, который требуется найти в коллекции <see cref="T:System.Collections.IList" />.</param>
        <summary>Определяет, содержит ли коллекция <see cref="T:System.Collections.IList" /> указанное значение.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="item" /> найден в коллекции <see cref="T:System.Collections.IList" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект для поиска в <see cref="T:System.Collections.IList" />.</param>
        <summary>Определяет индекс заданного элемента в списке <see cref="T:System.Collections.IList" />.</summary>
        <returns>Индекс значения <paramref name="item" />, если оно найдено в списке; в противном случае — значение -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить <c>элемент</c>.</param>
        <param name="item">Объект, вставляемый в коллекцию <see cref="T:System.Collections.IList" />.</param>
        <summary>Вставляет элемент в список <see cref="T:System.Collections.IList" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение параметра `index` равно количеству элементов в списке <xref:System.Collections.IList>, элемент `item` добавляется в конец списка.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> не является допустимым индексом в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, имеет ли список <see cref="T:System.Collections.IList" /> фиксированный размер.</summary>
        <value>Значение <see langword="true" />, если словарь <see cref="T:System.Collections.IList" /> имеет фиксированный размер; в противном случае — значение <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В созданной коллекции фиксированного размера запрещается добавлять или удалять элементы, но разрешается изменять существующие элементы.  
  
 Коллекция фиксированного размера является просто коллекцией с оболочкой, препятствующей добавлению и удалению элементов; Поэтому если были внесены изменения в базовой коллекции, включая добавление или удаление элементов, эти изменения отражаются в коллекции фиксированного размера.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли объект <see cref="T:System.Collections.IList" /> доступным только для чтения.</summary>
        <value>Значение <see langword="true" />, если интерфейс <see cref="T:System.Collections.IList" /> доступен только для чтения; в противном случае — значение <see langword="false" />.  В используемой по умолчанию реализации <see cref="T:System.Collections.Generic.List`1" /> это свойство всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После создания коллекции, доступной только для чтения, не разрешается добавление элементов в коллекцию, их изменение или удаление.  
  
 Коллекции, доступной только для чтения является просто коллекцией с оболочкой, препятствующей изменению коллекции. Таким образом при внесении изменений в базовую коллекцию, доступную только для чтения коллекцию отражает эти изменения.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс элемента, который требуется возвратить или задать.</param>
        <summary>Возвращает или задает элемент по указанному индексу.</summary>
        <value>Элемент, расположенный по указанному индексу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В языке C# используется [это](~/docs/csharp/language-reference/keywords/this.md) ключевое слово для определения индексаторов вместо реализации <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> свойство. В языке Visual Basic в качестве свойства по умолчанию реализовано свойство <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A>, предоставляющее те же возможности индексирования.  
  
 Получение значения данного свойства является операцией o(1). Задание этого свойства также является операцией o(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> не является допустимым индексом в <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство задано, и тип параметра <paramref name="value" /> не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект, который необходимо удалить из коллекции <see cref="T:System.Collections.IList" />.</param>
        <summary>Удаляет первое вхождение указанного объекта из коллекции <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет равенство, используя компаратор проверки на равенство по умолчанию <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> для `T`, тип значений в списке.  
  
 Этот метод выполняет линейный поиск; Таким образом, этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> имеет тип, который не может быть назначен <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует элементы списка <see cref="T:System.Collections.Generic.List`1" /> в новый массив.</summary>
        <returns>Массив, содержащий копии элементов списка <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Копирование элементов с помощью <xref:System.Array.Copy%2A?displayProperty=nameWithType>, который является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.ToArray%2A> метод и другие методы <xref:System.Collections.Generic.List%601> класс, который будет действовать на диапазоны. В конце примера <xref:System.Collections.Generic.List%601.GetRange%2A> метод используется для получения этих трех элементов в списке, начиная с индексом 2. <xref:System.Collections.Generic.List%601.ToArray%2A> Метод будет вызван на итоговый <xref:System.Collections.Generic.List%601>, создав массив из трех элементов. Отображаются элементы массива.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает емкость, равную фактическому числу элементов в списке <see cref="T:System.Collections.Generic.List`1" />, если это число меньше порогового значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для минимизации издержек коллекцией памяти, если новые элементы добавляются в коллекцию. Стоимость перераспределение и копирование больших <xref:System.Collections.Generic.List%601> могут быть значительными, тем не менее, поэтому <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод не выполняет никаких действий, если список находится на более 90% от общей мощности. Это позволяет избежать затрат на больших перераспределение при относительно небольшом выигрыше.  
  
> [!NOTE]
>  Текущее пороговое значение, равное 90 процентам может измениться в будущих выпусках.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Чтобы сбросить <xref:System.Collections.Generic.List%601> в исходное состояние, вызовите <xref:System.Collections.Generic.List%601.Clear%2A> метод перед вызовом метода <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод. Удаление пустой <xref:System.Collections.Generic.List%601> задает емкость объекта <xref:System.Collections.Generic.List%601> емкость по умолчанию.  
  
 Емкость можно также задать с помощью <xref:System.Collections.Generic.List%601.Capacity%2A> свойство.  
  
   
  
## Examples  
 Следующий пример демонстрирует проверьте емкость и количество <xref:System.Collections.Generic.List%601> , содержащее простой бизнес-объект и иллюстрирует использование <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод для удаления дополнительная емкость.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод. Несколько свойств и методов <xref:System.Collections.Generic.List%601> класса используются для добавления, вставлять и удалять элементы из списка строк. Затем <xref:System.Collections.Generic.List%601.TrimExcess%2A> метод используется для уменьшения емкости для совпадает с количеством и <xref:System.Collections.Generic.List%601.Capacity%2A> и <xref:System.Collections.Generic.List%601.Count%2A> отображаются свойства. Если было неиспользуемого пространства менее 10% от общей емкости, список будет не изменились. Наконец содержимое списка очищается.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Делегат <see cref="T:System.Predicate`1" />, определяющий условия, проверяемые для элементов.</param>
        <summary>Определяет, все ли элементы списка <see cref="T:System.Collections.Generic.List`1" /> удовлетворяют условиям указанного предиката.</summary>
        <returns>
          <see langword="true" />, если каждый элемент списка <see cref="T:System.Collections.Generic.List`1" /> удовлетворяет условиям заданного предиката, в противном случае — <see langword="false" />. Если в списке нет элементов, возвращается <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Делегат для метода, возвращающего `true` объект, переданный в его соответствие условиям, определенным в делегате.  Элементы текущей <xref:System.Collections.Generic.List%601> передаются по отдельности <xref:System.Predicate%601> делегат и обработка останавливается при делегат возвращает `false` для любого элемента. Элементы обрабатываются в порядке, и все вызовы выполняются в одном потоке.  
  
 Этот метод является операцией O (*n*) операции, где *n* — <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Collections.Generic.List%601.TrueForAll%2A> метод и несколько других методов, использующих <xref:System.Predicate%601> универсального метода-делегата.  
  
 Объект <xref:System.Collections.Generic.List%601> строк создается, содержащие 8 имена динозавров, два из которых (в позициях 1 и 5) заканчивается на «saurus». В примере также определяется метод предиката поиска с именем `EndsWithSaurus`, который принимает строковый параметр и возвращает логическое значение значение, указывающее, является ли входная строка заканчивается на «saurus».  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A> Метод проходит список с самого начала, передавая каждый элемент по очереди к `EndsWithSaurus` метод. Поиск останавливается, когда `EndsWithSaurus` возвращает `false`.  
  
> [!NOTE]
>  В C# и Visual Basic, нет необходимости создавать `Predicate<string>` делегата (`Predicate(Of String)` в Visual Basic) явным образом. Эти языки определить нужный делегат из контекста и создается автоматически.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="match" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>