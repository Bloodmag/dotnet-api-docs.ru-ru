<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3375080ab008f35379a851d18f700db732edfd23" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370808" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Тип ключей в коллекции.</typeparam>
    <typeparam name="TItem">Тип элементов в коллекции.</typeparam>
    <summary>Предоставляет абстрактный базовый класс для коллекции, ключи которой внедрены в значения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Класс предоставляет оба O(1) индексированное извлечение и ключом является получение которого приближается O(1). Это абстрактный тип, или точнее бесконечное множество абстрактных типов, поскольку каждый из его сконструированных универсальных типов является абстрактным базовым классом. Чтобы использовать <xref:System.Collections.ObjectModel.KeyedCollection%602>, наследуют соответствующего типа сконструированного типа коллекции.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Класс — это гибрид коллекции на основании <xref:System.Collections.Generic.IList%601> универсального интерфейса и коллекции на основе <xref:System.Collections.Generic.IDictionary%602> универсальный интерфейс. На основе коллекций, например <xref:System.Collections.Generic.IList%601> универсальный интерфейс <xref:System.Collections.ObjectModel.KeyedCollection%602> является индексированным списком элементов. На основе коллекций, например <xref:System.Collections.Generic.IDictionary%602> универсальный интерфейс <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет ключ, связанный с каждым элементом.  
  
 В отличие от словари, элемент <xref:System.Collections.ObjectModel.KeyedCollection%602> не пару ключ значение; вместо этого весь элемент представляет собой значение и ключ внедряется в пределах значения.  Например, элемента коллекции, производного от `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` в Visual Basic) может быть «Младший John Doe». где значение — «John Doe младший» и ключ — «Doe»; или коллекцию записей сотрудников, содержащих целочисленные ключи может быть получен из `KeyedCollection\<int,Employee>`. Абстрактный <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метод извлекает ключ из элемента.  
  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, которую можно получить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> свойство.  При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекаются один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение переопределяется путем указания порог создания словаря при создании <xref:System.Collections.ObjectModel.KeyedCollection%602>. Словарь поиска создается впервые, количество элементов превышает пороговое значение.  Если указать пороговое значение – 1, словарь поиска никогда не создается.  
  
> [!NOTE]
>  Когда используется внутренний словарь поиска, он содержит ссылки на все элементы в коллекции, если `TItem` является ссылочным типом или копирование всех элементов в коллекции, если `TItem` является типом значения. Таким образом, использование словаря поиска может быть неприемлемо, если `TItem` является типом значения.  
  
 Доступ к элементу по его индексу или ключу с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> свойство. Можно добавить элементы без ключа, но эти элементы впоследствии может осуществляться только по индексу.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере минимальный код, необходимый для являются производными от <xref:System.Collections.ObjectModel.KeyedCollection%602>и показывается, многие из унаследованных методов. Во втором примере показан способ переопределения защищенных методов <xref:System.Collections.ObjectModel.KeyedCollection%602> для предоставления пользовательского поведения.  
  
 **Пример 1.**  
  
 Этот пример кода показывает минимальный код, необходимо унаследовать класс коллекции <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределения <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метода, а также предоставлять открытый конструктор, который выполняет делегирование конструктор базового класса. В примере кода также демонстрируется ряд свойств и методов, унаследованных из <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простым списком заявки, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методы, а также для Настройка заданного по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство (индексатор в C#). В этом примере пользовательское поведение является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет порядок простой формы. Форма заказа `OrderItem` объекты, представляющие элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление для определения типа изменений.  
  
 В примере кода показано настраиваемое поведение, путем вызова свойства и методы производного класса в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, в котором используется компаратор по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Collections.ObjectModel.KeyedCollection%602> с этим конструктор использует универсальный компаратор по умолчанию для типа ключа, полученный от <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Чтобы указать другой универсальный компаратор, используйте <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> конструктор или <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор.  
  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекаются один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение можно переопределить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор и указав порог создания словаря.  
  
> [!NOTE]
>  Поскольку <xref:System.Collections.ObjectModel.KeyedCollection%602> класс является абстрактным (`MustInherit` в Visual Basic), необходимо создать производный от него для использования. В конструкторе производного типа вызова соответствующего <xref:System.Collections.ObjectModel.KeyedCollection%602> конструктор. Необязательно для предоставления функциональных возможностей, таких как компаратор или порог создания словаря в конструкторах.  
  
 Этот конструктор является операцией o(1).  
  
   
  
## Examples  
 Этот пример кода показывает минимальный код, необходимо унаследовать класс коллекции <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределения <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метода, а также предоставлять открытый конструктор, который выполняет делегирование конструктор базового класса. В примере кода также демонстрируется ряд свойств и методов, унаследованных из <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простым списком заявки, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, которая может использоваться при сравнении ключей, или <see langword="null" />, чтобы использовать компаратор по умолчанию для типа ключа, полученного из <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, в котором используется заданный компаратор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекаются один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение можно переопределить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор и указав порог создания словаря.  
  
> [!NOTE]
>  Поскольку <xref:System.Collections.ObjectModel.KeyedCollection%602> класс является абстрактным (`MustInherit` в Visual Basic), необходимо создать производный от него для использования. В конструкторе производного типа вызова соответствующего <xref:System.Collections.ObjectModel.KeyedCollection%602> конструктор. Необязательно для предоставления функциональных возможностей, таких как компаратор или порог создания словаря в конструкторах.  
  
 Этот конструктор является операцией o(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, которая может использоваться при сравнении ключей, или <see langword="null" />, чтобы использовать компаратор по умолчанию для типа ключа, полученного из <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Количество элементов, которое может содержать коллекция без создания словаря поиска (при значении 0 словарь поиска создается при добавлении первого элемента), или –1, чтобы определить, что словарь поиска не будет создаться никогда.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, который использует заданный компаратор и создает словарь поиска при превышении заданного порога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекаются один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Этот конструктор позволяет переопределить это поведение. Укажите 0, чтобы создать словарь при добавлении первого элемента, 1, чтобы создать словарь при добавлении второго элемента и т. д. Если указать пороговое значение – 1, словарь поиска никогда не создается.  
  
 Для небольших коллекций повышение скорости получения данных, предоставляемые словарь поиска не может быть стоит дополнительную память, необходимую для словаря. Задание порога позволяет определить, когда такой компромисс.  
  
> [!NOTE]
>  Поскольку <xref:System.Collections.ObjectModel.KeyedCollection%602> класс является абстрактным (`MustInherit` в Visual Basic), необходимо создать производный от него для использования. В конструкторе производного типа вызова соответствующего <xref:System.Collections.ObjectModel.KeyedCollection%602> конструктор. Необязательно для предоставления функциональных возможностей, таких как компаратор или порог создания словаря в конструкторах.  
  
 Этот конструктор является операцией o(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методы, а также для Настройка заданного по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство (индексатор в C#). В этом примере пользовательское поведение является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода используется <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор с пороговым значением 0, чтобы внутренний словарь создается в первый раз, когда объект добавляется в коллекцию.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет порядок простой формы. Форма заказа `OrderItem` объекты, представляющие элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление для определения типа изменений.  
  
 В примере кода показано настраиваемое поведение, путем вызова свойства и методы производного класса в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="dictionaryCreationThreshold" /> меньше –1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, ключ которого требуется изменить.</param>
        <param name="newKey">Новый ключ для <c>item</c>.</param>
        <summary>Изменяет ключ, связанный с указанным элементом в словаре поиска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не изменяет ключ, внедренных в `item`; он просто заменяет ключ, сохраненный в словаре поиска.  Таким образом Если `newKey` отличается от ключа, которая встроена в `item`, не может получить доступ к `item` с помощью ключа, возвращенных <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Этот метод не выполняет никаких действий при <xref:System.Collections.ObjectModel.KeyedCollection%602> имеет словарь поиска.  
  
 Каждый ключ в <xref:System.Collections.ObjectModel.KeyedCollection%602> должно быть уникальным. Ключ не может быть `null`.  
  
 Этот метод является операцией o(1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Перед изменением ключа внедрены в элемент, необходимо вызвать этот метод, чтобы обновить ключ в словаре поиска. Если порог создания словаря равен – 1, вызов этого метода не требуется.  
  
 Не предоставляйте <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метода в качестве открытого метода производного класса. Неправильное использование этого метода помещает словарь поиска не синхронизировано с ключами элементов. Например, установите значение ключа `null` и задав другое значение добавляет несколько ключей для элемента в словаре поиска. Предоставляйте этот метод внутренним образом, чтобы разрешить изменяемые ключи элементов: при изменении ключа для элемента, этот метод используется для изменения ключа в словаре поиска.  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метод для поддержки изменяемые ключи и переопределение защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методов для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа к свойству метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. В этом случае создается исключение, и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как достигается это поле <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Это поле имеет значение, если элемент добавляется в коллекцию и очищается, когда элемент удален.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="item" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> не найден.  
  
 - или -  
  
 Указанный параметр <paramref name="key" /> уже существует в <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> все элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если словарь поиска, этот метод очищает его, но не удаляет его.  
  
 Если количество элементов превысило порог создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> — с помощью словарь поиска, она будет продолжать использование, даже если количество элементов снова находится ниже порогового значения.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение для <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> метод, унаследованный от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
 Вызовите реализацию базового класса этого метода для очистки коллекции и очистить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> метод, чтобы предоставить пользовательское поведение для очистки всех объектов из коллекции. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методы, а также для Настройка заданного по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство (индексатор в C#). В этом примере пользовательское поведение является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет порядок простой формы. Форма заказа `OrderItem` объекты, представляющие элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление для определения типа изменений.  
  
 В примере кода показано настраиваемое поведение, путем вызова свойства и методы производного класса в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метод для поддержки изменяемые ключи и переопределение защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методов для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа к свойству метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. В этом случае создается исключение, и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как достигается это поле <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Это поле имеет значение, если элемент добавляется в коллекцию и очищается, когда элемент удален.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает универсальный компаратор, используемый для определения равенства ключей в коллекции.</summary>
        <value>Реализация универсального интерфейса <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, используемого для определения равенства ключей в коллекции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ, который требуется найти в <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Определяет, содержится ли в коллекции элемент с указанным ключом.</summary>
        <returns>
          <see langword="true" />, если <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> содержит элемент с указанным ключом, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Collections.ObjectModel.KeyedCollection%602> словарь поиска, `key` будет использоваться для поиска в словаре. Если отсутствует словарь поиска, ключа каждого элемента извлекается с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метод и сравнивается с указанным ключом.  
  
 Этот метод является операцией o(1), если <xref:System.Collections.ObjectModel.KeyedCollection%602> словарь поиска; в противном случае это O (`n`) операции, где `n` — <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Этот пример кода показывает минимальный код, необходимо унаследовать класс коллекции <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределения <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метода, а также предоставлять открытый конструктор, который выполняет делегирование конструктор базового класса. В примере кода также демонстрируется ряд свойств и методов, унаследованных из <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простым списком заявки, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает словарь поиска <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <value>Словарь поиска коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, если он существует; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Collections.ObjectModel.KeyedCollection%602> включает словарь поиска, который создается при добавлении первого элемента. При добавлении элемента <xref:System.Collections.ObjectModel.KeyedCollection%602>, извлекаются один раз и сохраняется в словарь поиска для ускорения поиска ключа элемента. Это поведение можно переопределить с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> конструктор и указав порог создания словаря.  
  
 Получение значения данного свойства является операцией порядка сложности O(1).  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метод для поддержки изменяемые ключи и переопределение защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методов для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа к свойству метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. В этом случае создается исключение, и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как достигается это поле <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Это поле имеет значение, если элемент добавляется в коллекцию и очищается, когда элемент удален.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, из которого нужно извлечь ключ.</param>
        <summary>При реализации в производном классе извлекает ключ из указанного элемента.</summary>
        <returns>Ключ для указанного элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ в словаре поиска отличается от ключа, который внедряется в `item`, не может получить доступ к `item` с помощью ключа, возвращенных <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Можно реализовать этот метод для возврата `null` для коллекции, содержащей элементы без ключей, в этом случае элементы может осуществляться только по индексу. Этот метод является операцией o(1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Необходимо переопределить этот метод, чтобы предоставить для словаря способ извлечения ключей из элементов в словаре.  
  
 Этот метод вызывается внутренним образом. Необязательно для него должен быть открытым.  
  
   
  
## Examples  
 Этот пример кода показывает минимальный код, необходимо унаследовать класс коллекции <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределения <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метода, а также предоставлять открытый конструктор, который выполняет делегирование конструктор базового класса. В примере кода также демонстрируется ряд свойств и методов, унаследованных из <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 `SimpleOrder` Класс является очень простым списком заявки, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс, по которому следует вставить <c>элемент</c>.</param>
        <param name="item">Вставляемый объект.</param>
        <summary>Вставляет элемент в коллекцию <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> по указанному индексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `index` равен <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` добавляется в конец <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> вызывается методом <xref:System.Collections.ObjectModel.Collection%601.Add%2A> и <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> методы.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A> и <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> методы, унаследованные от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
 Вызовите реализацию базового класса этого метода для вставки элемента в коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод, чтобы предоставить пользовательское поведение для добавления или вставке объектов в коллекции. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методы, а также для Настройка заданного по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство (индексатор в C#). В этом примере пользовательское поведение является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет порядок простой формы. Форма заказа `OrderItem` объекты, представляющие элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление для определения типа изменений.  
  
 В примере кода показано настраиваемое поведение, путем вызова свойства и методы производного класса в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метод для поддержки изменяемые ключи и переопределение защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методов для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа к свойству метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. В этом случае создается исключение, и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как достигается это поле <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Это поле имеет значение, если элемент добавляется в коллекцию и очищается, когда элемент удален.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> меньше 0.  
  
 - или -  
  
 Значение <paramref name="index" /> больше значения <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ элемента, который требуется получить.</param>
        <summary>Получает элемент с указанным ключом.</summary>
        <value>Элемент с указанным ключом. Если элемент с указанным ключом не найден, выдается исключение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет возможность доступа к указанному элементу коллекции с помощью следующего синтаксиса: `myCollection[key]` (`myCollection(key)` в Visual Basic).  
  
> [!NOTE]
>  Это свойство отличается от наследуемого <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> свойство, которое возвращает и задает элементов по числовому индексу. Однако если `TKey` типа <xref:System.Int32>, это свойство маскирует наследуемое свойство. В этом случае можно получить унаследованное свойство путем приведения <xref:System.Collections.ObjectModel.KeyedCollection%602> со своим базовым типом. Например `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` в Visual Basic `KeyedCollection<int, MyType^>` в C++) может быть приведен к `Collection<MyType>` (`Collection(Of MyType)` в Visual Basic `Collection<MyType^>` в C++).  
  
 Если <xref:System.Collections.ObjectModel.KeyedCollection%602> словарь поиска, `key` используется для извлечения элемента из словаря.  Если отсутствует словарь поиска, ключа каждого элемента извлекается с помощью <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метод и сравнивается с указанным ключом.  
  
 Ключевое слово языка C# используется для определения индексаторов вместо реализации <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> свойство. В языке Visual Basic в качестве свойства по умолчанию реализовано свойство <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A>, предоставляющее те же возможности индексирования.  
  
 Получение значения данного свойства является операцией o(1), если <xref:System.Collections.ObjectModel.KeyedCollection%602> словарь поиска; в противном случае это O (`n`) операции, где `n` — <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Этот пример кода показывает минимальный код, необходимо унаследовать класс коллекции <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределения <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метода, а также предоставлять открытый конструктор, который выполняет делегирование конструктор базового класса. В примере кода также демонстрируется ряд свойств и методов, унаследованных из <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 Пример кода вызывает и <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> свойство, которое доступно только для чтения и извлекает ключом, и <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> свойство, которое можно задать и извлекает по индексу. Показано, как получить доступ к последнему свойству, когда объекты в производной коллекции имеет целочисленный ключ, не отличается от целых чисел, используемый для получения элементов по индексу.  
  
 `SimpleOrder` Класс является очень простым списком заявки, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Элемент с указанным ключом отсутствует в коллекции.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ элемента, который требуется удалить.</param>
        <summary>Удаляет элемент с указанным ключом из <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns>
          Значение <see langword="true" />, если элемент успешно удален; в противном случае — значение <see langword="false" />.  Этот метод также возвращает <see langword="false" />, если элемент <paramref name="key" /> не найден в коллекции <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключ элемента также удаляется из словаря поиска.  
  
 Если количество элементов превысило порог создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> — с помощью словарь поиска, она будет продолжать использование, даже если количество элементов снова находится ниже порогового значения.  
  
> [!NOTE]
>  Чтобы настроить поведение данного метода, переопределите <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> метод.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Этот пример кода показывает минимальный код, необходимо унаследовать класс коллекции <xref:System.Collections.ObjectModel.KeyedCollection%602>: переопределения <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> метода, а также предоставлять открытый конструктор, который выполняет делегирование конструктор базового класса. В примере кода также демонстрируется ряд свойств и методов, унаследованных из <xref:System.Collections.ObjectModel.KeyedCollection%602> и <xref:System.Collections.ObjectModel.Collection%601> классы.  
  
 В примере показано <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> метод наследуется от <xref:System.Collections.ObjectModel.KeyedCollection%602>, который удаляет элемент с указанным ключом, а также <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> и <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> методами, унаследованными от <xref:System.Collections.ObjectModel.Collection%601>, удаляющие объектом и индексу соответственно.  
  
 `SimpleOrder` Класс является очень простым списком заявки, содержащий `OrderItem` объектов, каждый из которых представляет элемент строки в порядке. Ключ `OrderItem` является неизменяемым, особенно важно для классов, производных от <xref:System.Collections.ObjectModel.KeyedCollection%602>. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="key" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс элемента, который должен быть удален.</param>
        <summary>Удаляет элемент списка <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключ элемента также удаляется из словаря поиска.  
  
 Если количество элементов превысило порог создания словаря и <xref:System.Collections.ObjectModel.KeyedCollection%602> — с помощью словарь поиска, она будет продолжать использование, даже если количество элементов снова находится ниже порогового значения.  
  
 Этот метод является операцией O (`n`) операции, где `n` — <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение для <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> и <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> методы, унаследованные от <xref:System.Collections.ObjectModel.Collection%601> универсального класса и <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> метод.  
  
 Вызовите реализацию базового класса этого метода для удаления элемента из базовой коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> метод, чтобы предоставить пользовательское поведение для удаления объектов из коллекции. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методы, а также для Настройка заданного по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство (индексатор в C#). В этом примере пользовательское поведение является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет порядок простой формы. Форма заказа `OrderItem` объекты, представляющие элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление для определения типа изменений.  
  
 В примере кода показано настраиваемое поведение, путем вызова свойства и методы производного класса в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метод для поддержки изменяемые ключи и переопределение защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методов для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа к свойству метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. В этом случае создается исключение, и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как достигается это поле <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Это поле имеет значение, если элемент добавляется в коллекцию и очищается, когда элемент удален.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Индекс (с нуля) заменяемого элемента.</param>
        <param name="item">Новый элемент.</param>
        <summary>Заменяет элемент по заданному индексу указанным элементом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словарь поиска обновляется соответствующим образом. То есть ключ элемента, который заменяется удаляется из словаря поиска и добавляется ключ нового элемента.  
  
 Этот метод является операцией o(1).  
  
## <a name="notes-for-implementers"></a>Примечания для разработчиков  
 Переопределите этот метод, чтобы предоставить настраиваемое поведение параметра <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство унаследовано от <xref:System.Collections.ObjectModel.Collection%601> универсального класса.  
  
> [!NOTE]
>  Этот метод не влияет на поведение <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> свойство, которое доступно только для чтения.  
  
 Вызовите реализацию базового класса этот метод, чтобы задать элемент в базовой коллекции и обновить словарь поиска.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода, демонстрирующие переопределение <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> метод, чтобы предоставить пользовательское поведение для параметра <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> свойство. В первом примере добавляется настраиваемое событие уведомления и второй обеспечивает поддержку для коллекции объектов с изменяемыми ключами.  
  
 Пример 1  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методы, чтобы обеспечить пользовательское поведение для <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, и <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> методы, а также для Настройка заданного по умолчанию <xref:System.Collections.ObjectModel.Collection%601.Item%2A> свойство (индексатор в C#). В этом примере пользовательское поведение является событие уведомления с именем `Changed`, который вызывается в конце каждого переопределенного метода.  
  
 В примере кода создается `SimpleOrder` класс, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602> и представляет порядок простой формы. Форма заказа `OrderItem` объекты, представляющие элементы упорядочены. В примере кода также создает `SimpleOrderChangedEventArgs` класс, содержащий сведения о событии, а также перечисление для определения типа изменений.  
  
 В примере кода показано настраиваемое поведение, путем вызова свойства и методы производного класса в `Main` метод `Demo` класса.  
  
 Данный пример кода использует объекты с неизменяемыми ключами. Пример кода, в котором используются изменяемые ключи см. в разделе <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Пример 2  
  
 В следующем примере кода показано, как переопределить защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> метод для поддержки изменяемые ключи и переопределение защищенный <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, и <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> методов для обеспечения целостности ключей и Коллекция.  
  
 В примере кода создается `MutableKeys` коллекции, который является производным от <xref:System.Collections.ObjectModel.KeyedCollection%602>и `MutableKey` класса. `MutableKey` Класс имеет устанавливаемое `Key` свойство. При назначении нового ключа к свойству метод задания свойства вызывает `internal` (`Friend` в Visual Basic) `ChangeKey` метода для проверки нового ключа может конфликтовать с существующим ключом в коллекции. В этом случае создается исключение, и значение свойства не изменяется.  
  
 Чтобы поддерживать соединение между `MutableKey` объекта и `MutableKeys` коллекции и предотвращения объекта, вставляемого в двух коллекций, `MutableKey` класс имеет `internal` (`Friend` в Visual Basic) `Collection`поля. Защищенные методы, которые предоставляют пользовательское поведение для добавления и удаления элементов из коллекции, такие как достигается это поле <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> метод. Это поле имеет значение, если элемент добавляется в коллекцию и очищается, когда элемент удален.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="item" Type="TItem&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>