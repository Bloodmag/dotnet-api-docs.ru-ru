<Type Name="DataContext" FullName="System.Data.Linq.DataContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="614bf8b628b9e044f43fb12a554abe74af90df70" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174266" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Linq.DataContext" />
  <TypeSignature Language="VB.NET" Value="Public Class DataContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataContext : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет основную точку входа для платформы LINQ to SQL.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext> Является источником всех сущностей, сопоставленный через подключение к базе данных. Она отслеживает изменения, внесенные для всех извлеченных сущностей и поддерживает «кэш удостоверения», представленный гарантии, что сущности, извлеченные более чем один раз с помощью тот же экземпляр объекта.  
  
 В общем случае <xref:System.Data.Linq.DataContext> экземпляр предназначен для последнего для одну «единицу работы», однако приложение определяет этот термин. Объект <xref:System.Data.Linq.DataContext> , являются упрощенными и не занимает много времени. Типичный [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] приложение создает <xref:System.Data.Linq.DataContext> экземпляров в области метода или члена кратковременных классов, представляющих логический набор связанных операций базы данных.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />. Используемая строка подключения может представлять собой строку подключения ADO.NET. Кроме того, можно задать имя файла в файле SQL Server Express или SQL Server Compact.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Подключение, используемое [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на подключение, используемое [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Data.Linq.DataContext> открывает и закрывает подключение к базе данных, при необходимости, при указании закрытия подключения или строки подключения. В общем случае не следует необходимо вызвать `Dispose` на <xref:System.Data.Linq.DataContext>. При указании открытое соединение, <xref:System.Data.Linq.DataContext> не закроет его. Таким образом, не следует создавать экземпляры <xref:System.Data.Linq.DataContext> с открытым соединением, если у вас есть веская причина для этого. В <xref:System.Transactions> транзакции, <xref:System.Data.Linq.DataContext> не открыть или закрыть подключение во избежание повышения роли.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.IDbConnection connection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.Data.IDbConnection,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As IDbConnection, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::Data::IDbConnection ^ connection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.IDbConnection" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="connection">Соединение, используемое платформой .NET Framework.</param>
        <param name="mapping">Источник сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на подключение и источник сопоставления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection, System.Data.Linq.Mapping.MappingSource mapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection, class System.Data.Linq.Mapping.MappingSource mapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String,System.Data.Linq.Mapping.MappingSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String, mapping As MappingSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection, System::Data::Linq::Mapping::MappingSource ^ mapping);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" />
        <Parameter Name="mapping" Type="System.Data.Linq.Mapping.MappingSource" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">Этот аргумент может принимать любое из следующих значений: имя файла, где находится база данных SQL Server Express.  Имя сервера, где находится база данных. В этом случае поставщик использует для пользователя базу данных по умолчанию.  Полная строка подключения. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] просто передает строку поставщику без изменений.</param>
        <param name="mapping">Источник сопоставления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на источник файлов и источник сопоставления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataContext (string fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileOrServerOrConnection) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileOrServerOrConnection As String)" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ fileOrServerOrConnection);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public DataContext (string connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.#ctor(System.String)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataContext(System::String ^ connectionString);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileOrServerOrConnection" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="connectionString" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileOrServerOrConnection">To be added.</param>
        <param name="connectionString">To be added.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Linq.DataContext" />, ссылаясь на источник файла.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeConflicts">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeConflictCollection ChangeConflicts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.ChangeConflictCollection ChangeConflicts" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ChangeConflicts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChangeConflicts As ChangeConflictCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::ChangeConflictCollection ^ ChangeConflicts { System::Data::Linq::ChangeConflictCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeConflictCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию объектов, ставшую причиной конфликта параллелизма, когда был вызван метод <see cref="M:System.Data.Linq.DataContext.SubmitChanges" />.</summary>
        <value>Коллекция объектов, ставшая причиной конфликта параллелизма.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующем примере показано, как коллекции может быть выполнен обход для получения сведений о конфликте.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.objectchangeconflict/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ObjectChangeConflict#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.objectchangeconflict/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CommandTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое увеличивает время ожидания для запросов, для которых в противном случае истекло время ожидание в течение времени ожидания по умолчанию.</summary>
        <value>Целое число, которое увеличивает время ожидания для запросов, для которых в противном случае истекло время ожидание в течение времени ожидания по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство Возвращает или задает время ожидания команды, используемые для выполнения сгенерированных команд (`IDbCommands`). Дополнительные сведения см. в разделе <xref:System.Data.IDbCommand.CommandTimeout%2A>.  
  
 Если это свойство не задано, значение по умолчанию <xref:System.Data.IDbCommand.CommandTimeout%2A> используется для выполнения команды запроса. Это значение по умолчанию задается поставщиком хранилища. Обратите внимание, что некоторые поставщики могут вызывать исключения, если это значение равно ненулевое значение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает подключение, используемое платформой.</summary>
        <value>Подключение, используемое платформой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для взаимодействия с реляционным кодом ADO.NET.  
  
 Возвращенное подключение будет закрыто, если он был явно открыт пользователем.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает базу данных на сервере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя базы данных создается с помощью следующего алгоритма:  
  
1. Если база данных определена в строке подключения, используется его имя.  
1. Если <xref:System.Data.Linq.Mapping.DatabaseAttribute> присутствует атрибут, ее <xref:System.Data.Linq.Mapping.DatabaseAttribute.Name%2A> свойство используется в качестве имени базы данных.  
1. Если ни один тег базы данных в строке подключения и строго типизированные <xref:System.Data.Linq.DataContext> используется, базу данных с тем же именем, что <xref:System.Data.Linq.DataContext> наследование класса создается.  
1. Если слабо типизированным <xref:System.Data.Linq.DataContext> — используется, создается исключение.  
1. Если <xref:System.Data.Linq.DataContext> был создан с помощью имени файла, создается база данных, соответствующее имени этого файла.  
     
  
## Examples  
 Ниже показано, как настроить временную базу данных, а затем удалите его.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMethodCallQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryable&lt;TResult&gt; CreateMethodCallQuery&lt;TResult&gt; (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Linq.IQueryable`1&lt;!!TResult&gt; CreateMethodCallQuery&lt;TResult&gt;(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.CreateMethodCallQuery``1(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Linq::IQueryable&lt;TResult&gt; ^ CreateMethodCallQuery(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип элементов в возвращаемой коллекции.</typeparam>
        <param name="instance">Экземпляр вызова метода (текущий объект).</param>
        <param name="methodInfo">
          <see cref="T:System.Reflection.MethodInfo" />, который определяет метод CLR, соответствующий методу базы данных.</param>
        <param name="parameters">Массив параметров для передачи команде.</param>
        <summary>Выполняет табличную функцию базы данных, связанную с указанным методом CLR.</summary>
        <returns>Коллекция результирующих значений, возвращаемых запросом базы данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext.CreateMethodCallQuery%2A> Метод используется в автоматически создаваемый код и действует как прокси для функции базы данных.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, можно ли открыть связанную базу данных.</summary>
        <returns>Значение <see langword="true" />, если указанную базу данных можно открыть; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует подключение в <xref:System.Data.Linq.DataContext.Connection%2A> свойство попыток открытия связанной базы данных.  
  
   
  
## Examples  
 В следующем примере этот метод используется для определения, является ли база данных уже существует.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLoadingEnabled">
      <MemberSignature Language="C#" Value="public bool DeferredLoadingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DeferredLoadingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.DeferredLoadingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property DeferredLoadingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DeferredLoadingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли загружать с задержкой связи "один к одному" или "один ко многим".</summary>
        <value>
          <see langword="true" />, если отложенная загрузка разрешена; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если код обращается к одной из таких связей, значение null возвращается, если связь является один к одному и возвращается пустая коллекция, если один ко многим. Связи по-прежнему может быть заполнен, задав <xref:System.Data.Linq.DataContext.LoadOptions%2A> свойство.  
  
 Чтобы можно было извлечь часть объектной модели и отправить ее (например, веб-служба) является основным сценарием для этого свойства.  
  
> [!NOTE]
>  Если это свойство имеет значение `false` после выполнения запроса возникает исключение. В разделе **допустимые режимы** ниже, в разделе для получения дополнительной информации.  
  
## <a name="valid-modes"></a>Допустимые режимы  
 Отложенная загрузка требует отслеживания объектов. Допустимы только следующие три режима:  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `false`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> пропускается и выведен как `false`. Это поведение соответствует только для чтения <xref:System.Data.Linq.DataContext>.  
  
-   <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> = `true`. <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> = `false`. Такой ситуации соответствует <xref:System.Data.Linq.DataContext> , которая позволяет пользователям для загрузки граф объектов с помощью <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> директивы, но он не поддерживает отложенной загрузки.  
  
-   Оба равным `true`. Это значение по умолчанию.  
  
 Флаги не могут изменяться после выполнения запроса. После выполнения первого запроса, который использует любое изменение <xref:System.Data.Linq.DataContext> приводит к возникновению исключения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет связанную базу данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует подключение в <xref:System.Data.Linq.DataContext.Connection%2A> свойство для идентификации базы данных для удаления.  
  
   
  
## Examples  
 Приведенный ниже показано, как удалить базу данных, созданной временно.  
  
 [!code-csharp[System.Data.Linq.DataContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#1)]
 [!code-vb[System.Data.Linq.DataContext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.Linq.DataContext.Dispose" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождение ресурсов, используемых классом <see cref="T:System.Data.Linq.DataContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые классом <see cref="T:System.Data.Linq.DataContext" /> (при необходимости освобождает и управляемые ресурсы).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCommand">
      <MemberSignature Language="C#" Value="public int ExecuteCommand (string command, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteCommand(string command, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteCommand (command As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteCommand(System::String ^ command, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="command">Выполняемая команда SQL.</param>
        <param name="parameters">Массив параметров для передачи команде. Обратите внимание на следующее поведение: если количество объектов в массиве меньше, чем наибольшее число команд, определенных в командной строке, создается исключение.  Если массив содержит объекты, на которые нет ссылок в командной строке, исключение не создается.  Если значение одного из параметров равно NULL, оно преобразуется в значение <see langword="DBNull.Value" />.</param>
        <summary>Выполняет команды SQL непосредственно в базе данных.</summary>
        <returns>Количество строк, измененных выполненной командой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является транзитным механизмом для случаев, где [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] обеспечивает должным образом для того или иного сценария.  
  
 Синтаксис для команды аналогично синтаксиса, используемого для создания ADO.NET `DataCommand`. Единственное отличие заключается в том, как параметры заданы. В частности, параметры указываются путем заключения в фигурные скобки ({}...) и перечислить их начиная с 0. Параметр связан с объектом с таким же номером в массиве параметров.  
  
 `ExecuteQuery` и `ExecuteCommand` позволяют задавать переменное число аргументов для параметра подстановки. Например, можно указать параметры при вызове метода ExecuteQuery\<TResult >:  
  
```  
db.ExecuteQuery<Customer>("select * from dbo.Customers where City = {0}", "London");  
```  
  
 Кроме того, еще один пример:  
  
```  
db.ExecuteCommand("UPDATE Products SET QuantityPerUnit = {0} WHERE ProductID = {1}", "24 boxes", 5);  
```  
  
 Следующий пример открывает соединение и передает SQL `UPDATE` командой SQL engine.  
  
   
  
## Examples  
 [!code-csharp[DLinqCommunicatingWithDatabase#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqCommunicatingWithDatabase/cs/Program.cs#3)]
 [!code-vb[DLinqCommunicatingWithDatabase#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqCommunicatingWithDatabase/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicDelete">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicDelete (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicDelete(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicDelete(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicDelete (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicDelete(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, которая будет удалена.</param>
        <summary>Выполняет внутренние методы переопределения удаления для повторного делегирования в [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] задачи создания и выполнения динамического SQL для операций удаления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. раздел <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicInsert">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicInsert (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicInsert(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicInsert(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicInsert (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicInsert(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, которая будет вставлена.</param>
        <summary>Выполняет внутренние методы переопределения вставки для повторного делегирования в [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] задачи создания и выполнения динамического SQL для операций вставки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание на следующие аспекты:  
  
-   Так как метод с модификатором protected, его использование требует создания подкласса <xref:System.Data.Linq.DataContext>.  
  
-   Исключение возникает в том случае, если эта операция не вызывается внутри <xref:System.Data.Linq.DataContext.SubmitChanges%2A> операции. Он не предназначен для вызова как автономной работе за пределами области <xref:System.Data.Linq.DataContext.SubmitChanges%2A> операции. <xref:System.Data.Linq.DataContext.SubmitChanges%2A> сама вызывает переопределить методы при их реализации и рассмотренные выше методы являются предназначен для непосредственного вызова внутренние переопределенные методы.  
  
-   Он отвечает разработчик для передачи в правильную сущность. Реализация подтверждает, что отслеживается переданной сущности. Тем не менее он отвечает разработчик сохранить порядок или передавать в той же сущности два раза.  
  
-   Возлагается на разработчика вызвать правильный динамический API-Интерфейс. Например, в `Update` Переопределите метод, только <xref:System.Data.Linq.DataContext.ExecuteDynamicUpdate%2A> метод может вызываться. [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] не обнаруживает и не проверяет вызванный динамический метод на предмет соответствия применяемой операции. Результаты не определены, если вызывается неприменимый метод (например, вызов <xref:System.Data.Linq.DataContext.ExecuteDynamicDelete%2A> для обновления объекта).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDynamicUpdate">
      <MemberSignature Language="C#" Value="protected internal void ExecuteDynamicUpdate (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void ExecuteDynamicUpdate(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteDynamicUpdate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub ExecuteDynamicUpdate (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void ExecuteDynamicUpdate(System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Сущность, которая будет обновлена.</param>
        <summary>Выполняет внутренние методы переопределения обновления для повторного делегирования в [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] задачи создания и выполнения динамического SQL для операций обновления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 См. раздел <xref:System.Data.Linq.DataContext.ExecuteDynamicInsert%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMethodCall">
      <MemberSignature Language="C#" Value="protected System.Data.Linq.IExecuteResult ExecuteMethodCall (object instance, System.Reflection.MethodInfo methodInfo, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Data.Linq.IExecuteResult ExecuteMethodCall(object instance, class System.Reflection.MethodInfo methodInfo, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteMethodCall(System.Object,System.Reflection.MethodInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::Linq::IExecuteResult ^ ExecuteMethodCall(System::Object ^ instance, System::Reflection::MethodInfo ^ methodInfo, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IExecuteResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Экземпляр вызова метода (текущий объект).</param>
        <param name="methodInfo">Определяет метод CLR, соответствующий методу базы данных.</param>
        <param name="parameters">Массив параметров для передачи команде.</param>
        <summary>Выполняет хранимую процедуру базы данных или скалярную функцию, связанную с указанным методом среды CLR.</summary>
        <returns>Результат (возвращаемое значение и выходные параметры) выполнения указанного метода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Linq.DataContext.ExecuteMethodCall%2A> Метод используется в автоматически создаваемый код и действует как прокси для функции базы данных.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ExecuteQuery (Type elementType, string query, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable ExecuteQuery(class System.Type elementType, string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery(System.Type,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery (elementType As Type, query As String, ParamArray parameters As Object()) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ ExecuteQuery(Type ^ elementType, System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Collections.Generic.IEnumerable`1" />, который должен быть возвращен.  Алгоритм сопоставления столбцов в результате запроса с полями или свойствами в объекте работает таким образом: если поле или свойство сопоставляется с определенным именем столбца, это имя столбца ожидается в наборе результатов.  Если поле или свойство не сопоставляется, столбец с тем же именем, что и поле или свойство, ожидается в наборе результатов.  Сначала в сравнении выполняется поиск совпадения с учетом регистра. Если это совпадение не найдено, следующий поиск выполняется для совпадений без учета регистра.  Запрос должен возвращать все отслеженные поля и свойства объекта (кроме тех, загрузка которых отложена), если выполняются все следующие условия: <c>T</c> является сущностью, явно отслеживаемой <see cref="T:System.Data.Linq.DataContext" />.  
  
 Свойство <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> имеет значение <see langword="true" />.  Сущность имеет первичный ключ.  В противном случае возникает исключение.</param>
        <param name="query">Запрос SQL для выполнения.</param>
        <param name="parameters">Массив параметров для передачи команде. Обратите внимание на следующее поведение: если количество объектов в массиве меньше, чем наибольшее число команд, определенных в командной строке, создается исключение.  Если массив содержит объекты, на которые нет ссылок в командной строке, исключение не создается.  Если значение параметра равно <see langword="null" />, он преобразовывается в <see langword="DBNull.Value" />.</param>
        <summary>Выполняет SQL-запросы непосредственно в базе данных.</summary>
        <returns>Коллекция объектов <see cref="T:System.Collections.Generic.IEnumerable`1" />, возвращаемых запросом.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteQuery&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; ExecuteQuery&lt;TResult&gt; (string query, params object[] parameters) where TResult : new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; ExecuteQuery&lt;.ctor TResult&gt;(string query, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.ExecuteQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteQuery(Of TResult As New) (query As String, ParamArray parameters As Object()) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; where TResult : gcnew() System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ ExecuteQuery(System::String ^ query, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип элементов в возвращаемой коллекции.</typeparam>
        <param name="query">Запрос SQL для выполнения.</param>
        <param name="parameters">Массив параметров для передачи команде. Обратите внимание на следующее поведение: если количество объектов в массиве меньше, чем наибольшее число команд, определенных в командной строке, создается исключение.  Если массив содержит объекты, на которые нет ссылок в командной строке, исключение не создается.  Если значение параметра равно NULL, он преобразуется в <see langword="DBNull.Value" />.</param>
        <summary>Выполняет запросы SQL непосредственно в базе данных и возвращает объекты.</summary>
        <returns>Коллекция объектов, возвращенных запросом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является транзитным механизмом для случаев, где [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] не предоставляет для того или иного сценария.  
  
 Алгоритм сопоставления столбцов в результатах запроса с полями и свойствами в объекте работает следующим образом:  
  
-   Если поле или свойство сопоставляется с определенным именем столбца, это имя столбца ожидается в наборе результатов.  
  
-   Если поле или свойство не сопоставляется, столбец с тем же именем, что и поле или свойство, ожидается в наборе результатов.  
  
-   Сравнение выполняется первой ищет совпадение с учетом регистра. Если такое совпадение не найдено, следующий поиск выполняется без учета регистра соответствия.  
  
-   Запрос должен возвращать все отслеженные поля и свойства объекта (кроме тех элементов, которые относятся к отложенной загрузке) Если выполняются все следующие:  
  
    -   Если `<T>` сущность явно отслеживается <xref:System.Data.Linq.DataContext>.  
  
    -   ObjectTrackingEnabled имеет значение true.  
  
    -   Сущность имеет первичный ключ.  
  
     В противном случае возникает исключение.  
  
-   Во всех остальных случаях запрос может извлекать только подмножество отслеженные поля и свойства для объекта.  
  
 В следующем фрагменте на C# показано один использования для этого метода:  
  
```  
var customers = db.ExecuteQuery<Customer>(@"SELECT CustomerID, CompanyName, ContactName, ContactTitle,   
   Address, City, Region, PostalCode, Country, Phone, Fax  
   FROM   dbo.Customers  
   WHERE  City = {0}", "London");  
  
foreach (Customer c in customers)  
   Console.WriteLine(c.ContactName);  
```  
  
 В Visual Basic  
  
```  
Dim customers = db.ExecuteQuery(Of Customer)("SELECT CustomerID, _    CompanyName, ContactName, ContactTitle, _  
   Address, City, Region, PostalCode, Country, Phone, Fax _  
   FROM dbo.Customers _  
WHERE City = {0}", "London")  
  
For Each c As Customer In customers  
    Console.WriteLine(c.ContactName)  
Next  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChangeSet">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ChangeSet GetChangeSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ChangeSet GetChangeSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetChangeSet" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChangeSet () As ChangeSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ChangeSet ^ GetChangeSet();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ChangeSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает измененные объекты, отслеживаемые <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <returns>Набор объектов возвращается как три коллекции, доступные только для чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание на следующие аспекты:  
  
-   <xref:System.Data.Linq.DataContext.GetChangeSet%2A> может иметь побочные эффекты, например вывод вставки и удаления, которые обычно выполняются во время <xref:System.Data.Linq.DataContext.SubmitChanges%2A>. Например объекты, которые используются в следующих операциях можно создать соответствующие выделенные операции в следующем списке:  
  
    -   <xref:System.Data.Linq.EntitySet%601.Add%2A> Чтобы <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.  
  
    -   <xref:System.Data.Linq.EntityRef%601> Присвоение null (возможно из-за <xref:System.Data.Linq.EntitySet%601.Remove%2A> для <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.  
  
-   Набор не может быть упорядочены в соответствии с ограничениями внешнего ключа.  
  
-   Генерируемые базой данных значения (например, значения первичного и внешнего ключей, отметки времени и так далее) недоступны. Такие данные требуют выполнения команд базы данных и возможно, распространения извлеченных сведений (например, внешний ключ из первичного ключа).  
  
-   Набор измененных объектов вычисляется во время вызова. Последующие вызовы <xref:System.Data.Linq.DataContext.SubmitChanges%2A> может создать другой набор, если были внесены дополнительные изменения.  
  
 Если не были внесены изменения получается следующий результат:  
  
 `{Added: 0, Removed: 0, Modified: 0}`  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#2](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#2)]
 [!code-vb[DLinqDebuggingSupport#2](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand GetCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Common.DbCommand GetCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCommand (query As IQueryable) As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Common::DbCommand ^ GetCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">Запрос, сведения о команде SQL которого должны быть извлечены.</param>
        <summary>Возвращает сведения о командах SQL, созданных [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)].</summary>
        <returns>Запрошенный объект данных команды.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен только для считывания и не влияет на <xref:System.Data.Linq.DataContext> состояние.  
  
 Обратите внимание на следующие аспекты:  
  
-   Аргумент должен быть непустым. В противном случае — значение null, аргумент возникает исключение.  
  
-   Обычные исключения преобразования запросов во время [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] выполнение запроса применяются для запроса, который не может быть преобразован.  
  
-   Возвращается только команда первого запроса. В частности, дополнительные команды, которые используются для упреждающую (<xref:System.Data.Linq.DataLoadOptions.LoadWith%2A>) не включаются.  
  
-   <xref:System.Data.Linq.DataContext> не отслеживает действия пользователя с помощью команды. Например, результаты из выполнения возвращенной команды, не отслеживаются и не влияют на <xref:System.Data.Linq.DataContext> состояние.  
  
   
  
## Examples  
 [!code-csharp[DLinqDebuggingSupport#3](~/samples/snippets/csharp/VS_Snippets_Data/DLinqDebuggingSupport/cs/Program.cs#3)]
 [!code-vb[DLinqDebuggingSupport#3](~/samples/snippets/visualbasic/VS_Snippets_Data/DLinqDebuggingSupport/vb/Module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIDbCommand">
      <MemberSignature Language="C#" Value="public System.Data.IDbCommand GetIDbCommand (System.Linq.IQueryable query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.IDbCommand GetIDbCommand(class System.Linq.IQueryable query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetIDbCommand(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIDbCommand (query As IQueryable) As IDbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::IDbCommand ^ GetIDbCommand(System::Linq::IQueryable ^ query);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.Linq.IQueryable" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable">
      <MemberSignature Language="C#" Value="public System.Data.Linq.ITable GetTable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.ITable GetTable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::ITable ^ GetTable(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.ITable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип возвращаемых объектов.</param>
        <summary>Возвращает коллекцию объектов определенного типа, где тип определяется параметром <paramref name="type" />.</summary>
        <returns>Коллекция объектов, определенных параметром <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это слабо типизированным версия <xref:System.Data.Linq.DataContext.GetTable%2A>. Важно иметь слабо типизированной версии, так как он является относительно распространенной практикой для динамического построения запросов. Будет неудобно, чтобы принудительно применить использовать отражение для вызова правильного универсального метода.  
  
 Если отсутствует коллекция для определенного типа, создается исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTable&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Table&lt;TEntity&gt; GetTable&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.Table`1&lt;!!TEntity&gt; GetTable&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.GetTable``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTable(Of TEntity As Class) () As Table(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Linq::Table&lt;TEntity&gt; ^ GetTable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Table&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Тип возвращаемых объектов.</typeparam>
        <summary>Возвращает коллекцию объектов определенного типа, где тип определяется параметром <paramref name="TEntity" />.</summary>
        <returns>Коллекция объектов, определенных параметром <paramref name="TEntity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является главную точку входа для выполнения запросов. Когда со строгой типизацией <xref:System.Data.Linq.DataContext> будет создан, новые созданные свойства инкапсулируют вызовы этого метода. Например `Customers` создать свойство, возвращающее `GetTable<Customer>`.  
  
 Если отсутствует коллекция для определенного типа, создается исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadOptions">
      <MemberSignature Language="C#" Value="public System.Data.Linq.DataLoadOptions LoadOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.DataLoadOptions LoadOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.LoadOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadOptions As DataLoadOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::DataLoadOptions ^ LoadOptions { System::Data::Linq::DataLoadOptions ^ get(); void set(System::Data::Linq::DataLoadOptions ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.DataLoadOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Data.Linq.DataLoadOptions" />, связанный с данным объектом <see cref="T:System.Data.Linq.DataContext" />.</summary>
        <value>Предварительно выбранные параметры загрузки для связанных данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство Возвращает или задает параметры, которые используются для определения поведения предварительную загрузку для элементов с отложенной загрузкой и членства связанных коллекций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Log" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Log { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает назначение для записи команды или запроса SQL.</summary>
        <value>Объект <see cref="T:System.IO.TextReader" /> для записи команды.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `null` отключение ведения журнала команд.  
  
   
  
## Examples  
 В следующем примере отображается созданный код SQL в окне консоли перед его отображением результатов запроса.  
  
 [!code-csharp[System.Data.Linq.DataContext#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Data.Linq.DataContext/cs/Program.cs#2)]
 [!code-vb[System.Data.Linq.DataContext#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Data.Linq.DataContext/vb/Module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mapping">
      <MemberSignature Language="C#" Value="public System.Data.Linq.Mapping.MetaModel Mapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Linq.Mapping.MetaModel Mapping" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Mapping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mapping As MetaModel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Linq::Mapping::MetaModel ^ Mapping { System::Data::Linq::Mapping::MetaModel ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.Mapping.MetaModel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Data.Linq.Mapping.MetaModel" />, на котором основано сопоставление.</summary>
        <value>Сопоставление между базой данных и объектами домена.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectTrackingEnabled">
      <MemberSignature Language="C#" Value="public bool ObjectTrackingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ObjectTrackingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ObjectTrackingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ObjectTrackingEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, включено ли отслеживание объекта.</summary>
        <value>Значение <see langword="true" />, если отслеживание объекта включено; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвоение этому свойству `false` повысить производительность во время извлечения, поскольку меньшее количество элементов для отслеживания.  
  
 Порождено исключение:  
  
-   Если свойство имеет значение `false` после выполнения запроса.  
  
     Дополнительные сведения см. в разделе допустимые режимы <xref:System.Data.Linq.DataContext>.  
  
-   Если свойство имеет значение `false` и <xref:System.Data.Linq.DataContext.SubmitChanges%2A> вызывается.  
  
 Если <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> — `false`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> игнорируется и обрабатывается `false`. В этом случае <xref:System.Data.Linq.DataContext> доступно только для чтения.  
  
 Если <xref:System.Data.Linq.DataContext.ObjectTrackingEnabled%2A> — `true`, <xref:System.Data.Linq.DataContext.DeferredLoadingEnabled%2A> — `false`. В этом случае <xref:System.Data.Linq.DataContext> позволяет загрузить граф объектов с помощью <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> директивы, но не включает отложенная загрузка.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCacheEnabled">
      <MemberSignature Language="C#" Value="public bool QueryCacheEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool QueryCacheEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.QueryCacheEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property QueryCacheEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool QueryCacheEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет состояние объекта, используя данные в базе данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод полезно использовать после возникновения ошибки оптимистичного параллелизма, чтобы привести элементы в состояние для следующей попытки. Обновляет состояние примитивов поля и свойства объектов.  
  
> [!NOTE]
>  Если объект находится на *много* стороне связи «один ко многим», внешний ключ для объекта будет установлено и указателя на объект на стороне связи присваивается новое значение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, System.Collections.IEnumerable entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, class System.Collections.IEnumerable entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entities As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Collections::IEnumerable ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="mode">Значение, указывающее, как обрабатываются конфликты оптимистичного параллелизма.</param>
        <param name="entities">Коллекция сущностей, которые должны быть обновлены.</param>
        <summary>Обновляет коллекцию объектов сущности согласно указанному режиму.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, System::Object ^ entity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="mode">Значение, указывающее, как обрабатываются конфликты оптимистичного параллелизма.</param>
        <param name="entity">Обновляемый объект.</param>
        <summary>Обновляет объект сущности согласно указанному режиму.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Linq.RefreshMode mode, params object[] entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Linq.RefreshMode mode, object[] entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Refresh(System.Data.Linq.RefreshMode,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh (mode As RefreshMode, ParamArray entities As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Linq::RefreshMode mode, ... cli::array &lt;System::Object ^&gt; ^ entities);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.Linq.RefreshMode" />
        <Parameter Name="entities" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="mode">Значение, указывающее, как обрабатываются конфликты оптимистичного параллелизма.</param>
        <param name="entities">Обновляемый массив объектов сущности.</param>
        <summary>Обновляет массив объектов сущности согласно указанному режиму.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubmitChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вычисляет набор измененных объектов, которые следует вставить, обновить или удалить, и выполняет соответствующие команды для внесения изменений в базу данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для инструкции insert, update или delete, методы переопределения <xref:System.Data.Linq.DataContext.SubmitChanges%2A> выполняет эти методы вместо значения по умолчанию [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] команд.  
  
 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> Начинает транзакцию и будет откатываться, если исключение возникает во время <xref:System.Data.Linq.DataContext.SubmitChanges%2A> выполняется. Однако это не откатить изменения в памяти, или контролируется системой <xref:System.Data.Linq.DataContext>; эти изменения будет необходимо выполнить откат вручную. Можно начать с нового экземпляра <xref:System.Data.Linq.DataContext> Если изменения в памяти, будут отменены.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public void SubmitChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubmitChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubmitChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubmitChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вычисляет набор измененных объектов, которые следует вставить, обновить или удалить, и выполняет соответствующие команды для внесения изменений в базу данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для инструкции insert, update или delete, методы переопределения <xref:System.Data.Linq.DataContext.SubmitChanges%2A> выполняет эти методы вместо значения по умолчанию [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] команд.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubmitChanges">
      <MemberSignature Language="C#" Value="public virtual void SubmitChanges (System.Data.Linq.ConflictMode failureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubmitChanges(valuetype System.Data.Linq.ConflictMode failureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.SubmitChanges(System.Data.Linq.ConflictMode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SubmitChanges (failureMode As ConflictMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SubmitChanges(System::Data::Linq::ConflictMode failureMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="failureMode" Type="System.Data.Linq.ConflictMode" />
      </Parameters>
      <Docs>
        <param name="failureMode">Действие, выполняемое в случае сбоя отправки. Допустимые аргументы:  <see cref="F:System.Data.Linq.ConflictMode.FailOnFirstConflict" /><see cref="F:System.Data.Linq.ConflictMode.ContinueOnConflict" /></param>
        <summary>Отправляет изменения, которые были внесены в извлеченные объекты для основной базы данных, и указывает действие, которое следует выполнить, если не удастся осуществить передачу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим сбоя по умолчанию — <xref:System.Data.Linq.ConflictMode.FailOnFirstConflict>.  
  
   
  
## Examples  
 [!code-csharp[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/csharp/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/cs/program.cs#1)]
 [!code-vb[System.Data.Linq.ConflictModeEnumeration#1](~/samples/snippets/visualbasic/VS_Snippets_Data/system.data.linq.conflictmodeenumeration/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Linq.DataContext.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbTransaction ^ Transaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает локальную транзакцию для [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], чтобы использовать ее для доступа к базе данных.</summary>
        <value>Объект транзакции, который используется объектом <see cref="T:System.Data.Linq.DataContext" /> при выполнении запросов и команд.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основной сценарий для этого свойства — это взаимодействие с реляционными [!INCLUDE[vstecado](~/includes/vstecado-md.md)] кода. Например, это свойство при написании собственного `Create` / `Update` / `Delete` способа установить `Transaction` свойство ADO `Command` объекта.  
  
 Обратите внимание на следующее условия:  
  
-   Если это свойство не было задано явно, метод считывания возвращает значение null.  
  
-   Если код выполняется в <xref:System.Transactions.Transaction> контекста, задание этого свойства приводит к возникновению исключения.  
  
-   Если это свойство имеет набор и новый <xref:System.Transactions.Transaction> будет открыт, создается исключение при выполнении запроса или обновления.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Translate">
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает существующий <see cref="T:System.Data.IDataReader" /> в объекты.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждая строка в <xref:System.Data.IDataReader> преобразуется в объект <xref:System.Collections.Generic.IEnumerable%601>.  
  
```  
public IEnumerable<T> Translate<T>(IDataReader reader) {}  
```  
  
 Описание: Этот метод используется для преобразования существующего <xref:System.Data.Common.DbDataReader> к объектам. Каждая строка в <xref:System.Data.Common.DbDataReader> преобразуется в объект <xref:System.Collections.Generic.IEnumerable%601>.  
  
 **Универсальные параметры:**  
  
 `T`: Просмотреть <xref:System.Data.Linq.DataContext.ExecuteQuery%2A>.  
  
 **Параметры:**  
  
 `Query`: См. в описании команды в разделе <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 `Parameters`: См. в описании параметров в разделе <xref:System.Data.Linq.DataContext.ExecuteCommand%2A>.  
  
 **Тип возвращаемого значения:**  
  
 <xref:System.Collections.Generic.IEnumerable%601>: Коллекция объектов, возвращаемых преобразованием.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Data.Linq.IMultipleResults Translate (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Linq.IMultipleResults Translate(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (reader As DbDataReader) As IMultipleResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Linq::IMultipleResults ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Linq.IMultipleResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Преобразуемая структура <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Преобразовывает существующий <see cref="T:System.Data.Common.DbDataReader" /> в объекты.</summary>
        <returns>Список объектов, возвращаемых преобразованием.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable Translate (Type elementType, System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerable Translate(class System.Type elementType, class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate(System.Type,System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate (elementType As Type, reader As DbDataReader) As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerable ^ Translate(Type ^ elementType, System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <param name="elementType">Тип <see cref="T:System.Collections.Generic.IEnumerable`1" />, который должен быть возвращен.  Алгоритм сопоставления столбцов в результате с полями и свойствами в объекте работает таким образом: если поле или свойство сопоставляется с определенным именем столбца, это имя столбца ожидается в наборе результатов.  Если поле или свойство не сопоставляется, столбец с тем же именем, что и поле или свойство, ожидается в наборе результатов.  Сначала в сравнении выполняется поиск совпадения с учетом регистра. Если это совпадение не найдено, следующий поиск выполняется для совпадений без учета регистра.  Запрос должен возвращать все отслеженные поля и свойства объекта (кроме тех, загрузка которых отложена), если выполняются все следующие условия: <c>T</c> является сущностью, явно отслеживаемой <see cref="T:System.Data.Linq.DataContext" />.  
  
 Свойство <see cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" /> имеет значение <see langword="true" />.  Сущность имеет первичный ключ.  В противном случае возникает исключение.</param>
        <param name="reader">Преобразуемая структура <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Преобразовывает существующий <see cref="T:System.Data.Common.DbDataReader" /> в объекты.</summary>
        <returns>Список объектов, возвращаемых преобразованием.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TResult&gt; Translate&lt;TResult&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Translate&lt;TResult&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Linq.DataContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TResult) (reader As DbDataReader) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип <see cref="T:System.Collections.Generic.IEnumerable`1" />, который должен быть возвращен.</typeparam>
        <param name="reader">Преобразуемая структура <see cref="T:System.Data.IDataReader" />.</param>
        <summary>Преобразовывает существующий <see cref="T:System.Data.Common.DbDataReader" /> в объекты.</summary>
        <returns>Коллекция объектов, возвращаемых преобразованием.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>