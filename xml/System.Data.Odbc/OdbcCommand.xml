<Type Name="OdbcCommand" FullName="System.Data.Odbc.OdbcCommand">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a32b600318bf52a50113d6d84e46df94ff49822a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30390498" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OdbcCommand : System.Data.Common.DbCommand, ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OdbcCommand extends System.Data.Common.DbCommand implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Odbc.OdbcCommand" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OdbcCommand&#xA;Inherits DbCommand&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OdbcCommand sealed : System::Data::Common::DbCommand, ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Odbc</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbCommand</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RecordsAffected")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.OdbcCommandDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет инструкцию SQL или хранимую процедуру, выполняемую с источником данных. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Odbc.OdbcCommand> Класс предоставляет следующие методы для выполнения команд в источнике данных:  
  
|Элемент|Описание:|  
|----------|-----------------|  
|<xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A>|Выполняет команды, которые возвращают строки.|  
|<xref:System.Data.Odbc.OdbcCommand.ExecuteNonQuery%2A>|Выполняет команды, такие как инструкции SQL INSERT, DELETE, UPDATE и НАБОР.|  
|<xref:System.Data.Odbc.OdbcCommand.ExecuteScalar%2A>|Возвращает одно значение, например, статистическое значение из базы данных.|  
  
 Вы можете сбросить <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойство и повторное использование <xref:System.Data.Odbc.OdbcCommand> объекта. Тем не менее, необходимо закрыть <xref:System.Data.Odbc.OdbcDataReader> перед выполнением новой или предыдущей команды.  
  
 Если выполнение этой команды вызывает возникло неустранимое исключение <xref:System.Data.Odbc.OdbcException> например SQL Server уровень серьезности 20 или более в <xref:System.Data.Odbc.OdbcConnection> может закрыться. Тем не менее, пользователь может опять открыть подключение и продолжить работу.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Data.Odbc.OdbcCommand.ExecuteNonQuery%2A>.  
  
 [!code-csharp[Classic WebData OdbcCommand#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData OdbcCommand/CS/source.cs#1)]
 [!code-vb[Classic WebData OdbcCommand#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData OdbcCommand/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Data.Odbc.OdbcDataAdapter" />
    <altmember cref="T:System.Data.Odbc.OdbcConnection" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Odbc.OdbcCommand" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OdbcCommand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OdbcCommand();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Odbc.OdbcCommand" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый конструктор инициализирует все поля значениями по умолчанию. Следующей таблице представлены исходные значения свойств для экземпляра класса <xref:System.Data.Odbc.OdbcCommand>.  
  
|Свойства|Начальное значение|  
|----------------|-------------------|  
|<xref:System.Data.Odbc.OdbcCommand.CommandText%2A>|Пустая строка (»»)|  
|<xref:System.Data.Odbc.OdbcCommand.CommandTimeout%2A>|30|  
|<xref:System.Data.Odbc.OdbcCommand.CommandType%2A>|`Text`|  
|<xref:System.Data.Odbc.OdbcCommand.Connection%2A>|null|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.Odbc.OdbcDataAdapter" />
        <altmember cref="T:System.Data.Odbc.OdbcConnection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OdbcCommand (string cmdText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string cmdText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (cmdText As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OdbcCommand(System::String ^ cmdText);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cmdText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cmdText">Текст запроса.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Odbc.OdbcCommand" /> текстом запроса.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OdbcCommand (string cmdText, System.Data.Odbc.OdbcConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string cmdText, class System.Data.Odbc.OdbcConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.#ctor(System.String,System.Data.Odbc.OdbcConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (cmdText As String, connection As OdbcConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OdbcCommand(System::String ^ cmdText, System::Data::Odbc::OdbcConnection ^ connection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cmdText" Type="System.String" />
        <Parameter Name="connection" Type="System.Data.Odbc.OdbcConnection" />
      </Parameters>
      <Docs>
        <param name="cmdText">Текст запроса.</param>
        <param name="connection">Объект <see cref="T:System.Data.Odbc.OdbcConnection" />, представляющий подключение к источнику данных.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Odbc.OdbcCommand" /> с текстом запроса и объектом <see cref="T:System.Data.Odbc.OdbcConnection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OdbcCommand (string cmdText, System.Data.Odbc.OdbcConnection connection, System.Data.Odbc.OdbcTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string cmdText, class System.Data.Odbc.OdbcConnection connection, class System.Data.Odbc.OdbcTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.#ctor(System.String,System.Data.Odbc.OdbcConnection,System.Data.Odbc.OdbcTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (cmdText As String, connection As OdbcConnection, transaction As OdbcTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OdbcCommand(System::String ^ cmdText, System::Data::Odbc::OdbcConnection ^ connection, System::Data::Odbc::OdbcTransaction ^ transaction);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cmdText" Type="System.String" />
        <Parameter Name="connection" Type="System.Data.Odbc.OdbcConnection" />
        <Parameter Name="transaction" Type="System.Data.Odbc.OdbcTransaction" />
      </Parameters>
      <Docs>
        <param name="cmdText">Текст запроса.</param>
        <param name="connection">Объект <see cref="T:System.Data.Odbc.OdbcConnection" />, представляющий подключение к источнику данных.</param>
        <param name="transaction">Транзакция, в которой выполняется <see cref="T:System.Data.Odbc.OdbcCommand" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.Odbc.OdbcCommand" /> с текстом запроса, объектом <see cref="T:System.Data.Odbc.OdbcConnection" /> и транзакцией <see cref="P:System.Data.Odbc.OdbcCommand.Transaction" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показаны исходные значения свойств для экземпляра этой реализации <xref:System.Data.Odbc.OdbcCommand>.  
  
|Свойства|Начальное значение|  
|----------------|-------------------|  
|<xref:System.Data.Odbc.OdbcCommand.CommandText%2A>|`cmdText`|  
|<xref:System.Data.Odbc.OdbcCommand.CommandTimeout%2A>|30|  
|<xref:System.Data.Odbc.OdbcCommand.CommandType%2A>|`Text`|  
|<xref:System.Data.Odbc.OdbcCommand.Connection%2A>|Новый <xref:System.Data.Odbc.OdbcConnection> , представляющий значение `connection` параметра.|  
  
 Значение любого из этих параметров можно изменить, задав соответствующее свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public override void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Cancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Cancel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается отменить выполнение <see cref="T:System.Data.Odbc.OdbcCommand" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если команда, выполнение которой нужно отменить, отсутствует, ничего не происходит. Если команда выполняется, и попытка отменить завершается с ошибкой, исключение не формируется.  
  
 Отмена запроса в одном потоке <xref:System.Data.Odbc.OdbcCommand.Cancel%2A> должна вызываться из другого потока. Поскольку невозможно выполнить команды асинхронно с <xref:System.Data.Odbc.OdbcCommand>, для отмены команды из другого потока один поток должен выполняться синхронно. Это означает, что <xref:System.Data.Odbc.OdbcCommand> объект должен быть доступен с обоих потоков.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandText">
      <MemberSignature Language="C#" Value="public override string CommandText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CommandText" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.CommandText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property CommandText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CommandText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Odbc.Design.OdbcCommandTextEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает инструкцию или хранимую процедуру SQL, выполняемую с источником данных.</summary>
        <value>Инструкция или хранимая процедура SQL, подлежащая выполнению. Значением по умолчанию является пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Data.IDbCommand.CommandType%2A> свойству `StoredProcedure`, <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойство должно быть установлено с помощью escape-последовательности Стандартная ODBC хранимой процедуры. Параметр <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> имя хранимой процедуры не работает в отличие от других поставщиков данных .NET Framework.  
  
 Многие возможности языка, такие как внешние соединения и вызовы скалярных функций, обычно реализуются источниками данных. Даже синтаксис для этих возможностей обычно используется источника данных. Таким образом ODBC определяет управляющие последовательности, которые содержат стандартный синтаксис для следующих возможностей языка:  
  
-   Интервал литералы даты, времени, отметки времени и даты и времени  
  
-   Скалярные функции, такие как числовые, строку и функции преобразования типов данных  
  
-   Управляющий символ предиката LIKE  
  
-   Внешние соединения  
  
-   Вызовы процедур  
  
 Escape-последовательность, в ODBC выглядит следующим образом:  
  
```  
{extension}  
```  
  
 Escape-последовательность опознается и анализируется драйверами ODBC. Они затем замените все escape-последовательности грамматики конкретного источника данных.  
  
 Процедура является исполняемым объектом, хранящимся в источнике данных. Обычно это один или несколько предварительно скомпилированных инструкций SQL. Escape-последовательность для вызова процедуры  
  
```  
{[?=]call procedure-name[([parameter][,[parameter]]...)]}  
```  
  
 где `procedure-name` указывает имя процедуры и `parameter` указывает параметр процедуры.  
  
 Команда выполняет эту хранимую процедуру при вызове одного из методов Execute (например, <xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A> или <xref:System.Data.Odbc.OdbcCommand.ExecuteNonQuery%2A>).  
  
 Не удается задать <xref:System.Data.Odbc.OdbcCommand.Connection%2A>, <xref:System.Data.Odbc.OdbcCommand.CommandType%2A> и <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойства, если текущее подключение выполняет операцию выполнения или получения.  
  
 ODBC.NET поставщик не поддерживает именованные параметры для передачи параметров в инструкции SQL или хранимую процедуру, вызываемую <xref:System.Data.Odbc.OdbcCommand> при <xref:System.Data.Odbc.OdbcCommand.CommandType%2A> равно `Text`. В этом случае необходимо использовать местозаполнитель вопросительный знак (?). Пример:  
  
```  
SELECT * FROM Customers WHERE CustomerID = ?  
```  
  
 Таким образом, порядок, в котором <xref:System.Data.Odbc.OdbcParameter> объекты добавляются в <xref:System.Data.Odbc.OdbcParameterCollection> должен строго соответствовать позиции местозаполнитель для параметра.  
  
 Если параметр содержит значение null, поставщик данных .NET Framework для ODBC по-прежнему связывает этот параметр, но использует параметр по умолчанию, если таковая определена с помощью SQL_DEFAULT_PARAM, а не значение null. Например <xref:System.Data.Odbc.OdbcParameterCollection>:  
  
```  
{1, null, 2}  
```  
  
 переданные в <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойство:  
  
```  
{call sp(?, ?, ?)}  
```  
  
 вызывает поставщик данных .NET Framework для ODBC связывает первый параметр со значением 1, третий параметр со значением 2 и для второго параметра SQL_DEFAULT_PARAM. Однако это поведение зависит от драйвера. Если драйвер не поддерживает эту функцию, просто не передавайте значение параметра. Например, использовать <xref:System.Data.Odbc.OdbcParameterCollection>:  
  
```  
{1, 2}  
```  
  
 и задайте <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> следующее:  
  
```  
{call sp(?, null, ?)}  
```  
  
> [!NOTE]
>  Если параметр опущен, должна присутствовать запятая, отделяющая его от других параметров. Если входной или входной выходной параметр задан, процедура будет использовать значение по умолчанию параметра. Другой способ указать значение по умолчанию параметра ввода или ввода вывода является установка значение буфера длины и индикатора, привязанное к параметру процедуры SQL_DEFAULT_PARAM.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.Odbc.OdbcCommand.Connection" />
        <altmember cref="P:System.Data.Odbc.OdbcCommand.CommandTimeout" />
        <altmember cref="P:System.Data.Odbc.OdbcCommand.CommandType" />
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public override int CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property CommandTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CommandTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает время ожидания перед прекращением попытки выполнить команду и выводом ошибки.</summary>
        <value>Время в секундах, в течение которого должно происходить ожидание выполнения команды. По умолчанию используется значение 30 секунд.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение ноль (0) указывает на отсутствие ограничения времени ожидания, время ожидания и его следует избегать.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandType">
      <MemberSignature Language="C#" Value="public override System.Data.CommandType CommandType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.CommandType CommandType" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.CommandType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property CommandType As CommandType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::CommandType CommandType { System::Data::CommandType get(); void set(System::Data::CommandType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.CommandType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, как интерпретируется свойство <see cref="P:System.Data.Odbc.OdbcCommand.CommandText" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Data.CommandType" />. Значение по умолчанию: <see langword="Text" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Data.Odbc.OdbcCommand.CommandType%2A> свойству `StoredProcedure`, следует задать <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойства полный синтаксис запроса ODBC. Затем команда выполняет эту хранимую процедуру при вызове одного из методов Execute (например, <xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A> или <xref:System.Data.Odbc.OdbcCommand.ExecuteNonQuery%2A>).  
  
 <xref:System.Data.Odbc.OdbcCommand.Connection%2A>, <xref:System.Data.Odbc.OdbcCommand.CommandType%2A> И <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> не удается задать свойства, если текущее подключение выполняет операцию выполнения или получения.  
  
 Поставщик данных .NET Framework для ODBC не поддерживает передачу именованных параметров в инструкции SQL или хранимую процедуру, вызываемую <xref:System.Data.Odbc.OdbcCommand>. В любом из этих случаев используйте прототип вопросительного знака (?). Пример:  
  
```  
SELECT * FROM Customers WHERE CustomerID = ?  
```  
  
 Порядок, в котором <xref:System.Data.Odbc.OdbcParameter> объекты добавляются в <xref:System.Data.Odbc.OdbcParameterCollection> должен строго соответствовать позиции местозаполнитель для параметра.  
  
> [!NOTE]
>  Поставщик данных .NET Framework для ODBC не поддерживает <xref:System.Data.CommandType> параметра `TableDirect`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение не является допустимым объектом <see cref="T:System.Data.CommandType" />.</exception>
        <altmember cref="P:System.Data.Odbc.OdbcCommand.CommandText" />
        <altmember cref="P:System.Data.Odbc.OdbcCommand.UpdatedRowSource" />
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Odbc.OdbcConnection Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Odbc.OdbcConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As OdbcConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Odbc::OdbcConnection ^ Connection { System::Data::Odbc::OdbcConnection ^ get(); void set(System::Data::Odbc::OdbcConnection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DbConnectionEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Odbc.OdbcConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Data.Odbc.OdbcConnection" />, используемый этим экземпляром класса <see cref="T:System.Data.Odbc.OdbcCommand" />.</summary>
        <value>Подключение к источнику данных. Значение по умолчанию null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не удается задать <xref:System.Data.Odbc.OdbcCommand.Connection%2A>, <xref:System.Data.Odbc.OdbcCommand.CommandType%2A>, и <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойства, если текущее подключение выполняет операцию выполнения или получения.  
  
 Если значение <xref:System.Data.Odbc.OdbcCommand.Connection%2A> присваивается во время выполнения транзакции и свойство <xref:System.Data.Odbc.OdbcCommand.Transaction%2A> не равно NULL, то возникает исключение <xref:System.InvalidOperationException>. Если задать <xref:System.Data.Odbc.OdbcCommand.Connection%2A> после фиксации или отката транзакции и <xref:System.Data.Odbc.OdbcCommand.Transaction%2A> свойства не равно null, <xref:System.Data.Odbc.OdbcCommand.Transaction%2A> свойство устанавливается в значение null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Data.Odbc.OdbcCommand.Connection" /> изменилось в течение транзакции.</exception>
        <altmember cref="P:System.Data.Odbc.OdbcCommand.CommandText" />
        <altmember cref="P:System.Data.Odbc.OdbcCommand.CommandTimeout" />
        <altmember cref="P:System.Data.Odbc.OdbcCommand.CommandType" />
      </Docs>
    </Member>
    <Member MemberName="CreateDbParameter">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbParameter CreateDbParameter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbParameter CreateDbParameter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.CreateDbParameter" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateDbParameter () As DbParameter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbParameter ^ CreateDbParameter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbParameter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParameter">
      <MemberSignature Language="C#" Value="public System.Data.Odbc.OdbcParameter CreateParameter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Odbc.OdbcParameter CreateParameter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.CreateParameter" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateParameter () As OdbcParameter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Odbc::OdbcParameter ^ CreateParameter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Odbc.OdbcParameter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр объекта <see cref="T:System.Data.Odbc.OdbcParameter" />.</summary>
        <returns>Объект <see cref="T:System.Data.Odbc.OdbcParameter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Odbc.OdbcCommand.CreateParameter%2A> Метод является строго типизированной версией <xref:System.Data.IDbCommand.CreateParameter%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DbConnection">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbConnection DbConnection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection DbConnection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.DbConnection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property DbConnection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Data::Common::DbConnection ^ DbConnection { System::Data::Common::DbConnection ^ get(); void set(System::Data::Common::DbConnection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DbParameterCollection">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbParameterCollection DbParameterCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbParameterCollection DbParameterCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.DbParameterCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DbParameterCollection As DbParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Data::Common::DbParameterCollection ^ DbParameterCollection { System::Data::Common::DbParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DbTransaction">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbTransaction DbTransaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbTransaction DbTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.DbTransaction" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Property DbTransaction As DbTransaction" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Data::Common::DbTransaction ^ DbTransaction { System::Data::Common::DbTransaction ^ get(); void set(System::Data::Common::DbTransaction ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignTimeVisible">
      <MemberSignature Language="C#" Value="public override bool DesignTimeVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignTimeVisible" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.DesignTimeVisible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property DesignTimeVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DesignTimeVisible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должен ли объект команды быть видимым в настраиваемом элементе управления интерфейса.</summary>
        <value>**значение true,**, если объект команды должен быть видимым в элементе управления; в противном случае **false**. Значение по умолчанию — **true**.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteDbDataReader">
      <MemberSignature Language="C#" Value="protected override System.Data.Common.DbDataReader ExecuteDbDataReader (System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Data.Common.DbDataReader ExecuteDbDataReader(valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.ExecuteDbDataReader(System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ExecuteDbDataReader (behavior As CommandBehavior) As DbDataReader" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Data::Common::DbDataReader ^ ExecuteDbDataReader(System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbDataReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="behavior">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteNonQuery">
      <MemberSignature Language="C#" Value="public override int ExecuteNonQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ExecuteNonQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.ExecuteNonQuery" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExecuteNonQuery () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ExecuteNonQuery();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет оператор SQL применительно к свойству <see cref="P:System.Data.Odbc.OdbcCommand.Connection" /> и возвращает количество измененных командой строк.</summary>
        <returns>Операторы UPDATE, INSERT и DELETE возвращают количество строк, которые были обработаны с их помощью. Для всех прочих типов операторов возвращаемым значением является -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Data.Odbc.OdbcCommand.ExecuteNonQuery%2A> для выполнения операций с каталогом (например, запрос структуры базы данных или создание объектов базы данных, таких как таблицы); или для изменения данных в базе данных без использования <xref:System.Data.DataSet>, путем выполнения UPDATE, INSERT или удаления инструкции.  
  
 Можно также использовать <xref:System.Data.Odbc.OdbcCommand.ExecuteNonQuery%2A> для выполнения нескольких инструкций SQL, если основной драйвер ODBC поддерживает данную функцию. В этом случае возвращаемое значение — количество строк, затронутых всеми операторами в команде.  
  
 Несмотря на то что <xref:System.Data.Odbc.OdbcCommand.ExecuteNonQuery%2A> возвращает ни одной строки, любые выходные параметры или возвращаемые значения, которые сопоставлены с параметрами, заполняются данными.  
  
 Операторы UPDATE, INSERT и DELETE возвращают количество строк, которые были обработаны с их помощью. Для всех прочих типов операторов возвращаемым значением является -1. В случае отката возвращаемое значение также равно -1.  
  
 Если существует триггер для таблицы и данных добавленных или измененных в таблице, возвращаемое значение включает количество строк, затронутых при операции вставки или обновления и количество строк, затронутых триггерами.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Подключение не существует.  
  
 - или -  
  
 Соединение не открыто.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Отправляет свойство <see cref="P:System.Data.Odbc.OdbcCommand.CommandText" /> свойству <see cref="P:System.Data.Odbc.OdbcCommand.Connection" /> и создает объект <see cref="T:System.Data.Odbc.OdbcDataReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteReader">
      <MemberSignature Language="C#" Value="public System.Data.Odbc.OdbcDataReader ExecuteReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Odbc.OdbcDataReader ExecuteReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.ExecuteReader" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteReader () As OdbcDataReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Odbc::OdbcDataReader ^ ExecuteReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Odbc.OdbcDataReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отправляет свойство <see cref="P:System.Data.Odbc.OdbcCommand.CommandText" /> свойству <see cref="P:System.Data.Odbc.OdbcCommand.Connection" /> и создает объект <see cref="T:System.Data.Odbc.OdbcDataReader" />.</summary>
        <returns>Объект <see cref="T:System.Data.Odbc.OdbcDataReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо задать <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойства полный синтаксис запроса ODBC для хранимых процедур. Команда выполняет эту хранимую процедуру при вызове <xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A>.  
  
 Хотя <xref:System.Data.Odbc.OdbcDataReader> используется, связанный с ним <xref:System.Data.Odbc.OdbcConnection> обслуживает <xref:System.Data.Odbc.OdbcDataReader>. В этом состоянии могут выполняться никакие другие операции на <xref:System.Data.Odbc.OdbcConnection> кроме закрытия. Это состояние сохраняется до <xref:System.Data.Odbc.OdbcDataReader.Close%2A> метод <xref:System.Data.Odbc.OdbcDataReader> вызывается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteReader">
      <MemberSignature Language="C#" Value="public System.Data.Odbc.OdbcDataReader ExecuteReader (System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Odbc.OdbcDataReader ExecuteReader(valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.ExecuteReader(System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteReader (behavior As CommandBehavior) As OdbcDataReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Odbc::OdbcDataReader ^ ExecuteReader(System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Odbc.OdbcDataReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="behavior">Одно из значений перечисления <see langword="System.Data.CommandBehavior" />.</param>
        <summary>Отправляет <see cref="P:System.Data.Odbc.OdbcCommand.CommandText" /> в <see cref="P:System.Data.Odbc.OdbcCommand.Connection" /> и создает <see cref="T:System.Data.Odbc.OdbcDataReader" />, используя одно из значений <see langword="CommandBehavior" />.</summary>
        <returns>Объект <see cref="T:System.Data.Odbc.OdbcDataReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ожидается, что инструкция SQL вернет только одну строку, указав `SingleRow` как <xref:System.Data.CommandBehavior> значение может улучшить производительность приложения.  
  
 Необходимо задать <xref:System.Data.Odbc.OdbcCommand.CommandText%2A> свойства полный синтаксис запроса ODBC для хранимых процедур. Команда выполняет эту хранимую процедуру при вызове <xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A>.  
  
 <xref:System.Data.Odbc.OdbcDataReader> Поддерживает специальный режим, позволяющий эффективного чтения больших двоичных параметров. Дополнительные сведения см. в разделе `SequentialAccess` для <xref:System.Data.CommandBehavior>.  
  
> [!NOTE]
>  `SequentialAccess` Значение <xref:System.Data.CommandBehavior> не является ограничивающим задание; он просто означает, что будет иметь по крайней мере последовательного доступа к <xref:System.Data.Odbc.OdbcDataReader>. Например, при использовании драйвер ODBC для SQL Server в `SequentialAccess` режиме, можно по-прежнему переместить первый столбец <xref:System.Data.Odbc.OdbcDataReader> строки после прочитав последовательно все остальные столбцы.  
  
 Хотя <xref:System.Data.Odbc.OdbcDataReader> используется, связанный с ним <xref:System.Data.Odbc.OdbcConnection> обслуживает <xref:System.Data.Odbc.OdbcDataReader>. В этом состоянии могут выполняться никакие другие операции на <xref:System.Data.Odbc.OdbcConnection> кроме закрытия. Это условие выполняется, пока не будет вызван <xref:System.Data.Odbc.OdbcDataReader.Close%2A?displayProperty=nameWithType> метод. Если <xref:System.Data.Odbc.OdbcDataReader> создается с <xref:System.Data.CommandBehavior> значение `CloseConnection`, закрытие <xref:System.Data.Odbc.OdbcDataReader> подключение будет закрыто автоматически.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteScalar">
      <MemberSignature Language="C#" Value="public override object ExecuteScalar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ExecuteScalar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.ExecuteScalar" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExecuteScalar () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ExecuteScalar();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет запрос и возвращает первый столбец первой строки результирующего набора, возвращаемого запросом. Дополнительные столбцы или строки не обрабатываются.</summary>
        <returns>Первый столбец первой строки набора результатов или пустая ссылка, если набор результатов пуст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.Odbc.OdbcCommand.ExecuteScalar%2A> метод, чтобы извлечь одно значение (например, статистическое значение) из источника данных. Это требует меньшего объема кода, чем при использовании <xref:System.Data.Odbc.OdbcCommand.ExecuteReader%2A> метод и затем выполняет операции, необходимые для создания одного значения из данных, возвращаемых функцией <xref:System.Data.Odbc.OdbcDataReader>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameters">
      <MemberSignature Language="C#" Value="public System.Data.Odbc.OdbcParameterCollection Parameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Odbc.OdbcParameterCollection Parameters" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.Parameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parameters As OdbcParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Odbc::OdbcParameterCollection ^ Parameters { System::Data::Odbc::OdbcParameterCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Odbc.OdbcParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает набор <see cref="T:System.Data.Odbc.OdbcParameterCollection" />.</summary>
        <value>Параметры инструкции SQL или хранимой процедуры. По умолчанию является пустой коллекцией.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Data.Odbc.OdbcCommand.CommandType%2A> равно `Text`, поставщик данных .NET Framework для ODBC не поддерживает передачу именованных параметров в инструкции SQL или хранимую процедуру, вызываемую <xref:System.Data.Odbc.OdbcCommand>. В любом из этих случаев используйте прототип вопросительного знака (?). Пример:  
  
```  
SELECT * FROM Customers WHERE CustomerID = ?  
```  
  
 Порядок, в котором <xref:System.Data.Odbc.OdbcParameter> объекты добавляются в <xref:System.Data.Odbc.OdbcParameterCollection> должен строго соответствовать позиции местозаполнитель для параметра в тексте команды.  
  
> [!NOTE]
>  Если параметры в коллекции не соответствуют требованиям для выполнения запроса, то может возникнуть ошибка.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.Odbc.OdbcParameter" />
      </Docs>
    </Member>
    <Member MemberName="Prepare">
      <MemberSignature Language="C#" Value="public override void Prepare ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Prepare() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.Prepare" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Prepare ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Prepare();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает подготовленную (или скомпилированную) версию команды в источнике данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Odbc.OdbcCommand.Prepare%2A> ODBC вызывает метод `SQLPrepare` функции. В зависимости от возможностей основного драйвера ODBC и источника данных сведения о параметрах, таких как типы данных могут проверяться при подготовке инструкции, если все параметры были привязаны или если он выполняется, если не все параметры были привязаны. Для максимальной совместимости приложение должно разорвать связи всех параметров, которые применялись для предыдущей инструкции SQL до подготовки новой инструкции SQL на том же <xref:System.Data.Odbc.OdbcCommand>. Это позволяет избежать ошибок, вызванных сведений о предыдущих параметрах при новой инструкции SQL.  
  
 Если метод Execute вызывается после вызова метода <xref:System.Data.Odbc.OdbcCommand.Prepare%2A>, все значения параметров, больше, чем значение, указанное в <xref:System.Data.Odbc.OdbcParameter.Size%2A> свойство автоматически усекается до исходного размера указанного параметра, и ошибки усечения не возвращаются. .  
  
 Выходные параметры (как подготовленные или нет) должен иметь тип данных, определяемый пользователем. Если указать тип данных переменной длины, необходимо также указать максимальное <xref:System.Data.Odbc.OdbcParameter.Size%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Data.Odbc.OdbcCommand.Connection" /> не указывается.  
  
 - или -  
  
 Свойство <see cref="P:System.Data.Odbc.OdbcCommand.Connection" /> не является методом <see cref="M:System.Data.Odbc.OdbcConnection.Open" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetCommandTimeout">
      <MemberSignature Language="C#" Value="public void ResetCommandTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetCommandTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.ResetCommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetCommandTimeout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetCommandTimeout();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сбрасывает значение свойства <see cref="P:System.Data.Odbc.OdbcCommand.CommandTimeout" /> и задает ему значение по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение по умолчанию <xref:System.Data.Odbc.OdbcCommand.CommandTimeout%2A> составляет 30 секунд.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Odbc.OdbcCommand.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.ICloneable.Clone" />.</summary>
        <returns>Новый экземпляр <see cref="T:System.Object" />, являющийся копией данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.Odbc.OdbcCommand> приведен к типу интерфейса <xref:System.ICloneable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transaction">
      <MemberSignature Language="C#" Value="public System.Data.Odbc.OdbcTransaction Transaction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Odbc.OdbcTransaction Transaction" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.Transaction" />
      <MemberSignature Language="VB.NET" Value="Public Property Transaction As OdbcTransaction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Odbc::OdbcTransaction ^ Transaction { System::Data::Odbc::OdbcTransaction ^ get(); void set(System::Data::Odbc::OdbcTransaction ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Odbc.OdbcTransaction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает транзакцию <see cref="T:System.Data.Odbc.OdbcTransaction" />, в которой выполняется команда <see cref="T:System.Data.Odbc.OdbcCommand" />.</summary>
        <value>Объект <see cref="T:System.Data.Odbc.OdbcTransaction" />. Значение по умолчанию null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не удается задать <xref:System.Data.Odbc.OdbcCommand.Transaction%2A> свойства, если оно уже задано конкретное значение и команда находится в процессе выполнения. Если значение свойства transaction <xref:System.Data.Odbc.OdbcTransaction> объект, который не подключен к тому же <xref:System.Data.Odbc.OdbcConnection> как <xref:System.Data.Odbc.OdbcCommand> объекта, при попытке выполнить инструкцию в следующий раз будет создано исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedRowSource">
      <MemberSignature Language="C#" Value="public override System.Data.UpdateRowSource UpdatedRowSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.UpdateRowSource UpdatedRowSource" />
      <MemberSignature Language="DocId" Value="P:System.Data.Odbc.OdbcCommand.UpdatedRowSource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UpdatedRowSource As UpdateRowSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::UpdateRowSource UpdatedRowSource { System::Data::UpdateRowSource get(); void set(System::Data::UpdateRowSource value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Odbc</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.UpdateRowSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, каким образом метод **Update** должен применять результаты выполнения команды к **DataRow**.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Data.UpdateRowSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение по умолчанию <xref:System.Data.UpdateRowSource> значение **оба** Если команда не создается автоматически, как в случае с <xref:System.Data.Odbc.OdbcCommandBuilder>, в этом случае значение по умолчанию — **нет**.  
  
 Дополнительные сведения об использовании <xref:System.Data.Odbc.OdbcCommand.UpdatedRowSource%2A> свойство, в разделе [параметры DataAdapter](~/docs/framework/data/adonet/dataadapter-parameters.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>