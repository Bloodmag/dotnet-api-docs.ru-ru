<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="69379b993f96f3e6579fc6f1fe9d4d03c40dd835" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36684342" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a large object binary (<see langword="LOB" />) data type stored on an Oracle server. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob> Отличается от <xref:System.Data.OracleClient.OracleBFile> в том, что данные хранятся на сервере, а не в физическом файле в операционной системе. Это также может быть объект чтения и записи, в отличие от <xref:System.Data.OracleClient.OracleBFile>, который всегда доступен только для чтения.  
  
 <xref:System.Data.OracleClient.OracleLob> Может принимать одно из следующих <xref:System.Data.OracleClient.OracleType> типов данных.  
  
|Тип данных OracleType|Описание:|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` тип данных, который содержит двоичные данные с максимальным размером 4 гигабайта (ГБ). Он сопоставляется с <xref:System.Array> типа <xref:System.Byte>.|  
|`Clob`|Oracle `CLOB` тип данных, содержащий символьные данные, в зависимости от символа по умолчанию, установленной на сервере, размером до 4 ГБ. Он сопоставляется с <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` тип данных, содержащий символьные данные на основании национальной кодировки сервера размером до 4 ГБ. Он сопоставляется с <xref:System.String>.|  
  
 Разработчик приложения .NET могут получать Oracle `LOB` значения в базовые типы данных .NET, такие как <xref:System.Array> типа <xref:System.Byte> и <xref:System.String>, или специализированную <xref:System.Data.OracleClient.OracleLob> тип данных. <xref:System.Data.OracleClient.OracleLob> Поддерживает чтение данных и запись в Oracle класс `LOB` в базе данных Oracle.  
  
 Ниже перечислены основные характеристики <xref:System.Data.OracleClient.OracleLob> тип данных, который отличается от базовых типов данных .NET:  
  
-   После получения Oracle `LOB` значение из базы данных Oracle в <xref:System.Data.OracleClient.OracleLob> , можно изменить `LOB` данные в открытой транзакции и изменения отражаются непосредственно в базу данных. При извлечении Oracle `LOB` значение в <xref:System.Array> типа <xref:System.Byte> или <xref:System.String> и обновить эти массивы, изменения не отражаются в базу данных.  
  
-   При использовании <xref:System.Data.OracleClient.OracleLob> класса для доступа к фрагмент `LOB` значение, только этот фрагмент передается из базы данных Oracle для клиента. При использовании <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> метод для доступа к фрагмент `LOB` значение, все содержимое значения передаются из базы данных Oracle для клиента.  
  
 Для получения <xref:System.Data.OracleClient.OracleLob> , вызовите <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> метод.  
  
 Можно создать <xref:System.Data.OracleClient.OracleLob> , имеет значение NULL, используя следующий формат:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Этот метод используется главным образом для проверки ли `LOB` имеет значение NULL, возвращаемые с сервера, как показано в этом примере:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Значение NULL `LOB` ведет себя аналогично пустой `LOB` в том, что <xref:System.Data.OracleClient.OracleLob.Read%2A> завершается успешно и всегда возвращает 0 байт.  
  
 При выборе `LOB` столбец, содержащий значение null возвращает <xref:System.Data.OracleClient.OracleLob.Null>.  
  
 Необходимо начать транзакцию до получения временного `LOB`. В противном случае <xref:System.Data.OracleClient.OracleDataReader> может не получить данных более поздней версии.  
  
 Можно также открыть временный `LOB` в Oracle путем вызова DBMS_LOB. CREATETEMPORARY системные хранимые процедуры и привязки `LOB` выходной параметр. На стороне клиента временный `LOB` ведет себя как табличный `LOB`. Например, чтобы обновить временный `LOB`, он должен быть заключен в транзакции.  
  
 В следующем примере C# показано, как открыть временный `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  Наследуемый <xref:System.IO.Stream.WriteByte%2A> метод завершается ошибкой, если используются с символьными данными и <xref:System.InvalidOperationException> возникает исключение. Вместо этого рекомендуется использовать метод <xref:System.Data.OracleClient.OracleLob.Write%2A>.  
>   
>  Временные `LOB`только закрываются, если подключение закрывается, но на пул и при наличии нагрузки временные `LOB`не закрывайте s. Эту ситуацию можно разрешить, удалив временные `LOB`, путем вызова `tempLob.Dispose()`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source">The <see langword="LOB" /> from which to append data.</param>
        <summary>Appends data from the specified <see langword="LOB" /> to the current <see langword="LOB" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
 Все данные из источника `LOB` добавляется в конец текущего `LOB`. Позиция `LOB` будет вычислена или изменена во время этого процесса.  
  
 Базовые типы данных необходимо всегда совпадать. Например, при добавлении из <xref:System.Data.OracleClient.OracleType.NClob>, назначения <xref:System.Data.OracleClient.OracleLob> также должен быть <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  В этом выпуске операции записи только для чтения `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null.</exception>
        <exception cref="T:System.InvalidOperationException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The source <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple write operations.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prevents server-side triggers from firing while performing multiple read operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Открывает `LOB` в <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> режиме, поэтому `LOB` можно только считывать данные, не записано, до соответствующего вызова <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. Для выполнения операции пакетной записи `LOB`, вызовите <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> с <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>.  
  
 Вызов <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> более чем один раз в одной транзакции в настоящее время создает исключение Oracle «ORA-22293: LOB уже открыт в той же транзакции» ошибка. Кроме того, если получен `LOB` с помощью другой <xref:System.Data.OracleClient.OracleDataReader>, и данные первоначального вызывающего объекта не вызван <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> создается метод, та же ошибка. Поэтому необходимо вызвать метод <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> метод при завершении с помощью <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Mode (one of the <see cref="T:System.Data.OracleClient.OracleLobOpenMode" /> values) in which the <see langword="LOB" /> can be accessed between this <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> call and the corresponding <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" /> call.</param>
        <summary>Prevents server-side triggers from firing while performing multiple read and write operations in the specified access mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
 Вызов <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> более чем один раз в одной транзакции в настоящее время создает исключение Oracle «ORA-22293: LOB уже открыт в той же транзакции» ошибка. Кроме того, если получен `LOB` с помощью другой <xref:System.Data.OracleClient.OracleDataReader>, и данные первоначального вызывающего объекта не вызван <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> создается метод, та же ошибка. Поэтому необходимо вызвать метод <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> метод при завершении с помощью <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see langword="LOB" /> stream can be read.</summary>
        <value>
          <see langword="true" /> Если <see langword="LOB" /> потоке поддерживаются операции чтения, в противном случае <see langword="false" /> Если <see langword="LOB" /> закрыт или удален.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether forward and backward seek operations can be performed.</summary>
        <value>
          <see langword="false" /> Если <see langword="LOB" /> закрыт или удален, в противном случае <see langword="true" />. Всегда <see langword="true" /> для <see cref="F:System.Data.OracleClient.OracleLob.Null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Always returns true, regardless of whether the <see langword="LOB" /> supports writing or not.</summary>
        <value>Всегда возвращает <see langword="true" />независимо от того, следует ли запись открытый или неудаленный <see langword="LOB" /> поддерживает запись или нет, <see langword="false" /> Если <see langword="LOB" /> закрыт или удален.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT и начать локальную транзакцию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating the minimum number of bytes to retrieve from or send to the server during a read/write operation.</summary>
        <value>Минимальное число байтов для получения или отправки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> свойство не является параметром поставщика данных .NET Framework для Oracle. Вместо этого это значение, которое использует интерфейс вызова Oracle (OCI), при взаимодействии с сервером. Используйте <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> для убедитесь, что клиентские блоки одинакового размера. Чтения или записи в небольшие блоки не кэширует данные и вызывает менее оптимизированный цикл обработки на сервере, так как не получено или не отправлен полный пакет.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <returns>A new <see cref="T:System.Data.OracleClient.OracleLob" /> object that references the same Oracle <see langword="LOB" /> as the original <see cref="T:System.Data.OracleClient.OracleLob" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства нового <xref:System.Data.OracleClient.OracleLob> объекта изначально имеют те же значения, что и исходный объект. Однако после <xref:System.Data.OracleClient.OracleLob.Clone%2A> завершена, каждый <xref:System.Data.OracleClient.OracleLob> объекта не зависит от другого. Например, изменение значения <xref:System.Data.OracleClient.OracleLob.Position%2A> свойство на исходном <xref:System.Data.OracleClient.OracleLob> не изменяет значение <xref:System.Data.OracleClient.OracleLob.Position%2A> копии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.OracleClient.OracleConnection" /> used by this instance of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Подключение к источнику данных.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" />.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовые типы данных необходимо всегда совпадать. Например, при копировании из <xref:System.Data.OracleClient.OracleType.NClob>, назначения <xref:System.Data.OracleClient.OracleLob> также должен быть <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Если конечное смещение выходит за пределы назначения `LOB`, `LOB` расширена, в которую копируются данные. Пространство между окончанием `LOB` и конечное смещение выходит за пределы дополняется нулями для `BLOB` типов данных и пробелы для `CLOB` и `NCLOB` типов данных.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
> [!NOTE]
>  В этом выпуске операции записи только для чтения `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` будут обновлены. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
>   
>  `CopyTo` Метод очищает содержимое назначения `OracleLob` перед выполнением операции копирования.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is null.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination">The destination <see cref="T:System.Data.OracleClient.OracleLob" /></param>
        <param name="destinationOffset">The offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number of bytes.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовые типы данных необходимо всегда совпадать. Например, при копировании из <xref:System.Data.OracleClient.OracleType.NClob>, назначения <xref:System.Data.OracleClient.OracleLob> также должен быть <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Если конечное смещение выходит за пределы назначения `LOB`, `LOB` расширена, в которую копируются данные. Пространство между окончанием `LOB` и конечное смещение выходит за пределы дополняется нулями для `BLOB` типов данных и пробелы для `CLOB` и `NCLOB` типов данных.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
> [!NOTE]
>  В этом выпуске операции записи только для чтения `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
>   
>  `CopyTo` Метод очищает содержимое назначения `OracleLob` перед выполнением операции копирования.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">The offset from which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="destination">The destination <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">The destination offset to which to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to copy. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Copies from this <see cref="T:System.Data.OracleClient.OracleLob" /> to a destination <see cref="T:System.Data.OracleClient.OracleLob" /> with the specified amount of data, and the source offset.</summary>
        <returns>The number of bytes copied. This excludes any padded bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовые типы данных необходимо всегда совпадать. Например, при копировании из <xref:System.Data.OracleClient.OracleType.NClob>, назначения <xref:System.Data.OracleClient.OracleLob> также должен быть <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Если конечное смещение выходит за пределы назначения `LOB`, `LOB` расширена, в которую копируются данные. Пространство между окончанием `LOB` и конечное смещение выходит за пределы дополняется нулями для `BLOB` типов данных и пробелы для `CLOB` и `NCLOB` типов данных.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
> [!NOTE]
>  В этом выпуске операции записи только для чтения `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
>   
>  `CopyTo` Метод очищает содержимое назначения `OracleLob` перед выполнением операции копирования.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.OracleClient.OracleLob" /> specified in the <paramref name="destination" /> parameter is full.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  A value specified in the <paramref name="amount" />, <paramref name="sourceOffset" />, or <paramref name="destinationOffset" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Allows server-side triggers to resume firing after performing multiple write operations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> метод перед началом выполнения операций записи на <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erases data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erases all data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> не приводит к усечению данных. `LOB` Длина остается одинаковым для `BLOB` тип данных и стертые данные заменяются на 0x00. `CLOB` и `NCLOB` типов данных заменяются пробелами.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
> [!NOTE]
>  В этом выпуске операции записи только для чтения `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">The offset from which to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="amount">The quantity of data, in bytes, to erase. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Erases the specified amount of data from this <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>The number of bytes erased.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сумма значений в `offset` и `amount` параметры могут быть выше, чем размер <xref:System.Data.OracleClient.OracleLob>. Таким образом, указав значение больше, чем возвращенные функцией <xref:System.Data.OracleClient.OracleLob.Length%2A> свойство завершается успешно, однако <xref:System.Data.OracleClient.OracleLob.Erase%2A> удаляет только до конца <xref:System.Data.OracleClient.OracleLob>. (Аналогичным образом, в том случае, если передается отрицательное значение `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> выполнена успешно, но только стереть начиная с начала <xref:System.Data.OracleClient.OracleLob>.) Это поведение отличается от поведения <xref:System.Data.OracleClient.OracleLob.Read%2A> и <xref:System.Data.OracleClient.OracleLob.Write%2A> методы и предложения, преимуществом является возможность удаления всех данных из значения, заданные `offset` без внесения дополнительного обмена данными с сервером для проверки фактического размера.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> не приводит к усечению данных. `LOB` Длина остается одинаковым для `BLOB` тип данных и стертые данные заменяются на 0x00. `CLOB` и `NCLOB` типов данных заменяются пробелами.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
> [!NOTE]
>  В этом выпуске операции записи только для чтения `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Not currently supported.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этом выпуске этот метод не работает.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether an application called the <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> method.</summary>
        <value>
          <see langword="true" /> Если приложение вызвало <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" /> метода, в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании сервера Oracle 8.0.5 Oracle «ORA-00600: код внутренней ошибки» возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> stream.</summary>
        <value>
          <see langword="true" /> Если <see cref="T:System.Data.OracleClient.OracleLob" /> — <see cref="F:System.Data.OracleClient.OracleBFile.Null" /> поток, в противном случае <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Data.OracleClient.OracleLob" /> is a temporary <see langword="LOB" />.</summary>
        <value>
          <see langword="true" /> Если <see cref="T:System.Data.OracleClient.OracleLob" /> является временным <see langword="LOB" />, в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующий пример демонстрирует создание временной `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the size of the <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Размер <see cref="T:System.Data.OracleClient.OracleLob" /> в байтах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер <xref:System.Data.OracleClient.OracleLob> всегда возвращается в байтах для всех типов данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that returns the <see langword="LOB" /> data type.</summary>
        <value>Один из <see cref="T:System.Data.OracleClient.OracleType" /><see langword="LOB" /> типов данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob> Может принимать одно из следующих <xref:System.Data.OracleClient.OracleType> типов данных.  
  
|Тип данных OracleType|Описание:|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` тип данных, который содержит двоичные данные с максимальным размером 4 гигабайта. Он сопоставляется с <xref:System.Array> типа <xref:System.Byte>.|  
|`Clob`|Oracle `CLOB` тип данных, содержащий символьные данные, в зависимости от символа по умолчанию, установленной на сервере, с максимальным размером 4 гигабайта. Он сопоставляется с <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` тип данных, содержащий символьные данные на основании национальной кодировки сервера размером до 4 гигабайт. Он сопоставляется с <xref:System.String>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents a null <see cref="T:System.Data.OracleClient.OracleLob" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно создать <xref:System.Data.OracleClient.OracleLob> , имеет значение NULL, используя следующий формат:  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Этот метод используется главным образом для проверки ли `LOB` имеет значение NULL, возвращаемые с сервера, как показано в этом примере:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Значение NULL `LOB` ведет себя аналогично нулю байтов `LOB` в том, что <xref:System.Data.OracleClient.OracleLob.Read%2A> завершается успешно и всегда возвращает 0 байт.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current read position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <value>Текущее положение в <see cref="T:System.Data.OracleClient.OracleLob" /> потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток должен поддерживать поиск требуется получить или задать положение. Используйте <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> свойство, чтобы определить, поддерживает ли поток поиск.  
  
 Поддерживается поиск в любом месте за пределами длины потока. Поиск до нечетной позиции для `CLOB` и `NCLOB` также поддерживаемые типы данных. Дополнительные сведения см. в разделе «Примечания» <xref:System.Data.OracleClient.OracleLob.Read%2A> свойство.  
  
 <xref:System.Data.OracleClient.OracleLob.Position%2A> Свойства не хранить список число байтов из потока, который были использованы, пропущена, или оба.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c>) replaced by the bytes read from the current source.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The maximum number of bytes to be read from the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Reads a sequence of bytes from the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream and advances the position within the stream by the number of bytes read.</summary>
        <returns>The total number of bytes read into the buffer. This may be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Read%2A> Метод считывает более `count` байтов из текущего потока и сохраняет их в `buffer` начиная `offset`. Текущее положение в потоке увеличивается на число считанных байтов; Однако при возникновении исключения текущее положение в потоке не изменяется. <xref:System.Data.OracleClient.OracleLob.Read%2A> Возвращает число считанных байтов. Возвращаемое значение равно нулю, только в том случае, если текущее положение находится в конце потока. <xref:System.Data.OracleClient.OracleLob.Read%2A> будет блокироваться, пока не может прочитать хотя бы один байт данных, в случае, если данные недоступны.<xref:System.Data.OracleClient.OracleLob.Read%2A> Возвращает 0 при попытке чтения из `LOB` Если текущее положение находится в конце `LOB`. <xref:System.Data.OracleClient.OracleLob.Read%2A> может вернуть меньше байтов, чем было запрошено, даже если не достигнут конец потока.  
  
 Поставщик данных .NET Framework для Oracle обрабатывает все `CLOB` и `NCLOB` данные в кодировке Юникод. Таким образом при доступе к `CLOB` и `NCLOB` типов данных, всегда выполняются операции с количеством байт, где каждый символ занимает 2 байта. Например, если текстовая строка, содержащая три символа сохраняется как `NCLOB` на сервере Oracle, где набор символов — 4 байта на символ, а также выполнения `Read` операции, следует указать длину строки 6 байтов, несмотря на то, что он является хранятся в виде 12 байт на сервере.  
  
 В следующем примере C# показано, как выполнить чтение <xref:System.Data.OracleClient.OracleLob> объектов.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 Можно создать <xref:System.Data.OracleClient.OracleLob> , имеет значение NULL, используя следующий формат:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Этот метод используется главным образом для проверки ли `LOB` имеет значение NULL, возвращаемые с сервера, как показано в следующем примере.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Значение NULL `LOB` ведет себя аналогично нулю байтов `LOB` в том, что <xref:System.Data.OracleClient.OracleLob.Read%2A> завершается успешно и всегда возвращает 0 байт.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the offset and count parameters is larger than the buffer length.  -or-  A value specified in the <paramref name="amount" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">A byte offset relative to origin. If <c>offset</c> is negative, the new position precedes the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>. If <c>offset</c> is zero, the new position is the position specified by <c>origin</c>. If <c>offset</c> is positive, the new position follows the position specified by <c>origin</c> by the number of bytes specified by <c>offset</c>.</param>
        <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</param>
        <summary>Sets the position on the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream.</summary>
        <returns>The new position within the current stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `offset` имеет отрицательное значение, новая позиция должна предшествовать позиции, заданной параметром `origin` на число байтов, указанное в `offset`. Если `offset` равен нулю, новое положение должно быть задано с помощью `origin`. Если `offset` положительное, новое положение должны соответствовать позиции, указанной параметром `origin` на число байтов, указанное в `offset`.  
  
 Поддерживается поиск в любом месте за пределами длины потока. Поиск до нечетной позиции для `CLOB` и `NCLOB` также поддерживаемые типы данных. Дополнительные сведения см. в разделе «Примечания» <xref:System.Data.OracleClient.OracleLob.Read%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="origin" /> parameter does not contain a valid value.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting position is beyond the length of the value.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Data.OracleClient.OracleLob" /> object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The desired length of the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream in bytes. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Sets the length of the <see cref="T:System.Data.OracleClient.OracleLob" /> stream to a value less than the current length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка увеличить длину <xref:System.Data.OracleClient.OracleLob> поток завершается с ошибкой и возвращает «сообщение: ORA-22926: указано, длина больше длины текущего значения LOB» на сервере Oracle.  
  
 Поток должен поддерживать запись и поиск для <xref:System.Data.OracleClient.OracleLob.SetLength%2A> функции.  
  
 Поставщик данных .NET Framework для Oracle обрабатывает все `CLOB` и `NCLOB` данные в кодировке Юникод. Таким образом при доступе к `CLOB` и `NCLOB` типов данных, всегда выполняются операции с количеством байт, где каждый символ занимает 2 байта. Например, если текстовая строка, содержащая три символа сохраняется как `NCLOB` на сервере Oracle, где набор символов — 4 байта на символ, а также выполнения `SetLength` операции, следует указать длину строки 6 байтов, несмотря на то, что он является хранятся в виде 12 байт на сервере.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
> [!NOTE]
>  Операции записи в объект только для чтения для `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A value specified in the <paramref name="value" /> parameter for a <see langword="CLOB" /> or <see langword="NCLOB" /> data type is not even.  -or-  A value specified in the <paramref name="value" /> parameter is less than zero or greater than 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the common language runtime stream value equivalent of the underlying value.</summary>
        <value>Для <see cref="F:System.Data.OracleClient.OracleType.Blob" />, массив элементов типа <see langword="Byte[]" />. Для <see cref="F:System.Data.OracleClient.OracleType.Clob" /> и <see cref="F:System.Data.OracleClient.OracleType.NClob" />, <see langword="String" />. Для пустых данных <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.Data.OracleClient.OracleType.Blob> типы данных <xref:System.Data.OracleClient.OracleLob.Value%2A> возвращает все базовые данные как непрерывный массив типа `Byte[]`. Для <xref:System.Data.OracleClient.OracleType.Clob> и <xref:System.Data.OracleClient.OracleType.NClob> типы данных <xref:System.Data.OracleClient.OracleLob.Value%2A> возвращает все данные в виде `String` тип данных. Для пустых данных <xref:System.Data.OracleClient.OracleLob.Value%2A> возвращает <xref:System.DBNull>. Сравнивая возвращенные значения, можно отличить пустых данных значение null, данные и данные.  
  
> [!NOTE]
>  Преимуществом использования `LOB` типов данных является возможность извлечения больших фрагментов данных на клиенте. Тем не менее, при использовании <xref:System.Data.OracleClient.OracleLob.Value%2A>, получение всех данных для `LOB` столбца в виде одной непрерывной области, которая может значительно увеличить дополнительные издержки приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of bytes. This method copies the number of bytes specified in <c>count</c> from <c>buffer</c> to the current stream.</param>
        <param name="offset">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <param name="count">The number of bytes to be written to the current stream. For <see langword="CLOB" /> and <see langword="NCLOB" /> data types, this must be an even number.</param>
        <summary>Writes a sequence of bytes to the current <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the current position within this stream by the number of bytes written.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция записи прошла успешно, положение в потоке увеличивается число записанных байтов. Если возникает исключение, положение в потоке остается без изменений.  
  
 Запись за пределами `LOB` разрешено, в результате `LOB` на число записанных байтов.  
  
 Поставщик данных .NET Framework для Oracle обрабатывает все `CLOB` и `NCLOB` данные в кодировке Юникод. Таким образом при доступе к `CLOB` и `NCLOB` типов данных, всегда выполняются операции с количеством байт, где каждый символ занимает 2 байта. Например, если текстовая строка, содержащая три символа сохраняется как `NCLOB` на сервере Oracle, где набор символов — 4 байта на символ, а также выполнения `Write` операции, следует указать длину строки 6 байтов, несмотря на то, что он является хранятся в виде 12 байт на сервере.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
 В следующем примере C# показано, как записать <xref:System.Data.OracleClient.OracleLob> объектов.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  Операции записи в объект только для чтения для `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in the <paramref name="offset" /> or <paramref name="count" /> parameter is not positive.  -or-  The sum of the <paramref name="offset" /> and <paramref name="count" /> parameters is larger than the <paramref name="buffer" /> length.  -or-  A value specified in the <paramref name="count" /> or <paramref name="offset" /> parameter is less than zero or greater than 4 gigabytes.  -or-  You must specify <see langword="CLOB" /> and <see langword="NCLOB" /> data types as an even number of bytes.</exception>
        <exception cref="T:System.InvalidOperationException">The operation is not within a transaction, the <see cref="T:System.Data.OracleClient.OracleLob" /> object is null, or the connection is closed.</exception>
        <exception cref="T:System.ObjectDisposedException">The object was closed or disposed.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">An Oracle error has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The byte to write to the stream.</param>
        <summary>Writes a byte to the current position in the <see cref="T:System.Data.OracleClient.OracleLob" /> stream, and advances the position within the stream by one byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При успешном выполнении операции записи на один байт перемещает позицию в потоке. Если возникает исключение, положение в потоке остается без изменений.  
  
 Запись за пределами `LOB` разрешено, в результате `LOB` на один байт.  
  
 Для записи `LOB`, необходимо извлечь `LOB` с помощью предложения FOR UPDATE в инструкции SQL SELECT где требуется начать локальную транзакцию.  
  
> [!NOTE]
>  Операции записи в объект только для чтения для `LOB` может завершиться успешно, но не обновлять `LOB` на сервере. Таким образом, однако локальная копия `LOB` обновляется. Поэтому чтение операций на <xref:System.Data.OracleClient.OracleLob> объект может вернуть результаты операции записи.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>