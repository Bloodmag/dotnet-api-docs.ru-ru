<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ae2d2ca49781b6fbea2101bb4f63426c09bee1b1" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33685194" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет одну таблицу данных в памяти.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable> Является центральным объектом библиотеки ADO.NET. Другие объекты, использующие <xref:System.Data.DataTable> включают <xref:System.Data.DataSet> и <xref:System.Data.DataView>.  
  
 При доступе к <xref:System.Data.DataTable> объектов, обратите внимание, что они условию с учетом регистра. Например, если один <xref:System.Data.DataTable> называется «mydatatable» и другой называется «Mydatatable», строка, используемая для поиска одной из таблиц рассматривается с учетом регистра. Тем не менее если существует «mydatatable» и «Mydatatable» нет, строка поиска считается без учета регистра. Объект <xref:System.Data.DataSet> может содержать два <xref:System.Data.DataTable> объектов с одинаковым <xref:System.Data.DataTable.TableName%2A> значение свойства, но разные <xref:System.Data.DataTable.Namespace%2A> значений свойств. Дополнительные сведения о работе с <xref:System.Data.DataTable> объектов, в разделе [создание таблицы данных](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 При создании <xref:System.Data.DataTable> программно, необходимо сначала определить его схему, добавив <xref:System.Data.DataColumn> объектов <xref:System.Data.DataColumnCollection> (через <xref:System.Data.DataTable.Columns%2A> свойство). Дополнительные сведения о добавлении <xref:System.Data.DataColumn> объектов, в разделе [Добавление столбцов в таблицу данных](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Для добавления строк к <xref:System.Data.DataTable>, сначала необходимо с помощью <xref:System.Data.DataTable.NewRow%2A> метод для возврата нового <xref:System.Data.DataRow> объекта. <xref:System.Data.DataTable.NewRow%2A> Возвращает строку со схемой <xref:System.Data.DataTable>, как оно определено в таблице <xref:System.Data.DataColumnCollection>. Максимальное число строк, которые <xref:System.Data.DataTable> можно хранилища равно 16 777 216. Дополнительные сведения см. в разделе [Добавление данных в таблицу данных](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 <xref:System.Data.DataTable> Также содержит коллекцию <xref:System.Data.Constraint> объекты, которые могут использоваться для обеспечения целостности данных. Дополнительные сведения см. в разделе [ограничения таблиц данных](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Существует много <xref:System.Data.DataTable> события, которые можно использовать для определения, когда изменения вносятся в таблицу. К ним относятся <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> и <xref:System.Data.DataTable.RowDeleted>. Дополнительные сведения о событиях, которые можно использовать с <xref:System.Data.DataTable>, в разделе [обработка событий DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 При создании экземпляра <xref:System.Data.DataTable> создается, некоторые из для чтения записи свойствам присваиваются начальные значения. Список этих значений см. в разделе <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> разделе конструктор.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> И <xref:System.Data.DataTable> объекты наследуют от <xref:System.ComponentModel.MarshalByValueComponent>и поддерживают <xref:System.Runtime.Serialization.ISerializable> интерфейс для удаленного взаимодействия .NET Framework. Это единственные объекты ADO.NET, которые можно использовать для удаленного взаимодействия .NET Framework.  
  
   
  
## Examples  
 В следующем примере создается два <xref:System.Data.DataTable> объектов и один <xref:System.Data.DataRelation> и добавляет новые объекты для <xref:System.Data.DataSet>. Затем эти таблицы отобразятся в <xref:System.Windows.Forms.DataGridView> элемента управления.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 В этом примере показано, как вручную создать объект DataTable с определенной схеме определения:  
  
-   Создайте несколько таблиц данных и определите начальные столбцы.  
  
-   Создание ограничения таблицы.  
  
-   Введите значения и отображения таблиц.  
  
-   Создание столбцов выражений и отображения таблиц.  
  
 Проекты C# и Visual Basic с этим образцом кода можно найти на [примеры кода от разработчиков](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Этот тип является безопасным для многопоточных операций чтения. Необходимо синхронизировать все операции записи.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataTable" />, не передавая ему никаких аргументов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор задает начальные значения для всех свойств <xref:System.Data.DataTable> объекта. В следующей таблице показаны свойства и их значения по умолчанию. При создании экземпляра <xref:System.Data.DataTable> создается следующие начальные значения задаются свойства чтения и записи.  
  
|Свойство.|Значение по умолчанию|  
|--------------|-------------------|  
|**CaseSensitive**|То же, что родительский <xref:System.Data.DataSet>, если она относится к одному. В противном случае — значение `false`.|  
|**DisplayExpression**|Пустая строка (»»)|  
|**Языковой стандарт**|То же, что родительский <xref:System.Data.DataSet> объекта <xref:System.Globalization.CultureInfo> (возвращенный <xref:System.Data.DataSet.Locale%2A> свойство); Если отсутствия родительского элемента, значение по умолчанию — текущая система <xref:System.Globalization.CultureInfo>.|  
|**Значение MinimumCapacity**|50 строк.|  
  
 Можно изменить значение любого из этих свойств, вызвав его отдельно.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Data.DataTable> с <xref:System.Data.DataColumn> и <xref:System.Data.DataRow>и отображает его в <xref:System.Windows.Forms.DataGridView> элемента управления.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Имя, задаваемое таблице. Если значение параметра <c>tableName</c> — <see langword="null" /> или пустая строка, имя по умолчанию присваивается при добавлении в коллекцию <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataTable" /> с указанным именем таблицы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается <xref:System.Data.DataTable> и отображает его в <xref:System.Windows.Forms.DataGridView> элемента управления.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Данные, необходимые для сериализации или десериализации объекта.</param>
        <param name="context">Источник и назначение данного сериализованного потока.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataTable" /> со свойствами <see cref="T:System.Runtime.Serialization.SerializationInfo" /> и <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация <xref:System.Data.DataTable> конструктор необходим для <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Имя, задаваемое таблице. Если значение параметра <c>tableName</c> — <see langword="null" /> или пустая строка, имя по умолчанию присваивается при добавлении в коллекцию <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">Пространство имен для XML-представления данных, хранящихся в <see langword="DataTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataTable" /> с заданными именем таблицы и пространством имен.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Фиксирует все изменения, внесенные в таблицу после последнего вызова метода <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Data.DataTable.AcceptChanges%2A> вызывается, каждый <xref:System.Data.DataRow> объект остается в режиме редактирования успешно завершает его изменения. <xref:System.Data.DataRowState> Также изменяется: все `Added` и `Modified` строками стать `Unchanged`, и `Deleted` удаляются строки.  
  
 <xref:System.Data.DataTable.AcceptChanges%2A> Метод обычно вызывается при <xref:System.Data.DataTable> после попытки обновления <xref:System.Data.DataSet> с помощью <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере проверка всех таблиц на наличие ошибок. Если ошибки могут быть согласованы (путем передачи его неопределенной функции), <xref:System.Data.DataTable.AcceptChanges%2A> вызван; в противном случае — <xref:System.Data.DataTable.RejectChanges%2A> вызывается.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию <see cref="T:System.Data.DataTable" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применяется в среде разработки Visual Studio .NET для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.Data.DataTable.EndInit%2A> Метод завершает инициализацию. С помощью <xref:System.Data.DataTable.BeginInit%2A> и <xref:System.Data.DataTable.EndInit%2A> методы предотвращает использование до полной инициализации элемента управления.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отключает уведомления, ведение индексов и ограничения в процессе загрузки данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.BeginLoadData%2A> в сочетании с <xref:System.Data.DataTable.LoadDataRow%2A> и <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Показывает, учитывается ли регистр при сравнении строк в таблице.</summary>
        <value>
          Значение <see langword="true" />, если при сравнении регистр учитывается; в противном случае — значение <see langword="false" />. Значение по умолчанию устанавливается равным значению свойства <see cref="T:System.Data.DataSet" /> родительского объекта <see cref="P:System.Data.DataSet.CaseSensitive" />, или значение <see langword="false" />, если объект <see cref="T:System.Data.DataTable" /> создавался независимо от класса <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A> Свойство влиять на сравнения строк в сортировку, поиск и фильтрация.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Data.DataTable.Select%2A> вызывается дважды для <xref:System.Data.DataTable>. В первый раз <xref:System.Data.DataTable.CaseSensitive%2A> свойству `false`, во-вторых, для `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию дочерних отношений для объекта <see cref="T:System.Data.DataTable" />.</summary>
        <value>Коллекция <see cref="T:System.Data.DataRelationCollection" />, содержащая дочерние отношения для таблицы. Если отсутствуют объекты <see cref="T:System.Data.DataRelation" /> возвращается пустая коллекция.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Data.DataRelation> определяет связь между двумя таблицами. Как правило две таблицы связаны с помощью одного поля, содержит те же данные. Например таблица с адресными данными может иметь одно поле с кодами, представляющими странах и регионах. Вторая таблица, содержащая данные страны или региона будет одно поле, содержащий код, который идентифицирует страны или региона, и именно этот код, который вставляется в соответствующее поле в первой таблице. Объект <xref:System.Data.DataRelation>, содержит по крайней мере четыре фрагмента данных: (1) имя первой таблицы, (2) имя столбца первой таблицы, (3) имя второй таблицы и (4) имя столбца во второй таблице.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Data.DataTable.ChildRelations%2A> свойство для возврата каждого дочернего <xref:System.Data.DataRelation> в <xref:System.Data.DataTable>. Каждое отношение используется в качестве аргумента в <xref:System.Data.DataRow.GetChildRows%2A> метод <xref:System.Data.DataRow> для возвращения массива строк. Затем выводит значение каждого столбца в строке.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает <see cref="T:System.Data.DataTable" /> от всех данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Удаляются все строки во всех таблицах. Если таблица имеет назначенные дочерние отношения, приводящие дочерние строки будут изолированы, создается исключение.  
  
 Если <xref:System.Data.DataSet> привязан к <xref:System.Xml.XmlDataDocument>, вызов <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> или <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> вызывает <xref:System.NotSupportedException>. Чтобы избежать такой ситуации, просмотрите каждую таблицу и удалить каждую строку одновременно. При использовании <xref:System.Data.DataTable.NewRow%2A> для создания новых строк, строки должны быть обработаны перед вызовом метода <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 В следующем примере удаляются все данные в таблице.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует структуру объекта <see cref="T:System.Data.DataTable" />, включая все схемы и ограничения <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Новый класс <see cref="T:System.Data.DataTable" />, имеющий ту же схему, что и текущий класс <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если эти классы являются производными, копия также будет производным классом.  
  
 Создает новый клон <xref:System.Data.DataTable> ту же структуру, что и исходный <xref:System.Data.DataTable>, данные не копируются, но (новый <xref:System.Data.DataTable> не будет содержать `DataRows`). Чтобы скопировать структуру и данные в новую <xref:System.Data.DataTable>, используйте <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 В следующем образце показано, как обновить структуры и ограничений целевой таблицы после выполнения DataTable.Clone. Класс ClonedDataTable возвратит целевой таблицы и включает все обновления события. После клонирования структурных изменений в исходной таблице не будут отражены в целевой таблице. В частности в этом примере выполняет следующие действия:  
  
-   Обновление изменений для столбцов в исходной таблице.  
  
-   Обновление изменений для UniqueConstraint в исходной таблице.  
  
-   Обновление изменений для ForeignKeyConstraint в исходной таблице.  
  
 Проекты C# и Visual Basic с этим образцом кода можно найти на [примеры кода от разработчиков](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 В этом примере показано, как изменить данные в таблице данных и обновление источника данных.  
  
 Сначала создайте базу данных.  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Теперь можно скомпилировать и запустить образец. [Как изменить данные в таблицу данных и обновления источника данных](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) проектов Visual Basic и C# образца.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения значения указанного объекта <see cref="T:System.Data.DataColumn" /> в <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [обработка событий DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения указанного объекта <see cref="T:System.Data.DataColumn" /> в <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [обработка событий DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию столбцов, принадлежащих данной таблице.</summary>
        <value>Коллекция <see cref="T:System.Data.DataColumnCollection" />, содержащая коллекцию объектов <see cref="T:System.Data.DataColumn" /> для таблицы. Если отсутствуют объекты <see cref="T:System.Data.DataColumn" /> возвращается пустая коллекция.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection> Определяет схему таблицы с помощью определения типа данных каждого столбца.  
  
   
  
## Examples  
 В следующем примере выводится каждого значения каждой строки таблицы с помощью <xref:System.Data.DataTable.Columns%2A> свойство.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Вычисляемое выражение.</param>
        <param name="filter">Фильтр, ограничивающий число строк, используемых выражением.</param>
        <summary>Вычисляет заданное выражение для текущих строк, отвечающих условию фильтра.</summary>
        <returns>Класс <see cref="T:System.Object" />, которому задан результат сравнения. Если выражение имеет значение null, возвращаемое значение будет <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression` Параметр требует наличия статистической функции. Например следующее выражение является допустимым:  
  
 `Count(Quantity)`  
  
 Однако это выражение не равно:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Если необходимо выполнить операцию на несколько столбцов, необходимо создать <xref:System.Data.DataColumn>, задайте его <xref:System.Data.DataColumn.Expression%2A> свойства соответствующее выражение, а использовать статистическое выражение на результирующего столбца. В этом случае заданному <xref:System.Data.DataColumn> с именем «итог» и <xref:System.Data.DataColumn.Expression%2A> значение этого свойства:  
  
 `"Quantity * UnitPrice"`  
  
 Аргумент выражения для <xref:System.Data.DataTable.Compute%2A> метод будет иметь это:  
  
 `Sum(total)`  
  
 Второй параметр `filter`, определяет строки, используемые в выражении. Например если таблица содержит столбец с именем «colDate» даты, можно ограничить строки с помощью следующего выражения:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Правила создания выражений для обоих параметров в разделе <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> свойство.  
  
   
  
## Examples  
 Следующий пример выполняет суммирование значений столбца с именем «Итог» для менеджера по продажам, идентификационный номер которого равен пяти.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию ограничений, содержащихся в данной таблице.</summary>
        <value>Коллекция <see cref="T:System.Data.ConstraintCollection" />, содержащая коллекцию объектов <see cref="T:System.Data.Constraint" /> для таблицы. Если отсутствуют объекты <see cref="T:System.Data.Constraint" /> возвращается пустая коллекция.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Data.ForeignKeyConstraint> ограничивает действие, выполняемое при удалении или обновлении значения столбца (столбцов). Такое ограничение предназначено для использования с первичными ключевыми столбцами. В отношении "родители потомки" между двумя таблицами Удаление значения из родительской таблицы может влиять на дочерние строки в один из следующих способов.  
  
-   Дочерние строки могут быть удалены (каскадное действие).  
  
-   Значения null можно присваивать значения в дочерний столбец (или столбцы).  
  
-   Значения в дочерний столбец (или столбцы) можно задать значения по умолчанию.  
  
-   Может быть создано исключение.  
  
 Объект <xref:System.Data.UniqueConstraint> становится активным, при попытке задать значение в первичном ключе, не уникальное значение.  
  
   
  
## Examples  
 В следующем примере добавляется <xref:System.Data.ForeignKeyConstraint> к коллекции ограничений.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует структуру и данные для <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Новый класс <see cref="T:System.Data.DataTable" />, имеющий ту же структуру (схемы таблиц и ограничения) и данные, что и класс <see cref="T:System.Data.DataTable" />.  
  
 Если эти классы являются производными, то и копия также будет таким же производным классом.  
  
 <see cref="M:System.Data.DataTable.Copy" /> создает новый <see cref="T:System.Data.DataTable" /> с той же структурой и данными, как и оригинальный <see cref="T:System.Data.DataTable" />. Чтобы скопировать структуру в новый <see cref="T:System.Data.DataTable" />, но не данные, используйте <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется <xref:System.Data.DataTable.Copy%2A> метод для создания копии исходного <xref:System.Data.DataTable>. Имя пространства имен не сохраняются, если оно унаследовано из родительского <xref:System.Data.DataTable> или <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Data.DataTableReader" />, соответствующий данным в этой таблице <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Объект <see cref="T:System.Data.DataTableReader" />, содержащий один набор результатов, который соответствует исходному экземпляру <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующее приложение командной строки создает экземпляр <xref:System.Data.DataTable>. Затем в примере заполненный <xref:System.Data.DataTable> процедура, которая вызывает <xref:System.Data.DataTable.CreateDataReader%2A> метод, который выполняет проход по результатам, содержащихся в <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 В этом примере в окне консоли отображаются следующие выходные данные:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Новое выражение.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает класс <see cref="T:System.Data.DataSet" />, к которому принадлежит данная таблица.</summary>
        <value>Набор <see cref="T:System.Data.DataSet" />, к которому принадлежит данная таблица.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элемент управления имеет данные, привязанные к <xref:System.Data.DataTable>, и таблица принадлежит к <xref:System.Data.DataSet>, можно получить <xref:System.Data.DataSet> через это свойство.  
  
   
  
## Examples  
 В следующем примере возвращается родительский <xref:System.Data.DataSet> данной таблицы через <xref:System.Data.DataTable.DataSet%2A> свойство.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает настраиваемое представление таблицы, которая может включать в себя представление с фильтром или положение курсора.</summary>
        <value>Объект <see cref="T:System.Data.DataView" />, связанный с объектом <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A> Возвращает <xref:System.Data.DataView> можно использовать для сортировки, фильтрации и поиска <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 В следующем примере задается свойство <xref:System.Data.DataTable> объекта <xref:System.Data.DataView> через <xref:System.Data.DataTable.DefaultView%2A> свойство. Этот пример также демонстрирует привязку <xref:System.Windows.Forms.DataGridView> управления <xref:System.Data.DataTable> «поставщики», которая включает столбец с именем «CompanyName».  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает выражение, возвращающее значение, используемое для представления таблицы в пользовательском интерфейсе. Свойство <see langword="DisplayExpression" /> позволяет отображать имя этой таблицы в пользовательском интерфейсе.</summary>
        <value>Строка отображения данных.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает инициализацию <see cref="T:System.Data.DataTable" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применяется в среде разработки Visual Studio .NET для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.Data.DataTable.BeginInit%2A> Метод начинает инициализацию. С помощью <xref:System.Data.DataTable.BeginInit%2A> и <xref:System.Data.DataTable.EndInit%2A> методы предотвращает использование до полной инициализации элемента управления.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Включает уведомления, ведение индексов и ограничения после загрузки данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.EndLoadData%2A> в сочетании с <xref:System.Data.DataTable.LoadDataRow%2A> и <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию настраиваемых пользовательских сведений.</summary>
        <value>Класс <see cref="T:System.Data.PropertyCollection" />, содержащий настраиваемые данные пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.ExtendedProperties%2A> для добавления пользовательской информации о <xref:System.Data.DataTable>. Добавление данных с `Add` метод. Получить сведения с `Item` метод.  
  
 Расширенные свойства должны иметь тип <xref:System.String>. Свойства не типа String не сохраняются при <xref:System.Data.DataTable> записывается как XML.  
  
   
  
## Examples  
 В следующем примере добавляется метка времени <xref:System.Data.DataTable> через <xref:System.Data.DataTable.ExtendedProperties%2A> свойство.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Проверяет, выполняется ли инициализация. Инициализация происходит во время выполнения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает копию таблицы <see cref="T:System.Data.DataTable" />, содержащую все изменения, внесенные после ее последней загрузки или после вызова метода <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает копию таблицы <see cref="T:System.Data.DataTable" />, содержащую все изменения, внесенные после ее загрузки или после последнего вызова метода <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <returns>Копия изменений из данного объекта <see cref="T:System.Data.DataTable" /> или значение <see langword="null" />, если изменения не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Создает новый <xref:System.Data.DataSet> содержит копию всех строк в исходной коллекции <xref:System.Data.DataSet> , ожидающими изменениями. Ограничения отношений могут приводить дополнительные строки без изменений для добавления нового <xref:System.Data.DataSet> Если неизмененные строки содержат первичные ключи, соответствующие внешним ключам в измененных строках. Метод возвращает `null` (`Nothing` в Visual Basic), если нет ни одной строки в исходном <xref:System.Data.DataSet> с ожидающими изменениями.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Одно из значений перечисления <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Получает копию таблицы <see cref="T:System.Data.DataTable" />, содержащую все изменения, внесенные после ее последней загрузки или после вызова метода <see cref="M:System.Data.DataTable.AcceptChanges" /> и отфильтрованные по параметру <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Отфильтрованная копия таблицы <see cref="T:System.Data.DataTable" />, с которой можно работать и позднее объединить обратно с <see cref="T:System.Data.DataTable" />, используя метод <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Если строки с требуемым типом <see cref="T:System.Data.DataRowState" /> отсутствуют, метод вернет значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A> Метод используется для создания второго <xref:System.Data.DataTable> объект, содержащий только изменения, появившиеся в исходный. Используйте `rowStates` аргумент, чтобы указать тип изменений, должен содержать новый объект.  
  
 Ограничения связи могут вызвать без изменений родительских строк для включения.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Экземпляр <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</param>
        <summary>Этот метод возвращает экземпляр <see cref="T:System.Xml.Schema.XmlSchemaSet" />, содержащий язык описания веб-служб (WSDL), который описывает объект <see cref="T:System.Data.DataTable" /> для веб-служб.</summary>
        <returns>Экземпляр класса <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает массив объектов <see cref="T:System.Data.DataRow" />, содержащих ошибки.</summary>
        <returns>Массив объектов <see cref="T:System.Data.DataRow" /> с ошибками.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращает список <xref:System.Data.DataRow> объектов, у которых <xref:System.Data.DataRow.RowError%2A> значение. Например, ошибки могут возникать при вызове <xref:System.Data.Common.DataAdapter.Update%2A> с <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> значение **true**. Не вызывайте <xref:System.Data.DataTable.AcceptChanges%2A> на <xref:System.Data.DataTable> до устранить все ошибки и повторно отправьте <xref:System.Data.DataSet> для обновления.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Data.DataTable.GetErrors%2A> метод, чтобы вернуть массив <xref:System.Data.DataRow> объекты с ошибками.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, содержащий сериализованные данные, связанные с объектом <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с объектом <see cref="T:System.Data.DataTable" />.</param>
        <summary>Заполняет объект сведений о сериализации данными, необходимыми для сериализации <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Значением параметра <paramref name="info" /> является пустая ссылка (<see langword="Nothing" /> в Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает тип строки.</summary>
        <returns>Возвращает тип объекта <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" />, описывающая представление XML объекта, полученного из метода <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> и включенного в метод <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее наличие ошибок в строках таблиц класса <see cref="T:System.Data.DataSet" />, к которому принадлежат таблицы.</summary>
        <value>
          Значение <see langword="true" />, если ошибки есть; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При работе на набор данных, содержащихся в <xref:System.Data.DataTable>, можно пометить каждое изменение с ошибкой, если оно вызывает сбой проверки. Вы можете пометить весь <xref:System.Data.DataRow> с ошибкой сообщение с помощью <xref:System.Data.DataRow.RowError%2A> свойство. Ошибки можно также установить на каждый столбец строки с <xref:System.Data.DataRow.SetColumnError%2A> метод.  
  
 Перед обновлением источника данных с <xref:System.Data.DataSet>, рекомендуется сначала вызвать <xref:System.Data.DataSet.GetChanges%2A> метод на целевом сервере <xref:System.Data.DataSet>. В результате метод <xref:System.Data.DataSet> , содержащий только изменения, внесенные в исходный. Перед отправкой <xref:System.Data.DataSet> к источнику данных для обновления проверьте <xref:System.Data.DataTable.HasErrors%2A> свойства каждой таблицы, чтобы увидеть, если любой ошибок для строк или столбцов в строках.  
  
 После согласования ошибок, очистить ошибки с <xref:System.Data.DataRow.ClearErrors%2A> метод `DataRow`.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Data.DataTable.HasErrors%2A> свойство для проверки, если таблица содержит ошибки.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">Импортируемый объект <see cref="T:System.Data.DataRow" />.</param>
        <summary>Копирует объект <see cref="T:System.Data.DataRow" /> в <see cref="T:System.Data.DataTable" />, сохраняя все параметры свойств, а также текущие и исходные значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Data.DataTable.NewRow%2A> добавляет строку в таблицу, используя существующую схему таблицы, но со значениями по умолчанию для строки и задает <xref:System.Data.DataRowState> для `Detached`. Вызов <xref:System.Data.DataTable.ImportRow%2A> сохраняется имеющийся <xref:System.Data.DataRowState> и другие значения в строке. Если `DataRow` , передается как параметр находится в отсоединенном состоянии, учитывается, и исключение не возникает.  
  
 Новая строка добавляется в конец таблицы данных.  
  
 Если новая строка нарушает ограничение не будет добавлена в таблицу данных.  
  
 Индекс новой строки с DataTable.Rows.Find и DataTable.Rows.IndexOf можно получить. Дополнительные сведения см. в разделах <xref:System.Data.DataRowCollection> и <xref:System.Data.DataTable.Rows%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после инициализации таблицы <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, инициализирована ли таблица <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          Значение <see langword="true" /> указывает, что компонент завершил инициализацию; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращает состояние <xref:System.Data.DataTable> пока она создана, например с помощью Visual Studio. <xref:System.Data.DataTable.BeginInit%2A> Задает метод для `false` и <xref:System.Data.DataTable.EndInit%2A> задает метод для `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Заполняет таблицу <see cref="T:System.Data.DataTable" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />. Если объект <see langword="DataTable" /> уже содержит строки, входящие данные из источника данных объединяются с существующими строками.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` Метод может использоваться в нескольких общих сценариях, которые все направлены на получение данных из указанного источника данных и добавление его в текущем контейнере данных (в данном случае `DataTable`). В следующих сценариях описано стандартный способ `DataTable`, описывающие его обновления и слияния поведение.  
  
 Объект `DataTable` синхронизирует или обновления с одного основного источника данных. `DataTable` Отслеживает изменения, допускающие синхронизацию с основным источником данных. Кроме того `DataTable` может принимать добавочные данные из одного или нескольких вторичных источников данных. `DataTable` Не отвечает за отслеживание изменений для обеспечения синхронизации со вторичного источника данных.  
  
 Если эти два гипотетические источника данных, пользователь скорее всего, потребуется один из следующих ситуаций:  
  
-   Инициализация `DataTable` из основного источника данных. В этом сценарии пользователь хочет инициализировать пустой `DataTable` значениями из основного источника данных. Позднее пользователь планирует распространить изменения обратно на основной источник данных.  
  
-   Сохранение изменений и повторная синхронизация из первичного источника данных. В этом сценарии пользователь хочет воспользоваться `DataTable` заполнения в предыдущем сценарии и выполнять добавочную синхронизацию с основным источником данных, сохраняя изменения, сделанные в `DataTable`.  
  
-   Веб-канал добавочных данных из дополнительных источников данных. В этом сценарии пользователь хочет объединить изменения из одного или нескольких вторичных источников данных и распространить эти изменения обратно на основной источник данных.  
  
 `Load` Метод обеспечивает реализацию этих сценариев. Только один из перегрузок этого метода позволяет указать параметр варианта загрузки, что означает, как строки уже <xref:System.Data.DataTable> объединения с загружаемых строк. (Перегрузка, которая не позволяет задать поведение используется вариант загрузки по умолчанию). В следующей таблице описаны три варианта загрузки, предоставляемые <xref:System.Data.LoadOption> перечисления. В каждом случае описание определяет поведение, когда первичный ключ строки во входных данных с первичным ключом существующей строки.  
  
|Параметр загрузки|Описание:|  
|-----------------|-----------------|  
|`PreserveChanges` (по умолчанию)|Обновляет исходную версию строки со значением входящей строки.|  
|`OverwriteChanges`|Обновляет текущую и первоначальную версию строки, используя значение входной строки.|  
|`Upsert`|Обновляет текущую версию строки со значением входящей строки.|  
  
 Как правило `PreserveChanges` и `OverwriteChanges` параметры предназначены для сценариев, в которых пользователю требуется синхронизировать `DataSet` и его изменения с основным источником данных. `Upsert` Параметр облегчает сбор изменений из одного или нескольких вторичных источников данных.  
  
   
  
## Examples  
 В следующем примере демонстрируется некоторые проблемы, связанные с вызовом <xref:System.Data.DataTable.Load%2A> метод. Во-первых, пример рассматриваются проблемы схемы, включая получение схемы из загруженного <xref:System.Data.IDataReader>, а затем на обработке несовместимых схем и схем с отсутствующими или дополнительными столбцами. Приведенный Далее рассматриваются проблемы данных, включая обработку различных параметров загрузки.  
  
> [!NOTE]
>  В этом примере показано, как использовать один из перегруженных версий `Load`. Другие примеры, которые могут быть доступны см. в разделах отдельных перегрузки.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Data.IDataReader" />, предоставляющий набор результатов.</param>
        <summary>Заполняет таблицу <see cref="T:System.Data.DataTable" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />. Если объект <see cref="T:System.Data.DataTable" /> уже содержит строки, входящие данные из источника данных объединяются с существующими строками.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> Метод использует первый результирующий набор из загруженного <xref:System.Data.IDataReader>и после успешного завершения устанавливает средство чтения положение к следующему результирующему набору, если таковые имеются. При преобразовании данных, `Load` метод использует те же самые правила, как <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> метод.  
  
 <xref:System.Data.DataTable.Load%2A> Метод должен принимать во внимание три конкретные проблемы при загрузке данных из <xref:System.Data.IDataReader> экземпляр: операций схемы, данные и события. При работе со схемой, <xref:System.Data.DataTable.Load%2A> метода могут возникнуть условия, как описано в следующей таблице. Операции со схемой выполняются для всех импортированных результирующих наборов, даже не содержащих данных.  
  
|Условие|Поведение|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Не имеет схемы.|<xref:System.Data.DataTable.Load%2A> Метод формирует схему на основании результирующий набор из импортированного <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Имеет схему, но он не совместим с загрузить схему.|<xref:System.Data.DataTable.Load%2A> Метод создает исключение, соответствующей конкретной ошибки, возникающее при попытке загрузки данных в схеме несовместимый.|  
|Схемы совместимы, но схема загруженного набора результатов содержит столбцы, которые не существуют в <xref:System.Data.DataTable>.|<xref:System.Data.DataTable.Load%2A> Метод добавляет дополнительные столбцы в `DataTable`элемента схемы. Метод вызывает исключение, если соответствующие столбцы в <xref:System.Data.DataTable> и загрузить результирующий набор, не совместимые значения. Этот метод также извлекает сведения об ограничениях в результирующем наборе для всех добавленных столбцов. За исключением случая ограничения Primary Key, эти сведения об ограничениях используется только в том случае, если текущий <xref:System.Data.DataTable> не содержит какие-либо столбцы в начале операции загрузки.|  
|Схемы совместимы, но схема загруженного набора результатов содержит меньше столбцов, чем `DataTable`.|Если отсутствующий столбец имеет определенное значение по умолчанию или тип данных столбца допускает значение NULL, <xref:System.Data.DataTable.Load%2A> метод позволяет строки, которые должны быть добавлены, заменив значение по умолчанию или `null` значение в столбце отсутствует. Если нет значения по умолчанию или `null` можно использовать, а затем `Load` метод создает исключение. Если нет конкретное значение по умолчанию не указано, `Load` использует метод `null` значение в качестве значения по умолчанию подразумеваемых.|  
  
 Прежде чем анализировать поведение `Load` метод с точки зрения операций с данными, примите во внимание каждой строки внутри <xref:System.Data.DataTable> сохраняет текущее значение и исходное значение для каждого столбца. Эти значения могут совпадать, или может отличаться, если данные в строке были изменены с момента заполнения `DataTable`.  Дополнительные сведения см. в разделе [состояния строк и версии строк](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Эта версия `Load` метод пытается сохранить текущие значения в каждой строке, а исходное значение останутся без изменений. (Если требуется детальный контроль над поведением входящих данных, см. раздел <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Если существующая строка и входная строка содержит соответствующие значения первичного ключа, строка обрабатывается с помощью его текущее значение строки состояния, в противном случае он рассматривается как новой строки.  
  
 С точки зрения операций событий <xref:System.Data.DataTable.RowChanging> событие возникает перед изменением каждой строки и <xref:System.Data.DataTable.RowChanged> событие возникает после изменения каждой строки. В каждом случае <xref:System.Data.DataRowChangeEventArgs.Action%2A> свойство <xref:System.Data.DataRowChangeEventArgs> экземпляр, переданный в обработчик события содержит сведения о конкретного действия, связанного с событием. Значение этого действия зависит от состояния строки до операции загрузки. В каждом случае происходят оба события и действие — то же самое для каждого. Действие может применяться к текущей или исходной версии каждой строки (или оба) в зависимости от состояния текущей строки.  
  
 В следующей таблице представлены поведения `Load` метод. Последняя строка (с меткой "(отсутствует)») описывается поведение для входящих строк, которые не соответствуют любой существующей строки. Каждая ячейка в этой таблице описывает текущее и исходное значение поля в строке, вместе с <xref:System.Data.DataRowState> для значения после `Load` метод завершения. В этом случае метод не позволяет указать параметр загрузки и использует значение по умолчанию `PreserveChanges`.  
  
|Существующие DataRowState|Значения после `Load` метод и действия события|  
|---------------------------|--------------------------------------------------|  
|Добавлено|Текущий = \<существующие ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = ChangeOriginal|  
|Изменено|Текущий = \<существующие ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = ChangeOriginal|  
|Deleted|Текущий = \<недоступно ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<удален ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Отсутствует)|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Значения в <xref:System.Data.DataColumn> ограниченного через использование свойств, таких как <xref:System.Data.DataColumn.ReadOnly%2A> и <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Метод обрабатывает такие столбцы таким способом, который согласуется с поведением, определяются свойства столбца. Чтение Единственное ограничение на <xref:System.Data.DataColumn> применимо только для изменений, произошедших в памяти. `Load` Метод перезаписывает значения столбца только для чтения, при необходимости.  
  
 Чтобы определить, какую версию следует использовать для сравнения текущей строки с входящей строки, поля первичного ключа `Load` метод использует исходную версию значения первичного ключа в строке, если он существует. В противном случае `Load` метод использует текущую версию поля первичного ключа.  
  
   
  
## Examples  
 В следующем примере демонстрируется некоторые проблемы, связанные с вызовом <xref:System.Data.DataTable.Load%2A> метод. Во-первых, пример рассматриваются проблемы схемы, включая получение схемы из загруженного <xref:System.Data.IDataReader>, а затем на обработке несовместимых схем и схем с отсутствующими или дополнительными столбцами. Затем в примере вызывается `Load` метод отображения данных до и после операции загрузки.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Data.IDataReader" />, предоставляющий один или несколько наборов результатов.</param>
        <param name="loadOption">Значение из перечисления <see cref="T:System.Data.LoadOption" />, которое показывает способ комбинирования строк, уже находящихся в таблице <see cref="T:System.Data.DataTable" />, с поступающими строками, которые совместно используют один и тот же первичный ключ.</param>
        <summary>Заполняет таблицу <see cref="T:System.Data.DataTable" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />. Если объект <see langword="DataTable" /> уже содержит строки, поступающие данные из источника данных объединяются с существующими строками согласно значению параметра <paramref name="loadOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` Метод использует первый результирующий набор из загруженного <xref:System.Data.IDataReader>и после успешного завершения устанавливает средство чтения положение к следующему результирующему набору, если таковые имеются. При преобразовании данных, `Load` метод использует те же самые правила, как <xref:System.Data.Common.DbDataAdapter.Fill%2A> метод.  
  
 `Load` Метод должен принимать во внимание три конкретные проблемы при загрузке данных из <xref:System.Data.IDataReader> экземпляр: операций схемы, данные и события. При работе со схемой, `Load` метода могут возникнуть условия, как описано в следующей таблице. Операции со схемой выполняются для всех импортированных результирующих наборов, даже не содержащих данных.  
  
|Условие|Поведение|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Не имеет схемы.|`Load` Метод формирует схему на основании результирующий набор из импортированного <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Имеет схему, но он не совместим с загрузить схему.|`Load` Метод создает исключение, соответствующей конкретной ошибки, возникающее при попытке загрузки данных в схеме несовместимый.|  
|Схемы совместимы, но схема загруженного набора результатов содержит столбцы, которые не существуют в `DataTable`.|`Load` Метод добавляет дополнительные столбцы в `DataTable`элемента схемы. Метод вызывает исключение, если соответствующие столбцы в <xref:System.Data.DataTable> и загрузить результирующий набор, не совместимые значения. Этот метод также извлекает сведения об ограничениях в результирующем наборе для всех добавленных столбцов. За исключением случая ограничения Primary Key, эти сведения об ограничениях используется только в том случае, если текущий <xref:System.Data.DataTable> не содержит какие-либо столбцы в начале операции загрузки.|  
|Схемы совместимы, но схема загруженного набора результатов содержит меньше столбцов, чем `DataTable`.|Если отсутствующий столбец имеет определенное значение по умолчанию или тип данных столбца допускает значение NULL, `Load` метод позволяет добавлять, строки подстановки значения по умолчанию или значение null для отсутствующего столбца. Если используется не значение по умолчанию или значение null, то `Load` метод создает исключение. Если нет конкретное значение по умолчанию не указано, `Load` метод использует значение null в качестве подразумеваемого значения по умолчанию.|  
  
 Прежде чем анализировать поведение `Load` метод с точки зрения операций с данными, примите во внимание каждой строки внутри <xref:System.Data.DataTable> сохраняет текущее значение и исходное значение для каждого столбца. Эти значения могут совпадать, или может отличаться, если данные в строке были изменены с момента заполнения `DataTable`. В разделе [состояния строк и версии строк](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) для получения дополнительной информации.  
  
 При вызове этого метода, указанного <xref:System.Data.LoadOption> параметр влияет на обработку входящих данных. Как метод Load должен обрабатывать загрузку строк, имеющих тот же первичный ключ, как и существующие строки? Его следует изменять текущие значения и исходные значения? Эти проблемы и многое другое, управляются `loadOption` параметра.  
  
 Если существующая строка и входная строка содержит соответствующие значения первичного ключа, строка обрабатывается с помощью его текущее значение строки состояния, в противном случае он рассматривается как новой строки.  
  
 С точки зрения операций событий <xref:System.Data.DataTable.RowChanging> событие возникает перед изменением каждой строки и <xref:System.Data.DataTable.RowChanged> событие возникает после изменения каждой строки. В каждом случае <xref:System.Data.DataRowChangeEventArgs.Action%2A> свойство <xref:System.Data.DataRowChangeEventArgs> экземпляр, переданный в обработчик события содержит сведения о конкретного действия, связанного с событием. Значение этого действия варьируется в зависимости от состояния строки до операции загрузки. В каждом случае происходят оба события и действие — то же самое для каждого. Действие может применяться к текущей или исходной версии каждой строки (или оба) в зависимости от состояния текущей строки.  
  
 В следующей таблице показаны поведение метода Load при вызове с каждым из `LoadOption` значений, а также показано, как значения взаимодействуют с состоянием загружаемой строки. Последняя строка (с меткой "(отсутствует)») описывается поведение для входящих строк, которые не соответствуют любой существующей строки. Каждая ячейка в этой таблице описывает текущее и исходное значение поля в строке, вместе с <xref:System.Data.DataRowState> для значения после `Load` метод завершения.  
  
|Существующие DataRowState|Upsert|OverwriteChanges|Флаг PreserveChanges (по умолчанию)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Добавлено|Текущий = \<входящих ><br /><br /> Исходный = -\<недоступно ><br /><br /> Состояние = \<добавлены ><br /><br /> RowAction = изменение|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<существующие ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = ChangeOriginal|  
|Изменено|Текущий = \<входящих ><br /><br /> Исходный = \<существующие ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = изменение|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<существующие ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = ChangeOriginal|  
аленный|(Загрузка не влияет на удаленные строки)<br /><br /> Текущий =---<br /><br /> Исходный = \<существующие ><br /><br /> Состояние = \<удален ><br /><br /> (Со следующими характеристиками добавляется новая строка)<br /><br /> Текущий = \<входящих ><br /><br /> Исходный = \<недоступно ><br /><br /> Состояние = \<добавлены ><br /><br /> RowAction = добавить|Отмените удаление и<br /><br /> Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<недоступно ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<удален ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Текущий = \<входящих ><br /><br /> Исходный = \<существующие ><br /><br /> Если новое значение совпадает со значением существующее значение затем<br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = Nothing<br /><br /> ELSE<br /><br /> Состояние = \<изменения ><br /><br /> RowAction = изменение|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Отсутствует)|Текущий = \<входящих ><br /><br /> Исходный = \<недоступно ><br /><br /> Состояние = \<добавлены ><br /><br /> RowAction = добавить|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Значения в <xref:System.Data.DataColumn> ограниченного через использование свойств, таких как <xref:System.Data.DataColumn.ReadOnly%2A> и <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Метод обрабатывает такие столбцы таким способом, который согласуется с поведением, определяются свойства столбца. Чтение Единственное ограничение на <xref:System.Data.DataColumn> применимо только для изменений, произошедших в памяти. `Load` Метод перезаписывает значения столбца только для чтения, при необходимости.  
  
 Если указать параметры OverwriteChanges или PreserveChanges при вызове `Load` становится, входящих данных поступает из метода, то предполагается `DataTable`в первичный источник данных и объекта DataTable отслеживает изменения и может распространять изменения в источнике данных. Если выбран параметр Upsert, предполагается, что поступают данные из одного из вторичного источника данных, например данные, предоставляемые компонентом среднего уровня, может быть изменено пользователем. В этом случае предполагается, что цель состоит в сборе данных из одного или нескольких источников данных в `DataTable`, а затем данные могут распространяться обратно в основной источник данных. <xref:System.Data.LoadOption> Параметр используется для определения конкретной версии строки, которая будет использоваться для сравнения первичных ключей. Сведения в следующей таблице.  
  
|Параметр загрузки|Версия DataRow используется для сравнения первичных ключей|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Исходная версия, если он существует, в противном случае текущая версия|  
|`PreserveChanges`|Исходная версия, если он существует, в противном случае текущая версия|  
|`Upsert`|Текущая версия, если он существует, в противном случае исходная версия|  
  
   
  
## Examples  
 В следующем примере демонстрируется некоторые проблемы, связанные с вызовом <xref:System.Data.DataTable.Load%2A> метод. Во-первых, пример рассматриваются проблемы схемы, включая получение схемы из загруженного <xref:System.Data.IDataReader>, а затем на обработке несовместимых схем и схем с отсутствующими или дополнительными столбцами. Приведенный Далее рассматриваются проблемы данных, включая обработку различных параметров загрузки.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Data.IDataReader" />, предоставляющий набор результатов.</param>
        <param name="loadOption">Значение из перечисления <see cref="T:System.Data.LoadOption" />, которое показывает способ комбинирования строк, уже находящихся в таблице <see cref="T:System.Data.DataTable" />, с поступающими строками, которые совместно используют один и тот же первичный ключ.</param>
        <param name="errorHandler">Делегат <see cref="T:System.Data.FillErrorEventHandler" />, вызываемый при возникновении ошибки во время загрузки данных.</param>
        <summary>Заполняет таблицу <see cref="T:System.Data.DataTable" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />, использующего делегат для обработки ошибок.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` Метод использует первый результирующий набор из загруженного <xref:System.Data.IDataReader>и после успешного завершения устанавливает средство чтения положение к следующему результирующему набору, если таковые имеются. При преобразовании данных, `Load` метод использует те же самые правила, как <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> метод.  
  
 `Load` Метод должен принимать во внимание три конкретные проблемы при загрузке данных из <xref:System.Data.IDataReader> экземпляр: операций схемы, данные и события. При работе со схемой, `Load` метода могут возникнуть условия, как описано в следующей таблице. Операции со схемой выполняются для всех импортированных результирующих наборов, даже не содержащих данных.  
  
|Условие|Поведение|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Не имеет схемы.|`Load` Метод формирует схему на основании результирующий набор из импортированного <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Имеет схему, но он не совместим с загрузить схему.|`Load` Метод создает исключение, соответствующей конкретной ошибки, возникающее при попытке загрузки данных в схеме несовместимый.|  
|Схемы совместимы, но схема загруженного набора результатов содержит столбцы, которые не существуют в `DataTable`.|`Load` Метод добавляет дополнительные столбцы для `DataTable`элемента схемы. Метод вызывает исключение, если соответствующие столбцы в <xref:System.Data.DataTable> и загрузить результирующий набор, не совместимые значения. Этот метод также извлекает сведения об ограничениях в результирующем наборе для всех добавленных столбцов. За исключением случая ограничения Primary Key, эти сведения об ограничениях используется только в том случае, если текущий <xref:System.Data.DataTable> не содержит какие-либо столбцы в начале операции загрузки.|  
|Схемы совместимы, но схема загруженного набора результатов содержит меньше столбцов, чем `DataTable`.|Если отсутствующий столбец имеет определенное значение по умолчанию или тип данных столбца допускает значение NULL, `Load` метод позволяет добавлять, строки подстановки значения по умолчанию или значение null для отсутствующего столбца. Если используется не значение по умолчанию или значение null, то `Load` метод создает исключение. Если нет конкретное значение по умолчанию не указано, `Load` метод использует значение null в качестве подразумеваемого значения по умолчанию.|  
  
 Прежде чем анализировать поведение `Load` метод с точки зрения операций с данными, примите во внимание каждой строки внутри <xref:System.Data.DataTable> сохраняет текущее значение и исходное значение для каждого столбца. Эти значения могут совпадать, или может отличаться, если данные в строке были изменены с момента заполнения `DataTable`. В разделе [состояния строк и версии строк](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) для получения дополнительной информации.  
  
 При вызове этого метода, указанного <xref:System.Data.LoadOption> параметр влияет на обработку входящих данных. Как метод Load должен обрабатывать загрузку строк, имеющих тот же первичный ключ, как и существующие строки? Его следует изменять текущие значения и исходные значения? Эти проблемы и многое другое, управляются `loadOption` параметра.  
  
 Если существующая строка и входная строка содержит соответствующие значения первичного ключа, строка обрабатывается с помощью его текущее значение строки состояния, в противном случае он рассматривается как новой строки.  
  
 С точки зрения операций событий <xref:System.Data.DataTable.RowChanging> событие возникает перед изменением каждой строки и <xref:System.Data.DataTable.RowChanged> событие возникает после изменения каждой строки. В каждом случае <xref:System.Data.DataRowChangeEventArgs.Action%2A> свойство <xref:System.Data.DataRowChangeEventArgs> экземпляр, переданный в обработчик события содержит сведения о конкретного действия, связанного с событием. Значение этого действия варьируется в зависимости от состояния строки до операции загрузки. В каждом случае происходят оба события и действие — то же самое для каждого. Действие может применяться к текущей или исходной версии каждой строки (или оба) в зависимости от состояния текущей строки.  
  
 В следующей таблице показаны поведение метода Load при вызове с каждым из `LoadOption` значений, а также показано, как значения взаимодействуют с состоянием загружаемой строки. Последняя строка (с меткой "(отсутствует)») описывается поведение для входящих строк, которые не соответствуют любой существующей строки. Каждая ячейка в этой таблице описывает текущее и исходное значение поля в строке, вместе с <xref:System.Data.DataRowState> для значения после `Load` метод завершения.  
  
|Существующие DataRowState|Upsert|OverwriteChanges|Флаг PreserveChanges (по умолчанию)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Добавлено|Текущий = \<входящих ><br /><br /> Исходный = -\<недоступно ><br /><br /> Состояние = \<добавлены ><br /><br /> RowAction = изменение|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<существующие ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = ChangeOriginal|  
|Изменено|Текущий = \<входящих ><br /><br /> Исходный = \<существующие ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = изменение|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<существующие ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<изменения ><br /><br /> RowAction = ChangeOriginal|  
аленный|(Загрузка не влияет на удаленные строки)<br /><br /> Текущий =---<br /><br /> Исходный = \<существующие ><br /><br /> Состояние = \<удален ><br /><br /> (Со следующими характеристиками добавляется новая строка)<br /><br /> Текущий = \<входящих ><br /><br /> Исходный = \<недоступно ><br /><br /> Состояние = \<добавлены ><br /><br /> RowAction = добавить|Отмените удаление и<br /><br /> Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<недоступно ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<удален ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Текущий = \<входящих ><br /><br /> Исходный = \<существующие ><br /><br /> Если новое значение совпадает со значением существующее значение затем<br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = Nothing<br /><br /> ELSE<br /><br /> Состояние = \<изменения ><br /><br /> RowAction = изменение|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Отсутствует)|Текущий = \<входящих ><br /><br /> Исходный = \<недоступно ><br /><br /> Состояние = \<добавлены ><br /><br /> RowAction = добавить|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|Текущий = \<входящих ><br /><br /> Исходный = \<входящих ><br /><br /> Состояние = \<без изменений ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Значения в <xref:System.Data.DataColumn> ограниченного через использование свойств, таких как <xref:System.Data.DataColumn.ReadOnly%2A> и <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Метод обрабатывает такие столбцы таким способом, который согласуется с поведением, определяются свойства столбца. Чтение Единственное ограничение на <xref:System.Data.DataColumn> применимо только для изменений, произошедших в памяти. `Load` Метод перезаписывает значения столбца только для чтения, при необходимости.  
  
 Если указать параметры OverwriteChanges или PreserveChanges при вызове `Load` становится, входящих данных поступает из метода, то предполагается `DataTable`в первичный источник данных и объекта DataTable отслеживает изменения и может распространять изменения в источнике данных. Если выбран параметр Upsert, предполагается, что поступают данные из одного из вторичного источника данных, например данные, предоставляемые компонентом среднего уровня, может быть изменено пользователем. В этом случае предполагается, что цель состоит в сборе данных из одного или нескольких источников данных в `DataTable`, а затем данные могут распространяться обратно в основной источник данных. <xref:System.Data.LoadOption> Параметр используется для определения конкретной версии строки, которая будет использоваться для сравнения первичных ключей. Сведения в следующей таблице.  
  
|Параметр загрузки|Версия DataRow используется для сравнения первичных ключей|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Исходная версия, если он существует, в противном случае текущая версия|  
|`PreserveChanges`|Исходная версия, если он существует, в противном случае текущая версия|  
|`Upsert`|Текущая версия, если он существует, в противном случае исходная версия|  
  
 `errorHandler` Параметр <xref:System.Data.FillErrorEventHandler> делегат, который ссылается на процедуру, которая вызывается при возникновении ошибки во время загрузки данных. <xref:System.Data.FillErrorEventArgs> Параметр, передаваемый процедуре предоставляет свойства, которые позволяют получить сведения об ошибке, возникшей, текущей строки данных, и <xref:System.Data.DataTable> заполнения. Использование механизма этого делегата, вместо простой блок try/catch, позволяет определять ошибки, обрабатывать ситуации и продолжить обработку при необходимости. <xref:System.Data.FillErrorEventArgs> Параметр предоставляет <xref:System.Data.FillErrorEventArgs.Continue%2A> свойство: значение этого свойства `true` чтобы указать, что ошибка была обработана и продолжить обработку. Это свойство равно `false` для указания, что вы хотите остановить процесс. Имейте в виду, что для свойства значение `false` вызывает код, который был источником проблемы для создания исключения.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Находит и обновляет конкретную строку. Если нужная строка не найдена, то с помощью заданных значений создается новая строка.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Массив значений, используемых для создания новой строки.</param>
        <param name="fAcceptChanges">
          Значение <see langword="true" /> — принять изменения; в противном случае — значение <see langword="false" />.</param>
        <summary>Находит и обновляет конкретную строку. Если нужная строка не найдена, то с помощью заданных значений создается новая строка.</summary>
        <returns>Новый объект <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> Метод принимает массив значений и находит соответствующие значения в столбцы первичного ключа.  
  
 Если столбец содержит значение по умолчанию, необходимо передайте значение null в массиве, чтобы задать значение по умолчанию для этого столбца. Аналогично Если в столбце его <xref:System.Data.DataColumn.AutoIncrement%2A> установлено значение true, передать значение null в массив для установки автоматически сформированное значение для строки.  
  
 Если `fAcceptChanges` параметр `true` или не указан, добавления новых данных и затем <xref:System.Data.DataTable.AcceptChanges%2A> вызывается, чтобы применить все изменения в <xref:System.Data.DataTable>; Если аргумент является `false`, новых добавленных строк, помечаются как операции вставки и изменения существующие строки, помеченные как изменения.  
  
 Исключения могут также возникнуть в <xref:System.Data.DataTable.ColumnChanging> или <xref:System.Data.DataTable.RowChanging> событий. При возникновении исключения, строка не добавляется в таблицу.  
  
 Используйте <xref:System.Data.DataTable.LoadDataRow%2A> в сочетании с <xref:System.Data.DataTable.BeginLoadData%2A> и <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Data.DataTable.LoadDataRow%2A> метод, чтобы попытаться найти строку. Если строка найдена, значения используются для создания новой строки.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Размер массива превышает число столбцов в таблице.</exception>
        <exception cref="T:System.InvalidCastException">Значение не отвечает соответствующему типу столбца.</exception>
        <exception cref="T:System.Data.ConstraintException">Добавление строки нарушает ограничение.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Попытка поместить значение null в столбец, у которого <see cref="P:System.Data.DataColumn.AllowDBNull" /> имеет значение "false".</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Массив значений, используемых для создания новой строки.</param>
        <param name="loadOption">Используется для определения способа применения значений массива к соответствующим значениям в существующей строке.</param>
        <summary>Находит и обновляет конкретную строку. Если нужная строка не найдена, то с помощью заданных значений создается новая строка.</summary>
        <returns>Новый объект <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> Метод принимает массив значений и находит соответствующие значения в столбцы первичного ключа.  
  
 Если столбец содержит значение по умолчанию, необходимо передайте значение null в массиве, чтобы задать значение по умолчанию для этого столбца. Аналогично Если в столбце его <xref:System.Data.DataColumn.AutoIncrement%2A> установлено значение true, передать значение null в массив для установки автоматически сформированное значение для строки.  
  
 Значение `loadOption` параметр используется для определения способа применения значения в массиве в существующую строку. Например если `loadOption` равно `OverwriteChanges`, `Original` и `Current` значения каждого столбца заменяются значениями из входящей строки и `RowState` свойству `Unchanged`.  
  
 Исключения могут также возникнуть в <xref:System.Data.DataTable.ColumnChanging> или <xref:System.Data.DataTable.RowChanging> событий. При возникновении исключения, строка не добавляется в таблицу.  
  
 Используйте <xref:System.Data.DataTable.LoadDataRow%2A> в сочетании с <xref:System.Data.DataTable.BeginLoadData%2A> и <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о языке, используемые для сравнения строк таблицы.</summary>
        <value>Класс <see cref="T:System.Globalization.CultureInfo" />, содержащий данные о языковом стандарте, используемом пользователем на компьютере. Значением по умолчанию является языковый стандарт <see cref="T:System.Data.DataSet" /> объекта <see cref="T:System.Globalization.CultureInfo" /> (возвращаемый свойством <see cref="P:System.Data.DataSet.Locale" />), к которому принадлежит таблица <see cref="T:System.Data.DataTable" />; если таблица не принадлежит набору <see cref="T:System.Data.DataSet" />, значением по умолчанию является языковый стандарт <see cref="T:System.Globalization.CultureInfo" /> текущей системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Globalization.CultureInfo> представляет программные настройки конкретного языка и сообщества.  
  
 При сравнении строк <xref:System.Globalization.CultureInfo> влияет на сортировки и сравнения и фильтрации.  
  
> [!NOTE]
>  В столбцах, содержащих выражения <xref:System.StringComparison.InvariantCulture> используется. <xref:System.StringComparison.CurrentCulture> Учитывается.  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Globalization.CultureInfo> через <xref:System.Data.DataTable.Locale%2A> и выводит имя языка ISO.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Объединяет заданный объект <see cref="T:System.Data.DataTable" /> с текущим объектом <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` Метод используется для объединения двух <xref:System.Data.DataTable> объекты, которые во многом аналогично схемами. Слияние с данными обычно используется для клиентских приложений для включения последних изменений из источника данных в существующую коллекцию <xref:System.Data.DataTable>. Это позволяет клиентскому приложению обновлять <xref:System.Data.DataTable> последние данные из источника данных.  
  
 Операция слияния принимает во внимание только исходная таблица и объединяемая таблица. Дочерние таблицы не влияет и не включены. Если таблица содержит один или несколько дочерних таблиц, определенных как часть отношения, каждая дочерняя таблица должны быть объединены по отдельности.  
  
   
  
## Examples  
 Следующее консольное приложение демонстрирует поведение `missingSchemaAction` параметр <xref:System.Data.DataTable.Merge%2A> метода. В этом примере создаются две версии одной таблицы, изменения схемы для второй версии. Код пытается объединить вторую таблицу с первой.  
  
> [!NOTE]
>  В этом примере показано, как использовать один из перегруженных версий метода Merge. Другие примеры, которые могут быть доступны см. в разделах отдельных перегрузки.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Объект <see cref="T:System.Data.DataTable" />, объединяемый с текущим объектом <see cref="T:System.Data.DataTable" />.</param>
        <summary>Объединяет заданный объект <see cref="T:System.Data.DataTable" /> с текущим объектом <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод Merge используется для объединения двух <xref:System.Data.DataTable> объекты, которые во многом аналогично схемами. Слияние с данными обычно используется для клиентских приложений для включения последних изменений из источника данных в существующую коллекцию <xref:System.Data.DataTable>. Это позволяет клиентскому приложению обновлять <xref:System.Data.DataTable> последние данные из источника данных.  
  
 Операция слияния принимает во внимание только исходная таблица и объединяемая таблица. Дочерние таблицы не влияет и не включены. Если таблица содержит один или несколько дочерних таблиц, определенных как часть отношения, каждая дочерняя таблица должны быть объединены по отдельности.  
  
 `Merge` Метод обычно вызывается в конце серии процедур, включающей проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и наконец обновление существующего <xref:System.Data.DataTable>.  
  
 При выполнении слияния, изменения, внесенные в существующие данные до слияния, сохраняются по умолчанию во время операции слияния. Разработчики могут изменить это поведение, путем вызова одного из двух других перегрузок данного метода и указав значение false для `preserveChanges` параметра.  
  
 В клиентском приложении обычно существует одна кнопка, которой пользователь может щелкнуть собрать измененные данные и проверить их перед отправкой назад в компонент среднего уровня. В этом сценарии <xref:System.Data.DataTable.GetChanges%2A> сначала вызывается метод. Метод возвращает второй <xref:System.Data.DataTable> оптимизированный для проверки и слияния. Второй шаг <xref:System.Data.DataTable> объект содержит только <xref:System.Data.DataRow> объектов, которые были изменены, приведет к подмножество исходного <xref:System.Data.DataTable>. Это подмножество обычно меньше и поэтому более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. Средний уровень может отправить назад либо новый <xref:System.Data.DataTable> с исходными данными и последними данными из источника данных (повторив исходный запрос), или он может отправить обратно подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения могут передаваться обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataTable> могут быть объединены обратно в исходный клиентское приложение <xref:System.Data.DataTable> с <xref:System.Data.DataTable.Merge%2A> метод.  
  
 При слиянии нового источника <xref:System.Data.DataTable> и конечного объекта исходные строки со <xref:System.Data.DataRowState> значение `Unchanged`, `Modified`, или `Deleted`, сопоставляется с конечным строкам и имеют те же значения первичного ключа. Исходные строки со <xref:System.Data.DataRowState> значение `Added` сопоставляются с новым конечным строкам с теми же значениями первичного ключа, как новые исходные строки.  
  
   
  
## Examples  
 Следующее консольное приложение создает простой <xref:System.Data.DataTable> и добавляет данные в таблицу. Затем в примере создается копия таблицы путем добавления строк в копию. Наконец, в примере вызывается <xref:System.Data.DataTable.Merge%2A> метод для слияния данных во второй таблице с данными в первой таблице.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">Объект <see langword="DataTable" />, объединяемый с текущим объектом <see langword="DataTable" />.</param>
        <param name="preserveChanges">
          Значение <see langword="true" />, если необходимо сохранить изменения в текущем объекте <see langword="DataTable" />; в противном случае — значение <see langword="false" />.<see langword="" /></param>
        <summary>Объедините заданный объект <see cref="T:System.Data.DataTable" /> с текущим объектом <see langword="DataTable" />, указав, следует ли сохранить изменения в контейнере данных <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод Merge используется для объединения двух <xref:System.Data.DataTable> объекты, которые во многом аналогично схемами. Слияние с данными обычно используется для клиентских приложений для включения последних изменений из источника данных в существующую коллекцию <xref:System.Data.DataTable>. Это позволяет клиентскому приложению обновлять <xref:System.Data.DataTable> последние данные из источника данных.  
  
 Операция слияния принимает во внимание только исходная таблица и объединяемая таблица. Дочерние таблицы не влияет и не включены. Если таблица содержит один или несколько дочерних таблиц, определенных как часть отношения, каждая дочерняя таблица должны быть объединены по отдельности.  
  
 `Merge` Метод обычно вызывается в конце серии процедур, включающей проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и наконец обновление существующего <xref:System.Data.DataTable>.  
  
 При выполнении слияния, изменения, внесенные в существующие данные до слияния, сохраняются при слиянии, если только значение "false" для `preserveChanges` параметра. Если `preserveChanges` параметр имеет значение `true`, входные значения не переопределяют существующие значения в версии Current существующей строки. Если `preserveChanges` параметр имеет значение `false`, входные значения переопределяют существующие значения в версии Current существующей строки. Дополнительные сведения о версиях строк см. в разделе [состояния строк и версии строк](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 В клиентском приложении обычно существует одна кнопка, которой пользователь может щелкнуть собрать измененные данные и проверить их перед отправкой назад в компонент среднего уровня. В этом сценарии <xref:System.Data.DataTable.GetChanges%2A> сначала вызывается метод. Метод возвращает второй <xref:System.Data.DataTable> оптимизированный для проверки и слияния. Второй шаг <xref:System.Data.DataTable> объект содержит только <xref:System.Data.DataTable> и <xref:System.Data.DataRow> объектов, которые были изменены, приведет к подмножество исходного <xref:System.Data.DataTable>. Это подмножество обычно меньше и поэтому это подмножество более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. Средний уровень может отправить назад либо новый <xref:System.Data.DataTable> с исходными данными и последними данными из источника данных (повторив исходный запрос), или он может отправить обратно подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения могут передаваться обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataTable> могут быть объединены обратно в исходный клиентское приложение <xref:System.Data.DataTable> с <xref:System.Data.DataTable.Merge%2A> метод.  
  
 При слиянии нового источника <xref:System.Data.DataTable> и конечного объекта исходные строки со <xref:System.Data.DataRowState> значение `Unchanged`, `Modified`, или `Deleted` сопоставляются с конечным строкам и имеют те же значения первичного ключа. Исходные строки со <xref:System.Data.DataRowState> значение `Added` сопоставляются с новым конечным строкам с теми же значениями первичного ключа, как новые исходные строки.  
  
   
  
## Examples  
 Следующее консольное приложение создает <xref:System.Data.DataTable> содержит строки, изменяет некоторые данные в этих строках и предпринимается попытка объединить данные из разных <xref:System.Data.DataTable>. В примере показано различное поведение для `preserveChanges` параметра.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Объект <see cref="T:System.Data.DataTable" />, объединяемый с текущим объектом <see cref="T:System.Data.DataTable" />.</param>
        <param name="preserveChanges">
          Значение <see langword="true" />, если необходимо сохранить изменения в текущем объекте <see cref="T:System.Data.DataTable" />; в противном случае — значение <see langword="false" />.</param>
        <param name="missingSchemaAction">Одно из значений перечисления <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Объедините заданный объект <see cref="T:System.Data.DataTable" /> с текущим объектом <see langword="DataTable" />, указав, следует ли сохранить изменения и способ обработки отсутствующей схемы в текущем контейнере данных <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` Метод используется для объединения двух <xref:System.Data.DataTable> объекты, которые во многом аналогично схемами. Слияние с данными обычно используется для клиентских приложений для включения последних изменений из источника данных в существующую коллекцию <xref:System.Data.DataTable>. Это позволяет клиентскому приложению обновлять <xref:System.Data.DataTable> последние данные из источника данных.  
  
 Операция слияния принимает во внимание только исходная таблица и объединяемая таблица. Дочерние таблицы не влияет и не включены. Если таблица содержит один или несколько дочерних таблиц, определенных как часть отношения, каждая дочерняя таблица должны быть объединены по отдельности.  
  
 `Merge` Метод обычно вызывается в конце серии процедур, включающей проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и наконец обновление существующего <xref:System.Data.DataTable>.  
  
 При выполнении слияния, изменения, внесенные в существующие данные до слияния, сохраняются при слиянии, если только значение "false" для `preserveChanges` параметра. Если `preserveChanges` параметр имеет значение `true`, входные значения не переопределяют существующие значения в версии Current существующей строки. Если `preserveChanges` параметр имеет значение `false`, входные значения переопределяют существующие значения в версии Current существующей строки. Дополнительные сведения о версиях строк см. в разделе [состояния строк и версии строк](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 В клиентском приложении обычно существует одна кнопка, которой пользователь может щелкнуть собрать измененные данные и проверить их перед отправкой назад в компонент среднего уровня. В этом сценарии <xref:System.Data.DataTable.GetChanges%2A> сначала вызывается метод. Метод возвращает второй <xref:System.Data.DataTable> оптимизированный для проверки и слияния. Второй шаг <xref:System.Data.DataTable> объект содержит только <xref:System.Data.DataTable> и <xref:System.Data.DataRow> объектов, которые были изменены, приведет к подмножество исходного <xref:System.Data.DataTable>. Это подмножество обычно меньше и поэтому это подмножество более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. Средний уровень может отправить назад либо новый <xref:System.Data.DataTable> с исходными данными и последними данными из источника данных (повторив исходный запрос), или он может отправить обратно подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения могут передаваться обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataTable> могут быть объединены обратно в исходный клиентское приложение <xref:System.Data.DataTable> с <xref:System.Data.DataTable.Merge%2A> метод.  
  
 Когда <xref:System.Data.DataTable.Merge%2A> вызывается метод, схемы двух <xref:System.Data.DataTable> объекты сравнения, так как это схемы могут быть изменены. Например в бизнес-сценарии, добавлены новые столбцы могут XML-схеме автоматизированным процессом. Если источник <xref:System.Data.DataTable> содержит элементы схемы (добавлены <xref:System.Data.DataColumn> объектов), которые отсутствуют в целевом объекте, могут быть добавлены к целевому элементы схемы, задав `missingSchemaAction` аргумент `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataTable> содержит добавленные схему и данные.  
  
 Данные объединяются после слияния схем.  
  
 При слиянии нового источника <xref:System.Data.DataTable> и конечного объекта исходные строки со <xref:System.Data.DataRowState> значение `Unchanged`, `Modified`, или `Deleted` сопоставляются с конечным строкам и имеют те же значения первичного ключа. Исходные строки со <xref:System.Data.DataRowState> значение `Added` сопоставляются с новым конечным строкам с теми же значениями первичного ключа, как новые исходные строки.  
  
   
  
## Examples  
 Следующее консольное приложение демонстрирует поведение `missingSchemaAction` параметр <xref:System.Data.DataTable.Merge%2A> метода. В этом примере создаются две версии одной таблицы, изменения схемы для второй версии. Код пытается объединить вторую таблицу с первой.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает начальный размер таблицы.</summary>
        <value>Начальный размер (в строках) этой таблицы. Значение по умолчанию — 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A> Позволяет системе создать соответствующий набор ресурсов перед получением данных. В ситуации, когда важна производительность, задание этого свойства можно оптимизировать производительность.  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Data.DataTable.MinimumCapacity%2A> из <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает пространство имен для представления данных объекта <see cref="T:System.Data.DataTable" /> в формате XML.</summary>
        <value>Пространство имен <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый класс <see cref="T:System.Data.DataRow" />, имеющий ту же схему, что и таблица.</summary>
        <returns>Класс <see cref="T:System.Data.DataRow" />, имеющий ту же схему, что и класс <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо использовать <xref:System.Data.DataTable.NewRow%2A> метод для создания новых <xref:System.Data.DataRow> объектов с той же схеме, <xref:System.Data.DataTable>. После создания <xref:System.Data.DataRow>, его можно добавить к <xref:System.Data.DataRowCollection>, с помощью <xref:System.Data.DataTable> объекта <xref:System.Data.DataTable.Rows%2A> свойство. При использовании <xref:System.Data.DataTable.NewRow%2A> для создания новых строк, строки должен быть добавляется или удаляется из таблицы данных, перед вызовом метода <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataTable>, добавляются два <xref:System.Data.DataColumn> объектов, которые определяют схему таблицы и создаются несколько <xref:System.Data.DataRow> объектов с помощью <xref:System.Data.DataTable.NewRow%2A> метод. Те <xref:System.Data.DataRow> объекты затем добавляются в <xref:System.Data.DataRowCollection> с помощью <xref:System.Data.DataRowCollection.Add%2A> метод.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Значение <see cref="T:System.Int32" />, описывающее размер массива.</param>
        <summary>Возвращает массив <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Новый массив.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Объект <see cref="T:System.Data.DataRowBuilder" />.</param>
        <summary>Создает новую строку из существующей строки.</summary>
        <returns>Производный класс <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataColumnChangeEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.ColumnChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataColumnChangeEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.ColumnChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Объект <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">Удаляемый объект <see cref="T:System.Data.DataColumn" />.</param>
        <summary>Сообщает классу <see cref="T:System.Data.DataTable" /> об удалении объекта <see cref="T:System.Data.DataColumn" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataRowChangeEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.RowChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataRowChangeEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.RowChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataRowChangeEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.RowDeleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataRowChangeEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.RowDeleting" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataTableClearEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.TableCleared" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывает <xref:System.Data.DataTable.TableCleared> событие, которое создается немедленно после все строки успешно удалены перед вызовом <xref:System.Data.DataTable.Clear%2A> метод возвращает управление вызывающему объекту.  
  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataTableClearEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.TableClearing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывает <xref:System.Data.DataTable.TableClearing> событие, которое возникает перед началом обработки <xref:System.Data.DataTable.Clear%2A> начала операции.  
  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Data.DataTableNewRowEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Data.DataTable.TableNewRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывает <xref:System.Data.DataTable.TableNewRow> события, который вызывается после создания нового <xref:System.Data.DataRow> был создан с помощью <xref:System.Data.DataTable.NewRow%2A>.  
  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию родительских отношений для объекта <see cref="T:System.Data.DataTable" />.</summary>
        <value>Коллекция <see cref="T:System.Data.DataRelationCollection" />, содержащая родительские отношения для таблицы. Если отсутствуют объекты <see cref="T:System.Data.DataRelation" /> возвращается пустая коллекция.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется <xref:System.Data.DataTable.ParentRelations%2A> свойство для возврата всех его родительских <xref:System.Data.DataRelation> в <xref:System.Data.DataTable>. Каждое отношение используется в качестве аргумента в <xref:System.Data.DataRow.GetParentRows%2A> метод <xref:System.Data.DataRow> для возвращения массива строк. Затем выводит значение каждого столбца в строке.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает пространство имен для представления данных объекта <see cref="T:System.Data.DataTable" /> в формате XML.</summary>
        <value>Префикс объекта <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает массив столбцов, которые являются столбцами первичного ключа для таблицы данных.</summary>
        <value>Массив объектов <see cref="T:System.Data.DataColumn" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первичный ключ таблицы должен быть уникальным для определения записи в таблице. Можно также создать таблицу с первичным ключом, состоящий из двух или более столбцов. Это происходит, когда один столбец не может содержать достаточного количества уникальных значений. Например два столбца первичного ключа может состоять из столбца «Имя» и «Фамилия». Поскольку первичные ключи могут состоять из более чем один столбец <xref:System.Data.DataTable.PrimaryKey%2A> свойство состоит из массива <xref:System.Data.DataColumn> объектов.  
  
   
  
## Examples  
 В первом примере показано, как возвращать столбцы первичного ключа для <xref:System.Data.DataTable> в `DataGrid`. Во втором примере показано, как задать столбцы первичного ключа для <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">Ключ является внешним ключом.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A> Метод предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable> из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A> метод считывает только схему. Для чтения данных и схемы, используйте один из `ReadXML` перегрузки, включающие `XmlReadMode` параметра и присвойте ему значение `ReadSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A> и <xref:System.Data.DataTable.WriteXmlSchema%2A> методов, соответственно. Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Производный объект от класса <see cref="T:System.IO.Stream" />.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataTable" />, используя указанный класс <see cref="T:System.IO.Stream" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Data.DataTable> и его потомков, загружаемых с данными из предоставленного <xref:System.IO.Stream>. Поведение данного метода, идентичной <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> метода, за исключением того, в этом случае данные загружаются только для текущей таблицы и всех его потомков.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Метод предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable> из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A> метод считывает только схему.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A> и <xref:System.Data.DataTable.WriteXmlSchema%2A> методов, соответственно. Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.  
  
 Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.  
  
> [!NOTE]
>  `DataSet` Не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataTable> содержащий два столбца и десяти строк. В примере выполняется запись <xref:System.Data.DataTable> схему и данные в потоке памяти путем вызова <xref:System.Data.DataTable.WriteXml%2A> метод. В примере создается второй <xref:System.Data.DataTable> и вызывает <xref:System.Data.DataTable.ReadXml%2A> метод для заполнения его со схемой и данными.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.IO.TextReader" />, используемый для чтения данных.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataTable" />, используя указанный класс <see cref="T:System.IO.TextReader" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Data.DataTable> и его потомков, загружаемых с данными из предоставленного <xref:System.IO.TextReader>. Поведение данного метода, идентичной <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> метода, за исключением того, в этом случае данные загружаются только для текущей таблицы и всех его потомков.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Метод предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable> из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A> метод считывает только схему.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A> и <xref:System.Data.DataTable.WriteXmlSchema%2A> методов, соответственно. Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.  
  
 Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.  
  
> [!NOTE]
>  `DataSet` Не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataTable> содержащий два столбца и десяти строк. В примере выполняется запись <xref:System.Data.DataTable> схему и данные в потоке памяти путем вызова <xref:System.Data.DataTable.WriteXml%2A> метод. В примере создается второй <xref:System.Data.DataTable> и вызывает <xref:System.Data.DataTable.ReadXml%2A> метод для заполнения его со схемой и данными.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла, из которого читаются данные.</param>
        <summary>Читает данные и схему XML в <see cref="T:System.Data.DataTable" /> из указанного файла.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Data.DataTable> и его потомков, загружаемых с данными в файле с именем в предоставленном <xref:System.String>. Поведение данного метода, идентичной <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> метода, за исключением того, в этом случае данные загружаются только для текущей таблицы и всех его потомков.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Метод предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable> из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A> метод считывает только схему.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A> и <xref:System.Data.DataTable.WriteXmlSchema%2A> методов, соответственно. Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.  
  
 Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.  
  
> [!NOTE]
>  `DataSet` Не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataTable> содержащий два столбца и десяти строк. В примере выполняется запись <xref:System.Data.DataTable> схемы и данных на диске. В примере создается второй <xref:System.Data.DataTable> и вызывает <xref:System.Data.DataTable.ReadXml%2A> метод для заполнения его со схемой и данными.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Xml.XmlReader" />, используемый для чтения данных.</param>
        <summary>Читает данные и схему XML в <see cref="T:System.Data.DataTable" />, используя указанное средство чтения <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий <xref:System.Data.DataTable> и его потомков, загружаемых с данными в файле с именем в предоставленном <xref:System.Xml.XmlReader>. Поведение данного метода, идентичной <xref:System.Data.DataTable.ReadXml%2A> метода, за исключением того, в этом случае данные загружаются только для текущей таблицы и всех его потомков.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Метод предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable> из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A> метод считывает только схему.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A> и <xref:System.Data.DataTable.WriteXmlSchema%2A> методов, соответственно. Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.  
  
 Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.  
  
> [!NOTE]
>  `DataSet` Не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataTable> содержащий два столбца и десяти строк. В примере выполняется запись <xref:System.Data.DataTable> схему и данные для <xref:System.Xml.XmlReader>. В примере создается второй <xref:System.Data.DataTable> и вызывает <xref:System.Data.DataTable.ReadXml%2A> метод для заполнения его схемы и данных из <xref:System.Xml.XmlReader> экземпляра.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает схему XML в таблицу <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `ReadXmlSchema` метод для создания схемы для <xref:System.Data.DataTable>. Схема содержит определения таблиц, связей и ограничений.  
  
 Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> метод.  
  
 XML-схема интерпретируется согласно стандарту XSD.  
  
 `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A> метод, который используется для заполнения <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, используемый для чтения схемы.</param>
        <summary>Считывает XML-схему в <see cref="T:System.Data.DataTable" />, используя указанный поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.ReadXmlSchema%2A> метод для создания схемы для <xref:System.Data.DataTable>. Схема содержит определения таблиц, связей и ограничений.  
  
 Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> метод.  
  
 XML-схема интерпретируется согласно стандарту XSD.  
  
 Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.  
  
 `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A> метод, который используется для заполнения <xref:System.Data.DataTable>.  
  
 Для создания вложенного отношения с помощью XML-схемы, используйте неявные вложенные элементы. Можно также настроить вложенное отношение для использования явных имен столбцов. Элементы должны быть неявно вложены в порядке для соответствующего DataTables участвовать во вложенном отношении.  
  
   
  
## Examples  
 Следующее консольное приложение создает новый <xref:System.Data.DataTable>и записывает схему для этой таблицы <xref:System.IO.MemoryStream>. Затем в примере создается новый <xref:System.Data.DataTable> и ее схема читается из сохраненной XML-схемы.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения <see cref="T:System.IO.TextReader" />, используемое для чтения сведений схемы.</param>
        <summary>Считывает XML-схему в <see cref="T:System.Data.DataTable" />, используя указанный объект <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.ReadXmlSchema%2A> метод для создания схемы для <xref:System.Data.DataTable>. Схема содержит определения таблиц, связей и ограничений.  
  
 Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> метод.  
  
 XML-схема интерпретируется согласно стандарту XSD.  
  
 Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.  
  
 `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A> метод, который используется для заполнения <xref:System.Data.DataTable>.  
  
 Для создания вложенного отношения с помощью XML-схемы, используйте неявные вложенные элементы. Также можно перенастроить вложенное отношение для использования явных имен столбцов. Элементы должны быть неявно вложены в порядке для соответствующего DataTables участвовать во вложенном отношении.  
  
   
  
## Examples  
 Следующее консольное приложение создает новый <xref:System.Data.DataTable>и записывает схему для этой таблицы <xref:System.IO.MemoryStream>. Затем в примере создается новый <xref:System.Data.DataTable> и ее схема читается из сохраненной XML-схемы с помощью <xref:System.IO.StreamReader> (который наследуется от <xref:System.IO.TextReader>) в качестве источника.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла, из которого считываются сведения схемы.</param>
        <summary>Считывает XML-схему из указанного файла в таблицу <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.ReadXmlSchema%2A> метод для создания схемы для <xref:System.Data.DataTable>. Схема содержит определения таблиц, связей и ограничений.  
  
 Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> метод.  
  
 XML-схема интерпретируется согласно стандарту XSD.  
  
 Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.  
  
 `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A> метод, который используется для заполнения `DataTable`.  
  
 Для создания вложенного отношения с помощью XML-схемы, используйте неявные вложенные элементы. Также можно перенастроить вложенное отношение для использования явных имен столбцов. Элементы должны быть неявно вложены в порядке для соответствующего DataTables участвовать во вложенном отношении.  
  
   
  
## Examples  
 Следующее консольное приложение создает новый <xref:System.Data.DataTable>и записывает схему для этой таблицы в файл. Затем в примере создается новый <xref:System.Data.DataTable> и ее схема читается из сохраненной XML-схемы с помощью файла в качестве источника.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения <see cref="T:System.Xml.XmlReader" />, используемое для чтения сведений схемы.</param>
        <summary>Считывает XML-схему в <see cref="T:System.Data.DataTable" />, используя указанный объект <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.ReadXmlSchema%2A> метод для создания схемы для <xref:System.Data.DataTable>. Схема содержит определения таблиц, связей и ограничений.  
  
 Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> метод.  
  
 XML-схема интерпретируется согласно стандарту XSD.  
  
 Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.  
  
 `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A> метод, который используется для заполнения <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Способ создания вложенного отношения с помощью XML-схемы будет иметь неявные вложенные элементы. Кроме того вложенное отношение может быть переопределено для использования явных имен столбцов. Является обязательным для элементов, которые должны быть неявно вложенными для соответствующего DataTables участвовать во вложенном отношении.  
  
   
  
## Examples  
 Следующее консольное приложение создает новый <xref:System.Data.DataTable>и записывает схему для этой таблицы <xref:System.IO.MemoryStream>. Затем в примере создается новый <xref:System.Data.DataTable> и ее схема читается из сохраненной XML-схемы с помощью <xref:System.Xml.XmlTextReader> (который наследуется от <xref:System.Xml.XmlReader>) в качестве источника.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Считывает из XML-потока.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняется откат всех изменений, внесенных в таблицу с момента ее загрузки или после последнего вызова метода <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Data.DataTable.RejectChanges%2A> вызове любой <xref:System.Data.DataRow> объекты, которые все еще находятся в режиме редактирования отменить их изменения. Новые строки будут удалены. Строки, у которых <xref:System.Data.DataRowState> значение `Modified` или `Deleted` возвращаются в исходное состояние.  
  
   
  
## Examples  
 В следующем примере происходит несколько изменений <xref:System.Data.DataTable>, но отклоняет изменения, вызвав <xref:System.Data.DataTable.RejectChanges%2A> метод.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает формат сериализации.</summary>
        <value>Перечисление <see cref="T:System.Data.SerializationFormat" />, задающее сериализацию типа <see langword="Binary" /> или <see langword="Xml" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Data.DataTable" /> в исходное состояние. Сброс удаляет все данные, индексы, связи и столбцы таблицы. Если набор данных содержит таблицы данных, то таблица по-прежнему будет частью набора данных после того, как таблица будет сброшена.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после успешного изменения <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [обработка событий DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении объекта <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [обработка событий DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после удаления строки таблицы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [обработка событий DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит перед удалением строки таблицы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе [обработка событий DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию строк, принадлежащих данной таблице.</summary>
        <value>Коллекция <see cref="T:System.Data.DataRowCollection" />, содержащая объекты <see cref="T:System.Data.DataRow" />; в противном случае — значение null, если нет ни одного объекта <see cref="T:System.Data.DataRow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы создать новую <xref:System.Data.DataRow>, необходимо использовать <xref:System.Data.DataTable.NewRow%2A> метод для возврата объекта. Такой объект автоматически настраивается в соответствии со схемой, определенной для <xref:System.Data.DataTable> через его коллекцию <xref:System.Data.DataColumn> объектов. После создания новой строки и задание значений для каждого столбца в строке, добавьте строку <xref:System.Data.DataRowCollection> с помощью `Add` метод.  
  
 Каждый <xref:System.Data.DataRow> в коллекции представляет строку данных в таблице. Чтобы сохранить измененное значение столбца в строке, необходимо вызвать <xref:System.Data.DataTable.AcceptChanges%2A> метод.  
  
   
  
## Examples  
 Ниже представлены два примера возврата и задания строк. В первом примере используется <xref:System.Data.DataTable.Rows%2A> свойства и выводится значение каждого столбца для каждой строки. Во втором примере <xref:System.Data.DataTable> объекта <xref:System.Data.DataTable.NewRow%2A> метод для создания нового <xref:System.Data.DataRow> объекта со схемой <xref:System.Data.DataTable>. После задания значений, то добавляется строка для <xref:System.Data.DataRowCollection> через `Add` метод.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает массив объектов <see cref="T:System.Data.DataRow" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает массив всех объектов <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Массив объектов <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить правильную сортировку, укажите критерии сортировки с <xref:System.Data.DataTable.Select%2A> или <xref:System.Data.DataTable.Select%2A>.  
  
   
  
## Examples  
 В следующем примере возвращается массив <xref:System.Data.DataRow> объектов через <xref:System.Data.DataTable.Select%2A> метод.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Условия фильтрации строк. Примеры по фильтрации строк см. в разделе [Синтаксис DataView RowFilter [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Получает массив всех объектов <see cref="T:System.Data.DataRow" />, отвечающих условиям фильтра.</summary>
        <returns>Массив объектов <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания `filterExpression` аргумент, использующих те же правила, которые применяются к <xref:System.Data.DataColumn> класса <xref:System.Data.DataColumn.Expression%2A> значение свойства для создания фильтров.  
  
 Чтобы обеспечить правильную сортировку, укажите критерии сортировки с <xref:System.Data.DataTable.Select%2A> или <xref:System.Data.DataTable.Select%2A>.  
  
 Если столбец фильтра содержит значение null, он не будет часть результата.  
  
   
  
## Examples  
 В следующем примере выражение фильтра для возвращения массива <xref:System.Data.DataRow> объектов.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Условия фильтрации строк. Примеры по фильтрации строк см. в разделе [Синтаксис DataView RowFilter [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Строка, задающая столбец и порядок его сортировки.</param>
        <summary>Получает массив всех объектов <see cref="T:System.Data.DataRow" />, отвечающих условиям фильтра, согласно указанному порядку сортировки.</summary>
        <returns>Массив объектов <see cref="T:System.Data.DataRow" />, отвечающих выражению для фильтра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Форму `filterExpression` аргумент, использующих те же правила для создания <xref:System.Data.DataColumn> класса <xref:System.Data.DataColumn.Expression%2A> значение свойства. `Sort` Аргумент также использует те же правила для создания класса <xref:System.Data.DataColumn.Expression%2A> строки.  
  
 Если столбец фильтра содержит значение null, он не будет часть результата.  
  
   
  
## Examples  
 В следующем примере выражение фильтра для возвращения массива <xref:System.Data.DataRow> объектов.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Условия фильтрации строк. Примеры по фильтрации строк см. в разделе [Синтаксис DataView RowFilter [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Строка, задающая столбец и порядок его сортировки.</param>
        <param name="recordStates">Одно из значений перечисления <see cref="T:System.Data.DataViewRowState" />.</param>
        <summary>Получает массив всех объектов <see cref="T:System.Data.DataRow" />, отвечающих условиям фильтра, согласно порядку сортировки, соответствующему указанному состоянию.</summary>
        <returns>Массив объектов <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Форму `filterExpression` аргумент, использующих те же правила для создания <xref:System.Data.DataColumn> класса <xref:System.Data.DataColumn.Expression%2A> значение свойства. `Sort` Аргумент также использует те же правила для создания класса <xref:System.Data.DataColumn.Expression%2A> строки.  
  
 Если столбец фильтра содержит значение null, он не будет часть результата.  
  
   
  
## Examples  
 В следующем примере используется фильтр выражение и запись состояния для возвращения массива <xref:System.Data.DataRow> объектов.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип <see cref="T:System.ComponentModel.ISite" /> для объекта <see cref="T:System.Data.DataTable" />.</summary>
        <value>Интерфейс <see cref="T:System.ComponentModel.ISite" /> для <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узлы связывают <xref:System.ComponentModel.Component> для <xref:System.ComponentModel.Container> и разрешить связь между ними, а также предоставляют способ для управления компонентами в контейнере.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          Значение <see langword="true" />, если коллекция является коллекцией объектов <see cref="T:System.Collections.IList" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataTable> приведен к типу интерфейса <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Объект <see cref="T:System.Collections.IList" />, который можно привязать к источнику данных из объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataTable> приведен к типу интерфейса <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" />, описывающая представление XML объекта, полученного из метода <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> и включенного в метод <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XmlReader.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">XmlWriter.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после очистки <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared> События сразу после все строки успешно удалены перед вызовом <xref:System.Data.DataTable.Clear%2A> метод возвращает управление вызывающему объекту. <xref:System.Data.DataTable.TableCleared> Событие не создается, если все исключения во время операции очистки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда очищается таблица <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing> Событие перед началом обработки <xref:System.Data.DataTable.Clear%2A> начала операции. Это событие всегда возникает, когда <xref:System.Data.DataTable.Clear%2A> вызывается метод, даже если таблица содержит нулевые строки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя таблицы для объекта <see cref="T:System.Data.DataTable" />.</summary>
        <value>Имя <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A> Используется для возврата в этой таблице от родительского <xref:System.Data.DataSet> объекта <xref:System.Data.DataTableCollection> (возвращенный <xref:System.Data.DataSet.Tables%2A> свойство).  
  
   
  
## Examples  
 В следующем примере выводится <xref:System.Data.DataTable.TableName%2A> для каждой таблицы в коллекцию <xref:System.Data.DataTable> объектов.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Передается значение <see langword="null" /> или пустая строка (""), а таблица принадлежит коллекции.</exception>
        <exception cref="T:System.Data.DuplicateNameException">Таблица принадлежит коллекции, которая уже содержит таблицу с таким же именем. (При сравнении учитывается регистр).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда вставляется новая строка <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Активируется после создания нового <xref:System.Data.DataRow> был создан с помощью <xref:System.Data.DataTable.NewRow%2A>. Это событие возникает перед вызываемую `NewRow` возвращает метод. Новый <xref:System.Data.DataRow> экземпляр отключен; он не был добавлен в коллекцию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает свойства <see cref="P:System.Data.DataTable.TableName" /> и <see cref="P:System.Data.DataTable.DisplayExpression" />, если существует сцепленная строка.</summary>
        <returns>Строка, состоящая из значений свойств <see cref="P:System.Data.DataTable.TableName" /> и <see cref="P:System.Data.DataTable.DisplayExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращает <xref:System.Data.DataTable.TableName%2A> и <xref:System.Data.DataTable.DisplayExpression%2A> для <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 В следующем примере возвращается <xref:System.Data.DataTable.TableName%2A> и <xref:System.Data.DataTable.DisplayExpression%2A> с помощью <xref:System.Data.DataTable.ToString%2A> метод.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текущее содержимое таблицы <see cref="T:System.Data.DataTable" /> в формате XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Следующее консольное приложение создает два <xref:System.Data.DataTable> экземпляров, добавляются в <xref:System.Data.DataSet>, создает <xref:System.Data.DataRelation> двух связанных таблиц, а затем использует <xref:System.Data.DataTable.WriteXml%2A> метода для записи данных, содержащихся в родительской таблице для <xref:System.IO.TextWriter>. В примере показано поведение при задании `writeHierarchy` параметр для каждого из его значений.  
  
> [!NOTE]
>  В этом примере показано, как использовать один из перегруженных версий метода WriteXml. Другие примеры, которые могут быть доступны см. в разделах отдельных перегрузки.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 В этом примере в окне консоли отображаются следующие выходные данные:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, в который записываются данные.</param>
        <summary>Записывает текущее содержимое <see cref="T:System.Data.DataTable" /> как XML с использованием указанного элемента <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> — используется для записи содержимого.</param>
        <summary>Записывает текущее содержимое <see cref="T:System.Data.DataTable" /> как XML с использованием указанного элемента <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Файл, в который записываются XML-данные.</param>
        <summary>Записывает текущее содержимое таблицы <see cref="T:System.Data.DataTable" /> в формате XML, используя указанный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Средство записи <see cref="T:System.Xml.XmlWriter" />, с помощью которого записывается содержимое.</param>
        <summary>Записывает текущее содержимое <see cref="T:System.Data.DataTable" /> как XML с использованием указанного элемента <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, в который записываются данные.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущее содержимое <see cref="T:System.Data.DataTable" /> как XML с использованием указанного элемента <see cref="T:System.IO.Stream" />. Чтобы сохранить данные для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, в который записываются данные.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" /> в указанный файл с помощью заданного объекта <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> — используется для записи содержимого.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущее содержимое <see cref="T:System.Data.DataTable" /> как XML с использованием указанного элемента <see cref="T:System.IO.TextWriter" />. Чтобы сохранить данные для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех его потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Следующее консольное приложение создает два <xref:System.Data.DataTable> экземпляров, добавляются в <xref:System.Data.DataSet>, создает <xref:System.Data.DataRelation> двух связанных таблиц, а затем использует <xref:System.Data.DataTable.WriteXml%2A> метода для записи данных, содержащихся в родительской таблице для <xref:System.IO.TextWriter>. В примере показано поведение при задании `writeHierarchy` параметр `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.IO.TextWriter" />, используемый для записи документа.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" /> с помощью указанных <see cref="T:System.IO.TextWriter" /> и  <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Файл, в который записываются XML-данные.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущее содержимое таблицы <see cref="T:System.Data.DataTable" /> в формате XML, используя указанный файл. Чтобы сохранить данные для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла, в который записываются данные.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" />, используя указанный файл и заданное перечисление <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Средство записи <see cref="T:System.Xml.XmlWriter" />, с помощью которого записывается содержимое.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущее содержимое <see cref="T:System.Data.DataTable" /> как XML с использованием указанного элемента <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.Xml.XmlWriter" />, используемый для записи документа.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" /> с помощью указанных <see cref="T:System.Xml.XmlWriter" /> и  <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, в который записываются данные.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" /> в указанный файл с помощью заданного объекта <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />. Чтобы сохранить данные для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из `DataTable` в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в `XmlWriteMode` параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Как правило `WriteXml` метод сохраняет данные только для текущей таблицы. `WriteXml` Метод предоставляет способ записи только данных или данных вместе со схемой из `DataTable` в XML-документ, в то время как `WriteXmlSchema` метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в `XmlWriteMode` параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.IO.TextWriter" />, используемый для записи документа.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" /> с помощью указанных <see cref="T:System.IO.TextWriter" /> и  <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />. Чтобы сохранить данные для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Как правило `WriteXml` метод сохраняет данные только для текущей таблицы. <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Следующее консольное приложение создает два <xref:System.Data.DataTable> экземпляров, добавляются в <xref:System.Data.DataSet>, создает <xref:System.Data.DataRelation> двух связанных таблиц, а затем использует <xref:System.Data.DataTable.WriteXml%2A> метода для записи данных, содержащихся в родительской таблице для <xref:System.IO.TextWriter>. В примере показано поведение при задании `writeHierarchy` параметр для каждого из его значений.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 В этом примере в окне консоли отображаются следующие выходные данные:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла, в который записываются данные.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" />, используя указанный файл и заданное перечисление <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />. Чтобы сохранить данные для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Как правило `WriteXml` метод сохраняет данные только для текущей таблицы. Если вы хотите сохранить данные для текущей таблицы и все схемы, <xref:System.Data.DataTable.WriteXml%2A> метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.Xml.XmlWriter" />, используемый для записи документа.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает содержимое текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает данные только для текущей таблицы.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataTable" /> с помощью указанных <see cref="T:System.Xml.XmlWriter" /> и  <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />. Чтобы сохранить данные для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable> в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A> метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode> параметра и присвойте ему значение `WriteSchema`.  
  
 Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A> и <xref:System.Data.DataTable.ReadXmlSchema%2A> методов, соответственно. Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.  
  
 Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Будут созданы, если тип столбца в `DataRow` чтение и запись данных для реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> , но не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
   
  
## Examples  
 Следующее консольное приложение создает два <xref:System.Data.DataTable> экземпляров, добавляются в <xref:System.Data.DataSet>, создает <xref:System.Data.DataRelation> двух связанных таблиц, а затем использует <xref:System.Data.DataTable.WriteXmlSchema%2A> метода для записи данных, содержащихся в родительской таблице для <xref:System.IO.TextWriter>. В примере показано поведение при задании `writeHierarchy` параметр для каждого из его значений.  
  
> [!NOTE]
>  В этом примере показано, как использовать один из перегруженных версий `WriteXmlSchema` для других примеров, которые могут быть доступны, см. в разделах отдельных перегрузки.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 В этом примере в окне консоли отображаются следующие выходные данные:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, в который записывается XML-схема.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы в указанный поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.IO.TextWriter" />, с помощью которого осуществляется запись.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы, используя указанный класс <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя используемого файла.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы в указанный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Используемый <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы, используя указанный класс <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, в который записывается XML-схема.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает схему текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает схему только для текущей таблицы.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы в указанный поток. Чтобы сохранить схему для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.IO.TextWriter" />, с помощью которого осуществляется запись.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает схему текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает схему только для текущей таблицы.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы, используя указанный класс <see cref="T:System.IO.TextWriter" />. Чтобы сохранить схему для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
   
  
## Examples  
 Следующее консольное приложение создает два <xref:System.Data.DataTable> экземпляров, добавляются в <xref:System.Data.DataSet>, создает <xref:System.Data.DataRelation> двух связанных таблиц, а затем использует <xref:System.Data.DataTable.WriteXmlSchema%2A> метода для записи данных, содержащихся в родительской таблице для <xref:System.IO.TextWriter>. В примере показано поведение при задании `writeHierarchy` параметр для каждого из его значений.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 В этом примере в окне консоли отображаются следующие выходные данные:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя используемого файла.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает схему текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает схему только для текущей таблицы.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы в указанный файл. Чтобы сохранить схему для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.Xml.XmlWriter" />, используемый для записи документа.</param>
        <param name="writeHierarchy">Если значение равно <see langword="true" />, записывает схему текущей таблицы и всех ее потомков. Если значение равно <see langword="false" /> (значение по умолчанию), записывает схему только для текущей таблицы.</param>
        <summary>Записывает текущую структуру данных таблицы <see cref="T:System.Data.DataTable" /> в виде XML-схемы, используя указанный класс <see cref="T:System.Xml.XmlWriter" />. Чтобы сохранить схему для таблицы и всех ее потомков, установите для параметра <paramref name="writeHierarchy" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A> способ записи схемы для <xref:System.Data.DataTable> в XML-документ. Схема содержит определения таблиц, связей и ограничений.  
  
 XML-схема записывается с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A> метод.  
  
 Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>