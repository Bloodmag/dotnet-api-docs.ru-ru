<Type Name="ApplicationDeployment" FullName="System.Deployment.Application.ApplicationDeployment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cc0a2f81304b418f78fdfbda4bc0eb4102f24a62" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30400218" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ApplicationDeployment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ApplicationDeployment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.ApplicationDeployment" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ApplicationDeployment" />
  <TypeSignature Language="C++ CLI" Value="public ref class ApplicationDeployment sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Поддерживает программное обновление текущего развертывания и обрабатывает загрузку файлов по требованию. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно настроить на [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложению проверять наличие обновлений и устанавливать их автоматически посредством `subscription` манифеста развертывания. Однако некоторые приложения требуется более точный контроль их обновления. Можно программно установить необходимые обновления и предлагать пользователям устанавливать необязательные обновления при их возможности. Отключив обновления подписки в манифесте развертывания, можно получить полный контроль политик обновления приложения. В качестве альтернативы можно использовать автоматическое подписку в сочетании с <xref:System.Deployment.Application.ApplicationDeployment>, который дает возможность [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] обновления приложения периодически, но использует <xref:System.Deployment.Application.ApplicationDeployment> для загрузки обновлений вскоре после их выпуска.  
  
 Можно проверить наличие обновления развертывания с помощью <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> или <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> метод; последний метод вызывает <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> событий при успешном завершении. <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> Возвращает важные сведения об обновлении, такие как номер версии и является ли оно обязательное обновление для текущих пользователей. Если обновление доступно, его можно установить с помощью <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> или <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; последний метод вызывает <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> событий после завершения установки обновления. Для больших обновлений может получать уведомления о ходе выполнения с помощью <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> и <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> события и воспользоваться этими сведениями в <xref:System.ComponentModel.ProgressChangedEventArgs> для уведомления пользователя о состоянии загрузки.  
  
 Можно также использовать <xref:System.Deployment.Application.ApplicationDeployment> загрузка больших файлов и сборок по требованию. Эти файлы должны быть помечены во время установки манифесте развертывания приложения как «необязательные». Файлы в любой момент можно загрузить в течение периода времени приложения с помощью <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> или <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> метод. Вы можете загрузить сборки, перед их загрузкой в память путем предоставления обработчика событий для <xref:System.AppDomain.AssemblyResolve> события <xref:System.AppDomain> класса. Подробнее см. в разделе [Пошаговое руководство. Загрузка сборок по требованию с помощью API развертывания ClickOnce с использованием конструктора](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5).  
  
> [!NOTE]
>  При обновлении [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения во время выполнения приложения, пользователь не увидит обновления до вызова <xref:System.Windows.Forms.Application.Restart%2A> метод <xref:System.Windows.Forms.Application>, которая закроет текущему запущенному экземпляру приложения и немедленно перезапустить его.  
  
 <xref:System.Deployment.Application.ApplicationDeployment> не имеет открытого конструктора; получить экземпляры класса в [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение через <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> свойство. Вы используете <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> свойство для проверки текущего приложения [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения.  
  
 <xref:System.Deployment.Application.ApplicationDeployment> Поддержка проверки наличия обновлений и загрузка обновленные файлы асинхронно с помощью нового [Обзор асинхронной модели на основе событий](~/docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md), который предоставляет обратные вызовы завершения, как класс события. <xref:System.Deployment.Application.ApplicationDeployment> запускает и управляет потоками и выполняет обратный вызов приложения в правильном потоке пользовательского интерфейса. С помощью этого класса можно обновить, не блокируя приложения, чтобы этот пользователь может продолжать работу во время установки обновления. Если пользователю придется прекратить всю работу, пока выполняется обновление, рекомендуется использовать синхронные методы.  
  
> [!NOTE]
>  Выполнения асинхронного обновления требуется импортировать, приложение как <xref:System.Deployment.Application> и <xref:System.ComponentModel> пространства имен.  
  
   
  
## Examples  
 В следующем примере кода определяет во время загрузки приложения доступно новое обновление; Если доступно необходимое обновление, в примере кода устанавливает обновление асинхронно. Этот код следует добавить в форму, содержащую <xref:System.Windows.Forms.TextBox> с именем `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationUri">
      <MemberSignature Language="C#" Value="public Uri ActivationUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ActivationUri" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.ActivationUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ ActivationUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает URL-адрес, использованный для запуска манифеста развертывания приложения.</summary>
        <value>Строка нулевой длины, если <c>TrustUrlParameters</c> свойства в манифесте развертывания <see langword="false" />, или если пользователь предоставил UNC-путь для развертывания или открыл его локально. В противном случае будет возвращен полный URL-адрес, который был использован для запуска приложения, включая параметры запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство будет работать в полностью доверенной и частично доверенных приложениях.  
  
   
  
## Examples  
 Следующий код показывает способ получения параметров URL-адрес с помощью <xref:System.Deployment.Application.ApplicationDeployment.ActivationUri%2A>и способ использования <xref:System.Web.HttpUtility> класса безопасно преобразовать строку запроса. Несколько экземпляров одной и той же переменной строки запроса объединяются в одну запись возвращаемого <xref:System.Collections.Specialized.NameValueCollection>.  
  
 [!code-csharp[ClickOnceQueryString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceQueryString/CS/Form1.cs#1)]
 [!code-vb[ClickOnceQueryString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceQueryString/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForDetailedUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет те же действия, что и метод <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, однако возвращает развернутые сведения о доступном обновлении.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate () As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет те же действия, что и метод <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, однако возвращает развернутые сведения о доступном обновлении.</summary>
        <returns>Класс <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> для доступного обновления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> Метода позволяет вызывающим объектам синхронной получены такие же расширенные сведения, получить с помощью асинхронного вызывающим объектам <xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs> класса.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> для получения сведений о последних обновлениях. Если обновление существует, оно будет установлено автоматически только в том случае, если это обязательное обновление; в противном случае его пользователю.  
  
 [!code-cpp[ClickOnceAPI#7](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#7)]
 [!code-csharp[ClickOnceAPI#7](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#7)]
 [!code-vb[ClickOnceAPI#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Для текущего приложения не настроена поддержка обновлений либо уже выполняется другая операция проверки обновлений.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Невозможно загрузить манифест развертывания. Данное исключение появится в свойстве <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> события <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Манифест развертывания поврежден. Восстановите манифест приложения, перед тем, как пытаться развернуть его для пользователей. Данное исключение появится в свойстве <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> события <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />.</exception>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate (persistUpdateCheckResult As Boolean) As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate(bool persistUpdateCheckResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">Если <see langword="false" />, обновление будет применено молча и никакое диалоговое окно не будет показано.</param>
        <summary>Выполняет те же действия, что и метод <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, однако возвращает развернутые сведения о доступном обновлении.</summary>
        <returns>Класс <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> для доступного обновления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Проверяет свойство <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> чтобы определить наличие нового обновления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет свойство <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> чтобы определить наличие нового обновления.</summary>
        <returns>
          Значение <see langword="true" />, если новое обновление доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> Метод сравнивает версии развертывания, установленный с версией, указанной в манифесте развертывания, в <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>. Если версия на сервере отличается от установленной версии, он возвращает `true`.  
  
 Этот метод будет заблокирован до завершения выполнения проверки. Чтобы проверить наличие обновлений в асинхронном режиме, используйте <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> метод вместо него.  
  
> [!NOTE]
>  Если <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> видит, что доступно обновление, и пользователь не был установлен, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] запросит у пользователя, которое будет доступно обновление приложения при следующем запуске. Нет возможности отключить этого запроса. (Если приложение необходимое обновление [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] установка без запроса подтверждения.)  
  
   
  
## Examples  
 В следующем примере кода проверяет наличие обновлений для приложения; Если он доступен, оно будет установлено синхронно.  
  
 [!code-cpp[ClickOnceAPI#5](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#5)]
 [!code-csharp[ClickOnceAPI#5](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#5)]
 [!code-vb[ClickOnceAPI#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] создает это исключение сразу после вызова метода <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, когда уже выполняется операция обновления.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Невозможно загрузить манифест развертывания.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Манифест развертывания поврежден. Для устранения этой проблемы может понадобиться выполнить повторное развертывание приложения.</exception>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate (persistUpdateCheckResult As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate(bool persistUpdateCheckResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">Если <see langword="false" />, обновление будет применено молча и никакое диалоговое окно не будет показано.</param>
        <summary>Проверяет свойство <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> чтобы определить наличие нового обновления.</summary>
        <returns>
          Значение <see langword="true" />, если новое обновление доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsync">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно проверяет свойство <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> чтобы определить наличие нового обновления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> возврат немедленно, запускает отдельный поток загрузки обновленного приложения. Если метод завершается или отменяется, происходит <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> событий. Можно использовать <xref:System.ComponentModel.AsyncCompletedEventArgs> в этом обработчике событий, чтобы определить, является ли операция была отменена, или если возникло исключение во время обновления.  
  
 Асинхронное обновление можно отменить, вызвав <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel%2A>.  
  
> [!NOTE]
>  Если <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> видит, что доступно обновление, и пользователь не был установлен, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] запросит у пользователя, которое будет доступно обновление приложения при следующем запуске. Нет возможности отключить этого запроса. (Если приложение необходимое обновление [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] установка без запроса подтверждения.)  
  
   
  
## Examples  
 Следующий пример асинхронно проверяет наличие обновления и установка обновлений, если он существует.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] создает это исключение сразу после вызова метода <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />, когда уже выполняется операция обновления.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Невозможно загрузить манифест развертывания. Данное исключение появится в свойстве <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> события <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Манифест развертывания поврежден. Для устранения этой проблемы может понадобиться выполнить повторное развертывание приложения. Данное исключение появится в свойстве <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> события <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />.</exception>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsyncCancel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет асинхронную проверку обновлений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы отменить проверку обновлений для инициализации <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> метод.  
  
 Этот метод не отменит все фоновое обновление, возможно, уже выполняется, такие как обновление запущен в рамках подписки. Дополнительные сведения о подписках см. в разделе [Выбор стратегии обновления ClickOnce](http://msdn.microsoft.com/library/d8b6e7bb-4ea0-47f3-91cd-48580bdceccc).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateCompleted As CheckForUpdateCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::CheckForUpdateCompletedEventHandler ^ CheckForUpdateCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.CheckForUpdateCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после завершения работы метода <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs> Класс поможет определить, среди прочего, версия обновления, как большие обновления, и является ли доступное обновление обязательными или необязательными.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> решить, нужно ли запрашивать у пользователя для установки обновления в приложения. Если обновление является обязательным обновлением, <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> обработчик событий не запрашивать пользователя. В примере требуется развернуть приложение Windows Forms, которая включает <xref:System.Windows.Forms.StatusStrip> управления, а также этот элемент управления <xref:System.Windows.Forms.ToolStripStatusLabel> управления с именем `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ CheckForUpdateProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда доступные сведения о ходе выполнения обновления при вызове метода <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> отчеты о состоянии развертывания приложения загрузки манифеста. Это может быть важной информации для пользователей, которые загружают развертывания через медленное сетевое соединение.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> событий для оповещения пользователя, сколько манифеста развертывания остается для загрузки. В примере требуется развернуть приложение Windows Forms, которая включает <xref:System.Windows.Forms.StatusStrip> управления, а также этот элемент управления <xref:System.Windows.Forms.ToolStripStatusLabel> управления с именем `downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDeployment">
      <MemberSignature Language="C#" Value="public static System.Deployment.Application.ApplicationDeployment CurrentDeployment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Deployment.Application.ApplicationDeployment CurrentDeployment" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentDeployment" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDeployment As ApplicationDeployment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Deployment::Application::ApplicationDeployment ^ CurrentDeployment { System::Deployment::Application::ApplicationDeployment ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.ApplicationDeployment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий класс <see cref="T:System.Deployment.Application.ApplicationDeployment" /> для данного развертывания.</summary>
        <value>Текущее развертывание.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Невозможно создать экземпляры <xref:System.Deployment.Application.ApplicationDeployment> непосредственно в приложении; необходимо получить допустимый экземпляр через <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> свойство.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> Статическое свойство допустимо только в приложение, которое было развернуто с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. Пытается вызвать это свойство, отличными от[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения будет создано исключение. Если вы разрабатываете приложение, которое может или не могут быть развернуты с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], используйте <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> свойство для проверки текущей программы [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения.  
  
   
  
## Examples  
 Следующий код извлекает пример <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> и определяет, обновляется ли приложение за последние три дня.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Предпринята попытка вызова данного статического свойства из приложения, которое не является приложением [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      </Docs>
    </Member>
    <Member MemberName="CurrentVersion">
      <MemberSignature Language="C#" Value="public Version CurrentVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version CurrentVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ CurrentVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает версию развертывания для текущего выполняемого экземпляра приложения.</summary>
        <value>Текущая версия развертывания.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A> будет отличаться от <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> Если нового обновления был установлен, но еще не вызван <xref:System.Windows.Forms.Application.Restart%2A>. Если манифест развертывания настроен на автоматическое выполнение обновлений, можно сравнить эти два значения, чтобы определить, если необходимо перезапустить приложение.  
  
   
  
## Examples  
 В следующем примере кода определяется метод, который определяет, является ли [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] обновил приложения.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      </Docs>
    </Member>
    <Member MemberName="DataDirectory">
      <MemberSignature Language="C#" Value="public string DataDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.DataDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает путь к каталогу данных [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</summary>
        <value>Строка, содержащая путь к каталогу данных приложения на локальном диске.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroup">
      <MemberSignature Language="C#" Value="public void DownloadFileGroup (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroup(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroup (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroup(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Именованная группа файлов для загрузки. Для всех файлов, помеченных как "необязательные" в приложении [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], следует указать имя группы.</param>
        <summary>Загружает по требованию набор необязательных файлов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение во время инициализации или обновления не загружаются файлы, отмеченные как «необязательные» в манифесте приложения. Можно использовать <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> метод для загрузки всех файлов, принадлежащих именованную группу по требованию, так что они не используют сетевые ресурсы и места на диске пока не убедитесь, чтобы их. Например некоторым пользователям может потребоваться использовать пакет для анализа данных включается в приложении на ежедневной основе, тогда может никогда не вызвать другим пользователям.  
  
 Попытка использовать сборку, загруженный с <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>, присоединение прослушивателя событий для <xref:System.AppDomain.AssemblyResolve> события <xref:System.AppDomain.CurrentDomain%2A>. Пример см. в разделе =[Пошаговое руководство: загрузка сборок по требованию с помощью API развертывания ClickOnce конструктора](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5).  
  
 Все файлы загружаются [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] кэша приложения и являются таким образом изолировано в текущей версии приложения. Предположим, что после приложение загружает в файловую группу, пользователь устанавливает новую версию приложения, но позже возвращается к предыдущей версии приложения. В этом случае предыдущая версия по-прежнему будет иметь копии файлов, изначально загруженном. Дополнительные сведения о доступе к файлам данных см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> работает в частично доверенных приложениях, то есть, в каком-либо [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение, работающее с ограниченными разрешениями. Тем не менее при попытке динамической загрузки сборок приложению потребуется полное доверие.  
  
 Загрузка файлов данных по требованию в настоящее время не поддерживается.  
  
 Приложение не будет отвечать на запросы на ввод данных пользователем до <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> возвращает метод. Если вам нужно загрузить файлы, не прерывая работу пользователя рабочего процесса, используйте <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> метод вместо него.  
  
 Не удается загрузить один файл только его имя файла. Чтобы загрузить один файл, назначьте его имя группы в вашей [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] развертывания и загрузки в группу с помощью этого метода.  
  
   
  
## Examples  
 В следующем примере кода показано, как загрузить сборку по запросу, прослушивающие <xref:System.AppDomain.AssemblyResolve> событий.  
  
 [!code-csharp[ClickOnceOnDemandCmdLine#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceOnDemandCmdLine/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="groupName" /> имеет значение null или нулевую длину.</exception>
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DownloadFileGroupAsync">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает по требованию набор необязательных файлов в фоновом режиме.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Именованная группа файлов для загрузки. Для всех файлов, помеченных как "необязательные" в приложении [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], следует указать имя группы.</param>
        <summary>Загружает по требованию набор необязательных файлов в фоновом режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение во время инициализации или обновления не загружаются файлы, отмеченные как «необязательные» в манифесте приложения. Можно использовать <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> метод для загрузки всех файлов, принадлежащих именованную группу по требованию, так что они не используют сетевые ресурсы и места на диске пока не убедитесь, чтобы их. Такой подход работает не только для статических файлов, но также и для сборок, которые приложение может или не требоваться. Например некоторым пользователям может потребоваться использовать пакет для анализа данных включается в приложении на ежедневной основе, тогда может никогда не вызвать другим пользователям.  
  
 Загрузка сборок по требованию, присоединение прослушивателя событий для <xref:System.AppDomain.AssemblyResolve> события <xref:System.AppDomain.CurrentDomain%2A>. Пример см. в разделе [Пошаговое руководство: загрузка сборок по требованию с помощью API развертывания ClickOnce](http://msdn.microsoft.com/library/d20e2789-8621-4806-b5b7-841122da1456).  
  
 Все сборки загружаются [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] кэш приложения.  
  
 Все статические файлы загружаются в [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] каталог данных приложения и являются таким образом изолировано в текущей версии приложения. Предположим, что после приложение загружает в файловую группу, пользователь устанавливает новую версию приложения, но позже возвращается к предыдущей версии приложения. В этом случае предыдущая версия по-прежнему будет иметь копии файлов, изначально загруженном. Дополнительные сведения о доступе к статическим файлам см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 Вы можете загрузить одновременно с помощью нескольких файловых групп <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>. Позволяет отличать одну из них с помощью <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A> свойство <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> класс, который передается <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> событий. Если нужно передать более сложное состояние, можно использовать <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> для передачи в `state` объекта.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> работает в частично доверенных приложениях, то есть, в каком-либо [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение, работающее с ограниченными разрешениями. Тем не менее при попытке динамической загрузки сборок приложению потребуется полное доверие.  
  
 Загрузка файлов данных по требованию в настоящее время не поддерживается.  
  
 Не удается загрузить один файл только его имя файла. Чтобы загрузить один файл, назначьте его имя группы в вашей [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] развертывания и загрузки в группу с помощью этого метода.  
  
 Чтобы Отмена асинхронной операции загрузки, вызовите <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="groupName" /> имеет значение null или нулевую длину.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно одновременно инициировать более одной операции загрузки <paramref name="groupName" />.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName, System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="groupName">Именованная группа файлов для загрузки. Для всех файлов, помеченных как "необязательные" в приложении [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], следует указать имя группы.</param>
        <param name="userState">Произвольный объект, содержащий сведения о состоянии для асинхронной операции.</param>
        <summary>Загружает по требованию набор необязательных файлов в фоновом режиме и передает фрагмент состояния приложения обратным вызовам события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение во время инициализации или обновления не загружаются файлы, отмеченные как «необязательные» в манифесте приложения. Можно использовать <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> метод для загрузки всех файлов, принадлежащих именованную группу по требованию, так что они не используют сетевые ресурсы и места на диске пока не убедитесь, чтобы их. Такой подход работает не только для статических файлов, но также и для сборок, которые приложение может или не требоваться. Например некоторым пользователям может потребоваться использовать пакет для анализа данных включается в приложении на ежедневной основе, тогда может никогда не вызвать другим пользователям. Загрузка сборок по требованию, присоединение прослушивателя событий для <xref:System.AppDomain.AssemblyResolve> события <xref:System.AppDomain.CurrentDomain%2A>.  
  
 Одновременное скачивание нескольких файловых групп с помощью <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> метод. Позволяет отличать одну из них с помощью <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A> свойство <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> класс, который передается <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> событий. Если нужно передать более сложное состояние, можно использовать  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> для передачи в `state` объекта.  
  
 Все статические файлы загружаются в [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] каталог данных приложения и являются таким образом изолировано в текущей версии приложения. Дополнительные сведения о доступе к статическим файлам см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d). . Предположим, приложение загружает в файловую группу, пользователь устанавливает новую версию приложения, но более поздней версии пользователь возвращается к предыдущей версии приложения. В этом случае предыдущая версия по-прежнему будет иметь копии файлов, изначально загруженном.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> работает в частично доверенных приложениях, то есть, в каком-либо [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение, работающее с ограниченными разрешениями. Тем не менее при попытке динамической загрузки сборок приложению потребуется полное доверие.  
  
 Загрузка файлов данных по требованию в настоящее время не поддерживается.  
  
 Чтобы Отмена асинхронной операции загрузки, вызовите <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="groupName" /> имеет значение null или нулевую длину.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно одновременно инициировать более одной операции загрузки <paramref name="groupName" />.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsyncCancel">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsyncCancel (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsyncCancel(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsyncCancel (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsyncCancel(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Именованная группа файлов для загрузки. Для всех файлов, помеченных как "необязательные" в приложении [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], следует указать имя группы.</param>
        <summary>Отменяет асинхронную операцию загрузки файла.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="groupName" /> не может иметь значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupCompleted As DownloadFileGroupCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DownloadFileGroupCompletedEventHandler ^ DownloadFileGroupCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DownloadFileGroupCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит для главного потока приложения после завершения загрузки файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted> Событие вызывается для основного потока приложения. Это потока можно вызывать элементы управления приложения Windows Forms непосредственно внутри этого обратного вызова.  
  
 Проверьте <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> свойство <xref:System.ComponentModel.AsyncCompletedEventArgs> предоставленный для этого обратного вызова. Если это свойство имеет `null`, загрузка завершилась успешно; Если это не `null`, не удалось успешно завершить установку и можно найти дополнительные сведения об ошибке установки через <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода загружает группы файлов справки в фоновом режиме. В примере требуется развернуть приложение Windows Forms, которая включает <xref:System.Windows.Forms.StatusStrip> управления, а также этот элемент управления <xref:System.Windows.Forms.ToolStripStatusLabel> управления с именем `downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ DownloadFileGroupProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда доступны сведения о состоянии операции загрузки файла, инициированной вызовом <see cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> Событие вызывается для основного потока приложения. Это потока можно вызывать элементы управления приложения Windows Forms непосредственно внутри этого обратного вызова.  
  
 Используйте сведения, предоставленные в <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> для передачи сведений о ходе выполнения для пользователей.  
  
   
  
## Examples  
 В следующем примере кода загружает группы файлов справки в фоновом режиме. В примере требуется развернуть приложение Windows Forms, которая включает <xref:System.Windows.Forms.StatusStrip> управления, а также этот элемент управления <xref:System.Windows.Forms.ToolStripStatusLabel> управления с именем `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFileGroupDownloaded">
      <MemberSignature Language="C#" Value="public bool IsFileGroupDownloaded (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFileGroupDownloaded(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFileGroupDownloaded (groupName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFileGroupDownloaded(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Именованная группа файлов для загрузки. Для всех файлов, помеченных как "необязательные" в приложении [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], следует указать имя группы.</param>
        <summary>Проверяет, загружена ли уже именованная группа файлов на клиентском компьютере.</summary>
        <returns>
          Значение <see langword="true" />, если группа файлов уже была загружена для текущей версии данного приложения; в противном случае — значение <see langword="false" />. Если новая версия приложения была установлена, но при этом она не добавила, не удалила или же не изменила файлы в группе файлов, метод <see cref="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" /> вернет значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded%2A> работает в частично доверенном приложении без любых требований к безопасности.  
  
 При обновлении приложения, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] копирует все файлы данных по требованию из предыдущей версии в каталог данных новой версии. Если вы загрузите новые версии этих файлов, следует удалить все данные, которые вы хотите сохранить старой версии и переместите его в новой версии.  
  
   
  
## Examples  
 В следующем примере кода загружает все файлы в `HelpFiles` группы на диск.  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">
          <paramref name="groupName" /> не является группой файлов, заданной в манифесте приложения.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstRun">
      <MemberSignature Language="C#" Value="public bool IsFirstRun { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstRun" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsFirstRun" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstRun As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstRun { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое сообщает, выполняется ли данное приложение на клиентском компьютере впервые.</summary>
        <value>
          <see langword="true" />, если данная версия приложения никогда ранее не выполнялась на клиентском компьютере; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> для определения, следует ли выполнять никаких операций одноразовую инициализацию при первом запуске приложения.  
  
 Не следует полагать, что <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> параметр `true` указывает, что этот экземпляр приложения является первым из отображать свой пользовательский интерфейс для пользователя. Из-за того, система планирует процессов, один экземпляр приложения, возможно, его <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> свойство `true`, но другой экземпляр может быть первым для отображения на экране. Значение этого свойства сбрасывается всякий раз, когда пользователь обновляет из одной версии до следующего. Если вы хотите выполнить операцию только при первом запуске любой версии запустить приложение, необходимо будет выполнить дополнительную проверку, такие как проверка существования файл, созданный впервые, или хранение флаг с помощью **приложения Параметры**.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> решить, нужно ли проверить наличие обновлений для файловой группы `HelpFiles`. Если один или несколько файлов, была обновлена, она вызывает <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> получить новые версии.  
  
 [!code-csharp[ClickOnceAPI#9](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#9)]
 [!code-vb[ClickOnceAPI#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsNetworkDeployed">
      <MemberSignature Language="C#" Value="public static bool IsNetworkDeployed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsNetworkDeployed" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsNetworkDeployed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsNetworkDeployed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, является ли текущее приложение приложением [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</summary>
        <value>
          Значение <see langword="true" />, если приложение является приложением [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если требуется, чтобы приложение будет работать как внутри, так и за пределами [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] развертывания (например, если необходимо выполнить отладку перед развертыванием приложения на локальном компьютере), тест <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> перед обращением к <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> свойство.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> Возвращает `true` независимо от того, установлен или размещенного в сети приложения, а также независимо от того, был ли он установлен с веб-сайта, общей папки или компакт-диска.  
  
   
  
## Examples  
 Следующий код извлекает пример <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> с помощью <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> сначала, чтобы убедиться, что эта ссылка не является `null`.  
  
 [!code-cpp[ClickOnceAPI#2](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#2)]
 [!code-csharp[ClickOnceAPI#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="TimeOfLastUpdateCheck">
      <MemberSignature Language="C#" Value="public DateTime TimeOfLastUpdateCheck { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime TimeOfLastUpdateCheck" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfLastUpdateCheck As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime TimeOfLastUpdateCheck { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дату и время последней проверки на наличие обновлений для приложения [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</summary>
        <value>Класс <see cref="T:System.DateTime" /> последней проверки обновлений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение можно настроить для обновления подписки. В этом сценарии [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] опрашивает расположение развертывания приложения автоматически через интервалы, определенные в манифесте развертывания и определяет, существует ли обновление. <xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A> Возвращает время последней проверки наличия обновлений независимо от того, является ли она была начата подпиской или явную проверку с использованием <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>, <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A>, <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A>, <xref:System.Deployment.Application.ApplicationDeployment.Update%2A>, или <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> метод.  
  
 Если проверка обновления не выполнено, так как приложение было установлено, <xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A> Возвращает время установки.  
  
   
  
## Examples  
 В следующем примере кода в примере выполняется проверка ли [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложение проверки обновлений за последние три дня.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public bool Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.Update" />
      <MemberSignature Language="VB.NET" Value="Public Function Update () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Update();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует операцию синхронной загрузки и установки последней версии данного приложения.</summary>
        <returns>
          <see langword="true" />, если коллекция была обновлена; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение называется обновляется при публикации новой версии приложения в расположении, заданном <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>, и номер версии в манифесте развертывания приложения больше, чем номер версии приложения в настоящее время установлены на компьютере пользователя.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> Вызов блокируется, пока обновление загружено на компьютер клиента и устанавливается в [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] кэшировать; в течение этого времени приложение не будет отвечать на запросы для пользователя. Если вы хотите поддерживать скорость реагирования приложения или отображение отчета о состоянии во время загрузки, используйте <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> метод вместо него.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> загружает все файлы, которые не помечены как «необязательные» в манифесте приложения. Можно загрузить дополнительные файлы по требованию с помощью <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> или <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> метод.  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] могут уже обновление приложения автоматически при вызове <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> метод; Если это происходит, вызов этого метода вызывает исключение <xref:System.InvalidOperationException>.  
  
 Если вы обновили один или несколько файлов в развертывании, но манифест приложения не обновлялся, вы получите <xref:System.Deployment.Application.InvalidDeploymentException>. Большую часть времени, повторное развертывание вашей [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения может решить проблему. Это исключение также будет возникать, если подпись открытого ключа в манифест развертывания и манифест приложения отсутствует или является недопустимым.  
  
 Обновление может запросить более высокий уровень доверия на локальном компьютере, чем для предыдущей версии приложения. Если приложение использует развертывание надежных приложений, диспетчер доверия среды CLR проверяет манифест развертывания, чтобы определить, содержит ли лицензию доверия. Если манифест развертывания не содержит соответствующую лицензию доверия [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] установка будет прервана и возникает исключение <xref:System.Deployment.Application.TrustNotGrantedException>. <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> Метод никогда не будет отображать предложит пользователю о необходимости предоставить разрешение для запуска приложения.  
  
   
  
## Examples  
 В следующем примере кода проверяет наличие обновлений для приложения; Если обновление доступно, оно будет установлено синхронно.  
  
 [!code-cpp[ClickOnceAPI#6](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#6)]
 [!code-csharp[ClickOnceAPI#6](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#6)]
 [!code-vb[ClickOnceAPI#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">Локальный компьютер не предоставляет приложению запрошенный уровень разрешений для выполнения.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Развертывание [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] повреждено. Советы по диагностике и устранению проблем см. в разделе [Устранение неполадок развертывания ClickOnce](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32).</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Новое развертывание не удалось скачать из сетевого расположения.</exception>
        <exception cref="T:System.InvalidOperationException">Приложение в настоящий момент загружается.</exception>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsync">
      <MemberSignature Language="C#" Value="public void UpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует операцию асинхронной загрузки и установки последней версии данного приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение называется обновляется при публикации новой версии приложения в расположении, заданном <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>, и номер версии в манифесте развертывания приложения больше, чем номер версии приложения в настоящее время установлены на компьютере пользователя.  
  
 При загрузке обновления, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] вызовет <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> обработчик событий для основного потока приложения содержат состояние загрузки. После завершения асинхронного обновления, или возникает исключение, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] вызовет <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> событие для основного потока приложения. Изучите <xref:System.ComponentModel.AsyncCompletedEventArgs> предоставленный для этого события, чтобы определить, успешно ли выполнено обновление.  
  
 Если <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> вызывает исключение, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] вызовы <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> и задает <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> свойство <xref:System.ComponentModel.AsyncCompletedEventArgs> на исключение, вызванное исключение.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> все файлы загружаются в развертывании не помечен как «необязательные» в манифесте приложения. Можно загрузить дополнительные файлы по требованию с помощью <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> или <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> метод.  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] могут уже обновление приложения автоматически при вызове <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> метод; Если это происходит, вызов этого метода вызывает исключение <xref:System.InvalidOperationException>.  
  
 Если вы обновили один или несколько файлов в развертывании, но манифест приложения не обновлялся, вы получите <xref:System.Deployment.Application.InvalidDeploymentException>. В большинстве случаев, перестроение манифест приложения может решить проблему. Это исключение также будет возникать, если подпись открытого ключа в манифест развертывания и манифест приложения отсутствует или является недопустимым.  
  
 Обновление может запросить более высокий уровень доверия на локальном компьютере, чем для предыдущей версии приложения. Если приложение использует развертывание надежных приложений, диспетчер доверия среды CLR проверяет манифест развертывания, чтобы определить, содержит ли лицензию доверия. Если манифест развертывания не содержит соответствующую лицензию доверия [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] установка будет прервана и возникает исключение <xref:System.Deployment.Application.TrustNotGrantedException>. <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> никогда не будет отображаться запрос запросом, следует ли предоставить приложению разрешения для выполнения.  
  
   
  
## Examples  
 В следующем примере кода определяет, доступен ли новое обновление во время загрузки приложения. Если обязательное обновление доступно, оно будет установлено асинхронно. В примере требуется развернуть приложение Windows Forms, которая включает <xref:System.Windows.Forms.StatusStrip> управления, а также этот элемент управления <xref:System.Windows.Forms.ToolStripStatusLabel> управления с именем `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">Локальный компьютер не предоставляет приложению запрошенный уровень разрешений для выполнения.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Развертывание [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] повреждено. Советы по диагностике и устранению проблем см. в разделе [Устранение неполадок развертывания ClickOnce](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32).</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Новое развертывание не удалось скачать из сетевого расположения.</exception>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void UpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsyncCancel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет асинхронное обновление, инициированное методом <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A> только отменяет обновление инициировано вызов <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; он не отменяет обновление запущен в рамках подписки.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ UpdateCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] заканчивает обновлять приложение после вызова метода <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> Событие вызывается для основного потока приложения. Элементы управления приложения Windows Forms непосредственно внутри этого обратного вызова может вызвать без возникновения исключения.  
  
 Проверьте <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> свойство <xref:System.ComponentModel.AsyncCompletedEventArgs> предоставленный для этого обратного вызова. Если это свойство имеет `null`, что установка прошла успешно; Если это не `null`, не удалось успешно завершить установку и можно найти дополнительные сведения об этой ошибке установки через <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> свойство. После загрузки обновления необходимо вызвать <xref:System.Windows.Forms.Application.Restart%2A> метод <xref:System.Windows.Forms.Application> для использования новой версии приложения.  
  
 Если установка обновления была отменена с помощью вызова <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A>, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> свойство <xref:System.ComponentModel.AsyncCompletedEventArgs> класс будет `true`.  
  
 Чтобы использовать этот обработчик событий, приложение необходимо импортировать оба <xref:System.Deployment.Application> и <xref:System.ComponentModel> пространства имен.  
  
   
  
## Examples  
 В следующем примере кода определяет во время загрузки приложения доступно новое обновление; Если обязательное обновление доступно, оно будет установлено асинхронно. В примере требуется развернуть приложение Windows Forms, которая включает <xref:System.Windows.Forms.StatusStrip> управления, а также этот элемент управления <xref:System.Windows.Forms.ToolStripStatusLabel> управления с именем `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedApplicationFullName">
      <MemberSignature Language="C#" Value="public string UpdatedApplicationFullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UpdatedApplicationFullName" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedApplicationFullName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedApplicationFullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UpdatedApplicationFullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полное имя приложения после обновления.</summary>
        <value>Строка <see cref="T:System.String" />, содержащая полное имя приложения.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedVersion">
      <MemberSignature Language="C#" Value="public Version UpdatedVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version UpdatedVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ UpdatedVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает версию последнего загруженного обновления.</summary>
        <value>
          <see cref="T:System.Version" /> описывает версию обновления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> отличается от <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A> Если новое обновление установлено, но еще не вызван <xref:System.Windows.Forms.Application.Restart%2A> на <xref:System.Windows.Forms.Application>. Если манифест развертывания для приложения настроен на автоматическое выполнение обновлений, можно сравнить эти два значения, чтобы определить, следует ли перезапускать приложение.  
  
 Если приложение не была обновлена, <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> возвращает то же значение, что <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A>.  
  
   
  
## Examples  
 В следующем примере кода определяется метод, который определяет, является ли [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] обновил приложения.  
  
 [!code-cpp[ClickOnceAPI#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#4)]
 [!code-csharp[ClickOnceAPI#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#4)]
 [!code-vb[ClickOnceAPI#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateLocation">
      <MemberSignature Language="C#" Value="public Uri UpdateLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UpdateLocation" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateLocation As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UpdateLocation { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает веб-сайт или общую папку, из которой осуществлялось обновление приложения.</summary>
        <value>Путь обновления может ссылаться на HTTP, HTTPS, URL-адрес файла или сетевой путь Windows (UNC) к файлу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A> Возможно, веб-сайт, используемый для загрузки приложения изначально, если для развертывания приложения настроен для использования перенаправления обновления по.  
  
 Это значение может быть изменено только в манифесте развертывания приложения.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Для полного доступа к локальному компьютеру. Связанное перечисление: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ UpdateProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] содержит новые сведения о состоянии для операции обновления, инициированной вызовом метода <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> Событие вызывается для основного потока приложения. Элементы управления приложения Windows Forms непосредственно внутри этого обратного вызова может вызвать без возникновения исключения.  
  
   
  
## Examples  
 В следующем примере кода определяет во время загрузки приложения доступно новое обновление; Если обязательное обновление доступно, оно будет установлено асинхронно.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>