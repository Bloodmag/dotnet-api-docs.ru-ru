<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Contract.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac518ccddeb7c646934cfcc1b40673135a0998cbc53.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">18ccddeb7c646934cfcc1b40673135a0998cbc53</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</source>
          <target state="translated">Содержит статические методы для представления контрактов программы, таких как предусловие, постусловие и инвариантность объектов.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</source>
          <target state="translated">Классы контрактов кода позволяют указать предусловия, постусловия и инварианты объектов в коде.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Preconditions are requirements that must be met when entering a method or property.</source>
          <target state="translated">Предусловия — это требования, которые должны быть выполнены при входе в метод или свойство.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Postconditions describe expectations at the time the method or property code exits.</source>
          <target state="translated">Постусловия описывают ожидания во время выхода из кода метода или свойства.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Object invariants describe the expected state for a class that has no condition problems.</source>
          <target state="translated">Инварианты объектов описывают ожидаемое состояние для класса, который не представляет никаких проблем условие.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>For more information about preconditions, postconditions, and object invariants, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](~/docs/framework/debug-trace-profile/code-contracts.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о предусловия, постусловия и инварианты объектов см. в разделе <bpt id="p1">[</bpt>контракты для кода<ept id="p1">](~/docs/framework/debug-trace-profile/code-contracts.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>For tools and detailed instructions for using code contracts, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">Сведения о средствах и подробные инструкции по использованию контрактов кода см. на странице <bpt id="p1">[</bpt>Контракты кода<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> на веб-сайте MSDN DevLabs.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>You must use a binary rewriter to insert run-time enforcement of contracts.</source>
          <target state="translated">Необходимо использовать двоичный метод переопределения для вставки принудительного выполнения контрактов.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Otherwise, contracts such as the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType&gt;</ph> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</source>
          <target state="translated">Например, в противном случае контракты <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType&gt;</ph> метод могут быть проверены только статически и не вызывают исключений во время выполнения в случае нарушения контракта.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>You can download the binary rewriter CCRewrite from <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">Двоичный модуль записи CCRewrite можно загрузить из <bpt id="p1">[</bpt>контракты для кода<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> на сайте DevLabs MSDN.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> page.</source>
          <target state="translated">CCRewrite поставляется с надстройки Visual Studio, которая позволяет активировать принудительного выполнения контракта из проекта <bpt id="p1">**</bpt>свойства<ept id="p1">**</ept> страницы.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Diagnostics.Contracts.Contract">
          <source>The binary rewriter and the Visual Studio add-in do not ship with <ph id="ph1">[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]</ph> or the Windows SDK.</source>
          <target state="translated">Двоичный модуль записи и надстройки Visual Studio не поставляются с <ph id="ph1">[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]</ph> или Windows SDK.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>In debug builds, performs a run-time test for a specified condition.</source>
          <target state="translated">В отладочных построениях осуществляет проверку во время выполнения для указанного условия.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>Checks for a condition; if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>, follows the escalation policy set for the analyzer.</source>
          <target state="translated">Проверяет условие; если условие имеет значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, следует политике эскалации, установленной для анализатора.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>The default escalation policy is to notify the attached debugger about a contract failure or to display an <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> dialog box if a debugger is not attached.</source>
          <target state="translated">Политика расширения по умолчанию — уведомлять присоединенного отладчика о сбое контракта или отображения <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> диалоговое окно «», если не присоединен отладчик.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
          <source>Optionally, the analyzer can be instructed to throw an exception.</source>
          <target state="translated">При необходимости анализатору может быть рекомендовано для создания исключения.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>A message to display if the condition is not met.</source>
          <target state="translated">Сообщение, отображаемое при несоответствии условия.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>Checks for a condition; if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>, follows the escalation policy set by the analyzer and displays the specified message.</source>
          <target state="translated">Проверяет условие; если условие имеет значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, следует политике эскалации, установленной анализатором, и отображает указанное сообщение.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>The default escalation policy is to notify the attached debugger about a contract failure or to display an <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> dialog box if a debugger is not attached.</source>
          <target state="translated">Политика расширения по умолчанию — уведомлять присоединенного отладчика о сбое контракта или отображения <bpt id="p1">**</bpt>Assert<ept id="p1">**</ept> диалоговое окно «», если не присоединен отладчик.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>Optionally, the analyzer can be instructed to throw an exception.</source>
          <target state="translated">При необходимости анализатору может быть рекомендовано для создания исключения.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>The <ph id="ph1">`userMessage`</ph> parameter is passed to the debugger output.</source>
          <target state="translated"><ph id="ph1">`userMessage`</ph> Параметр передается в выходные данные отладчика.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, tools may not be able to read it.</source>
          <target state="translated">Если <ph id="ph1">`userMessage`</ph> не является строковой константы литерал, средства может отсутствовать на его чтение.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Instructs code analysis tools to assume that a condition is <ph id="ph1">&lt;see langword="true" /&gt;</ph>, even if it cannot be statically proven to always be <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Инструктирует инструменты анализа кода полагать, что условием является <ph id="ph1">&lt;see langword="true" /&gt;</ph>, даже если статически невозможно подтвердить постоянное значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)">
          <source>The conditional expression to assume <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Предполагаемое условное выражение <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)">
          <source>Instructs code analysis tools to assume that the specified condition is <ph id="ph1">&lt;see langword="true" /&gt;</ph>, even if it cannot be statically proven to always be <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Инструктирует инструменты анализа кода полагать, что указанным условием является <ph id="ph1">&lt;see langword="true" /&gt;</ph>, даже если статически невозможно подтвердить постоянное значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)">
          <source>At run time, using this method is equivalent to using the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Во время выполнения с помощью этого метода эквивалентно использованию <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>The conditional expression to assume <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Предполагаемое условное выражение <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>The message to post if the assumption fails.</source>
          <target state="translated">Сообщение, создаваемое при ошибочном предположении.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>Instructs code analysis tools to assume that a condition is <ph id="ph1">&lt;see langword="true" /&gt;</ph>, even if it cannot be statically proven to always be <ph id="ph2">&lt;see langword="true" /&gt;</ph>, and displays a message if the assumption fails.</source>
          <target state="translated">Инструктирует инструменты анализа кода полагать, что условием является <ph id="ph1">&lt;see langword="true" /&gt;</ph>, даже если статически невозможно подтвердить постоянное значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и отображает сообщение, если предположение было ошибочным.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, the contract may not be understood by tools.</source>
          <target state="translated">Если <ph id="ph1">`userMessage`</ph> не является строковой константы литерал, контракт может быть не распознан средствами.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
          <source>At run time, using this method is equivalent to using the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Во время выполнения с помощью этого метода эквивалентно использованию <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Occurs when a contract fails.</source>
          <target state="translated">Происходит, когда контракт не выполняется.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>The event information for this event is supplied by the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType&gt;</ph> object that is passed to the event handler.</source>
          <target state="translated">Сведения о событии для этого события является результатом <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType&gt;</ph> объект, передаваемый обработчику событий.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</source>
          <target state="translated">Это событие сообщает среде управляемого приложения, такие как интерактивный интерпретатор или веб-узел браузера, что контракт не удался.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Before doing so, it will raise an event that an application can handle as it sees fit.</source>
          <target state="translated">Прежде чем сделать это, он будет вызывать событие, которое приложение может обрабатывать, как считает нужным.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>For example, if code is being run in a testing framework, you can log a test failure and then end the test.</source>
          <target state="translated">Например если код запускается в среде тестирования, можно войти сбоя теста и затем завершить тест.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A&gt;</ph> method in the .NET Framework class library is to call each handler that is registered with the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.ContractFailed&gt;</ph> event.</source>
          <target state="translated">Реализация по умолчанию <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A&gt;</ph> метод в библиотеке классов .NET Framework — вызывает каждый обработчик, зарегистрированный в <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract.ContractFailed&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A&gt;</ph> method for the event arguments.</source>
          <target state="translated">Исключения, создаваемые обработчики учитываются, но каждый обработчик можно указать, является ли сбой обрабатывается путем вызова <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A&gt;</ph> метод для аргументов событий.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>If any handler sets the failure as handled, the method returns <ph id="ph1">`null`</ph> and no further action is taken.</source>
          <target state="translated">Если обработчик устанавливает сбой как обработанное, метод возвращает <ph id="ph1">`null`</ph> и никакие дополнительные действия не выполняются.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>Alternatively, handlers can call the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A&gt;</ph> method to instruct the code to unwind.</source>
          <target state="translated">Кроме того, можно вызывать обработчики <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A&gt;</ph> метод, чтобы указать код для очистки.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>In that case, an exception is thrown after all handlers have executed.</source>
          <target state="translated">В этом случае исключение после выполнения всех обработчиков.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Diagnostics.Contracts.Contract.ContractFailed">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>Marks the end of the contract section when a method's contracts contain only preconditions in the <ph id="ph1">&lt;see langword="if" /&gt;</ph><ph id="ph2">-</ph><ph id="ph3">&lt;see langword="then" /&gt;</ph><ph id="ph4">-</ph><ph id="ph5">&lt;see langword="throw" /&gt;</ph> form.</source>
          <target state="translated">Помечает конец раздела контракта, когда контракты метода содержат только предусловия вида <ph id="ph1">&lt;see langword="if" /&gt;</ph><ph id="ph2">-</ph><ph id="ph3">&lt;see langword="then" /&gt;</ph><ph id="ph4">-</ph><ph id="ph5">&lt;see langword="throw" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>Most code already contains some parameter validation in the form of <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> code.</source>
          <target state="translated">Большая часть кода уже содержит определенную проверку параметров в виде <ph id="ph1">`if`</ph> <ph id="ph2">-</ph> <ph id="ph3">`then`</ph> <ph id="ph4">-</ph> <ph id="ph5">`throw`</ph> кода.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>The contract tools recognize <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <ph id="ph6">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> method call, such as a <ph id="ph7">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A&gt;</ph>, or <ph id="ph10">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph>.</source>
          <target state="translated">Средства контракта распознают <ph id="ph1">`if`</ph> <ph id="ph2">-</ph> <ph id="ph3">`then`</ph> <ph id="ph4">-</ph> <ph id="ph5">`throw`</ph> операторы как предусловия при операторы идут первыми внутри метода, и следуют явные всегонаборатакихоператоров<ph id="ph6">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> вызов метода, такие как <ph id="ph7">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph>, <ph id="ph9">&lt;xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A&gt;</ph>, или <ph id="ph10">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>When <ph id="ph1">`if`</ph><ph id="ph2">-</ph><ph id="ph3">`then`</ph><ph id="ph4">-</ph><ph id="ph5">`throw`</ph> statements appear in this form, the contract tools recognize them as legacy-require statements.</source>
          <target state="translated">Когда <ph id="ph1">`if`</ph> <ph id="ph2">-</ph> <ph id="ph3">`then`</ph> <ph id="ph4">-</ph> <ph id="ph5">`throw`</ph> операторы появляются в этой форме, средства контракта распознают их как устаревшие-инструкции.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
          <source>The <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> form is used only if no other contracts follow the <ph id="ph2">`if`</ph><ph id="ph3">-</ph><ph id="ph4">`then`</ph><ph id="ph5">-</ph><ph id="ph6">`throw`</ph> sequences, but they should still be tagged as legacy-requires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A&gt;</ph> Используется только в том случае, если нет других контрактов <ph id="ph2">`if`</ph> <ph id="ph3">-</ph> <ph id="ph4">`then`</ph> <ph id="ph5">-</ph> <ph id="ph6">`throw`</ph> последовательности, но они по-прежнему должен быть отмечен как устаревший-требуется.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a postcondition contract for the enclosing method or property.</source>
          <target state="translated">Указывает контракт постусловия для включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The expression may include <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph> values.</source>
          <target state="translated">Выражение может включать значения <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /&gt;</ph> и <ph id="ph3">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>Specifies a postcondition contract for the enclosing method or property.</source>
          <target state="translated">Указывает контракт постусловия для включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property returns normally.</source>
          <target state="translated"><ph id="ph1">`condition`</ph> Указывает постусловие, для которого должно быть <ph id="ph2">`true`</ph> при включающего метода или свойства возвращаются в обычном режиме.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>You must use the binary rewriter (available at <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</source>
          <target state="translated">Необходимо использовать двоичный метод переопределения (найти по адресу <bpt id="p1">[</bpt>контракты для кода<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> на сайте DevLabs MSDN) для принудительного выполнения данного постусловия.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> method to ensure that an expected value is returned.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> метод, чтобы гарантировать, что возвращается с ожидаемым значением.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The expression may include <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph> values.</source>
          <target state="translated">Выражение может включать значения <ph id="ph1">&lt;see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /&gt;</ph> и <ph id="ph2">&lt;see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The message to display if the expression is not <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Сообщение, отображаемое в том случае, если выражение не является <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Указывает контракт постусловия для предоставленного выходного условия и сообщение, отображаемое, если условие имеет значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property returns normally.</source>
          <target state="translated"><ph id="ph1">`condition`</ph> Указывает постусловие, для которого должно быть <ph id="ph2">`true`</ph> при включающего метода или свойства возвращаются в обычном режиме.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>You must use the binary rewriter (available at <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</source>
          <target state="translated">Необходимо использовать двоичный метод переопределения (найти по адресу <bpt id="p1">[</bpt>контракты для кода<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> на сайте DevLabs MSDN) для принудительного выполнения данного постусловия.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, the contract may not be understood by tools.</source>
          <target state="translated">Если <ph id="ph1">`userMessage`</ph> не является строковой константы литерал, контракт может быть не распознан средствами.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</source>
          <target state="translated">Задает контракт постусловия для включающего метода или свойства на основе предоставленных исключения и состояния.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>The type of exception that invokes the postcondition check.</source>
          <target state="translated">Тип исключения, вызвавшего проверку постусловия.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</source>
          <target state="translated">Задает контракт постусловия для включающего метода или свойства на основе предоставленных исключения и состояния.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property terminates abnormally and an exception of type <ph id="ph3">`TException`</ph> is thrown.</source>
          <target state="translated"><ph id="ph1">`condition`</ph> Указывает постусловие, для которого должно быть <ph id="ph2">`true`</ph> при включающего метода или свойства аварийно завершает работу и исключение типа <ph id="ph3">`TException`</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
          <source>You must use the binary rewriter for run-time enforcement of this postcondition.</source>
          <target state="translated">Необходимо использовать двоичный метод переопределения для принудительного выполнения данного постусловия.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The type of exception that invokes the postcondition check.</source>
          <target state="translated">Тип исключения, вызвавшего проверку постусловия.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The message to display if the expression is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Отображаемое сообщение при выражении <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>Specifies a postcondition contract and a message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph> for the enclosing method or property, based on the provided exception and condition.</source>
          <target state="translated">Задает контракт постусловия и сообщение, которое необходимо отобразить, если условие имеет значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, для включающего метода или свойства на основе предоставленных исключения и условия.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The <ph id="ph1">`condition`</ph> parameter specifies a postcondition that is expected to be <ph id="ph2">`true`</ph> when the enclosing method or property terminates abnormally and an exception of type <ph id="ph3">`TException`</ph> is thrown.</source>
          <target state="translated"><ph id="ph1">`condition`</ph> Указывает постусловие, для которого должно быть <ph id="ph2">`true`</ph> при включающего метода или свойства аварийно завершает работу и исключение типа <ph id="ph3">`TException`</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>The <ph id="ph1">`message`</ph> parameter specifies a message to display if the condition is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`message`</ph> Параметр задает сообщение, отображаемое, если условие равно <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>You must use the binary rewriter for run-time enforcement of this postcondition.</source>
          <target state="translated">Необходимо использовать двоичный метод переопределения для принудительного выполнения данного постусловия.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
          <source>If <ph id="ph1">`userMessage`</ph> is not a constant string literal, the contract may not be understood by tools.</source>
          <target state="translated">Если <ph id="ph1">`userMessage`</ph> не является строковой константы литерал, контракт может быть не распознан средствами.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The first integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Первое целое число для передачи в <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>One more than the last integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Последнее целое число для передачи в <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The function to evaluate for any value of the integer in the specified range.</source>
          <target state="translated">Функция, оцениваемая на предмет любого значения целого числа в указанном диапазоне.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>Determines whether a specified test is true for any integer within a range of integers.</source>
          <target state="translated">Определяет, удовлетворяет ли проверке какое-либо целое число в диапазоне целых чисел.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for any integer starting from <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> to <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> - 1.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph> для любого целого числа, начиная от <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> до <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> минус один.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The <ph id="ph1">`toExclusive`</ph> parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</source>
          <target state="translated"><ph id="ph1">`toExclusive`</ph> Параметр принадлежит к одному больше, чем последнее целое число для облегчения использования длины диапазон целых чисел, начиная с 0.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>For example, it would be set to 5 for integers 0 through 4.</source>
          <target state="translated">Например оно устанавливается равным 5 для целых чисел от 0 до 4.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> меньше <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The type that is contained in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Тип, который содержится в <bpt id="p1">&lt;c&gt;</bpt>коллекции<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The collection from which elements of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> will be drawn to pass to <bpt id="p2">&lt;c&gt;</bpt>predicate<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Коллекция, из которой будут извлекаться элементы типа <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> для передачи в <bpt id="p2">&lt;c&gt;</bpt>predicate<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The function to evaluate for an element in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Функция, оцениваемая на предмет элемента, содержащегося в параметре <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>Determines whether an element within a collection of elements exists within a function.</source>
          <target state="translated">Определяет, существует ли в рамках функции элемент в указанной коллекции элементов.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if and only if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for any element of type <ph id="ph4">&lt;paramref name="T" /&gt;</ph> in <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если и только если <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> возвращает значение <ph id="ph3">&lt;see langword="true" /&gt;</ph> для любого из элементов типа <ph id="ph4">&lt;paramref name="T" /&gt;</ph>, содержащихся в параметре <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> or <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> или <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The first integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Первое целое число для передачи в <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>One more than the last integer to pass to <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Последнее целое число для передачи в <bpt id="p1">&lt;c&gt;</bpt>predicate<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The function to evaluate for the existence of the integers in the specified range.</source>
          <target state="translated">Функция, оцениваемая, чтобы установить существование целых чисел в указанном диапазоне.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>Determines whether a particular condition is valid for all integers in a specified range.</source>
          <target state="translated">Определяет, выполняется ли определенное условие для всех целых чисел в указанном диапазоне.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for all integers starting from <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> to <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> - 1.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph> для всех целых чисел, начиная от <ph id="ph4">&lt;paramref name="fromInclusive" /&gt;</ph> до <ph id="ph5">&lt;paramref name="toExclusive" /&gt;</ph> минус один.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The <ph id="ph1">`toExclusive`</ph> parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</source>
          <target state="translated"><ph id="ph1">`toExclusive`</ph> Параметр принадлежит к одному больше, чем последнее целое число для облегчения использования длины диапазон целых чисел, начиная с 0.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>For example, it would be set to 5 for integers 0 through 4.</source>
          <target state="translated">Например оно устанавливается равным 5 для целых чисел от 0 до 4.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> method to determine whether an array has a null element.</source>
          <target state="translated">В следующем примере демонстрируется использование <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> метод, чтобы определить, имеет ли массив элемент null.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="predicate" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="toExclusive" /&gt;</ph> меньше <ph id="ph2">&lt;paramref name="fromInclusive" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The type that is contained in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Тип, который содержится в <bpt id="p1">&lt;c&gt;</bpt>коллекции<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The collection from which elements of type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> will be drawn to pass to <bpt id="p2">&lt;c&gt;</bpt>predicate<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Коллекция, из которой будут извлекаться элементы типа <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> для передачи в <bpt id="p2">&lt;c&gt;</bpt>predicate<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The function to evaluate for the existence of all the elements in <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Функция, оцениваемая на предмет наличия всех элементов, содержащихся в параметре <bpt id="p1">&lt;c&gt;</bpt>collection<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>Determines whether all the elements in a collection exist within a function.</source>
          <target state="translated">Определяет, существуют ли в рамках функции все элементы в коллекции.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if and only if <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph> for all elements of type <ph id="ph4">&lt;paramref name="T" /&gt;</ph> in <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если и только если <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> возвращает значение <ph id="ph3">&lt;see langword="true" /&gt;</ph> для всех элементов типа <ph id="ph4">&lt;paramref name="T" /&gt;</ph>, содержащихся в параметре <ph id="ph5">&lt;paramref name="collection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> method to determine whether a collection has a null element.</source>
          <target state="translated">В следующем примере демонстрируется использование <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ForAll%2A&gt;</ph> метод, чтобы определить, содержит ли коллекция элемент null.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> or <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="collection" /&gt;</ph> или <ph id="ph2">&lt;paramref name="predicate" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a contract for an enclosing method or property.</source>
          <target state="translated">Указывает контракт для включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>Specifies an invariant contract for the enclosing method or property.</source>
          <target state="translated">Задает инвариантный контракт ля включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> contracts are contained within a method that is identified by the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attribute; typically, the method is named <ph id="ph3">`ObjectInvariant`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> контракты внутри метода, который определяется параметром <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> атрибут; как правило, метод с именем <ph id="ph3">`ObjectInvariant`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>This contract can be specified only in a dedicated invariant method that is declared on a class.</source>
          <target state="translated">Этот контракт может быть указаны только в выделенной инвариантный метод, который объявлен в классе.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</source>
          <target state="translated">Если метод не запечатан, он должен указывать только на защищенные члены, не закрытые члены, чтобы быть уверенным в поддержке инвариантов подклассов.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</source>
          <target state="translated">Этот контракт не открыт для клиентов; Таким образом он может ссылаться на элементы, которые менее видимы, чем у включающего метода.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>You must use the binary rewriter for run-time enforcement of this invariant.</source>
          <target state="translated">Необходимо использовать двоичный метод переопределения для принудительного выполнения данной инвариантности.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>Invariants are conditionally defined based on the presence of the <ph id="ph1">`CONTRACTS FULL`</ph> symbol.</source>
          <target state="translated">Инварианты условно определяются на основе наличия из <ph id="ph1">`CONTRACTS FULL`</ph> символов.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>During run-time checking, invariants are checked at the end of each public method.</source>
          <target state="translated">При проверке во время выполнения инварианты проверяются в конце каждого открытого метода.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</source>
          <target state="translated">Если инвариант упоминает открытый метод в том же классе, проверка инварианта, которая обычно происходит в конце этого открытого метода отключены и проверяется только в конце самого внешнего вызова метода для этого класса.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
          <source>This also happens if the class is re-entered because of a call to a method on another class.</source>
          <target state="translated">Это также происходит, если класс повторно вводится в результате вызова метода в другом классе.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>The message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Отображаемое сообщение при условии <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</source>
          <target state="translated">Указывает инвариантный контракт для включающего метода или свойства и отображает сообщение, если условие для контракта не выполняется.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> contracts are contained within a method that is identified by the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> attribute; typically, the method is named <ph id="ph3">`ObjectInvariant`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Invariant%2A&gt;</ph> контракты внутри метода, который определяется параметром <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute&gt;</ph> атрибут; как правило, метод с именем <ph id="ph3">`ObjectInvariant`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>This contract can be specified only in a dedicated invariant method that is declared on a class.</source>
          <target state="translated">Этот контракт может быть указаны только в выделенной инвариантный метод, который объявлен в классе.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</source>
          <target state="translated">Этот контракт не открыт для клиентов; Таким образом он может ссылаться на элементы, которые менее видимы, чем у включающего метода.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>You must use the binary rewriter for run-time enforcement of this invariant.</source>
          <target state="translated">Необходимо использовать двоичный метод переопределения для принудительного выполнения данной инвариантности.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>Invariants are conditionally defined on the <ph id="ph1">`CONTRACTS FULL`</ph> symbol.</source>
          <target state="translated">Инварианты условно определяются на <ph id="ph1">`CONTRACTS FULL`</ph> символов.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>During run-time checking, invariants are checked at the end of each public method.</source>
          <target state="translated">При проверке во время выполнения инварианты проверяются в конце каждого открытого метода.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</source>
          <target state="translated">Если инвариант упоминает открытый метод в том же классе, проверка инварианта, которая обычно происходит в конце этого открытого метода отключены и проверяется только в конце самого внешнего вызова метода для этого класса.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
          <source>This also happens if the class is re-entered because of a call to a method on another class.</source>
          <target state="translated">Это также происходит, если класс повторно вводится в результате вызова метода в другом классе.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The type of value.</source>
          <target state="translated">Тип значения.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The value to represent (field or parameter).</source>
          <target state="translated">Представляемое значение (поле или параметр).</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>Represents values as they were at the start of a method or property.</source>
          <target state="translated">Представляет значения, какими они были в начале метода или свойства.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The value of the parameter or field at the start of a method or property.</source>
          <target state="translated">Значение параметра или поля при запуске метода или свойства.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>This method can be used only in the conditional expression for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contract.</source>
          <target state="translated">Этот метод может использоваться только в условного выражения для <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> контракта.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>The following example shows the use of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> method to ensure that a count has been updated.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> метод, чтобы гарантировать, что подсчет был обновлен.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="T:System.Diagnostics.Contracts.Contract">
          <source>Specifies a precondition contract for an enclosing method or property.</source>
          <target state="translated">Указывает контракт предусловия для включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>Specifies a precondition contract for the enclosing method or property.</source>
          <target state="translated">Указывает контракт предусловия для включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> method when backward compatibility does not force you to throw a particular exception.</source>
          <target state="translated">Используйте этот метод вместо <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> метод при обратной совместимости не заставляет выдачи исключения.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>The message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Отображаемое сообщение при условии <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</source>
          <target state="translated">Указывает контракт предусловия для включающего метода или свойства и отображает сообщение, если условие для контракта не выполняется.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method when backward compatibility does not force you to throw a particular exception.</source>
          <target state="translated">Используйте этот метод вместо <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> метод при обратной совместимости не заставляет выдачи исключения.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>The exception to throw if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Выдаваемое исключение при условии <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</source>
          <target state="translated">Указывает контракт предусловия для включающего метода или свойства и выдает исключение, если условие для контракта не выполняется.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>You must turn on run-time checking to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> method.</source>
          <target state="translated">Необходимо включить проверки для использования во время выполнения <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>If run-time checking is turned off, the process will be terminated.</source>
          <target state="translated">Если проверки во время выполнения отключен, процесс будет завершен.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>To obtain the tools for runtime checking, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">Чтобы получить средства проверки среды выполнения, см. <bpt id="p1">[</bpt>контракты для кода<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> на сайте DevLabs MSDN.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> method when you want to throw an exception if the precondition fails.</source>
          <target state="translated">Используйте этот метод вместо <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> метод для создания исключения, если условие сбоя.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>The exception to throw if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Выдаваемое исключение при условии <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>The conditional expression to test.</source>
          <target state="translated">Условное выражение, которое требуется подвергнуть проверке.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>The message to display if the condition is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Отображаемое сообщение при условии <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</source>
          <target state="translated">Задает контракт предусловия для включающего метода или свойства и создает исключение с предоставленным сообщением, если условие для контракта не выполняется.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>You must turn on run-time checking to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> method.</source>
          <target state="translated">Необходимо включить проверки для использования во время выполнения <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>If run-time checking is turned off, the process will be terminated.</source>
          <target state="translated">Если проверки во время выполнения отключен, процесс будет завершен.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>To obtain the tools for runtime checking, see <bpt id="p1">[</bpt>Code Contracts<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> on the MSDN DevLabs Web site.</source>
          <target state="translated">Чтобы получить средства проверки среды выполнения, см. <bpt id="p1">[</bpt>контракты для кода<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=152461)</ept> на сайте DevLabs MSDN.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>This method call must be at the beginning of a method or property, before any other code.</source>
          <target state="translated">Вызов этого метода должен быть в начале метода или свойства, перед любым другим кодом.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</source>
          <target state="translated">Этот контракт открыт для клиентов; Таким образом он должен ссылаться только на члены, по крайней мере видимость внешнего метода.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
          <source>Use this method instead of the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method when you want to throw an exception if the precondition fails.</source>
          <target state="translated">Используйте этот метод вместо <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> метод для создания исключения, если условие сбоя.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>Type of return value of the enclosing method or property.</source>
          <target state="translated">Тип возвращаемого значения включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>Represents the return value of a method or property.</source>
          <target state="translated">Представляет возвращаемое значение метода или свойства.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>Return value of the enclosing method or property.</source>
          <target state="translated">Возвращаемое значение включающего метода или свойства.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>This method can be used only in the conditional expression for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contract.</source>
          <target state="translated">Этот метод может использоваться только в условного выражения для <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> контракта.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Result%2A&gt;</ph> method to specify an expected return value.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Result%2A&gt;</ph> метод, чтобы указать ожидаемое возвращаемое значение.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.Result``1">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.ContractClassAttribute&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The type of the <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter.</source>
          <target state="translated">Тип параметра <ph id="ph1">&lt;see langword="out" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;see langword="out" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>Represents the final (output) value of an <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter when returning from a method.</source>
          <target state="translated">Представляет итоговое (выходное) значение параметра <ph id="ph1">&lt;see langword="out" /&gt;</ph> по возвращении из метода.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The output value of the <ph id="ph1">&lt;see langword="out" /&gt;</ph> parameter.</source>
          <target state="translated">Выходное значение параметра <ph id="ph1">&lt;see langword="out" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>This method can be used only in the conditional expression for the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> contract.</source>
          <target state="translated">Этот метод может использоваться только в условного выражения для <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.Ensures%2A&gt;</ph> контракта.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>As with the <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</source>
          <target state="translated">Как и в методе <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.OldValue%2A&gt;</ph>, вы можете опустить параметр универсального типа там, где компилятор способен вывести его тип.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The contract rewriter replaces the method call with the value of the <ph id="ph1">`out`</ph> parameter.</source>
          <target state="translated">Модуль переопределения контракта заменяет вызов метода значением параметра <ph id="ph1">`out`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> method may appear only in postconditions.</source>
          <target state="translated">Метод <ph id="ph1">&lt;xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A&gt;</ph> может появляться только в постусловиях.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The argument to the method must be an <ph id="ph1">`out`</ph> parameter or a field of a structure <ph id="ph2">`out`</ph> parameter.</source>
          <target state="translated">Аргумент метода должен быть параметром <ph id="ph1">`out`</ph> или полем параметра <ph id="ph2">`out`</ph> структуры.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
          <source>The latter is also useful when referring to fields in the postcondition of a structure constructor.</source>
          <target state="translated">Последний вариант также полезен при ссылке на поля в постусловии конструктора структуры.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>