<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ab683a58bdb6ba8eb978fb164cb7aa4c138637c7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30400518" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет компонент счетчика производительности Windows NT.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter> Компонент может использоваться для чтения существующих стандартных или пользовательских счетчиков и публикации (записи) производительности данных пользовательских счетчиков.  
  
 Существует множество предопределенных счетчиков, перечисленных в системном мониторе Windows [диалоговое окно «Добавить счетчики»](http://go.microsoft.com/fwlink/p/?LinkId=257854). Дополнительные сведения о счетчиках производительности .NET Framework см. в разделе [счетчики производительности](~/docs/framework/debug-trace-profile/performance-counters.md).  
  
 Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
> [!IMPORTANT]
>  В версиях 1.0 и 1.1 платформы .NET Framework для этого класса требуется непосредственных вызывающих объектов с полным доверием. Начиная с .NET Framework версии 2.0, для этого класса требуется <xref:System.Diagnostics.PerformanceCounterPermission> для выполнения конкретных действий. Настоятельно рекомендуется, <xref:System.Diagnostics.PerformanceCounterPermission> не предоставляется коду с частичным доверием.  Возможность чтения и записи счетчиков производительности позволяет коду выполнять действия, такие как перечисление выполняющихся процессов и получение информации о них.  
>   
>  Кроме того, передача <xref:System.Diagnostics.PerformanceCounter> менее доверенного кода, который можно создать угрозу безопасности. Никогда не передавать производительности счетчик объектов, таких как <xref:System.Diagnostics.PerformanceCounterCategory> или <xref:System.Diagnostics.PerformanceCounter>в менее надежный код.  
  
 Для чтения из счетчика производительности, создайте экземпляр <xref:System.Diagnostics.PerformanceCounter> класса, задайте <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и, возможно, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> или <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойства, а затем вызовите <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> метод, чтобы использовать производительности считывание счетчика.  
  
 Чтобы опубликовать данные счетчиков производительности, создание одного или нескольких пользовательских счетчиков с помощью <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> метод, создайте экземпляр класса <xref:System.Diagnostics.PerformanceCounter> класса, задайте <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> и, возможно, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> или <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойств а затем вызвать <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, или <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> методы или набор <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойства для изменения значения счетчика.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, И <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> методы используют блокировка для обновления значения счетчика. Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойство непосредственно до 5 раз улучшения производительности.  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.  
  
 Счетчик — это механизм, по производительности, какие данные собираются. Реестр хранит имена всех счетчиков, каждый из которых относится к определенной части функциональных возможностей системы. Примеры включают время занятости процессора, использование памяти или число байтов, полученных через сетевое подключение.  
  
 Каждый счетчик однозначно идентифицируется по его имени и расположения. Таким же образом, путь к файлу включает диск, каталог, один или несколько подкаталогов и имя файла, информация счетчика состоит из четырех элементов: компьютера, категории, экземпляра категории и имени счетчика.  
  
 Сведения о счетчике должен включать категории, или объект, счетчик измеряет данные. Категории компьютера включают физические компоненты, такие как процессоры, диски и память. Существуют также системные категории, например, процессы и потоки. Каждая категория относится к функциональному элементу на компьютере и имеет набор стандартных счетчиков, присвоенных ему. Эти объекты перечислены в раскрывающемся списке объекта производительности диалогового окна "Добавить счетчики" в системном мониторе Windows 2000, и их необходимо включить в путь счетчика. Данные производительности сгруппированы по категориям, к которым они относятся.  
  
 В некоторых случаях может существовать несколько копий одной категории. Например одновременно запускать несколько процессов и потоков, а некоторые компьютеры могут иметь более одного процессора. Копии категорий называются экземплярами категорий, и каждый экземпляр имеет набор стандартных счетчиков, назначенного ей. Если категория имеет более одного экземпляра, спецификация экземпляра должна включаться в информацию счетчика.  
  
 Чтобы получить данные о производительности для счетчиков, требующих начальное или предыдущее значение для выполнения необходимых вычислений, вызовите <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> два раза метод и использовать возвращаемую информацию по требованию приложения.  
  
> [!NOTE]
>  Категории счетчиков производительности, установленных с [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] использовать отдельную общую память, у каждого счетчика производительности есть свою собственную память. Можно указать размер отдельной общей памяти путем создания DWORD с именем FileMappingSize в ключе реестра HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<имя категории >* \ Производительность. Значение FileMappingSize установлен размер общей памяти категории. Размер по умолчанию составляет 131072 десятичное число. Если отсутствует значение FileMappingSize `fileMappingSize` значение атрибута для `performanceCounters` используется элемент, указанный в файле Machine.config, вызывает дополнительную нагрузку для обработки файла конфигурации. Можно значительно более высокую производительность для запуска приложения, установив размер файла сопоставления в реестре. Дополнительные сведения о размере файла сопоставления см. в разделе [ &lt;performanceCounters&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Diagnostics.PerformanceCounter> класс для создания и использования <xref:System.Diagnostics.PerformanceCounterType.AverageCount64> счетчика типа. Пример создает категорий, настраивает счетчики, сбор данных счетчиков и вызовы <xref:System.Diagnostics.CounterSampleCalculator> класса для интерпретации данных счетчиков производительности. Промежуточные и окончательные результаты отображаются в окне консоли. Дополнительные примеры других типов счетчиков производительности см. в разделе <xref:System.Diagnostics.PerformanceCounterType> перечисления.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот класс не может использоваться частично доверенным кодом.</permission>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.PerformanceCounter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" />, не связывая этот экземпляр с каким-нибудь системным или определенным пользователем счетчиком производительности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> свойства пустые строки ("») и задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойства на локальном компьютере (».»).  
  
 Этот конструктор не инициализирует счетчик производительности, поэтому связывает экземпляр с существующим счетчиком на локальном компьютере. Чтобы указать конкретный счетчик производительности, задайте <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и, возможно, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойства перед считыванием других свойств или при попытке чтения из счетчика. Чтобы записать в счетчик производительности, задайте <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> свойства `false`.  
  
> [!NOTE]
>  <xref:System.Security.Permissions.HostProtectionAttribute> Применен к этому члену атрибут имеет следующее <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A> значение свойства: <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState>. Атрибут <xref:System.Security.Permissions.HostProtectionAttribute> не оказывает влияния на настольные приложения (обычно запускаемые двойным щелчком значка, вводом команды или URL-адреса в браузере). Дополнительные сведения см. в разделе <xref:System.Security.Permissions.HostProtectionAttribute> класса или [программирование SQL Server и атрибуты защиты основного приложения](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md).  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр по умолчанию <xref:System.Diagnostics.PerformanceCounter> класса. После создания экземпляра <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> значения свойств, набор, а результаты вызова <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> метод отображаются.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности на локальном компьютере. Этот конструктор требует, чтобы категория имела единственный экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Используйте эту перегрузку для доступа к счетчику на локальном компьютере, к которому относится к категории, содержащей единственный экземпляр счетчика производительности категории. При попытке использовать этот конструктор для указания <xref:System.Diagnostics.PerformanceCounter> экземпляра или категорию, содержащую несколько экземпляров, конструктор выдаст исключение. Эта перегрузка может получить доступ к любой доступный только для чтения или чтения и записи счетчик, но делает это в режиме только для чтения. Объект <xref:System.Diagnostics.PerformanceCounter> экземпляром, созданным с помощью этой перегрузки не удается записать в счетчик, даже если этот счетчик доступен для чтения и записи.  
  
 Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> значения для свойств, передайте, задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойство на локальном компьютере».» и задает <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> свойства равным пустой строке (»»).  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> свойства должен указывать на существующий счетчик производительности на локальном компьютере.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
 - или -  
  
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
 - или -  
  
 Указанная категория не существует.  
  
 - или -  
  
 Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
 - или -  
  
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="readOnly">
          Значение <see langword="true" /> для доступа к счетчику в режиме только для чтения (хотя сам счетчик может быть для чтения/записи); значение <see langword="false" /> для доступа к счетчику в режиме чтения/записи.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения или для чтения и записи экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности на локальном компьютере. Этот конструктор требует, чтобы категория содержала единственный экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Используйте этот перегруженный метод для доступа только для чтения или чтения и записи счетчиков на локальном компьютере, к которому относится к категории, содержащей единственный экземпляр счетчика производительности категории. При попытке использовать этот конструктор для указания <xref:System.Diagnostics.PerformanceCounter> экземпляра или категорию, содержащую несколько экземпляров, конструктор выдаст исключение.  
  
 Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> значения для свойств, передайте, задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойство на локальном компьютере».» и задает <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> свойства равным пустой строке (»»).  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> свойства должен указывать на существующий счетчик производительности на локальном компьютере. Если экземпляр счетчика производительности, указывающие на недопустим, вызов конструктора возникло исключение.  
  
> [!NOTE]
>  Эта перегрузка можно использовать для подключения к системным счетчиком, но нельзя записывать в системный счетчик. Таким образом, задание `readOnly` для `false` при связи с системным счетчиком вызовет конструктор для создания исключения.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр <xref:System.Diagnostics.PerformanceCounter> класса. В примере передается в имена категорий, имена счетчиков и значение флага, показывающее, что значение счетчика не только для чтения. Данный пример кода является частью большего примера для <xref:System.Diagnostics.PerformanceCounter> класса.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значением параметра <paramref name="categoryName" /> является пустая строка ("").  
  
 - или -  
  
 Значением параметра <paramref name="counterName" /> является пустая строка ("").  
  
 - или -  
  
 Указанная категория не существует. (если <paramref name="readOnly" /> равен <see langword="true" />).  
  
 - или -  
  
 Заданная категория не является определенной пользователем .NET Framework категорией (если <paramref name="readOnly" /> равен <see langword="false" />).  
  
 - или -  
  
 Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
 - или -  
  
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="instanceName">Имя экземпляра категории счетчика производительности или пустая строка (""), если категория содержит единственный экземпляр.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности и экземпляром категории на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> значения для свойств передачи и задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойства на локальный компьютер «.».  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> свойства должен указывать на существующий счетчик производительности на локальном компьютере. Если экземпляр счетчика производительности, которые указывают на недопустим, вызов конструктора возникло исключение.  
  
 Эта перегрузка может получить доступ к любой доступный только для чтения или чтения и записи счетчик, но делает это в режиме только для чтения. Объект <xref:System.Diagnostics.PerformanceCounter> экземпляром, созданным с помощью этой перегрузки не удается записать в счетчик, даже если этот счетчик доступен для чтения и записи.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> конструктор. Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
 - или -  
  
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
 - или -  
  
 Задана недопустимая категория.  
  
 - или -  
  
 Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
 - или -  
  
 Длина параметра <paramref name="instanceName" /> превышает 127 символов.  
  
 - или -  
  
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="instanceName">Имя экземпляра категории счетчика производительности или пустая строка (""), если категория содержит единственный экземпляр.</param>
        <param name="readOnly">
          Значение <see langword="true" /> для доступа к счетчику в режиме только для чтения; значение <see langword="false" /> для доступа к счетчику в режиме чтения/записи.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения или для чтения и записи экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности и экземпляром категории на локальном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Используйте этот перегруженный метод для доступа к счетчику производительности в режиме только для чтения или в режиме чтения и записи.  
  
 Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> значения для свойств, передаваемому в его и наборы <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойство на локальный компьютер «.».  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> свойства должен указывать на существующий счетчик производительности на локальном компьютере. Если экземпляр счетчика производительности, указывающие на недопустим, вызов конструктора возникло исключение.  
  
> [!NOTE]
>  Эта перегрузка можно использовать для подключения к системным счетчиком, но нельзя записывать в системный счетчик. Таким образом, задание `readOnly` для `false` при связи с системным счетчиком вызовет конструктор для создания исключения.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> конструктор. Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
 - или -  
  
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
 - или -  
  
 Запрошенные параметры настройки разрешения на чтение/запись являются недопустимыми для этого счетчика.  
  
 - или -  
  
 Указанная категория не существует (если <paramref name="readOnly" /> равен <see langword="true" />).  
  
 - или -  
  
 Заданная категория не является определенной пользователем .NET Framework категорией (если <paramref name="readOnly" /> равен <see langword="false" />).  
  
 - или -  
  
 Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
 - или -  
  
 Длина параметра <paramref name="instanceName" /> превышает 127 символов.  
  
 - или -  
  
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</param>
        <param name="counterName">Имя счетчика производительности.</param>
        <param name="instanceName">Имя экземпляра категории счетчика производительности или пустая строка (""), если категория содержит единственный экземпляр.</param>
        <param name="machineName">Компьютер, на котором существуют счетчик производительности и связанная с ним категория.</param>
        <summary>Выполняет инициализацию нового, доступного только для чтения экземпляра класса <see cref="T:System.Diagnostics.PerformanceCounter" /> и связывает этот экземпляр с конкретным системным или определенным пользователем счетчиком производительности на указанном компьютере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В строках параметров регистр не учитывается.  
  
 Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> значения, переданные для свойств.  
  
 Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на указанном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойства должен указывать на существующий счетчик производительности. Если экземпляр счетчика производительности, которые указывают на недопустим, вызов конструктора возникло исключение. Эта перегрузка может получить доступ к любой доступный только для чтения или чтения и записи счетчик, но делает это в режиме только для чтения. Объект <xref:System.Diagnostics.PerformanceCounter> экземпляром, созданным с помощью этой перегрузки не удается записать в счетчик, даже если этот счетчик доступен для чтения и записи.  
  
> [!NOTE]
>  Не удалось записать в удаленные счетчики производительности. Нет ни одна перегрузка, которая позволяет указать экземпляр чтение и запись <xref:System.Diagnostics.PerformanceCounter> класс, который подключается к удаленному компьютеру.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> конструктор. Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
> [!NOTE]
>  В Windows Vista Если удаленный компьютер является членом рабочей группы, может потребоваться отключить контроль учетных Записей, чтобы учетная запись локального пользователя не фильтруется и может быть повышена до учетной записи администратора. По соображениям безопасности Отключение контроля учетных Записей должно быть крайней необходимости. Сведения об отключении контроля учетных Записей см. в разделе [контроль учетных записей пользователей и WMI](http://go.microsoft.com/fwlink/?LinkId=91617).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="categoryName" /> является пустой строкой ("").  
  
 - или -  
  
 Параметр <paramref name="counterName" /> является пустой строкой ("").  
  
 - или -  
  
 Запрошенные параметры настройки разрешения на чтение/запись являются недопустимыми для этого счетчика.  
  
 - или -  
  
 Счетчика не существует на указанном компьютере.  
  
 - или -  
  
 Указанная категория отмечается как многоэкземплярная и требует создания счетчика производительности с именем экземпляра.  
  
 - или -  
  
 Длина параметра <paramref name="instanceName" /> превышает 127 символов.  
  
 - или -  
  
 Параметры <paramref name="categoryName" /> и <paramref name="counterName" /> были локализованы на разных языках.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> является недопустимым.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="categoryName" /> или <paramref name="counterName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию экземпляра <see cref="T:System.Diagnostics.PerformanceCounter" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Разработки, этот метод применяется в среде для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> Метод завершает инициализацию. С помощью <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> и <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> методы предотвращает использование до полной инициализации компонента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя категории счетчика производительности для этого счетчика производительности.</summary>
        <value>Имя категории счетчика производительности (объект производительности), которому соответствует этот счетчик производительности.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Отображается в `Performance Object` поле закладки диспетчера счетчиков производительности в `Add Counter` диалоговое окно.  
  
 Счетчик производительности следит за поведением категории, или объект производительности, на компьютере. Категории включают физические компоненты (такие как процессоры, диски и память) и системные объекты (например, процессы и потоки). Системные счетчики, которые относятся к тому же объекту производительности группируются в категорию, показывающую их общие цели. При создании экземпляра <xref:System.Diagnostics.PerformanceCounter> класса, сначала указывается категория, с которой данный компонент будет взаимодействовать и затем выбрать счетчик из этой категории.  
  
 Например одна категория счетчиков Windows является категория памяти. Системные счетчики в этой категории отслеживают памяти данные, такие как число доступных байтов и число байтов в кэше. Если требуется работать с байтами, кэшируются в приложении, необходимо создать экземпляр <xref:System.Diagnostics.PerformanceCounter> компонента, подключите его к категории памяти, а затем выбрать соответствующий счетчик (в данном случае кэшированных байтов) из этой категории.  
  
 Несмотря на то, что в системе доступно множество дополнительных категорий счетчиков, категории, которые будет осуществляться взаимодействие с наиболее часто являются категории кэша, памяти, объекты, физический диск, процесс, процессор, сервера, системы и потока.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр по умолчанию <xref:System.Diagnostics.PerformanceCounter> класса. После создания экземпляра <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> значения свойств, набор, а результаты вызова <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> метод отображаются.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает счетчик производительности и высвобождает все ресурсы, распределенные под этот экземпляр счетчика производительности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если связать <xref:System.Diagnostics.PerformanceCounter> экземпляр счетчика производительности, который находится на сервере, система инициализирует экземпляр и выделяет память для хранения информации об образце счетчика. <xref:System.Diagnostics.PerformanceCounter.Close%2A> Метод освобождает ресурсы, выделенные объектом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Высвобождает разделенное состояние библиотеки счетчика производительности, распределенное под счетчики.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает описание для этого счетчика производительности.</summary>
        <value>Описание элемента или количества, которое измеряет этот счетчик производительности.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Диалоговое окно Добавить счетчики из оснастки MMC диспетчера счетчика производительности при отображении <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> текста, когда пользователь выбирает счетчик из списка счетчиков и нажатии кнопки объяснить.  
  
 При создании нового счетчика, используйте <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> текст, описывающий счетчик отслеживает этого пользователь может определить, следует ли добавить счетчик системного монитора.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса <see cref="T:System.Diagnostics.PerformanceCounter" /> не связан со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя категории счетчика производительности, связанного с данным экземпляром <see cref="T:System.Diagnostics.PerformanceCounter" />.</summary>
        <value>Имя счетчика, который описывает подсчитываемое количество. Имя, отображаемое в списке счетчиков закладки диспетчера счетчиков производительности MMC в диалоговом окне "Добавить счетчики".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список доступных готовых счетчиков можно получить из Windows производительности руководителя [диалоговое окно «Добавить счетчики»](http://go.microsoft.com/fwlink/p/?LinkId=257854).  
  
   
  
## Examples  
 В следующем примере кода показано, как задать <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> свойство с именем типичные счетчика.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип счетчика, с которым связан счетчик производительности.</summary>
        <value>Значение <see cref="T:System.Diagnostics.PerformanceCounterType" />, которое описывает, каким образом счетчик взаимодействует с отслеживающим приложением, и характер значений, которые он содержит (например, подсчитано или не подсчитано).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterType> Перечисление содержит типы счетчиков производительности, которые могут взаимодействовать. Некоторые типы счетчиков представляют вычисляемые значения, например среднее из измерений счетчика, взятых системой. Другие типы представляют начальное или не рассчитанное значения. В следующей таблице показаны типы счетчиков, которые будут взаимодействовать с наиболее часто.  
  
|Ответственность счетчика|Значение типа счетчика производительности|Пример|  
|------------------------------|----------------------------------|-------------|  
|Подсчет элементов или операций.|`NumberOfItems32`|Отслеживание числа полученных заказов в виде 32-разрядное целое число.|  
|Подсчет пропускную способность.|`NumberOfItems64`|Отслеживать количество заказов на узел с высокой нагрузкой, хранятся в виде 64-разрядное целое число.|  
|Отслеживайте количество элементов или операций в секунду.|`RateOfCountsPerSecond32`|Отслеживание заказов, получаемых в секунду на сайте.|  
|Отслеживайте пропускную способность количество элементов или операций в секунду.|`RateOfCountsPerSecond64`|Отслеживание заказов получаемых в секунду на узел с высокой нагрузкой.|  
|Подсчитывать среднее время для выполнения процесса или для обработки элемента|`AverageTimer32`|Вычисляет среднее время, необходимое для обработки заказа.|  
  
 При создании счетчика, тип которого требует использования соответствующего базового счетчика, необходимо объявить счетчик и базу в <xref:System.Diagnostics.CounterCreationDataCollection> передачи в <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> метод.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает значение связанного счетчика производительности на единицу через эффективные атомарные операции.</summary>
        <returns>Уменьшенное значение счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно записать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, И <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> методы используют блокировка для обновления значения счетчика. Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойство непосредственно до 5 раз улучшения производительности.  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому приложение не может уменьшить его значение.  
  
 - или -  
  
 Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Этот метод является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Он указывает размер глобальной памяти в байтах, используемой счетчиками производительности. Размер по умолчанию равен 524,288 байт.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает инициализацию экземпляра <see cref="T:System.Diagnostics.PerformanceCounter" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Разработки, среда использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> Метод начинает инициализацию. С помощью <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> и <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> методы предотвращает использование до полной инициализации компонента.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Увеличивает значение связанного счетчика производительности на единицу через эффективные атомарные операции.</summary>
        <returns>Увеличенное значение счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно записать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, И <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> методы используют блокировка для обновления значения счетчика. Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойство непосредственно до 5 раз улучшения производительности.  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому приложение не может увеличить его значение.  
  
 - или -  
  
 Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Этот метод является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Увеличиваемое значение. (Отрицательное значение уменьшает счетчик.)</param>
        <summary>Увеличивает или уменьшает значение связанного счетчика производительности на заданное значение посредством эффективных атомарных операций.</summary>
        <returns>Новое значение счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно записать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, И <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> методы используют блокировка для обновления значения счетчика. Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойство непосредственно до 5 раз улучшения производительности.  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> метод, чтобы добавить увеличивает счетчик. Данный пример кода является частью большего примера для <xref:System.Diagnostics.PerformanceCounter> класса.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому приложение не может увеличить его значение.  
  
 - или -  
  
 Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности, если <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> свойство <see langword="false" />. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
        <threadsafe>Этот метод является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает время существования процесса.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" />. Значение по умолчанию: <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если категория счетчиков производительности создается с платформой .NET Framework версии 1.0 или 1.1, она использует глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
> [!NOTE]
>  Если значение <xref:System.Diagnostics.PerformanceCounter.CounterType%2A> свойство <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>, <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> значение для счетчика производительности, должна быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Присвоенное значение не является членом перечисления <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> задается после инициализации <see cref="T:System.Diagnostics.PerformanceCounter" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя экземпляра для этого счетчика производительности.</summary>
        <value>Имя экземпляра категории счетчика производительности или пустая строка (""), если счетчик является единственным экземпляром.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Имена экземпляров должны быть короче, чем 128 символов.  
  
 В некоторых ситуациях категории подразделяются на экземпляры, которые следят за несколько экземпляров объекта, к которому относится категория для. Экземпляры применяются к категории в целом, а не отдельных счетчиков производительности. Каждый счетчик в категории содержит все экземпляры, определенные для данной категории. Например категория процессов содержит экземпляры, которые называются Idle и System. Таким образом, каждый счетчик в категории процессов содержит данные для каждого экземпляра, показывая информацию о незанятых или системные процессы.  
  
 Многие категории не содержат несколько экземпляров, поэтому это свойство можно оставить пустым, чтобы указать, что экземпляр не связан с категорией.  
  
 Если этот <xref:System.Diagnostics.PerformanceCounter> экземпляр точек на являющуюся категорией, можно выбрать только существующие экземпляры категории. Только в пользовательские категории, которые позволяют определить число счетчиков и категории экземпляры, при необходимости можно создать новые экземпляры категории.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> конструктор. Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Нельзя использовать символы "(",")», «#», «\\», или «/» в имени экземпляра. При использовании любого из этих символов консоли производительности (в разделе [профилирование среды выполнения](~/docs/framework/debug-trace-profile/runtime-profiling.md)) не может правильно отображают значения экземпляра.  
  
 Если имя экземпляра автоматически создается и может содержать символы "(",")», «#», «\\», или «/», используйте сопоставление символов в следующей таблице.  
  
|Знак|Сопоставленный символ|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 <xref:System.AppDomain.FriendlyName%2A> Свойство <xref:System.AppDomain> получен из <xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType> свойство часто является источником имена экземпляров, которые могут содержать недопустимые символы.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр по умолчанию <xref:System.Diagnostics.PerformanceCounter> класса. После создания экземпляра <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> значения свойств, набор, а результаты вызова <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> метод отображаются.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя компьютера для этого счетчика производительности.</summary>
        <value>Сервер, на котором постоянно находятся счетчик производительности и связанная с ним категория.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно записывать значения только в те счетчики, которые находятся на локальном компьютере. Тем не менее можно считывать значения счетчиков, с любого компьютера, на предприятии, для которого имеются права доступа.  
  
 При задании <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> свойство, чтобы он указывал на удаленный компьютер <xref:System.Diagnostics.PerformanceCounter> экземпляр пытается открыть счетчика на этом компьютере. Если значение счетчика не существует, задание этого свойства создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый формат <see cref="P:System.Diagnostics.PerformanceCounter.MachineName" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает образец счетчика и возвращает начальное или не рассчитанное значение для него.</summary>
        <returns>Тип <see cref="T:System.Diagnostics.CounterSample" />, представляющий следующее начальное значение, которое система получает для этого счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется для счетчиков, содержащих невычисляемые значения.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> для получения следующего не вычисленное значение счетчика. Данный пример кода является частью большего примера для <xref:System.Diagnostics.PerformanceCounter> класса.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает образец счетчика и возвращает расчетное значение для него.</summary>
        <returns>Следующее расчетное значение, получаемое системой для этого счетчика.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если вычисленное значение счетчика зависит от двух операций считывания, первая операция чтения возвращает 0,0. Сброс свойств счетчика производительности для указания другого счетчика равнозначен созданию нового счетчика производительности, и первая операция считывания с помощью новых свойств возвращает 0,0. Рекомендуемые задержка между вызовами <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> метод должно позволить счетчик для выполнения следующего добавочного чтения одной секунде.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности, требуются права администратора. В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Diagnostics.PerformanceCounterType.ElapsedTime> счетчика и использует <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> метод для отображения значений счетчика за период времени.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр класса, неправильно связанный со счетчиком производительности.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для чтения категории счетчика производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает начальное или не рассчитанное значение этого счетчика.</summary>
        <value>Начальное значение счетчика.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип счетчика является 32-битным, произведена попытка задать этому свойству значение, слишком велик для свойства усекает значение до 32 бит. При чтении счетчиков на локальном компьютере, используя <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойства, а не значение, вычисленное может привести к значительно более высокую производительность в сценариях, где необработанное значение является достаточным.  
  
 Если счетчик, который вы читаете доступна только для чтения, получение <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойство снимает показание счетчика одновременно с вызовом свойства. Это действие эквивалентно начальному вызову <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> метод. Если впоследствии вызвать <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>, можно производить вычисления над значениями, которые возвращены оба вызова.  
  
 Поскольку системные счетчики доступны только для чтения, можно получить, но не устанавливать их начальных значений.  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, И <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> методы используют блокировка для обновления значения счетчика. Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойство непосредственно до 5 раз улучшения производительности.  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
> [!NOTE]
>  Для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или права администратора.  
>   
>  Чтобы избежать необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.  
>   
>  В Windows Vista привилегии пользователя определяются контролем учетных записей (UAC). Члену встроенной группы "Администраторы" присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, , щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Diagnostics.CounterSample> класс, чтобы отобразить значение <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> свойства для счетчика.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка установить начальное значение счетчика, но счетчик доступен только для чтения.  
  
 - или -  
  
 Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Код, выполняющийся без привилегий администратора, предпринял попытку считывания значения счетчика производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, доступен ли экземпляр <see cref="T:System.Diagnostics.PerformanceCounter" /> только для чтения.</summary>
        <value>
          Значение <see langword="true" />, если экземпляр <see cref="T:System.Diagnostics.PerformanceCounter" /> доступен только для чтения (даже если сам счетчик является определенным счетчиком .NET Framework); значение <see langword="false" />, если счетчик работает в режиме чтения/записи. Значение по умолчанию — значение, заданное конструктором.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для системного счетчика <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> всегда должна `true`. Не удалось записать системные счетчики.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет экземпляр категории, указанной объектом <see cref="T:System.Diagnostics.PerformanceCounter" /> свойства <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно удалить экземпляр только для пользовательских счетчиков. Все системные счетчики доступны только для чтения, поэтому попытка удалить один из них вызовет исключение.  
  
> [!NOTE]
>  Чтобы избежать возникновения состояния гонки, при освобождении памяти общий счетчик производительности, рекомендуется <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> метод вызываться из <xref:System.AppDomain.DomainUnload> обработчика событий.  
  
 Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> конструктор. Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.  
  
> [!NOTE]
>  Если значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException> возникает исключение. Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>. Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Счетчик доступен только для чтения, поэтому любой экземпляр, связанный с данной категорией, не может быть удален.  
  
 - или -  
  
 Экземпляр класса, неправильно связанный со счетчиком производительности.  
  
 - или -  
  
 При использовании глобальной общей памяти свойству <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> присваивается значение <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при обращении к API-интерфейсу системы.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используемая платформа, Windows 98 или Windows Millennium Edition (Me), не поддерживает счетчики производительности.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">для записи категории счетчиков производительности. Связанное перечисление: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>