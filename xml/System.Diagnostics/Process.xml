<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f3b937515accae8f91569e4cac09306f70365d0" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061733" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к локальным и удаленным процессам и позволяет запускать и останавливать локальные системные процессы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Diagnostics.Process> компонент предоставляет доступ к процессу, на котором выполняется на компьютере. Процесс, проще говоря, — выполняемого приложения. Поток представляет собой базовую единицу, к которой операционная система выделяет время процессора. Поток может исполнять любую часть кода процесса, включая части, выполняющейся в данный момент другим потоком.  
  
 <xref:System.Diagnostics.Process> Компонент — это эффективное средство для запуск, остановка, управление и наблюдение за приложениями. Можно использовать <xref:System.Diagnostics.Process> компонента, чтобы получить список процессов, работающих под управлением, или можно запустить новый процесс. Объект <xref:System.Diagnostics.Process> компонент используется для доступа к системным процессам. После <xref:System.Diagnostics.Process> инициализации компонента, он может использоваться для получения сведений о выполняемом процессе. Такая информация включает множество потоков, загруженные модули (файлы .dll и .exe), и информацию о производительности, такие как объем памяти, используемой процессом.  
  
 Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
> [!NOTE]
>  32-разрядных процессов не может получить доступ к модулям 64-разрядном процессе. При попытке получить сведения о 64-разрядном процессе из 32-разрядного процесса, вы получите <xref:System.ComponentModel.Win32Exception> исключение. 64-разрядный процесс, с другой стороны, можно получить доступ к модули 32-разрядного процесса.  
  
 Компонент процесса получает сведения о группе свойств за один раз. После <xref:System.Diagnostics.Process> компонент получил информацию одного члена любой группы, он будет кэшировать значения для других свойств в этой группе и не получить новые сведения о других членах группы, пока не будет вызван <xref:System.Diagnostics.Process.Refresh%2A> метод. Таким образом, значение свойства, не обязательно будет новее, чем последнего вызова <xref:System.Diagnostics.Process.Refresh%2A> метод. Схемы групп, зависят от операционной системы.  
  
 Если путь к переменной, объявленной в системы с помощью кавычки, необходимо указывать полное этот путь при запуске любого процесса из этого расположения. В противном случае система не найдет путь. Например если `c:\mypath` не находится в пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо указывать полное любой процесс в `c:\mypath` при запуске.  
  
 Системный процесс однозначно идентифицируется в системе идентификатор процесса. Как и многие ресурсы Windows процесс также определяется по дескриптору, который может не быть уникальным на этом компьютере. Маркер – это общий термин для идентификатора ресурса. Операционная система сохраняет дескриптор процесса, к которому можно получить через <xref:System.Diagnostics.Process.Handle%2A> свойство <xref:System.Diagnostics.Process> компонента, даже в том случае, если процесс завершился. Таким образом, сведения, можно получить процесс администрирования, такие как <xref:System.Diagnostics.Process.ExitCode%2A> (обычно либо ноль для успеха или код ошибки ненулевое значение) и <xref:System.Diagnostics.Process.ExitTime%2A>. Дескрипторы являются чрезвычайно важным ресурсом, поэтому потеря дескрипторов более опасна, чем утечка памяти.  
  
> [!NOTE]
>  Этот класс содержит запрос компоновки и запрос наследования на уровне класса, который применяется ко всем элементам. Объект <xref:System.Security.SecurityException> возникает, когда непосредственного вызывающего или производного класса не имеет разрешения полного доверия. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Примечания  
 В платформе .NET Framework <xref:System.Diagnostics.Process> класса по умолчанию использует <xref:System.Console> кодировок, которые обычно являются кода кодировок страниц, для потоков ввода, вывода и ошибки. Пример кода см. в системах с языком и региональными параметрами является английский (США), кодовую страницу 437 имеет кодировку по умолчанию <xref:System.Console> класса. Тем не менее [!INCLUDE[net_core](~/includes/net-core-md.md)] может сделать доступными только ограниченный набор кодировок. Если это так, он использует <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> как кодирование по умолчанию.  
  
 Если <xref:System.Diagnostics.Process> объекта зависит от конкретного кода кодировок страниц, вы по-прежнему их можно сделать доступными, выполнив указанные ниже *перед* вызова любых <xref:System.Diagnostics.Process> методов:  
  
1.  Добавьте ссылку на сборку System.Text.Encoding.CodePages.dll в проект.  
  
2.  Получить <xref:System.Text.EncodingProvider> объекта из <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> свойство.  
  
3.  Передайте <xref:System.Text.EncodingProvider> объект <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> метод для установки дополнительных кодировок, поддерживаемых поставщиком кодировки доступен.  
  
 <xref:System.Diagnostics.Process> Класса будет автоматически использовать кодировку системы по умолчанию вместо UTF-8, при условии, что вы зарегистрировали кодировки поставщика перед вызовом любого <xref:System.Diagnostics.Process> методы.  
  
   
  
## Examples  
 В следующем примере используется экземпляр <xref:System.Diagnostics.Process> класса для запуска процесса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 В следующем примере используется <xref:System.Diagnostics.Process> классов сам и статический <xref:System.Diagnostics.Process.Start%2A> метод для запуска процесса.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 В следующем примере на языке F # определяется `runProc` функцию, которая запускает процесс, фиксирует все выходные данные и сведения об ошибке и записывает число миллисекунд, процесс был запущен.  `runProc` Функция имеет три параметра: имя приложения для запуска аргументы для передачи в приложение и начальный каталог.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 Код для `runProc` функция написана с [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) и доступен в разделе [открытой лицензии Майкрософт](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот класс не может использоваться частично доверенным кодом.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">для полного доверия для разработчиков производных классов. Этот класс не наследуется частично доверенным кодом.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не укажете <xref:System.Diagnostics.Process.MachineName%2A> свойства, значение по умолчанию — локальный компьютер, («.»).  
  
 Есть два способа сопоставления нового <xref:System.Diagnostics.Process> компонент с процесс на компьютере. Первый вариант — использовать конструктор для создания <xref:System.Diagnostics.Process> набор компонентов, соответствующих членов <xref:System.Diagnostics.Process.StartInfo%2A> свойство и вызвать <xref:System.Diagnostics.Process.Start%2A> связываемый <xref:System.Diagnostics.Process> новым процессом системы. Второй параметр — для связывания <xref:System.Diagnostics.Process> с выполняющийся процесс системы с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или один из <xref:System.Diagnostics.Process.GetProcesses%2A> возвращаемые значения.  
  
 Если вы используете `static` перегруженная версия <xref:System.Diagnostics.Process.Start%2A> метод для запуска нового процесса системы, метод создает новый <xref:System.Diagnostics.Process> компонента и связывает его с процессом.  
  
 При <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> задано значение по умолчанию `true`, вы можете запустить приложения и документы в способом, который аналогичен использованию `Run` диалогового окна `Start` меню. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> — `false`, можно запускать только исполняемые файлы.  
  
 Любой исполняемый файл, который можно вызвать из командной строки можно запустить одним из двух способов:, задав соответствующие члены <xref:System.Diagnostics.Process.StartInfo%2A> и вызова <xref:System.Diagnostics.Process.Start%2A> метод без параметров, либо путем передачи соответствующего параметра `static` <xref:System.Diagnostics.Process.Start%2A> член.  
  
 Можно создать <xref:System.Diagnostics.Process> компонент с помощью конструктора, одного из статических <xref:System.Diagnostics.Process.Start%2A> или любой из перегрузки <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, или <xref:System.Diagnostics.Process.GetProcessesByName%2A> методы. После этого делали, имеется представление связанного процесса. Это не динамическое представление, которое автоматически обновляется при изменении свойства процесса в памяти. Вместо этого необходимо вызвать <xref:System.Diagnostics.Process.Refresh%2A> компонента обновить <xref:System.Diagnostics.Process> сведения о свойстве в приложении.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает базовый приоритет связанного процесса.</summary>
        <value>Базовый приоритет, который вычисляется свойством <see cref="P:System.Diagnostics.Process.PriorityClass" /> связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> Процесса является стартовым приоритетом для потоков, созданных в связанном процессе. Можно просмотреть сведения о базовом приоритете через базовый приоритет счетчик системного монитора.  
  
 На основе времени, затраченного или других показателях, операционной системы можно изменить базовый приоритет, если процесс следует поместить впереди других.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Позволяет посмотреть стартовый приоритет, присвоенный процессу. Однако, так как он доступен только для чтения, его нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A> для задания приоритета процесса. Чтобы изменить приоритет, используйте <xref:System.Diagnostics.Process.PriorityClass%2A> свойство. <xref:System.Diagnostics.Process.BasePriority%2A> Можно просмотреть с помощью системного монитора, а <xref:System.Diagnostics.Process.PriorityClass%2A> не является. Как <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> можно просмотреть программно. В следующей таблице показаны связи между <xref:System.Diagnostics.Process.BasePriority%2A> значения и <xref:System.Diagnostics.Process.PriorityClass%2A> значения.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс завершен.  
  
 - или -  
  
 Процесс не запущен, поэтому нет идентификатора процесса.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает операции асинхронного чтения с перенаправленного потока <see cref="P:System.Diagnostics.Process.StandardError" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> Возможность чтения потока, синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> синхронной операции чтения в поток вывода ошибок в процессе выполнения. Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardError%2A> потока или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Этот метод включает маршрутизируемый обработчик событий вывода потока и сразу возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.  
  
 Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> для <xref:System.Diagnostics.Process> :  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> значение `true`.  
  
3.  Добавьте обработчик событий <xref:System.Diagnostics.Process.ErrorDataReceived> событий. Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> сигнатуре делегата.  
  
4.  Запустить <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Если запуск асинхронных операций чтения, обработчик событий вызывается при каждом запуске связанного <xref:System.Diagnostics.Process> записывает строку текста, чтобы его <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelErrorRead%2A>. Операция чтения может быть отменено, вызывающим или обработчик событий. После отмены, вы можете вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> еще раз, чтобы возобновить операции асинхронного чтения.  
  
> [!NOTE]
>  Нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process> открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardError%2A> поток, или наоборот. Однако можно считать два различных потоков в различных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> и затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
   
  
## Examples  
 В следующем примере используется `net view` команду, чтобы вывести список доступных сетевых ресурсов на удаленном компьютере. Пользователь вводит имя конечного компьютера в качестве аргумента командной строки. Пользователь также может указывать имя файла для вывода ошибок. Пример собирает выходные данные команды net, Ожидание завершения процесса, а затем запись в результаты вывода на консоль. Если пользователь вводит необязательный файл ошибок, ошибки в примере записываются в файл.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> — <see langword="false" />.  
  
 \- или -  
  
 Асинхронная операция чтения уже выполняется в потоке <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
 \- или -  
  
 Поток <see cref="P:System.Diagnostics.Process.StandardError" /> используется синхронной операцией чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает операции асинхронного чтения с перенаправленного потока <see cref="P:System.Diagnostics.Process.StandardOutput" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> Возможность чтения потока, синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнения синхронных операций чтения в выходной поток процесса. Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardOutput%2A> потока или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.  
  
 Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> для <xref:System.Diagnostics.Process> :  
  
1.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> значение `false`.  
  
2.  Присвойте свойству <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> значение `true`.  
  
3.  Добавьте обработчик событий <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> сигнатуре делегата.  
  
4.  Запустить <xref:System.Diagnostics.Process>.  
  
5.  Вызовите <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> для <xref:System.Diagnostics.Process>. Этот вызов запускает асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Если запуск асинхронных операций чтения, обработчик событий вызывается при каждом запуске связанного <xref:System.Diagnostics.Process> записывает строку текста, чтобы его <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelOutputRead%2A>. Операция чтения может быть отменено, вызывающим или обработчик событий. После отмены, вы можете вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> еще раз, чтобы возобновить операции асинхронного чтения.  
  
> [!NOTE]
>  Нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process> открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardOutput%2A> поток, или наоборот. Однако можно считать два различных потоков в различных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> и затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 Следующий пример показывает, как для выполнения асинхронных операций чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> поток `sort` команды. `sort` Команда является консольным приложением, которое считывает и сортирует ввода текста.  
  
 В примере создается делегат события для `SortOutputHandler` обработчик событий и связывает его с <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий получает строки текста из перенаправленной <xref:System.Diagnostics.Process.StandardOutput%2A> поток, форматирования текста и записывает текст на экране.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> — <see langword="false" />.  
  
 \- или -  
  
 Асинхронная операция чтения уже выполняется в потоке <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
 \- или -  
  
 Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> используется синхронной операцией чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет операцию асинхронного чтения в перенаправленном потоке <see cref="P:System.Diagnostics.Process.StandardError" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. <xref:System.Diagnostics.Process.CancelErrorRead%2A> заканчивается операции асинхронного чтения.  
  
 После отмены, можно возобновить операцию асинхронного чтения путем вызова <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelErrorRead%2A>, что все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardError%2A> завершены, а затем выключено обработчик события. Все дополнительные перенаправление вывода <xref:System.Diagnostics.Process.StandardError%2A> сохраняются в буфер. Если повторно включить обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, сохраненные данные выводятся в обработчик событий и возобновить операции асинхронного чтения. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий перед добавлением нового обработчика событий.  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardError%2A> потока. Один раз перенаправленный поток <xref:System.Diagnostics.Process> открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме. Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A> и затем нужно прочитать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> возобновление операции асинхронного чтения. Не выполняйте <xref:System.Diagnostics.Process.CancelErrorRead%2A> с помощью вызова для синхронного методы для чтения <xref:System.Diagnostics.Process.StandardError%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается `nmake` команды с пользователем указанные аргументы. Потоки ошибок и вывода считываются асинхронно; Накопленные строки текста выводится на консоль, а также записывается в файл журнала. Если выходные данные команды превышает указанное количество строк, отменяются операции асинхронного чтения.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardError" /> не включен для асинхронных операций чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет операцию асинхронного чтения в перенаправленном потоке <see cref="P:System.Diagnostics.Process.StandardOutput" /> приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. <xref:System.Diagnostics.Process.CancelOutputRead%2A> заканчивается операции асинхронного чтения.  
  
 После отмены, можно возобновить асинхронных операций чтения путем вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> еще раз.  
  
 При вызове <xref:System.Diagnostics.Process.CancelOutputRead%2A>, что все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardOutput%2A> завершены, а затем выключено обработчик события. Все дополнительные перенаправление вывода <xref:System.Diagnostics.Process.StandardOutput%2A> сохраняются в буфер. Если повторно включить обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, сохраненные данные выводятся в обработчик событий и возобновить операции асинхронного чтения. Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий перед добавлением нового обработчика событий.  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Один раз перенаправленный поток <xref:System.Diagnostics.Process> открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме. Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> и затем нужно прочитать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> возобновление операции асинхронного чтения. Не выполняйте <xref:System.Diagnostics.Process.CancelOutputRead%2A> с помощью вызова для синхронного методы для чтения <xref:System.Diagnostics.Process.StandardOutput%2A> например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 В следующем примере запускается `nmake` команды с пользователем указанные аргументы. Потоки ошибок и вывода считываются асинхронно; Накопленные строки текста выводится на консоль, а также записывается в файл журнала. Если выходные данные команды превышает указанное количество строк, отменяются операции асинхронного чтения.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> не включен для асинхронных операций чтения.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, связанные с этим компонентом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> Метод вызывает процесса, чтобы прекратить ожидание завершения Если ожидал, закрывает дескриптор процесса и очищает свойства, относящиеся к процессу. <xref:System.Diagnostics.Process.Close%2A> не закрывайте стандартные выходные данные, входные и ошибки чтения и записи в случае, если они ссылаются извне.  
  
> [!NOTE]
>  Метод <xref:System.Diagnostics.Process.Dispose%2A> вызывает <xref:System.Diagnostics.Process.Close%2A>. Размещение <xref:System.Diagnostics.Process> объекта в `using` блок освобождает ресурсы, без необходимости вызова <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем он извлекает использование физической памяти связанного процесса в 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается прежде, чем 10 секунд ожидания. В примере закрывается процесс, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает процесс, имеющий пользовательский интерфейс, посылая сообщение о закрытии главному окну процесса.</summary>
        <returns>
          Значение <see langword="true" />, если сообщение о закрытии было успешно отправлено; <see langword="false" />, если связанный процесс не имеет главного окна или если главное окно отключено (например, если отображается модальное диалоговое окно).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При выполнении процесса его цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, который закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата. Запрос на завершение процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не вынуждает приложение, чтобы выйти из программы. Приложение может запросить проверку пользователя перед завершением работы или она может отказаться закрыться. Чтобы принудительно завершить работу приложения, используйте <xref:System.Diagnostics.Process.Kill%2A> метод. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> идентична Закрыть главное окно приложения с помощью системного меню пользователь. Таким образом запрос на завершение процесса закрытием главного окна не вынуждает приложение немедленно завершиться.  
  
 Данные, изменять процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове метода <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> вызывает аварийного завершения процесса и должен использоваться только при необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A> включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом. Если <xref:System.Diagnostics.Process.CloseMainWindow%2A> завершается ошибкой, можно использовать <xref:System.Diagnostics.Process.Kill%2A> завершить процесс. <xref:System.Diagnostics.Process.Kill%2A> Это единственный способ завершения процессов, не имеющих графического интерфейса.  
  
 Можно вызвать <xref:System.Diagnostics.Process.Kill%2A> и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере. Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, могут только просматривать информацию для процессов, запущенных на удаленных компьютерах.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем она получает использование физической памяти связанного процесса в 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается прежде, чем 10 секунд ожидания. В примере закрывается процесс, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Этот процесс уже завершился.  
  
 - или -  
  
 Не существует процесса, связанного с данным объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Освобождает все ресурсы, используемые этим процессом.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли вызывать событие <see cref="E:System.Diagnostics.Process.Exited" /> при прекращении процесса.</summary>
        <value>
          Значение <see langword="true" />, если событие <see cref="E:System.Diagnostics.Process.Exited" /> должно быть вызвано при завершении связанного процесса (выход или вызов метода <see cref="M:System.Diagnostics.Process.Kill" />); в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />. Обратите внимание, что <see cref="E:System.Diagnostics.Process.Exited" /> события даже в том случае, если значение <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> — <see langword="false" /> при завершении процесса во время или до выполнения пользователем <see cref="P:System.Diagnostics.Process.HasExited" /> проверки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Свойство предлагает ли компонент уведомляться операционной системы завершил работу процесса. <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> Свойство используется в асинхронной обработке для уведомления приложения о завершении процесса. Чтобы принудительно выполнить приложение синхронно ожидания событие выхода (которое прерывает обработку приложения, пока не произошло событие выхода), используйте <xref:System.Diagnostics.Process.WaitForExit%2A> метод.

> [!NOTE]
> Если вы используете Visual Studio, а затем дважды щелкните <xref:System.Diagnostics.Process> компонента в своем проекте <xref:System.Diagnostics.Process.Exited> делегат события и обработчик событий создаются автоматически. Дополнительный код задает <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойства `false`. Необходимо изменить это свойство, чтобы `true` для обработчика событий для выполнения при завершении связанного процесса.

Если компонент <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> значение — `true`, или когда <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> является `false` и <xref:System.Diagnostics.Process.HasExited%2A> проверки вызывается с помощью компонента, компонент может получить доступ к административной информации для связанного процесса, который остается сохраняются операционной системой. Такая информация включает <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.ExitCode%2A>.

После выхода из процесса, <xref:System.Diagnostics.Process.Handle%2A> компонента больше не указывает на существующий ресурс процесса. Вместо этого он может использоваться только для доступа к информации операционной системы о ресурсе процесса. Операционная система не знать о дескрипторах завершенных процессов, которые еще не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> данные из памяти.

Нет затраты, связанные с наблюдением за завершением процесса. Если <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> — `true`, <xref:System.Diagnostics.Process.Exited> событие вызывается при завершении связанного процесса. Процедуры для <xref:System.Diagnostics.Process.Exited> запустить в это время события.

В некоторых случаях приложение запускает процесс, но не требует уведомления о его завершении. Например чтобы запустить приложение «Блокнот», чтобы разрешить пользователю редактировать текст, но больше не использовать приложение «Блокнот». Вы можете избежать уведомления при завершении процесса, так как он не имеет значения для продолжения работы приложения. Установка <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> для `false` позволяет сэкономить системные ресурсы.

## Examples  
В следующем примере кода создается процесс, который выводит файл. Он задает <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойство процесс для вызова <xref:System.Diagnostics.Process.Exited> событий при завершении работы. <xref:System.Diagnostics.Process.Exited> Обработчик событий выводит сведения о процессе.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает компонент <see cref="T:System.Diagnostics.Process" /> в состояние взаимодействия с работающим системным процессом, выполняющимся в специальном режиме путем включения встроенного свойства <see langword="SeDebugPrivilege" /> в данном потоке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы, выполняются в специальном режиме. Попытка чтения свойства или присоединения к процессам возможна только после вызова метода <xref:System.Diagnostics.Process.EnterDebugMode%2A> в компоненте. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A> при больше не нужен доступ к процессам, выполняющимся в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение выполняет запись в свой перенаправленный поток <see cref="P:System.Diagnostics.Process.StandardError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived> Событие означает, что в свой перенаправленный записал процесса <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Это событие происходит только во время асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>. Запуск асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardError%2A> поток <xref:System.Diagnostics.Process>, добавьте обработчик событий <xref:System.Diagnostics.Process.ErrorDataReceived> событий и вызовов <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. После этого <xref:System.Diagnostics.Process.ErrorDataReceived> сигналы процесс записывает строку в перенаправленной <xref:System.Diagnostics.Process.StandardError%2A> потока, пока процесс завершает работу или вызывает <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  Приложение, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit> метод, чтобы гарантировать записан выходной буфер. Обратите внимание, что если указать время ожидания с помощью <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> перегрузка *не* убедитесь в выходной буфер был записан на диск.
  
   
  
## Examples  
 В следующем примере используется `net view` команду, чтобы вывести список доступных сетевых ресурсов на удаленном компьютере. Пользователь вводит имя конечного компьютера в качестве аргумента командной строки. Пользователь также может указывать имя файла для вывода ошибок. Пример собирает выходные данные команды net, Ожидание завершения процесса, а затем запись в результаты вывода на консоль. Если пользователь вводит необязательный файл ошибок, ошибки в примере записываются в файл.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, заданное связанным процессом при завершении.</summary>
        <value>Код, который задал связанный процесс при завершении.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.ExitCode%2A> для получения статуса, которое вернул системный процесс при завершении. Можно использовать код выхода гораздо похож на возвращаемое значение из `main()` процедуры.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> Значение для процесса отражает конкретное соглашение, реализованные разработчиком приложения для этого процесса. Если используется значение кода выхода для принятия решений в коде, быть вы знаете, что соглашения кода выхода, используемой процессом приложения.  
  
 Разработчики обычно указывают успешный выход <xref:System.Diagnostics.Process.ExitCode%2A> значение ноль и обозначают ошибки ненулевыми значениями, которые вызывающий метод можно использовать для определения причины аварийного завершения процесса. Придерживайтесь следующих правил необязательно, но они являются соглашением.  
  
 При попытке получить <xref:System.Diagnostics.Process.ExitCode%2A> до завершения процесса создаст исключение. Изучите <xref:System.Diagnostics.Process.HasExited%2A> сначала, чтобы проверить, является ли связанный процесс завершился.  
  
> [!NOTE]
>  Когда стандартный вывод был перенаправлен обработчикам асинхронных событий, это возможно, что обработка вывода будет не завершена при <xref:System.Diagnostics.Process.HasExited%2A> возвращает `true`. Чтобы обеспечить завершение асинхронной обработки событий, вызовите <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр отсутствует перед проверкой <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Можно использовать <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A> метод для завершения связанного процесса.  
  
 Существует два способа уведомления о завершении связанного процесса: синхронный и асинхронный. Синхронное уведомление основывается на вызове <xref:System.Diagnostics.Process.WaitForExit%2A> метода для приостановки обработки приложения до выхода из сопоставленного компонента. Асинхронное уведомление основывается на <xref:System.Diagnostics.Process.Exited> событий. При использовании асинхронного уведомления <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть присвоено `true` для <xref:System.Diagnostics.Process> компонент для получения уведомления о завершении процесса.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не был завершен.  
  
 - или -  
  
 Процесс <see cref="P:System.Diagnostics.Process.Handle" /> не является допустимым.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ExitCode" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при завершении процесса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> Событие означает, что завершения связанного процесса. Данное событие означает, что процесс прекращен (прерван) или успешно завершился. Это событие может возникать только в том случае, если значение <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> свойство `true`.  
  
 Существует два способа уведомления о завершении связанного процесса: синхронный и асинхронный. Синхронное уведомление означает вызов <xref:System.Diagnostics.Process.WaitForExit%2A> метод блокирует текущий поток до завершения процесса. Использует асинхронное уведомление <xref:System.Diagnostics.Process.Exited> событие, которое позволяет вызывающему потоку продолжить выполнение в то же время. В последнем случае <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> должно быть присвоено `true` для вызывающего приложения для получения события завершил работу.  
  
 При завершении работы процесса операционной системы он уведомляет все процессы, зарегистрированные обработчики события завершил работу. В настоящее время дескриптор процесса, который только что завершил работу можно использовать для доступа к некоторые свойства, такие как <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.HasExited%2A> , операционная система поддерживает до полностью освобождает этот дескриптор.  
  
> [!NOTE]
>  Даже если у вас есть дескриптор завершенного процесса, нельзя вызвать <xref:System.Diagnostics.Process.Start%2A> вновь для связи с тем же процессом. Вызов <xref:System.Diagnostics.Process.Start%2A> автоматически освобождает связанный процесс и подключается к процессу с помощью того же файла, но с совершенно новым <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Дополнительные сведения об использовании <xref:System.Diagnostics.Process.Exited> событий в приложениях Windows Forms, в разделе <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Он выдает <xref:System.Diagnostics.Process.Exited> событий при завершении процесса, так как <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> было задано при создании процесса. <xref:System.Diagnostics.Process.Exited> Обработчик событий выводит сведения о процессе.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время завершения связанного процесса.</summary>
        <value>Класс <see cref="T:System.DateTime" />, показывающий время завершения связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс не был завершен, при попытке получить <xref:System.Diagnostics.Process.ExitTime%2A> вызывает исключение. Используйте <xref:System.Diagnostics.Process.HasExited%2A> перед получением <xref:System.Diagnostics.Process.ExitTime%2A> свойства, чтобы определить, является ли связанный процесс завершился.  
  
   
  
## Examples  
 В следующем примере кода создается процесс, который выводит файл. Процесс вызывает <xref:System.Diagnostics.Process.Exited> событий при выходе и обработчик событий отображает <xref:System.Diagnostics.Process.ExitTime%2A> свойства и другие обработки сведений.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ExitTime" /> процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает новый компонент <see cref="T:System.Diagnostics.Process" /> и связывает его с активным в данный момент процессом.</summary>
        <returns>Новый компонент <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом выполняющегося процесса в вызывающем приложении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> экземпляра и связать его с ресурсом процесса на локальном компьютере.  
  
 Как и подобные <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, и <xref:System.Diagnostics.Process.GetProcesses%2A> методы, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> связывает существующий ресурс с новым <xref:System.Diagnostics.Process> компонента.  
  
   
  
## Examples  
 Следующий пример извлекает сведения из текущего процесса, процессов, запущенных на локальном компьютере, все экземпляры Блокнота, работающих на локальном компьютере и определенном процессе на локальном компьютере. Затем он извлекает сведения о тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> и связывает его с существующим заданным ресурсом процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Уникальный в системе идентификатор ресурса процесса.</param>
        <summary>Возвращает новый компонент <see cref="T:System.Diagnostics.Process" />, по заданному идентификатору процесса на локальном компьютере.</summary>
        <returns>Компонент <see cref="T:System.Diagnostics.Process" />, связанный с локальным ресурсом процесса, определенного параметром <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> компонента и связать его с ресурсом процесса на локальном компьютере. Ресурс процесса должен уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> не создает системного ресурса, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process> компонента. Процесс <xref:System.Diagnostics.Process.Id%2A> можно получить только для процесса, которая запущена на компьютере. После завершения процесса <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> вызывает исключение, если передать его идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере идентификатор процесса является уникальным. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Возвращает не более одного процесса. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если существует несколько процессов на компьютере, работающим с приложением указанного <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбец отображает идентификатор, присвоенный процессу.  
  
   
  
## Examples  
 Следующий пример извлекает сведения из текущего процесса, процессов, запущенных на локальном компьютере, все экземпляры Блокнота, работающих на локальном компьютере и определенном процессе на локальном компьютере. Затем он извлекает сведения о тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Процесс, указанный параметром <paramref name="processId" />, не выполняется. Возможно, истек срок действия идентификатора.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен этим объектом.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Уникальный в системе идентификатор ресурса процесса.</param>
        <param name="machineName">Имя компьютера в сети.</param>
        <summary>Возвращает новый компонент <see cref="T:System.Diagnostics.Process" /> по заданному идентификатору процесса и имени компьютера в сети.</summary>
        <returns>Компонент <see cref="T:System.Diagnostics.Process" />, связанный с удаленным ресурсом процесса, определенного параметром <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания нового <xref:System.Diagnostics.Process> компонента и связать его с ресурсом процесса на удаленном компьютере в сети. Ресурс процесса должен уже существовать на указанном компьютере, так как <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> не создает системного ресурса, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process> компонента. Процесс <xref:System.Diagnostics.Process.Id%2A> можно получить только для процесса, которая запущена на компьютере. После завершения процесса <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> вызывает исключение, если передать его идентификатор с истекшим сроком действия.  
  
 На любом конкретном компьютере идентификатор процесса является уникальным. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Возвращает не более одного процесса. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Если существует несколько процессов на компьютере, работающим с приложением указанного <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> возвращает массив, содержащий все связанные процессы. Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбец отображает идентификатор, присвоенный процессу.  
  
 Если вы не укажете `machineName`, используется локальный компьютер. Кроме того, можно указать локальный компьютер, задав `machineName` значение «.» или пустая строка (»»).  
  
   
  
## Examples  
 Следующий пример извлекает сведения из текущего процесса, процессов, запущенных на локальном компьютере, все экземпляры Блокнота, работающих на локальном компьютере и определенном процессе на локальном компьютере. Затем он извлекает сведения о тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Процесс, указанный параметром <paramref name="processId" />, не выполняется. Возможно, истек срок действия идентификатора.  
  
 - или -  
  
 Недопустимый синтаксис параметра <paramref name="machineName" />. Возможно, имя имеет нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен этим объектом.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их с существующими ресурсами процесса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> для каждого ресурса процесса на локальном компьютере.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий все ресурсы процесса, выполняющегося на локальном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса на локальном компьютере. Ресурсы процесса уже должен существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> создает системных ресурсов, а связывает ресурсы с сформированные <xref:System.Diagnostics.Process> компонентов. Так как операционная система сама выполняет фоновые процессы, этот массив никогда не пуст.  
  
 Если вы не хотите получить все процессы, запущенные на компьютере, их количество можно ограничить с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> Создает <xref:System.Diagnostics.Process> компонент, связанный с процессом, определяется в системе, идентификатор процесса, который передается методу. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Создает массив из <xref:System.Diagnostics.Process> компоненты которого связанные ресурсы используют исполняемый файл, передайте методу.  
  
> [!NOTE]
>  В одном экземпляре процесса узла службы (svchost.exe) можно загрузить несколько служб Windows. GetProcesses не определяет таких отдельных служб. для этого в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Следующий пример извлекает сведения из текущего процесса, процессов, запущенных на локальном компьютере, все экземпляры Блокнота, работающих на локальном компьютере и определенном процессе на локальном компьютере. Затем он извлекает сведения о тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, из которого читается список процессов.</param>
        <summary>Создает новый компонент <see cref="T:System.Diagnostics.Process" /> для каждого ресурса процесса на указанном компьютере.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий все ресурсы процесса, выполняющегося на указанном компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса на указанном компьютере (обычно удаленном). Ресурсы процесса уже должен существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A> создает системных ресурсов, а связывает ресурсы с сформированные <xref:System.Diagnostics.Process> компонентов. Так как операционная система сама выполняет фоновые процессы, этот массив никогда не пуст.  
  
 Если вы не хотите получить все процессы, запущенные на компьютере, их количество можно ограничить с помощью <xref:System.Diagnostics.Process.GetProcessById%2A> или <xref:System.Diagnostics.Process.GetProcessesByName%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> Создает <xref:System.Diagnostics.Process> компонент, связанный с процессом, определяется в системе, идентификатор процесса, который передается методу. <xref:System.Diagnostics.Process.GetProcessesByName%2A> Создает массив из <xref:System.Diagnostics.Process> компоненты которого связанные ресурсы используют исполняемый файл, передайте методу.  
  
 Эта перегрузка <xref:System.Diagnostics.Process.GetProcesses%2A> метод обычно используется для получения списка ресурсов процесса, выполняющегося на удаленном компьютере в сети, но можно указать локальный компьютер, передав «.».  
  
> [!NOTE]
>  В одном экземпляре процесса узла службы (svchost.exe) можно загрузить несколько служб Windows. GetProcesses не определяет таких отдельных служб. для этого в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 Следующий пример извлекает сведения из текущего процесса, процессов, запущенных на локальном компьютере, все экземпляры Блокнота, работающих на локальном компьютере и определенном процессе на локальном компьютере. Затем он извлекает сведения о тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый синтаксис параметра <paramref name="machineName" />. Он может иметь нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Платформа операционной системы не поддерживает эту операцию на удаленных компьютерах.</exception>
        <exception cref="T:System.InvalidOperationException">Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла проблема при доступе к базовому системному API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их с существующими ресурсами процесса, для которых имя процесса является общедоступным.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Понятное имя процесса.</param>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их со всеми ресурсами процесса на локальном компьютере, для которых заданное имя процесса является общедоступным.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий ресурсы процесса, выполняющего указанное приложение или файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса, работающих под управлением того же исполняемого файла на локальном компьютере. Ресурсы процесса должны уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> создает системных ресурсов, а связывает их с сформированные <xref:System.Diagnostics.Process> компонентов. Объект `processName` могут быть указаны для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.  
  
 Имя процесса: понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл. Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут выполнять приложение, заданное параметром `processName` параметр. Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает не более одного процесса, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если необходимо работать с процессом, используя стандартные вызовы API, можно запросить каждый процесс по очереди по его идентификатору. Не удается доступ к ресурсам процесса процесса только через имя, но, получив массив <xref:System.Diagnostics.Process> компонентов, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.  
  
   
  
## Examples  
 Следующий пример извлекает сведения из текущего процесса, процессов, запущенных на локальном компьютере, все экземпляры Блокнота, работающих на локальном компьютере и определенном процессе на локальном компьютере. Затем он извлекает сведения о тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Понятное имя процесса.</param>
        <param name="machineName">Имя компьютера в сети.</param>
        <summary>Создает массив из новых компонентов <see cref="T:System.Diagnostics.Process" /> и связывает их со всеми ресурсами процесса на удаленном компьютере, для которых заданное имя процесса является общедоступным.</summary>
        <returns>Массив типа <see cref="T:System.Diagnostics.Process" />, представляющий ресурсы процесса, выполняющего указанное приложение или файл.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process> компоненты и связать их со всеми ресурсами процесса, работающих под управлением того же исполняемого файла на указанном компьютере. Ресурсы процесса должны уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A> создает системных ресурсов, а связывает их с сформированные <xref:System.Diagnostics.Process> компонентов. Объект `processName` могут быть указаны для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.  
  
 Имя процесса: понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A> полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл. Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.  
  
 Хотя процесс <xref:System.Diagnostics.Process.Id%2A> является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут выполнять приложение, заданное параметром `processName` параметр. Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A> возвращает не более одного процесса, но <xref:System.Diagnostics.Process.GetProcessesByName%2A> возвращает массив, содержащий все связанные процессы. Если необходимо работать с процессом, используя стандартные вызовы API, можно запросить каждый процесс по очереди по его идентификатору. Не удается доступ к ресурсам процесса процесса только через имя, но, получив массив <xref:System.Diagnostics.Process> компонентов, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.  
  
 Можно использовать эту перегрузку для получения процессов на локальном компьютере, а также на удаленном компьютере. Используйте «.» для указания локального компьютера. Существует другая перегрузка, которая по умолчанию используется локальный компьютер.  
  
 Можно получить доступ к процессам на удаленных компьютерах только для просмотра сведений о процессах, например статистики. Невозможно закрыть, завершать (с помощью <xref:System.Diagnostics.Process.Kill%2A>), или запуск процессов на удаленных компьютерах.  
  
   
  
## Examples  
 Следующий пример извлекает сведения из текущего процесса, процессов, запущенных на локальном компьютере, все экземпляры Блокнота, работающих на локальном компьютере и определенном процессе на локальном компьютере. Затем он извлекает сведения о тех же процессов на удаленном компьютере.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый синтаксис параметра <paramref name="machineName" />. Он может иметь нулевую длину (0).</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="machineName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Платформа операционной системы не поддерживает эту операцию на удаленных компьютерах.</exception>
        <exception cref="T:System.InvalidOperationException">Существуют проблемы при доступе к API счетчиков производительности, которые используются для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла проблема при доступе к базовому системному API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор связанного процесса.</summary>
        <value>Дескриптор, присвоенный процессу операционной системой при запуске. Система использует этот дескриптор для хранения атрибутов процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может получить дескриптор процесса, который может использоваться в качестве параметра для многих функций управления и обработки информации. Этот дескриптор можно использовать для инициализации <xref:System.Threading.WaitHandle> или вызова собственных методов с платформой неуправляемого кода.  
  
 Дескриптор этого процесса является закрытым в приложение — другими словами, процессы, которые могут использоваться только маркеры. Процесс также имеет <xref:System.Diagnostics.Process.Id%2A> которого, в отличие от <xref:System.Diagnostics.Process.Handle%2A>, уникален и, следовательно, действителен во всей системе.  
  
 Только процессы, запущенные посредством вызова <xref:System.Diagnostics.Process.Start%2A> задать <xref:System.Diagnostics.Process.Handle%2A> свойства соответствующего элемента <xref:System.Diagnostics.Process> экземпляров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не был запущен или был завершен. Свойство <see cref="P:System.Diagnostics.Process.Handle" /> не доступно для чтения из-за того, что нет процессов, связанных с этим экземпляром <see cref="T:System.Diagnostics.Process" />.  
  
 - или -  
  
 Экземпляр <see cref="T:System.Diagnostics.Process" /> был присоединен к выполняющемуся процессу, но не имеется необходимых разрешений для получения дескриптора с полными правами доступа.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Handle" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает число дескрипторов, открытых процессом.</summary>
        <value>Число дескрипторов операционной системы, открытых процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы предоставляют способ для процесса для ссылки на объекты. Процесс может получать дескрипторы файлов, ресурсов, очередей сообщений и многих других объектов операционной системы. Операционная система освобождает память, связанные с процессом только в том случае, когда число дескрипторов равно нулю.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее завершение связанного процесса.</summary>
        <value>
          Значение <see langword="true" />, если работающий системный процесс, на который ссылается компонент <see cref="T:System.Diagnostics.Process" />, был завершен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `true` для <xref:System.Diagnostics.Process.HasExited%2A> указывает, что связанный процесс был завершен обычным способом или аварийно. Вы можете запросить или принудить связанный процесс завершиться вызовом <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Если дескриптор открыт для процесса, операционная система освобождает память процесса, когда процесс был завершен, но сохраняет административную информацию о процессе, например дескриптор, код выхода и время выхода. Чтобы получить эти сведения, можно использовать <xref:System.Diagnostics.Process.ExitCode%2A> и <xref:System.Diagnostics.Process.ExitTime%2A> свойства. Эти свойства заполняются автоматически для процессов, запущенных этим компонентом. Административная информация освобождается при всех <xref:System.Diagnostics.Process> компоненты, связанные с системным процессом, разрушены и больше не содержат дескрипторов завершенных процессов.  
  
 Процесс может завершиться независимо от кода. Если вы начали с помощью этого компонента, система обновляет значение <xref:System.Diagnostics.Process.HasExited%2A> автоматически, даже если связанный процесс завершается независимо друг от друга.  
  
> [!NOTE]
>  Когда стандартный вывод был перенаправлен обработчикам асинхронных событий, это возможно, что обработка вывода не имеют завершена, когда это свойство возвращает `true`. Чтобы обеспечить завершение асинхронной обработки событий, вызовите <xref:System.Diagnostics.Process.WaitForExit> перегрузку, принимающую параметр отсутствует перед проверкой <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем она получает использование физической памяти связанного процесса в 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается прежде, чем 10 секунд ожидания. В примере закрывается процесс, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">С объектом не связаны никакие процессы.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удалось получить код выхода для процесса.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.HasExited" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор связанного процесса.</summary>
        <value>Созданный системой уникальный идентификатор, на который ссылается этот экземпляр <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Процесс <xref:System.Diagnostics.Process.Id%2A> не является допустимым, если связанный процесс не выполняется. Таким образом, следует убедиться, что процесс выполняется до получения <xref:System.Diagnostics.Process.Id%2A> свойство. До завершения процесса, идентификатор процесса однозначно идентифицирует процесс во всей системе.  
  
 Можно связать процесс, на котором выполняется на локальном или удаленном компьютере в новую <xref:System.Diagnostics.Process> экземпляра, передавая идентификатор процесса для <xref:System.Diagnostics.Process.GetProcessById%2A> метод. <xref:System.Diagnostics.Process.GetProcessById%2A> — `static` метод, который создает новый компонент и задает <xref:System.Diagnostics.Process.Id%2A> свойства для нового <xref:System.Diagnostics.Process> экземпляр автоматически.  
  
 Идентификаторы процесса могут использоваться повторно в системе. <xref:System.Diagnostics.Process.Id%2A> Значение свойства является уникальным только во время выполнения процесса. После завершения процесса, можно повторно использовать система <xref:System.Diagnostics.Process.Id%2A> значение свойства для несвязанного процесса.  
  
 Поскольку этот идентификатор уникален в системе, можно передать его в другие потоки, в качестве альтернативы для передачи <xref:System.Diagnostics.Process> экземпляра. Это действие может сэкономить ресурсы системы, но гарантирует, что правильно задан процесс.  
  
   
  
## Examples  
 В следующем примере демонстрируется получение <xref:System.Diagnostics.Process.Id%2A> для всех экземпляров приложения. Код создает новый экземпляр блокнота, перечисляет все экземпляры Блокнота и затем позволяет пользователю ввести <xref:System.Diagnostics.Process.Id%2A> номер для удаления конкретного экземпляра.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.Id" /> процесса не задано.  
  
 - или -  
  
 С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для свойства <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Немедленно останавливает связанный процесс.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> Вызывает принудительное завершение процесса, пока <xref:System.Diagnostics.Process.CloseMainWindow%2A> только запрашивает завершения. При выполнении процесса с графическим интерфейсом его цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A> отправляет запрос на закрытие главного окна, который закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата. Запрос на завершение процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A> не вынуждает приложение, чтобы выйти из программы. Приложение может запросить проверку пользователя перед завершением работы или она может отказаться закрыться. Чтобы принудительно завершить работу приложения, используйте <xref:System.Diagnostics.Process.Kill%2A> метод. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A> идентична Закрыть главное окно приложения с помощью системного меню пользователь. Таким образом запрос на завершение процесса закрытием главного окна не вынуждает приложение немедленно завершиться.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A> Метод выполняется асинхронно. После вызова метода <xref:System.Diagnostics.Process.Kill%2A> метод, вызовите <xref:System.Diagnostics.Process.WaitForExit%2A> метод для ожидания завершения выполнения или проверка процесса <xref:System.Diagnostics.Process.HasExited%2A> свойства, чтобы определить, если процесс завершился.  
  
 Данные, изменять процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове метода <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> вызывает аварийного завершения процесса и должен использоваться только при необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A> включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом. Если <xref:System.Diagnostics.Process.CloseMainWindow%2A> завершается ошибкой, можно использовать <xref:System.Diagnostics.Process.Kill%2A> завершить процесс. <xref:System.Diagnostics.Process.Kill%2A> Это единственный способ завершения процессов, не имеющих графического интерфейса.  
  
 Можно вызвать <xref:System.Diagnostics.Process.Kill%2A> и <xref:System.Diagnostics.Process.CloseMainWindow%2A> только для процессов, запущенных на локальном компьютере. Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, могут только просматривать информацию для процессов, запущенных на удаленных компьютерах.  
  
> [!NOTE]
>  Если вызов <xref:System.Diagnostics.Process.Kill%2A> метод внесенные в настоящее время выполняется завершение процесса, <xref:System.ComponentModel.Win32Exception> выдается в случае доступ запрещен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Связанный процесс не может быть завершен.  
  
 - или -  
  
 Выполняется завершение процесса.  
  
 - или -  
  
 Связанный процесс является исполняемым файлом Win16.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.Kill" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Этот процесс уже завершился.  
  
 - или -  
  
 С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выбирает компонент <see cref="T:System.Diagnostics.Process" /> из состояния, позволяющего ему взаимодействовать с процессами операционной системы, запущенными в специальном режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые процессы операционной системы, выполняются в специальном режиме. Попытка чтения свойства или присоединения к процессам возможна только после вызова метода <xref:System.Diagnostics.Process.EnterDebugMode%2A> в компоненте. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A> при больше не нужен доступ к процессам, выполняющимся в специальном режиме.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя компьютера, на котором выполняется связанный процесс.</summary>
        <value>Имя компьютера, на котором выполняется связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно просмотреть статистические данные и сведения о процессе для процессов, запущенных на удаленном компьютере, но не может вызвать <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, или <xref:System.Diagnostics.Process.Kill%2A> на удаленных компьютерах.  
  
> [!NOTE]
>  При выполнении процесса на локальном компьютере это свойство возвращает точку (".») для имени компьютера. Следует использовать <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> свойства, чтобы получить имя компьютера правильно.  
  
   
  
## Examples  
 Чтобы использовать следующий пример, необходимо сначала открыть хотя бы один экземпляр программы "Блокнот" на удаленном компьютере. Пример запрашивает имя удаленного компьютера, на котором выполняется Блокнот, а затем отображает соответствующее <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, и <xref:System.Diagnostics.Process.MachineName%2A> свойства для каждого экземпляра.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает главный модуль связанного процесса.</summary>
        <value>Модуль <see cref="T:System.Diagnostics.ProcessModule" />, который был использован для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. <xref:System.Diagnostics.Process.MainModule%2A> Свойство позволяет просматривать информацию об исполняемом файле, используемая для запуска процесса, включая имя модуля, имя файла и сведения о модуле памяти.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainModule" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32-разрядный процесс пытается получить доступ к модулям 64-разрядного процесса.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
 - или -  
  
 Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает дескриптор главного окна связанного процесса.</summary>
        <value>Созданный системой дескриптор главного окна связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Главное окно — это окно, открытых процессом в настоящий момент фокус ( <xref:System.Windows.Forms.Form.TopLevel%2A> формы). Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A> метод для обновления <xref:System.Diagnostics.Process> объекта, чтобы получить текущий дескриптор главного окна, если он был изменен. Как правило, поскольку кэшируется дескриптор окна, используйте <xref:System.Diagnostics.Process.Refresh%2A> порт заранее, чтобы гарантировать, что можно будет получить текущий дескриптор.  
  
 Вы можете получить <xref:System.Diagnostics.Process.MainWindowHandle%2A> свойством только для процессов, запущенных на локальном компьютере. <xref:System.Diagnostics.Process.MainWindowHandle%2A> Свойство имеет значение, которое однозначно определяет окно, связанный с процессом.  
  
 Процесс имеет главное окно, связанное с ним только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна, <xref:System.Diagnostics.Process.MainWindowHandle%2A> значение равно нулю. Значение является ноль, для процессов, которые были скрыты, то есть, процессов, которые не отображаются на панели задач. Это может быть случай для процессов, которые отображаются в виде значков в области уведомлений в правой части панели задач.  
  
 Если вы только что запущен процесс и хотите использовать дескриптор главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A> метод, который позволяет процессу завершить запуск, убедившись, что дескриптор главного окна был создан. В противном случае будет создаваться исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> не определено, так как процесс завершился.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает заголовок главного окна процесса.</summary>
        <value>Заголовок главного окна процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Процесс имеет главное окно, связанное с ним только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна (, чтобы <xref:System.Diagnostics.Process.MainWindowHandle%2A> равно нулю), <xref:System.Diagnostics.Process.MainWindowTitle%2A> — пустая строка (»»). Если вы только что запущен процесс и хотите использовать заголовок главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A> метод, который позволяет процессу завершить запуск, убедившись, что дескриптор главного окна был создан. В противном случае система создает исключение.  
  
> [!NOTE]
>  Главное окно — окно, которое в данный момент имеет фокус. Обратите внимание, что это может быть основного окна для процесса. Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A> метод для обновления <xref:System.Diagnostics.Process> объекта, чтобы получить текущий дескриптор главного окна, если он был изменен.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр программы "Блокнот" и получает заголовок главного окна процесса.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> не определено, так как процесс был завершен.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный допустимый размер рабочего множества (в байтах) для связанного процесса.</summary>
        <value>Максимальный размер рабочего множества в байтах, доступного в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлов и файлов system.dll. При увеличении размера рабочего набора, увеличивает объем памяти.  
  
 Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз при создании ресурса процесса, система резервирует объем памяти равен минимальному размеру рабочего набора процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше максимального размера.  
  
 Система задает размеры рабочего множества по умолчанию. Вы можете изменить эти размеры, используя <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A> члены. Однако задание этих значений не гарантирует, память будет зарезервированной или находящейся.  
  
> [!NOTE]
>  При увеличении размера рабочего множества процесса, можно воспользоваться физической памяти от остальной части системы. Убедитесь, не запрашивают размер минимального или максимального рабочего набора, в которой слишком велика, так как производительность системы может ухудшиться.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Максимальный размер рабочего множества является недопустимым. Это значение должно быть больше минимального размера рабочего множества или равно ему.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить сведения о рабочем множестве из ресурса связанного процесса.  
  
 - или -  
  
 Идентификатор или дескриптор процесса равен нулю, так как процесс не запущен.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
 - или -  
  
 Процесс завершен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает минимальный допустимый размер рабочего множества (в байтах) для связанного процесса.</summary>
        <value>Минимальный размер рабочего множества в байтах, требуемый в памяти для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлов и файлов system.dll. При увеличении размера рабочего набора, увеличивает объем памяти.  
  
 Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз при создании ресурса процесса, система резервирует объем памяти равен минимальному размеру рабочего набора процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше максимального размера.  
  
 Система задает размеры рабочего множества по умолчанию. Вы можете изменить эти размеры, используя <xref:System.Diagnostics.Process.MaxWorkingSet%2A> и <xref:System.Diagnostics.Process.MinWorkingSet%2A> члены. Однако задание этих значений не гарантирует, память будет зарезервированной или находящейся.  
  
> [!NOTE]
>  При увеличении размера рабочего множества процесса, можно воспользоваться физической памяти от остальной части системы. Убедитесь, не запрашивают размер минимального или максимального рабочего набора, в которой слишком велика, так как производительность системы может ухудшиться.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Минимальный размер рабочего множества является недопустимым. Это значение должно быть не больше максимального размера рабочего множества.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить сведения о рабочем множестве из ресурса связанного процесса.  
  
 - или -  
  
 Идентификатор или дескриптор процесса равен нулю, так как процесс не запущен.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> процесса, выполняющегося на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
 - или -  
  
 Процесс завершен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает модули, которые были загружены связанным процессом.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessModule" />, который предоставляет модули, загруженные связанным процессом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. Объект <xref:System.Diagnostics.ProcessModule> экземпляра позволяет просматривать информацию о модуле, включая имя модуля, имя файла и сведения о модуле памяти.  
  
 Процесс можно загрузить несколько модулей в память. Например файлы .exe, которые загружают Дополнительные DLL-файлы имеют несколько модулей.  
  
 После запуска процесса, эта коллекция будет пустой, пока процесс загрузки системы. Если процесс имеет главное окно, можно вызвать <xref:System.Diagnostics.Process.WaitForInputIdle%2A> перед считыванием этого свойства, чтобы убедиться, что коллекция не пуста при получения списка.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Modules" /> для процесса, выполняемого на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Modules" /> системного или бездействующего процесса. Эти процессы не имеют модулей.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем системной памяти в байтах, выделенной для связанного процесса, которую нельзя записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер невыгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и состоит из выгружаемого и невыгружаемого пулы. Выделение памяти в невыгружаемом страничном остаются в системной памяти и не выгружаются в файл подкачки виртуальной памяти.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт в невыгружаемом страничном пуле** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> является методом API, который вызывает <xref:System.Diagnostics.Process.Exited> событий. Вызов <xref:System.Diagnostics.Process.OnExited%2A> вызывает <xref:System.Diagnostics.Process.Exited> возникновения события и является единственным способом для вызова событий, используя <xref:System.Diagnostics.Process> компонента. <xref:System.Diagnostics.Process.OnExited%2A> используется главным образом при создании производных классов из компонента.  
  
 В качестве альтернативы для <xref:System.Diagnostics.Process.OnExited%2A>, можно написать собственный обработчик событий. Создание собственных делегата обработчика событий и собственного метода обработки событий.  
  
> [!NOTE]
>  При использовании среды Visual Studio делегата обработчика событий (AddOnExited) и метод обработки событий (Process1_Exited) создаются автоматически при перетаскивании <xref:System.Diagnostics.Process> компонента на форму и дважды щелкните значок. Создаваемый код, необходимо выполнить после <xref:System.Diagnostics.Process.Exited> вводится в процедуру Process1_Exited событием. Необходимо создать <xref:System.Diagnostics.Process.OnExited%2A> члена, так как она реализована для вас.  
  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Diagnostics.Process.OnExited%2A> метода в производном классе.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение записывает строку в свой перенаправленный поток <see cref="P:System.Diagnostics.Process.StandardOutput" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> Указывает, что связанный <xref:System.Diagnostics.Process> записал строки, завершается символом перевода строки в свой перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Событие включено во время асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>. Запуск асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardOutput%2A> поток <xref:System.Diagnostics.Process>, добавьте обработчик событий <xref:System.Diagnostics.Process.OutputDataReceived> событий и вызовов <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. После этого <xref:System.Diagnostics.Process.OutputDataReceived> сигналы процесс записывает строку в перенаправленной <xref:System.Diagnostics.Process.StandardOutput%2A> потока, пока процесс завершает работу или вызывает <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  Приложение, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A> метод, чтобы гарантировать записан выходной буфер.  
  
   
  
## Examples  
 Следующий пример показывает, как для выполнения асинхронных операций чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A> поток `ipconfig` команды.  
  
 В примере создается делегат события для `OutputHandler` обработчик событий и связывает его с <xref:System.Diagnostics.Process.OutputDataReceived> событий. Обработчик событий получает строки текста из перенаправленной <xref:System.Diagnostics.Process.StandardOutput%2A> поток, форматирует текст и сохраняет его в выходную строку, которая отображается в окне консоли в примере позже.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти в файле подкачки виртуальной памяти, используемой процессом, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. Не используется выгружаемой памяти, могут передаваться в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти, используемой операционной системы для процесса, используйте <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> свойство.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт файла подкачки** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот и извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем выгружаемой системной памяти (в байтах), выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенной системой для связанного процесса, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем выгружаемой системной памяти (в байтах), выделенной для связанного процесса.</summary>
        <value>Объем системной памяти в байтах, выделенной для связанного процесса, которую можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое значение этого свойства представляет текущий размер выгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и состоит из выгружаемого и невыгружаемого пулы. Не используется выгружаемой памяти, могут передаваться в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти приложения, используемой процессом, используйте <xref:System.Diagnostics.Process.PagedMemorySize64%2A> свойство.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт в выгружаемом страничном пуле** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальный объем памяти в байтах в файле подкачки виртуальной памяти, используемой связанным процессом.</summary>
        <value>Максимальный объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальный объем памяти в байтах в файле подкачки виртуальной памяти, используемой связанным процессом.</summary>
        <value>Максимальный объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое значение этого свойства представляет максимальный размер памяти в файле подкачки виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. Не используется выгружаемой памяти, могут передаваться в файл подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт файла подкачки (пик)** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем виртуальной памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальный объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем виртуальной памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальный объем виртуальной памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет максимальный объем виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физическую память или со страницами, сохраненными в файле подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **виртуальных байт (пик)** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальный размер рабочего множества для связанного процесса (в байтах).</summary>
        <value>Максимальный объем физической памяти, запрошенной связанным процессом одновременно (в байтах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и библиотеки системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает максимальный объем физической памяти (в байтах), используемой связанным процессом.</summary>
        <value>Максимальный объем физической памяти в байтах, выделенной для связанного процесса с момента его запуска.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством представляет максимальный размер памяти рабочего множества, используемой процессом с момента его запуска, в байтах. Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции из модулей процесса и библиотеки системы.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **рабочий набор (пик)** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли операционная система временно увеличить приоритет связанного процесса, когда основное окно процесса получит фокус.</summary>
        <value>
          Значение <see langword="true" />, если должно иметь место динамическое увеличение приоритета процесса, когда процесс выбирается из состояния ожидания; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток выполняется в процессе, для которого класс приоритета имеет одно из значений перечисления динамического приоритета (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), система временно увеличивает приоритет потока, когда он берется из состояния ожидания. Это действие предотвращает прерывание выполнения текущего потока другими процессами. <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Параметр влияет на все существующие потоки и каких-либо потоков, создаваемых в последующем процессом. Чтобы восстановить нормальное поведение, задайте <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> свойства `false`.  
  
> [!NOTE]
>  Повышение приоритета слишком высокого приоритета может лишить ресурсов может вызвать операционную систему и сетевые функции, вызывающих проблемы с другими задачами операционной системы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается получить информацию о повышении приоритета от связанного ресурса процесса.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.  
  
 - или -  
  
 Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает общую категорию приоритета для процесса.</summary>
        <value>Категория приоритета для связанного процесса, из которой вычисляется свойство <see cref="P:System.Diagnostics.Process.BasePriority" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс приоритета процесса включает диапазон уровней приоритета потоков. Потоки с различными приоритетами, которые выполняются в процессе запуска относительно класс приоритета процесса. Win32 использует четыре класса приоритетов с семью основными уровнями приоритета каждого класса. Эти классы приоритета процесса, сохраняются в <xref:System.Diagnostics.ProcessPriorityClass> приоритета процесса значение перечисления, который позволяет <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, или <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. На основе времени, затраченного или других показателях, базовый уровень приоритета можно изменить в операционной системе, если процесс должен поместить впереди других для доступа к процессору. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> для временного увеличения уровня приоритета потоков, взятых из состояния ожидания. Приоритет сбрасывается при возвращении процесса в состояние ожидания.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> Позволяет посмотреть стартовый приоритет, присвоенный процессу. Однако, так как он доступен только для чтения, его нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A> свойство для задания приоритета процесса. Чтобы изменить приоритет, используйте <xref:System.Diagnostics.Process.PriorityClass%2A> свойство, которое возвращает или задает общую категорию приоритета для процесса.  
  
 Класс приоритета нельзя просмотреть с помощью системного монитора. В следующей таблице показаны связи между <xref:System.Diagnostics.Process.BasePriority%2A> и <xref:System.Diagnostics.Process.PriorityClass%2A> значения.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Не удается задать или получить сведения о приоритете процесса от связанного ресурса процесса.  
  
 - или -  
  
 Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PriorityClass" /> для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Вы задали для класса <see cref="P:System.Diagnostics.Process.PriorityClass" /> значение <see langword="AboveNormal" /> или <see langword="BelowNormal" /> при использовании Windows 98 или Windows Millennium Edition (Windows Me). Эти платформы не поддерживают такие значения для класса приоритета.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Невозможно задать класс приоритета, поскольку он не использует допустимое значение, как определено в перечислении <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Число байтов, выделенных связанным процессом, которые не могут быть доступны другим процессам.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем памяти в байтах, выделенное для связанного процесса, которое не может быть доступно другим процессам.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти, используемой процессом, в байтах, который не может совместно использоваться другими процессами.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт исключительного пользования** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает права доступа на время процессора для этого процесса.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое процесс потратил на выполнение кода внутри ядра операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> для процесса, выполняемого на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя процесса.</summary>
        <value>Имя, которое использует система для идентификации процесса для пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> Свойство содержит имя исполняемого файла, например Outlook, который не поддерживает расширения .exe или путь. Это полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл.  
  
> [!NOTE]
>  На [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] операционных систем <xref:System.Diagnostics.Process.ProcessName%2A> свойство может быть усечено до 15 символов, если не удается получить сведения о процессе модуля.  
  
 Можно вызвать <xref:System.Diagnostics.Process.GetProcessesByName%2A>, передавая ему имя исполняемого файла, для получения массива, содержащего каждый выполняющийся экземпляр на указанном компьютере. Можно использовать этот массив, например, завершить работу всех выполняющихся экземпляров исполняемого файла.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет идентификатора, или нет процесса, связанного с <see cref="T:System.Diagnostics.Process" />.  
  
 - или -  
  
 Связанный процесс завершился.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">Процесс отсутствует на этом компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает процессоры, на которых может быть запланировано выполнение потоков данного процесса.</summary>
        <value>Битовая маска, представляющая процессоры, на которых могут выполняться потоки связанного процесса. По умолчанию маска зависит от числа процессоров в компьютере. Значение по умолчанию — 2 <sup>n</sup> -1, где n — число процессоров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В Windows 2000 и более поздних версиях поток в процессе может перемещаться с процессора на процессор, с каждым перемещением обновление кэша процессора. При больших системных нагрузках Указание определенного процессора для обработки определенного потока может повысить производительность за счет сокращения числа перезагрузок кэша процессора. Связь между процессор и поток называется соответствием процессоров.  
  
 Каждый процессор представляется как бит. Бит 0 — это первый процессор, 1-й бит — второй процессор и т. д. Если бит устанавливается в значение 1, соответствующий процессор будет выбран для назначения потоков. При задании <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значение, равное нулю, операционная система планирование набор алгоритмов схожесть потоков. Когда <xref:System.Diagnostics.Process.ProcessorAffinity%2A> имеет значение любое ненулевое значение, значение интерпретируется как битовую маску, определяющую процессоры, годные для выбора.  
  
 В следующей таблице показаны несколько <xref:System.Diagnostics.Process.ProcessorAffinity%2A> значения для системы восемью процессорами.  
  
|Битовая маска|Двоичное значение|Подходящие процессоры|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 и 2|  
|0x0007|00000000 00000111|1, 2 и 3|  
|0x0009|00000000 00001001|1 и 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 и 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          Не удается задать или получить сведения о <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> от связанного ресурса процесса.  
  
 - или -  
  
 Идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс <see cref="P:System.Diagnostics.Process.Id" /> недоступен.  
  
 - или -  
  
 Процесс завершен.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет любые кэшированные внутри компонента процесса сведения о связанном процессе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После <xref:System.Diagnostics.Process.Refresh%2A> вызова, то первый же запрос информации о каждом свойстве компонент процесса получает новое значение из связанного процесса.  
  
 Когда <xref:System.Diagnostics.Process> компонента связан с ресурсом процесса, значения свойств <xref:System.Diagnostics.Process> немедленно заполняются по состоянию процесса. Если сведения о связанном процессе впоследствии изменяется, эти изменения не отражаются в <xref:System.Diagnostics.Process> компонента кэшированные значения. <xref:System.Diagnostics.Process> Компонент является моментальным снимком ресурса процесса на момент они связаны. Чтобы просмотреть текущие значения для связанного процесса, вызовите <xref:System.Diagnostics.Process.Refresh%2A> метод.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем она получает использование физической памяти связанного процесса в 2-секундным интервалом не более 10 секунд. В данном примере отслеживается ли процесс завершается прежде, чем 10 секунд ожидания. В примере закрывается процесс, если он по-прежнему выполняется через 10 секунд.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, отвечает или нет пользовательский интерфейс.</summary>
        <value>
          Значение <see langword="true" />, если пользовательский интерфейс связанного процесса отвечает системе; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если процесс имеет пользовательский интерфейс, <xref:System.Diagnostics.Process.Responding%2A> связывается пользовательский интерфейс, чтобы определить, отвечает ли процесс на ввод данных пользователем. Если интерфейс не отвечает немедленно, <xref:System.Diagnostics.Process.Responding%2A> возвращает `false`. Используйте это свойство, чтобы определить, является ли интерфейс связанного процесса перестал отвечать на запросы.  
  
 Если процесс не имеет <xref:System.Diagnostics.Process.MainWindowHandle%2A>, это свойство возвращает `true`.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.Responding" /> для процесса, выполняемого на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор процесса.</summary>
        <value>Собственный дескриптор процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескриптор доступен только в том случае, если вызывающий компонент запущен процесс.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор сеанса служб терминалов для связанного процесса.</summary>
        <value>Идентификатор сеанса служба терминалов для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> Свойство идентифицирует сеанс, в котором выполняется приложение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">С этим процессом никакие сеансы не связаны.</exception>
        <exception cref="T:System.InvalidOperationException">С этим идентификатором сеанса не связаны никакие процессы.  
  
 - или -  
  
 На этом компьютере нет связанного процесса.</exception>
        <exception cref="T:System.PlatformNotSupportedException">В Windows 98 свойство <see cref="P:System.Diagnostics.Process.SessionId" /> не поддерживается.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для чтения вывода ошибок приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока ошибок приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в его стандартный поток ошибок, что текст обычно отображается на консоли. Путем перенаправления <xref:System.Diagnostics.Process.StandardError%2A> потока, можно управлять или подавлять вывод ошибок процесса. Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.  
  
> [!NOTE]
>  Для использования <xref:System.Diagnostics.Process.StandardError%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо задать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> для `true`. В противном случае чтение из <xref:System.Diagnostics.Process.StandardError%2A> поток вызывает исключение.  
  
 Перенаправленный <xref:System.Diagnostics.Process.StandardError%2A> возможность чтения потока, синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> синхронной операции чтения в поток вывода ошибок в процессе выполнения. Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardError%2A> потока или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.  
  
 Синхронное чтение операций устанавливают зависимость между считыванием вызывающего оператора из <xref:System.Diagnostics.Process.StandardError%2A> поток и дочерний процесс записи в поток. Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции, и не может происходить. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.  
  
 Например, следующий код C#, показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardError.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например, следующий код C#, выполняет операции чтения в обоих потоках.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке.  
  
> [!NOTE]
>  Нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process> открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardError%2A> поток, или наоборот. Однако можно считать два различных потоков в различных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> и затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере используется `net use` команду с пользователя указан аргумент для отображения сетевого ресурса. Затем считывается стандартный поток ошибок сетевой команды и записывается в консоль.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardError" /> не был определен для переадресации. Убедитесь, что для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> задано <see langword="true" />, а для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> — <see langword="false" />.  
  
 \- или -  
  
 Поток <see cref="P:System.Diagnostics.Process.StandardError" /> был открыт для асинхронных операций чтения с <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для записи ввода приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamWriter" />, используемый для записи стандартного входного потока приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Diagnostics.Process> может считывать введенный текст из его стандартный входной поток, обычно клавиатуры. Путем перенаправления <xref:System.Diagnostics.Process.StandardInput%2A> потока, можно программно задать входные данные. Например вместо ввода с клавиатуры, чтобы обеспечить текст из содержимого назначенного файла или выходных данных другого приложения.  
  
> [!NOTE]
>  Для использования <xref:System.Diagnostics.Process.StandardInput%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо задать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> для `true`. В противном случае запись в <xref:System.Diagnostics.Process.StandardInput%2A> поток вызывает исключение.  
  
   
  
## Examples  
 Следующий пример показывает, как перенаправлять <xref:System.Diagnostics.Process.StandardInput%2A> потока процесса. В примере запускается `sort` с перенаправленным вводом. Затем пользователю для текста и передает его `sort` процесса с помощью перенаправленных <xref:System.Diagnostics.Process.StandardInput%2A> потока. `sort` Результаты отображаются пользователю на консоль.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardInput" /> Поток не был определен, так как для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> установлено значение <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает поток, используемый для чтения текстовых выходных данных приложения.</summary>
        <value>Объект <see cref="T:System.IO.StreamReader" />, используемый для чтения стандартного потока вывода приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в его стандартный поток, что текст обычно отображается на консоли. Путем перенаправления <xref:System.Diagnostics.Process.StandardOutput%2A> потока, можно управлять или подавлять вывод процесса. Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.  
  
> [!NOTE]
>  Для использования <xref:System.Diagnostics.Process.StandardOutput%2A>, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> для `false`, и необходимо задать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> для `true`. В противном случае чтение из <xref:System.Diagnostics.Process.StandardOutput%2A> поток вызывает исключение.  
  
 Перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A> возможность чтения потока, синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнения синхронных операций чтения в выходной поток процесса. Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardOutput%2A> потока или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.  
  
 Синхронное чтение операций устанавливают зависимость между считыванием вызывающего оператора из <xref:System.Diagnostics.Process.StandardOutput%2A> поток и дочерний процесс записи в поток. Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции, и не может происходить. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.  
  
 Например, следующий код C#, показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardOutput.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardOutput.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например, следующий код C#, выполняет операции чтения в обоих потоках.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке.  
  
> [!NOTE]
>  Нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process> открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме. Например, не выполняйте <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> вызовом <xref:System.IO.StreamReader.ReadLine%2A> на <xref:System.Diagnostics.Process.StandardOutput%2A> поток, или наоборот. Однако можно считать два различных потоков в различных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> и затем вызвать <xref:System.IO.StreamReader.ReadLine%2A> для <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
   
  
## Examples  
 В следующем примере выполняется команда ipconfig.exe и перенаправляет его стандартные выходные данные в окне консоли в примере.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> не был определен для переадресации. Убедитесь, что для <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> задано <see langword="true" />, а для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> — <see langword="false" />.  
  
 \- или -  
  
 Поток <see cref="P:System.Diagnostics.Process.StandardOutput" /> был открыт для асинхронных операций чтения с <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает ресурс процесса и связывает его с компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает (или повторно использует) ресурс процесса, определенный свойством <see cref="P:System.Diagnostics.Process.StartInfo" /> этого компонента <see cref="T:System.Diagnostics.Process" />, и связывает его с компонентом.</summary>
        <returns>
          Значение <see langword="true" />, если ресурс процесса запущен; значение <see langword="false" />, если новый ресурс процесса не был запущен (например, при повторном использовании существующего процесса).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для запуска ресурса процесса и связывания его с текущим <xref:System.Diagnostics.Process> компонента. Возвращаемое значение `true` указывает, что новый ресурс процесса был запущен. Если ресурс процесса, указанный параметром <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> свойство уже выполняется на компьютере, дополнительные ресурсы процесса запуска. Вместо этого выполняющийся ресурс процесса используется повторно и `false` возвращается.  
  
 Можно запустить приложение ClickOnce, указав расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
> [!NOTE]
>  Если вы используете Visual Studio, эта перегрузка <xref:System.Diagnostics.Process.Start%2A> метод является тот, который можно вставить в код после перетаскивания <xref:System.Diagnostics.Process> компонента в конструктор. Используйте `Properties` окна, чтобы развернуть `StartInfo` категории и записи соответствующего значения в `FileName` свойство. Изменения отобразятся в форме `InitializeComponent` процедуры.  
  
 Эта перегрузка <xref:System.Diagnostics.Process.Start%2A> не `static` метод. Следует вызвать его из экземпляра <xref:System.Diagnostics.Process> класса. Перед вызовом метода <xref:System.Diagnostics.Process.Start%2A>, необходимо сначала задать <xref:System.Diagnostics.Process.StartInfo%2A> сведения о свойстве для данного <xref:System.Diagnostics.Process> экземпляра, так как эти сведения используется для определения ресурса процесса для запуска.  
  
 Другие перегрузки <xref:System.Diagnostics.Process.Start%2A> метод `static` члены. Необходимо создать экземпляр <xref:System.Diagnostics.Process> компонента перед вызовом этих перегрузок метода. Вместо этого можно вызвать метод <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> класса а, а новый <xref:System.Diagnostics.Process> компонент создается в том случае, если процесс был запущен. Или, `null` возвращается, если процесс был использован повторно. Ресурс процесса автоматически связывается с новым <xref:System.Diagnostics.Process> компонент, который возвращается методом <xref:System.Diagnostics.Process.Start%2A> метод.  
  
 <xref:System.Diagnostics.Process.StartInfo%2A> Члены, которые могут использоваться для дублирования функциональные возможности `Run` диалогового окна `Start` меню. Все, что можно ввести в командной строке можно запустить, задав соответствующие значения <xref:System.Diagnostics.Process.StartInfo%2A> свойство. Единственным <xref:System.Diagnostics.Process.StartInfo%2A> свойство, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Свойства не должен быть исполняемым файлом. Это может быть файл любого типа, для которого был связан с помощью приложения, установленного в системе расширения. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство может иметь расширение .txt, если текстовые файлы связаны с редактором, например «Блокнот» или расширением DOC, при наличии файлов с инструментом обработки текстов, например Microsoft Word.  
  
 В командной строке можно указать действия, выполняемые для определенных типов файлов. Например можно распечатать документы или изменения текстовых файлов. Укажите эти действия с помощью <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> свойство. Для других типов файлов, можно указать аргументы командной строки при запуске файла из `Run` диалоговое окно. Например, можно передать URL-адрес в качестве аргумента, если задать обозреватель в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Эти аргументы могут быть заданы в <xref:System.Diagnostics.Process.StartInfo%2A> свойства <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> элемента.  
  
 Если путь к переменной, объявленной в системы с помощью кавычки, необходимо указывать полное этот путь при запуске любого процесса из этого расположения. В противном случае система не найдет путь. Например если `c:\mypath` не находится в пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо указывать полное любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  ASP.NET Web страницы и сервера управления выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> метода в веб-страницы ASP.NET или серверный элемент управления выполняет новый процесс, на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, как браузер клиента и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов. Закрывать процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Можно проверить, была ли процесс уже закрыта с помощью его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент процесса <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибут `[STAThread]` на `main()` метод. В противном случае управляемый поток может быть в `unknown` состояние или поместить в `MTA` состоянии, последний конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют, чтобы состояние подразделения не были `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере используется экземпляр <xref:System.Diagnostics.Process> класса для запуска процесса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Имя файла не было указано в свойстве <see cref="P:System.Diagnostics.Process.StartInfo" /> компонента <see cref="T:System.Diagnostics.Process" />.
 - или- Член <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> свойства <see cref="P:System.Diagnostics.Process.StartInfo" /> имеет значение <see langword="true" />, тогда как <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> или <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> имеет значение <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при открытии связанного файла.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в операционных системах без поддержки оболочки, таких как Nano Server (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">Объект <see cref="T:System.Diagnostics.ProcessStartInfo" />, который содержит информацию, использующуюся для запуска процесса, включая имя файла и все аргументы командной строки.</param>
        <summary>Запускает ресурс процесса, определенный параметром, содержащим стартовую информацию процесса (например, имя файла запускаемого процесса), и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для запуска ресурса процесса путем указания <xref:System.Diagnostics.ProcessStartInfo> экземпляра. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес, адрес исполняемый файл, чтобы запустить процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Использование этой перегрузки с <xref:System.Diagnostics.ProcessStartInfo> параметра является альтернативой явным шагам создания нового <xref:System.Diagnostics.Process> экземпляр, задание его <xref:System.Diagnostics.Process.StartInfo%2A> свойства, а вызов метода <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 С помощью <xref:System.Diagnostics.ProcessStartInfo> экземпляр как параметр можно вызывать <xref:System.Diagnostics.Process.Start%2A> наиболее контроль над содержимым, передаваемым в вызов для запуска процесса. Если требуется передать только имя файла или имя файла с аргументами, нет необходимости создавать новый <xref:System.Diagnostics.ProcessStartInfo> экземпляра, несмотря на то, что это допустимый параметр. Единственным <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> свойство, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Свойство не требуется предоставлять исполняемый файл. Это может быть файл любого типа, для которого был связан с помощью приложения, установленного в системе расширения. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство может иметь расширение .txt, если текстовые файлы связаны с редактором, например «Блокнот» или расширением DOC, при наличии файлов с инструментом обработки текстов, например Microsoft Word.  
  
 Можно запустить приложение ClickOnce, указав расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> свойства <xref:System.Diagnostics.Process.StartInfo%2A> экземпляр заданы, неуправляемой `CreateProcessWithLogonW` вызывается функция, которая запускает процесс в новое окно даже в случае <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> значение свойства `true` или <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> значение свойства <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Если <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> свойство `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> свойство должно быть в формате имени участника-пользователя *пользователя*@*DNS_domain_name*.   
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать эти перегрузки, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузка, которая не имеет параметров позволяют задать стартовую информацию для ресурса процесса с помощью <xref:System.Diagnostics.ProcessStartInfo> экземпляра.  
  
 Если путь к переменной, объявленной в системы с помощью кавычки, необходимо указывать полное этот путь при запуске любого процесса из этого расположения. В противном случае система не найдет путь. Например если `c:\mypath` не находится в пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо указывать полное любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  ASP.NET Web страницы и сервера управления выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> метода в веб-страницы ASP.NET или серверный элемент управления выполняет новый процесс, на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, как браузер клиента и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов. Закрывать процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Можно проверить, была ли процесс уже закрыта с помощью его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на `startInfo` параметр, убедитесь, что установки потоковой модели приложения, задав атрибут `[STAThread]` на `main()` метод. В противном случае управляемый поток может быть в `unknown` состояние или поместить в `MTA` состоянии, последний конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют, чтобы состояние подразделения не были `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала порождается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображаются несколько определенных страниц или сайтов. Наконец он запускает Internet Explorer с окном минимизируется при переходе к определенному сайту.  
  
 Дополнительные примеры других использования данного метода, см. в разделе отдельных свойств <xref:System.Diagnostics.ProcessStartInfo> класса.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Имя файла не было указано в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> параметра <paramref name="startInfo" />.  
  
 - или -  
  
 Свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> параметра<paramref name="startInfo" /> имеет значение <see langword="true" /> и <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> или свойство <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> также имеет значение <see langword="true" />.  
  
 - или -  
  
 Свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> параметра <paramref name="startInfo" /> имеет значение <see langword="true" />, и свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> не равно <see langword="null" /> или не является пустым или свойство <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> не равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="startInfo" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл, указанный в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> параметра <paramref name="startInfo" />, не найден.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  
  
 - или -  
  
 Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала" или "Отказано в доступе".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в операционных системах без поддержки оболочки, таких как Nano Server (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя документа или файла приложения для запуска в процессе.</param>
        <summary>Запускает ресурс процесса путем указания имени документа или файла приложения и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы запустить ресурс процесса путем указания имени файла. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес, адрес исполняемый файл, чтобы запустить процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового <xref:System.Diagnostics.Process> экземпляр, задание <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> членом <xref:System.Diagnostics.Process.StartInfo%2A> свойства, а вызов метода <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Можно запустить приложение ClickOnce, задав `fileName` расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Запуск процесса путем указания имени файла похож на запуск с `Run` диалогового окна `Start` меню. Таким образом имя файла необязательно предоставлять исполняемый файл. Это может быть файл любого типа, для которого модуль был связан с приложением, установленных в системе. Пример имени файла может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или расширение .doc, при наличии файлов с инструментом обработки текстов, например Microsoft Word. Аналогичным образом, в том же, как `Run` диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот».  
  
 Эта перегрузка не допускает аргументы командной строки для процесса. Если необходимо указать один или несколько аргументов командной строки для процесса, используйте <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> или <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> перегрузки.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать эти перегрузки, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузка, которая не имеет параметров можно указать имя файла ресурса процесса для запуска.  
  
 Если путь к переменной, объявленной в системы с помощью кавычки, необходимо указывать полное этот путь при запуске любого процесса из этого расположения. В противном случае система не найдет путь. Например если `c:\mypath` не находится в пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо указывать полное любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  ASP.NET Web страницы и сервера управления выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> метода в веб-страницы ASP.NET или серверный элемент управления выполняет новый процесс, на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, как браузер клиента и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов. Закрывать процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Можно проверить, была ли процесс уже закрыта с помощью его <xref:System.Diagnostics.Process.HasExited%2A> свойство.  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент процесса <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибут `[STAThread]` на `main()` метод. В противном случае управляемый поток может быть в `unknown` состояние или поместить в `MTA` состоянии, последний конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют, чтобы состояние подразделения не были `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала порождается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображаются несколько определенных страниц или сайтов. Наконец он запускает Internet Explorer с окном минимизируется при переходе к определенному сайту.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Переменная среды PATH содержит строку с кавычками.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="arguments">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения и набора аргументов командной строки и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы запустить ресурс процесса путем указания имени файла и аргументы командной строки. Перегрузка связывает ресурс с новым <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  Если URL-адрес, адрес исполняемый файл, чтобы запустить процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового <xref:System.Diagnostics.Process> экземпляр, задание <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> члены <xref:System.Diagnostics.Process.StartInfo%2A> свойства, а вызов метода <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Запуск процесса путем указания имени файла и аргументов похож на ввод имени файла и аргументы командной строки в `Run` диалогового окна `Start` меню. Таким образом имя файла необязательно предоставлять исполняемый файл. Это может быть файл любого типа, для которого модуль был связан с приложением, установленных в системе. Пример имени файла может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или расширение .doc, при наличии файлов с инструментом обработки текстов, например Microsoft Word. Аналогичным образом, в том же, как `Run` диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстового файла в файл `Notepad.exe myfile.txt`. Если `fileName` параметр представляет командный (cmd) файл, `arguments` необходимо включить параметр "`/c`«или»`/k`" аргумент, чтобы указать, является ли командное окно завершает работу или остается после завершения.  
  
 В отличие от других перегрузок, перегрузка <xref:System.Diagnostics.Process.Start%2A> , не имеющего параметров не `static` член. Использовать эти перегрузки, если вы уже создали <xref:System.Diagnostics.Process> экземпляра указанной начальной сведения (включая имя файла) и нужно запустить ресурс процесса и связать его с существующим <xref:System.Diagnostics.Process> экземпляра. Используйте один из `static` перегрузок, если вы хотите создать новый <xref:System.Diagnostics.Process> компонента, а не запустить процесс для существующего компонента. Эта перегрузка и перегрузка, которая не имеет параметров можно указать имя файла ресурса процесса для запуска и аргументы командной строки для передачи.  
  
 Если путь к переменной, объявленной в системы с помощью кавычки, необходимо указывать полное этот путь при запуске любого процесса из этого расположения. В противном случае система не найдет путь. Например если `c:\mypath` не находится в пути, и он добавляется с использованием кавычек: `path = %path%;"c:\mypath"`, необходимо указывать полное любой процесс в `c:\mypath` при запуске.  
  
> [!NOTE]
>  ASP.NET Web страницы и сервера управления выполняется в контексте рабочего процесса ASP.NET на веб-сервере.  Если вы используете <xref:System.Diagnostics.Process.Start%2A> метода в веб-страницы ASP.NET или серверный элемент управления выполняет новый процесс, на веб-сервере с ограниченными разрешениями. Процесс не запускается в том же контексте, как браузер клиента и не имеет доступа к рабочему столу пользователя.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов. Закрывать процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Можно проверить, была ли процесс уже закрыта с помощью его <xref:System.Diagnostics.Process.HasExited%2A> свойство...  
  
 Примечание о состояния подразделения в управляемых потоках здесь не требуется. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` на компонент процесса <xref:System.Diagnostics.Process.StartInfo%2A> свойство, убедитесь, что установки потоковой модели приложения, задав атрибут `[STAThread]` на `main()` метод. В противном случае управляемый поток может быть в `unknown` состояние или поместить в `MTA` состоянии, последний конфликтует с <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> , `true`. Некоторые методы требуют, чтобы состояние подразделения не были `unknown`. Если состояние не задано явно, когда приложение обнаруживает такой метод, по умолчанию `MTA`, а затем состояние подразделения не может быть изменено. Однако `MTA` вызывает исключение, если оболочка операционной системы управляет потоком.  
  
   
  
## Examples  
 В следующем примере сначала порождается экземпляр Internet Explorer и отображает содержимое папки "Избранное" в браузере. Затем запускаются несколько других экземпляров Internet Explorer и отображаются несколько определенных страниц или сайтов. Наконец он запускает Internet Explorer с окном минимизируется при переходе к определенному сайту.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение параметра <paramref name="fileName" /> или параметра <paramref name="arguments" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  
  
 - или -  
  
 Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала" или "Отказано в доступе".</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Переменная среды PATH содержит строку с кавычками.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="userName">Имя пользователя, используемое при запуске процесса.</param>
        <param name="password">Объект <see cref="T:System.Security.SecureString" />, содержащий пароль для использования при запуске процесса.</param>
        <param name="domain">Домен, используемый при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения, имени пользователя, пароля и домена и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нового процесса и основной поток, указав имя файла, имя пользователя, пароль и домен. Затем новый процесс запускает указанный исполняемый файл в контексте безопасности указанные учетные данные (пользователя, домен и пароль).  
  
> [!NOTE]
>  Если исполняемый файл находится на удаленном диске, необходимо определить общей сетевой папке с помощью универсальный код ресурса (URI), не связанный с буквой диска.  
  
> [!NOTE]
>  Если URL-адрес, адрес исполняемый файл, чтобы запустить процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового <xref:System.Diagnostics.Process> экземпляр, задание <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A> свойства, а вызов метода <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Аналогичным образом, в том же, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстового файла в файл `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно представлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих `userName`, `password`, и `domain` параметров.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов. Закрывать процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Можно проверить, была ли процесс уже закрыта с помощью его <xref:System.Diagnostics.Process.HasExited%2A> свойство...  
  
   
  
## Examples  
 В следующем примере кода показано использование этой перегрузки для запуска исполняемого файла, а также демонстрируется возникновение <xref:System.ComponentModel.Win32Exception> при попытке запуска приложения, связанного с файлом неисполняемые.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не указано имя файла.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Произошла ошибка при открытии связанного файла.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в Linux или macOS (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла приложения для запуска в процессе.</param>
        <param name="arguments">Аргументы командной строки для передачи при запуске процесса.</param>
        <param name="userName">Имя пользователя, используемое при запуске процесса.</param>
        <param name="password">Объект <see cref="T:System.Security.SecureString" />, содержащий пароль для использования при запуске процесса.</param>
        <param name="domain">Домен, используемый при запуске процесса.</param>
        <summary>Запускает ресурс процесса путем указания имени приложения, набора аргументов командной строки, имени пользователя, пароля и домена и связывает ресурс с новым компонентом <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Новый процесс <see cref="T:System.Diagnostics.Process" />, связанный с ресурсом процесса, или <see langword="null" />, если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой тип Process, свойство <see cref="P:System.Diagnostics.Process.HasExited" /> которого равно <see langword="true" />. В этом случае запущенный процесс может активировать существующий экземпляр самого себя, а затем завершить работу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нового процесса и основной поток, указав имя файла, аргументы командной строки, имя пользователя, пароль и домен. Затем новый процесс запускает указанный исполняемый файл в контексте безопасности указанные учетные данные (пользователя, домен и пароль).  
  
> [!NOTE]
>  Если исполняемый файл находится на удаленном диске, необходимо определить общей сетевой папке с помощью универсальный код ресурса (URI), не связанный с буквой диска.  
  
> [!NOTE]
>  Если URL-адрес, адрес исполняемый файл, чтобы запустить процесс не запущен и `null` возвращается.  
  
 Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process> экземпляра. Перегрузка является альтернативой явным шагам создания нового <xref:System.Diagnostics.Process> экземпляр, задание <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> свойства <xref:System.Diagnostics.Process.StartInfo%2A> свойства, а вызов метода <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра.  
  
 Аналогичным образом, в том же, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстового файла в файл `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  Имя файла должно представлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A> перегрузок, имеющих `userName`, `password`, и `domain` параметров.  
  
 При использовании <xref:System.Diagnostics.Process.Start%2A> для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов. Закрывать процессы, используя <xref:System.Diagnostics.Process.CloseMainWindow%2A> или <xref:System.Diagnostics.Process.Kill%2A>. Можно проверить, была ли процесс уже закрыта с помощью его <xref:System.Diagnostics.Process.HasExited%2A> свойство...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не указано имя файла.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Возникла ошибка при открытии связанного файла.  
  
 - или -  
  
 Сумма длины аргументов и длины полного пути к соответствующему файлу превышает 2080. Сообщение об ошибке, связанной с этим исключением, может иметь следующую формулировку: "Область данных, переданная системному вызову, слишком мала" или "Отказано в доступе".</exception>
        <exception cref="T:System.ObjectDisposedException">Объект процесса уже удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Метод не поддерживается в Linux или macOS (только в .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает свойства для передачи их методу <see cref="M:System.Diagnostics.Process.Start" /> объекта <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>Класс <see cref="T:System.Diagnostics.ProcessStartInfo" />, который представляет данные для запуска процесса. Эти аргументы включают имя исполняемого файла или документа, использованного для запуска процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> Представляет набор параметров, используемых для запуска процесса. Когда <xref:System.Diagnostics.Process.Start%2A> вызове <xref:System.Diagnostics.Process.StartInfo%2A> используется для указания процесса для запуска. Только необходимые <xref:System.Diagnostics.Process.StartInfo%2A> член для задания представляет <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство. Запуск процесса путем указания <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство похож на запуск с **запуска** диалогового окна **запустить** меню. Таким образом <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство не требуется предоставлять исполняемый файл. Это может быть файл любого типа, для которого модуль был связан с приложением, установленных в системе. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с инструментом обработки текстов, например Microsoft Word. Аналогичным образом, в том же, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> член. Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство «Notepad.exe» или «Блокнот».  
  
 Можно запустить приложение ClickOnce, задав <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
 Если неисполняемые файла, например DOC-файл включает в себя имя файла можно включить команду, задающую какое действие необходимо выполнить для файла. Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> «Print» для файла с расширением .doc. Имя файла, указанное в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство не обязательно иметь расширение, если вручную ввести значение для <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> свойства. Тем не менее если вы используете <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> доступны свойства, чтобы определить, какие команды, должен включать расширение.  
  
 Можно изменить параметры, заданные в <xref:System.Diagnostics.Process.StartInfo%2A> свойство до времени, которые можно вызвать <xref:System.Diagnostics.Process.Start%2A> метод в процессе. После запуска процесса изменение <xref:System.Diagnostics.Process.StartInfo%2A> значения не влияет на и перезапуска процесса. При вызове метода <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> метод с <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> набором свойств, неуправляемой `CreateProcessWithLogonW` вызывается функция, которая запускает процесс в новое окно даже в случае <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> значение свойства `true` или <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> значение свойства <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Если вы не использовали <xref:System.Diagnostics.Process.Start%2A> метод для запуска процесса, <xref:System.Diagnostics.Process.StartInfo%2A> свойство отражает параметры, используемые для запуска процесса. Например, если вы используете <xref:System.Diagnostics.Process.GetProcesses%2A> для получения массива процессов, запущенных на компьютере, <xref:System.Diagnostics.Process.StartInfo%2A> каждого экземпляра <xref:System.Diagnostics.Process> не содержит исходное имя файла или аргументы, используемые для запуска процесса.  
  
 При запуске процесса имя файла — это файл, заполняющий (только для чтения) <xref:System.Diagnostics.Process.MainModule%2A> свойство. Если вы хотите получить исполняемый файл, который связан с процессом после начала процесса, используйте <xref:System.Diagnostics.Process.MainModule%2A> свойство. Если вы хотите задать исполняемый файл <xref:System.Diagnostics.Process> экземпляра, для которого связанный процесс не запущен, используйте <xref:System.Diagnostics.Process.StartInfo%2A> свойства <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> элемента. Так как члены <xref:System.Diagnostics.Process.StartInfo%2A> свойства, аргументы, передаваемые <xref:System.Diagnostics.Process.Start%2A> метод процесса, изменение <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство после начала процесса не приведет к сбросу <xref:System.Diagnostics.Process.MainModule%2A> свойство. Эти свойства используются только для инициализации связанного процесса.  
  
   
  
## Examples  
 В следующем примере происходит заполнение <xref:System.Diagnostics.Process.StartInfo%2A> с файлом для выполнения, действием над ней и необходимость отображения пользовательского интерфейса. Дополнительные примеры см. на соответствующих страницах свойств <xref:System.Diagnostics.ProcessStartInfo> класса.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение, указывающее <see cref="P:System.Diagnostics.Process.StartInfo" />, равняется <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время запуска связанного процесса.</summary>
        <value>Объект, показывающий время запуска процесса. Если процесс не выполняется, возникает исключение.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.StartTime" /> для процесса, выполняемого на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс завершен.  
  
 - или -  
  
 Процесс не был запущен.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">В вызове функции Windows произошла ошибка.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, используемый для маршалинга вызовов обработчика событий, происходящих в результате события завершения процесса.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, используемый для маршалинга вызовов обработчика событий, возникающих в результате события <see cref="E:System.Diagnostics.Process.Exited" /> в процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> — `null`, методы, обрабатывающие <xref:System.Diagnostics.Process.Exited> события вызываются в поток из пула потоков системы. Дополнительные сведения о системной группе потоков см. в разделе <xref:System.Threading.ThreadPool>.  
  
 Когда <xref:System.Diagnostics.Process.Exited> событие обрабатывается компонентом Windows Forms, такие как <xref:System.Windows.Forms.Button>, обращение к компоненту через пул потоков системы могут не работать или может привести к возникновению исключения. Этого можно избежать, установив <xref:System.Diagnostics.Process.SynchronizingObject%2A> в компонент Windows Forms, которое вызывает методы, обрабатывающие <xref:System.Diagnostics.Process.Exited> событий для вызова в том же потоке, в котором был создан компонент.  
  
 Если <xref:System.Diagnostics.Process> используется внутри [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> автоматически присваивается элемент управления, содержащий <xref:System.Diagnostics.Process>. Например, если поместить <xref:System.Diagnostics.Process> в конструктор для `Form1` (который наследуется от <xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство <xref:System.Diagnostics.Process> устанавливается на экземпляр `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Как правило, это свойство задается при компонент помещается внутри элемента управления или формы, так как эти компоненты привязаны к определенному потоку.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает множество потоков, выполняющихся в связанном процессе.</summary>
        <value>Массив объектов типа <see cref="T:System.Diagnostics.ProcessThread" />, представляющий потоки операционной системы, которые в настоящий момент выполняются в связанном процессе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток выполняет код в процессе. Каждый процесс запускается с одним потоком, а основной поток. Любой поток может создавать дополнительные потоки. Потоки процесса разделяют адресное пространство процесса.  
  
 Используйте <xref:System.Diagnostics.ProcessThread> для получения всех потоков, связанных с текущим процессом. Основной поток не обязательно с нулевым индексом в массиве.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Процесс не имеет <see cref="P:System.Diagnostics.Process.Id" />, или нет процесса, связанного с экземпляром <see cref="T:System.Diagnostics.Process" />.  
  
 - или -  
  
 Связанный процесс завершился.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me). Задайте для <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> значение <see langword="false" />, чтобы получить доступ к этому свойству в Windows 98 и Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует имя процесса в строку, объединенную с родительским типом компонента, если это применимо.</summary>
        <returns>Свойство <see cref="P:System.Diagnostics.Process.ProcessName" />, объединенное с возвращаемым значением метода <see cref="M:System.Object.ToString" /> базового компонента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> не поддерживается в Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает полное время процессора для этого процесса.</summary>
        <value>Объект <see cref="T:System.TimeSpan" />, указывающий количество времени, потраченного процессом на загрузку ЦП. Это значение является суммой значений свойств <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> и <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> для процесса, выполняемого на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает пользовательское время процессора для этого процесса.</summary>
        <value>Класс <see cref="T:System.TimeSpan" />, показывающий количество времени, которое связанный процесс потратил на выполнение кода внутри приложения (не внутри ядра операционной системы).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <exception cref="T:System.NotSupportedException">Вы пытаетесь получить доступ к свойству <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> для процесса, выполняемого на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер виртуальной памяти процесса (в байтах).</summary>
        <value>Объем виртуальной памяти в байтах, запрошенной связанным процессом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем виртуальной памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем виртуальной памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер виртуальной памяти, используемой процессом, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физическую память или со страницами, сохраненными в файле подкачки виртуальной памяти на диске.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт виртуальной памяти** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает период времени для ожидания завершения связанного процесса и блокирует текущий поток выполнения до того, как пройдет это время или процесс завершится. Чтобы избежать блокировки текущего потока, используйте событие <see cref="E:System.Diagnostics.Process.Exited" />.  
  
 Примеры кода см. на следующих страницах справочника по свойствам <see cref="P:System.Diagnostics.Process.StandardError" /> и <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать завершения связанного процесса в течение неограниченного времени.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> делает текущий поток ожидать завершения связанного процесса.  Его следует вызывать после всех других методов вызываются в процессе. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Указывает, что этот метод <xref:System.Diagnostics.Process> компонент ждать неограниченное количество времени для процесса и обработчики событий для выхода. Это может привести к зависанию приложения. Например, при вызове метода <xref:System.Diagnostics.Process.CloseMainWindow%2A> для процесса, которое имеет пользовательский интерфейс, запрос операционную систему на завершение процесса может быть не обработан запись процесса на никогда не войти в цикл сообщений.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версиях <xref:System.Diagnostics.Process.WaitForExit> перегрузки на ожидание <xref:System.Int32.MaxValue> миллисекунд (приблизительно 24 дня), не бесконечно. Кроме того, предыдущие версии была ожидает обработчики событий для выхода, если полный <xref:System.Int32.MaxValue> время достигнут.  
  
 Эта перегрузка гарантирует, что вся обработка завершения, включая обработку асинхронных событий для перенаправленного стандартного вывода. Эту перегрузку следует использовать после вызова <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> перегрузки, когда стандартный вывод был перенаправлен обработчикам асинхронных событий.  
  
 При завершении связанного процесса (то есть, когда она завершит работу операционной системы через нормальное или аварийное завершение), система сохраняет административную информацию о процессе и возвращает ее компоненту, вызвавшему метод <xref:System.Diagnostics.Process.WaitForExit>. <xref:System.Diagnostics.Process> Может получить доступ к информации, включая <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A> завершенных процессов.  
  
 Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A> свойства компонента больше не указывает на существующий ресурс процесса. Вместо этого дескриптор может использоваться только для доступа к информации операционной системы о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> сведения в памяти до <xref:System.Diagnostics.Process> компонент специально не освободит ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра, вызовите метод <xref:System.Diagnostics.Process.Close%2A> Если связанный процесс был завершен и больше не нужна административной информации о нем. <xref:System.Diagnostics.Process.Close%2A> Освобождает память, выделенную для завершенных процессов.  
  
   
  
## Examples  
 В разделе «Примечания» <xref:System.Diagnostics.Process.StandardError%2A> справочной странице.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Нет доступа к параметру ожидания.</exception>
        <exception cref="T:System.SystemException">Не задан <see cref="P:System.Diagnostics.Process.Id" /> процесса, и <see cref="P:System.Diagnostics.Process.Handle" />, из которого можно определить свойство <see cref="P:System.Diagnostics.Process.Id" />, не существует.  
  
 - или -  
  
 С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.  
  
 - или -  
  
 Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.WaitForExit" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Количество времени в миллисекундах для ожидания завершения связанного процесса. Максимальным является наибольшее возможное 32-битное целое число, которое представляет для операционной системы бесконечность.</param>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать завершения связанного процесса в течение указанного времени в миллисекундах.</summary>
        <returns>
          Значение <see langword="true" />, если связанный процесс завершился; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> делает текущий поток ожидать завершения связанного процесса. Его следует вызывать после всех других методов вызываются в процессе. Чтобы избежать блокировки текущего потока, используйте событие <xref:System.Diagnostics.Process.Exited>.  
  
 Указывает, что этот метод <xref:System.Diagnostics.Process> компонент ожидать конечное количество времени для завершения процесса. Если связанный процесс не завершится к концу интервал из-за отказа в запросе на завершение `false` возвращается в вызывающую процедуру. Можно указать <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для `milliseconds`, и <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> будет вести себя таким же, как <xref:System.Diagnostics.Process.WaitForExit> перегрузки. Если передается значение 0 (ноль) метод, он возвращает `true` только в том случае, если процесс уже завершился; в противном случае он немедленно возвращает `false`.  
  
> [!NOTE]
>  В [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] и более ранних версий, если `milliseconds` был -1, <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> перегрузки на ожидание <xref:System.Int32.MaxValue> миллисекунд (приблизительно 24 дня), не бесконечно.  
  
 Когда стандартный вывод был перенаправлен обработчикам асинхронных событий, возможно, что обработка вывода не имеют завершена при возвращении этим методом. Чтобы обеспечить завершение асинхронной обработки событий, вызовите <xref:System.Diagnostics.Process.WaitForExit> перегрузку, которая не получает параметра после получения `true` из этой перегрузки. Чтобы обеспечить <xref:System.Diagnostics.Process.Exited> правильной обработки событий в приложениях Windows Forms, задайте <xref:System.Diagnostics.Process.SynchronizingObject%2A> свойство.  
  
 При завершении связанного процесса (завершает работу операционной системы через нормальное или аварийное завершение), система сохраняет административную информацию о процессе и возвращает ее компоненту, вызвавшему метод <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. <xref:System.Diagnostics.Process> Может получить доступ к информации, включая <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A> завершенных процессов.  
  
 Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A> свойства компонента больше не указывает на существующий ресурс процесса. Вместо этого дескриптор может использоваться только для доступа к информации операционной системы о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process> компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A> и <xref:System.Diagnostics.Process.Handle%2A> сведения в памяти до <xref:System.Diagnostics.Process> компонент специально не освободит ресурсы. По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A> для <xref:System.Diagnostics.Process> экземпляра, вызовите метод <xref:System.Diagnostics.Process.Close%2A> Если связанный процесс был завершен и больше не нужна административной информации о нем. <xref:System.Diagnostics.Process.Close%2A> Освобождает память, выделенную для завершенных процессов.  
  
   
  
## Examples  
 Далее приведен пример кода <xref:System.Diagnostics.Process.ExitCode%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Нет доступа к параметру ожидания.</exception>
        <exception cref="T:System.SystemException">Не задан <see cref="P:System.Diagnostics.Process.Id" /> процесса, и <see cref="P:System.Diagnostics.Process.Handle" />, из которого можно определить свойство <see cref="P:System.Diagnostics.Process.Id" />, не существует.  
  
 - или -  
  
 С этим объектом <see cref="T:System.Diagnostics.Process" /> никакие процессы не связаны.  
  
 - или -  
  
 Вы пытаетесь вызвать метод <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> для процесса, выполняющегося на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="milliseconds" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать входа связанного процесса в состояние простоя.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать перехода связанного процесса в состояние простоя в течение неограниченного времени. Эта перегрузка применяется только к процессам с пользовательским интерфейсом и, следовательно, с циклом сообщений.</summary>
        <returns>
          Значение <see langword="true" />, если связанный процесс достиг состояния бездействия.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle> для принудительного выполнения приложение ожидает возвращения цикла сообщений в состояние бездействия. При выполнении процесса с пользовательским интерфейсом цикл сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Процесс считается в состоянии простоя при ожидании сообщения внутри цикла обработки сообщений. Это состояние полезно, например, когда приложению для ожидания запуска процесса завершить создание основного окна до взаимодействия приложения с этим окном.  
  
 Если процесс не имеет цикла обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> Перегрузка указывает, что <xref:System.Diagnostics.Process> компонента для неограниченного времени ожидания для процесса в состояние бездействия в цикл обработки сообщений. Эта инструкция может вызвать приложение перестает отвечать на запросы. Например, если процесс всегда записывается в сразу завершить работу цикла сообщений, как показано в фрагменте кода `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет графического интерфейса.  
  
 - или -  
  
 Произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.  
  
 - или -  
  
 Этот процесс уже завершился.  
  
 - или -  
  
 Не существует процесса, связанного с данным объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Значение от 1 до <see cref="F:System.Int32.MaxValue" />, определяющее количество времени в миллисекундах, в течение которого ожидается переход связанного процесса в состояние простоя. Значение "0" указывает немедленный возврат, а значение "-1" указывает неопределенно долгое ожидание.</param>
        <summary>Дает компоненту <see cref="T:System.Diagnostics.Process" /> команду ожидать входа связанного процесса в состояние простоя в течение указанного времени в миллисекундах. Эта перегрузка применяется только к процессам с пользовательским интерфейсом и, следовательно, с циклом сообщений.</summary>
        <returns>
          Значение <see langword="true" />, если связанный процесс достиг незанятого состояния; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> для принудительного выполнения приложение ожидает возвращения цикла сообщений в состояние бездействия. При выполнении процесса с пользовательским интерфейсом цикл сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Процесс считается в состоянии простоя при ожидании сообщения внутри цикла обработки сообщений. Это состояние полезно, например, когда приложению для ожидания запуска процесса завершить создание основного окна до взаимодействия приложения с этим окном.  
  
 Если процесс не имеет цикла обработки сообщений, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> Перегрузка указывает, что <xref:System.Diagnostics.Process> компоненту ожидать конечное количество времени для процесса в состояние бездействия в цикл обработки сообщений. Если связанный процесс имеет переходит в состояние простоя в конце интервала, так как цикл обработки сообщений, `false` возвращается в вызывающую процедуру.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Процесс не имеет графического интерфейса.  
  
 - или -  
  
 Произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.  
  
 - или -  
  
 Этот процесс уже завершился.  
  
 - или -  
  
 Не существует процесса, связанного с данным объектом <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает использование физической памяти связанного процесса (в байтах).</summary>
        <value>Общий объем физической памяти в байтах, используемой связанный процесс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти рабочего множества используемой процессом, в байтах. Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и библиотеки системы.  
  
   
  
## Examples  
 В следующем примере запускается экземпляр блокнота. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает код завершения процесса.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объем физической памяти в байтах, выделенной для связанного процесса.</summary>
        <value>Объем физической памяти в байтах, выделенной для связанного процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение, возвращаемое этим свойством, представляет текущий размер памяти рабочего множества используемой процессом, в байтах. Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.  
  
 Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции в модулях процесса и библиотеки системы.  
  
 Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **рабочее множество** счетчика производительности для процесса.  
  
   
  
## Examples  
 В следующем примере кода запускается экземпляр программы Блокнот. Затем в примере извлекает и отображает различные свойства связанного процесса. В данном примере отслеживается при завершении процесса и отображает его выхода кода и статистика использования памяти.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Используется платформа Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>