<Type Name="ProcessStartInfo" FullName="System.Diagnostics.ProcessStartInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="57b90f5410d83f27ef62009855cc5e70be040006" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36343336" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ProcessStartInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ProcessStartInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessStartInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ProcessStartInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessStartInfo sealed" />
  <TypeSignature Language="F#" Value="type ProcessStartInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Задает набор значений, используемых при запуске процесса.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo> используется совместно с <xref:System.Diagnostics.Process> компонента. При запуске процесса с помощью <xref:System.Diagnostics.Process> класс, у вас есть доступ для обработки сведений, доступных при подключении к выполняющемуся процессу.  
  
 Можно использовать <xref:System.Diagnostics.ProcessStartInfo> класса для улучшения контроля над началом процесса. Необходимо задать по крайней мере <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства, либо вручную или с помощью конструктора. Имя файла — любое приложение или документ. Здесь документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.  
  
 Кроме того можно задать другие свойства, которые определяют действия, выполняемые с этим файлом. Можно указать значение для типа <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> свойство. Например можно указать «печать» для типа документа. Кроме того, можно указать <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> значения свойства на аргументы командной строки для передачи процедура открытия файла. Например, если задать приложение текстового редактора в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства, можно использовать <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> свойство, чтобы указать текстовый файл должен открываться в редакторе.  
  
 Стандартный ввод обычно является клавиатура и стандартный выход и Стандартная ошибка — экран монитора. Тем не менее, можно использовать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, и <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> свойства, чтобы замедлить процесс получения входных данных из или возвращают выходные данные в файл или другое устройство. При использовании <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, или <xref:System.Diagnostics.Process.StandardError%2A> свойства <xref:System.Diagnostics.Process> компонента, необходимо сначала задать соответствующее значение в <xref:System.Diagnostics.ProcessStartInfo> свойство. В противном случае система создает исключение при чтении или записи в поток.  
  
 Задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойство, чтобы указать, нужно ли запускать процесс с помощью оболочки операционной системы. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> равно `false`, новый процесс наследует стандартный ввод стандартного вывода, и обработку стандартной ошибки потоков вызывающего объекта, если <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, или <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> , соответственно, задано значение `true`. 
  
 Можно изменить значение любого <xref:System.Diagnostics.ProcessStartInfo> свойство до момента запуска процесса. После запуска процесса изменение этих значений не оказывает влияния.  
  
> [!NOTE]
>  Этот класс содержит запрос компоновки на уровне класса, который применяется ко всем элементам. Объект <xref:System.Security.SecurityException> возникает, когда непосредственный вызывающий объект не имеет разрешения с полным доверием. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Diagnostics.ProcessStartInfo> класса, чтобы запустить Internet Explorer, указав URL-адресам, как <xref:System.Diagnostics.ProcessStartInfo> аргументы.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">для обращения к членам <see cref="T:System.Diagnostics.ProcessStartInfo" />. Требовать значение: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; [NIB: именованные наборы разрешений] (http://msdn.microsoft.com/library/08250d67-c99d-4ab0-8d2b-b0e12019f6e3): <see langword="FullTrust" />.</permission>
    <altmember cref="T:System.Diagnostics.Process" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.ProcessStartInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.ProcessStartInfo" />, не указывая имени файла, вместе с которым должен запускаться процесс.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо задать по крайней мере <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> перед началом процесса. Имя файла — любое приложение или документ. В этом случае документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.  
  
 При необходимости можно также задать другие свойства, прежде чем начать процесс. <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Свойство предоставляет действия, такие как «печать», с файлом, указанным в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство. <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Свойство предоставляет способ передачи аргументов командной строки в файл при открытии его системой.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Приложение или документ, вместе с которыми должен запускаться процесс.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.ProcessStartInfo" /> и задает имя файла, например приложение или документ, вместе с которым должен запускаться процесс.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя файла — любое приложение или документ. В этом случае документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.  
  
 Вы можете изменить <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство после вызова этого конструктора, до момента запуска процесса. После запуска процесса изменение этих значений не оказывает влияния.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, arguments As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.ProcessStartInfo : string * string -&gt; System.Diagnostics.ProcessStartInfo" Usage="new System.Diagnostics.ProcessStartInfo (fileName, arguments)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Приложение, с которым должен запускаться процесс.</param>
        <param name="arguments">Аргументы командной строки, передаваемые в приложение при запуске процесса.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Diagnostics.ProcessStartInfo" />, задает имя файла приложения, вместе с которым должен запускаться процесс, и указывает передаваемые в приложение аргументы командной строки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя файла — любое приложение или документ. В этом случае документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.  
  
 Вы можете изменить <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> или <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> свойства после вызова этого конструктора, до момента запуска процесса. После запуска процесса изменение этих значений не оказывает влияния.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ArgumentList">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; ArgumentList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; ArgumentList" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArgumentList As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ ArgumentList { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ArgumentList : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arguments">
      <MemberSignature Language="C#" Value="public string Arguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Arguments" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberSignature Language="VB.NET" Value="Public Property Arguments As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Arguments { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Arguments : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Command line arguments that will be passed to the application specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает набор аргументов командной строки, используемых при запуске приложения.</summary>
        <value>Одна строка, содержащая аргументы для передачи в целевое приложение, указанное в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />. Значение по умолчанию — пустая строка (""). В Windows Vista и более ранних версиях операционной системы Windows длина аргументов, добавляемых к длине полного пути к процессу, должна быть меньше 2080. В Windows 7 и более поздних версиях длина должна быть меньше 32699.  Аргументы анализируются и интерпретируются целевым приложением, поэтому они должны соответствовать ожидаемым аргументам приложения. Как показано в примерах ниже, для приложений .NET пробелы считаются разделителями между несколькими аргументами. Одиночный аргумент, включающий пробелы, должен быть заключен в кавычки, но кавычки не указываются в целевом приложении. В финальном проанализированном аргументе при включении кавычек к каждому знаку следует добавить escape-символ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В первом примере создается небольшое приложение (argsecho.exe), обозначающие аргументов в консоль. Во втором примере создается приложение, которое вызывает argsecho.exe для демонстрации различных варианта для свойства аргументы.  
  
 [!code-cpp[Process.Start_static#3](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#3)]
 [!code-csharp[Process.Start_static#3](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#3)]
 [!code-vb[Process.Start_static#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#3)]  
  
 [!code-cpp[Process.Start_static#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#2)]
 [!code-csharp[Process.Start_static#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#2)]
 [!code-vb[Process.Start_static#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNoWindow">
      <MemberSignature Language="C#" Value="public bool CreateNoWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CreateNoWindow" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property CreateNoWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CreateNoWindow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CreateNoWindow : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to start the process without creating a new window to contain it.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее определить, нужно ли запускать процесс в новом окне.</summary>
        <value>Значение <see langword="true" /> для процесс должен быть запущен без создания для него нового окна; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойство `true` или <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A> свойства не `null`, <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> значение свойства учитывается и создается новое окно.  

 .NET core не поддерживает создание windows непосредственно на Unix подобные платформ, включая macOS и Linux. Это свойство учитывается для таких платформ.
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее идентифицировать домен, используемый при запуске процесса. Если это значение равно <see langword="null" />, свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> должно быть указано в формате имени субъекта-пользователя.</summary>
        <value>Домен Active Directory, используемый при запуске процесса. Если это значение равно <see langword="null" />, свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> должно быть указано в формате имени субъекта-пользователя.</value>
        <remarks>Это свойство имеет главным образом для пользователей, работающих в корпоративной среде, в которых используется Active Directory.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Environment">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; Environment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; Environment" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Environment As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ Environment { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Environment : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает переменные среды, относящиеся к этому процессу и его дочерним процессам.</summary>
        <value>Универсальный словарь, содержащий переменные среды, относящиеся к этому процессу и его дочерним процессам. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переменные среды содержат пути поиска для файлов, каталоги временных файлов, параметры данного приложения и другие аналогичные сведения. Несмотря на то, что нельзя задать напрямую <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> можно изменить универсального словаря, возвращаемого этим свойством. Например, следующий код добавляет переменную среды каталог временных файлов: `myProcess.StartInfo.Environment.Add("TempPath", "C:\\Temp")`.  Необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойства `false` для запуска процесса после изменения <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> свойство. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true`, <xref:System.InvalidOperationException> возникает, когда <xref:System.Diagnostics.Process.Start%2A> вызывается метод.  
  
 Для приложений .NET Framework, с использованием <xref:System.Diagnostics.ProcessStartInfo.Environment%2A> имеет то же, как с помощью <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="EnvironmentVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.StringDictionary EnvironmentVariables" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvironmentVariables As StringDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::StringDictionary ^ EnvironmentVariables { System::Collections::Specialized::StringDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvironmentVariables : System.Collections.Specialized.StringDictionary" Usage="System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StringDictionaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Set of environment variables that apply to this process and child processes.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.StringDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает пути поиска файлов, каталоги временных файлов, параметры данного приложения и другие аналогичные сведения.</summary>
        <value>Словарь строк, предоставляющий переменные среды, применимые к этому процессу и дочерним процессам. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что не удается задать <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> свойства, можно изменить <xref:System.Collections.Specialized.StringDictionary> возвращаемый этим свойством. Например, следующий код добавляет переменную среды каталог временных файлов: `myProcess.StartInfo.EnvironmentVariables.Add("TempPath", "C:\\Temp")`.  Необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойства `false` для запуска процесса после изменения <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> свойство. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true`, <xref:System.InvalidOperationException> возникает, когда <xref:System.Diagnostics.Process.Start%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialog">
      <MemberSignature Language="C#" Value="public bool ErrorDialog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ErrorDialog" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ErrorDialog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialog : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to show an error dialog to the user if there is an error.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее определить, будет ли отображаться диалоговое окно сообщения об ошибке в случае невозможности запуска процесса.</summary>
        <value>Значение <see langword="true" />, если диалоговое окно сообщения об ошибке должно отображаться на экране при невозможности запуска процесса; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> должно быть `true` Если вы хотите установить <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> для `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialogParentHandle">
      <MemberSignature Language="C#" Value="public IntPtr ErrorDialogParentHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ErrorDialogParentHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialogParentHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ErrorDialogParentHandle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorDialogParentHandle : nativeint with get, set" Usage="System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает дескриптор окна, используемый при отображении диалогового окна сообщения об ошибке в случае невозможности запустить процесс.</summary>
        <value>Указатель на дескриптор диалогового окна сообщения об ошибке, возникшего в результате сбоя при запуске процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> — `true`, <xref:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle%2A> свойство указывает родительского окна для диалогового окна, которое отображается. Оно полезно для указания родительской для оставьте диалоговое окно перед приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileName">
      <MemberSignature Language="C#" Value="public string FileName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberSignature Language="VB.NET" Value="Public Property FileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FileName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StartFileNameEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the application, document or URL to start.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает приложение или документ для запуска.</summary>
        <value>Имя запускаемого приложения или имя документа, тип файла которого связан с приложением и для которого доступно действие открытия по умолчанию. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо задать по крайней мере <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> перед началом процесса. Имя файла — любое приложение или документ. Документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.  
  
 Набор типов файлов, доступных пользователю отчасти зависит от значения <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойство. Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true`, можно запустить любой документ и выполнять операции над файлом, например печать, с <xref:System.Diagnostics.Process> компонента. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `false`, можно запускать только исполняемые файлы с <xref:System.Diagnostics.Process> компонента.  
  
 Можно запустить приложение ClickOnce, задав <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.  
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUserProfile">
      <MemberSignature Language="C#" Value="public bool LoadUserProfile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadUserProfile" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadUserProfile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadUserProfile { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadUserProfile : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее определить, следует ли загружать профиль пользователя Windows из реестра.</summary>
        <value>Значение <see langword="true" />, если должен быть загружен профиль пользователя Windows; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется при запуске процесса, используя имя пользователя, пароль и домен.  
  
 Если значение равно `true`, профиль пользователя в `HKEY_USERS` загружается раздел реестра. Загрузка профиля может занять некоторое время. Таким образом, рекомендуется использовать это значение только в том случае, если необходимо получить доступ к информации в `HKEY_CURRENT_USER` раздел реестра.  
  
 В Windows Server 2003 и Windows 2000 профиль выгружается после завершения нового процесса, независимо от того, является ли процесс создал дочерние процессы.  
  
 В Windows XP профиль выгружается после завершения нового процесса и все дочерние процессы, созданные им будет прекращено.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Password">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Password { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.SecureString Password" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Password" />
      <MemberSignature Language="VB.NET" Value="Public Property Password As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::SecureString ^ Password { System::Security::SecureString ^ get(); void set(System::Security::SecureString ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Password : System.Security.SecureString with get, set" Usage="System.Diagnostics.ProcessStartInfo.Password" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает параметр безопасности, в котором содержится пароль пользователя, используемый при запуске процесса.</summary>
        <value>Пароль пользователя, используемый при запуске процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Свойства должны задаваться, если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A> предоставляются. Если свойство не задано, рабочим каталогом по умолчанию является % SYSTEMROOT%\system32.  
  
> [!NOTE]
>  Установка <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>и <xref:System.Diagnostics.ProcessStartInfo.Password%2A> свойства в <xref:System.Diagnostics.ProcessStartInfo> объект является рекомендуемый подход для запуска процесса с учетными данными пользователя.  
  
 Объект <xref:System.Security.SecureString> объект аналогичен <xref:System.String> объекта в том, что он имеет значение text. Тем не менее значение <xref:System.Security.SecureString> объект шифруется автоматически, можно изменить, пока приложение помечает его как доступную только для чтения и удалять из памяти компьютера, приложения или сборщика мусора .NET Framework.  
  
 Дополнительные сведения о параметрах безопасности и пример того, как получить пароль, чтобы установить это свойство см. в разделе <xref:System.Security.SecureString> класса.  
  
> [!NOTE]
>  Если указать значение для <xref:System.Diagnostics.ProcessStartInfo.Password%2A> свойства <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойство должно быть `false`, или <xref:System.InvalidOperationException> возникает при <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> вызывается метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PasswordInClearText">
      <MemberSignature Language="C#" Value="public string PasswordInClearText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PasswordInClearText" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordInClearText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PasswordInClearText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordInClearText : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает пароль пользователя в виде открытого текста, который будет использоваться при запуске процесса.</summary>
        <value>Пароль пользователя в виде открытого текста.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardError">
      <MemberSignature Language="C#" Value="public bool RedirectStandardError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardError : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process's error output is written to the Process instance's StandardError member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее определить, записываются ли выходные данные об ошибках приложения в поток <see cref="P:System.Diagnostics.Process.StandardError" />.</summary>
        <value>Значение <see langword="true" />, если выходные сообщения об ошибках должны записываться в <see cref="P:System.Diagnostics.Process.StandardError" />; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в его стандартный поток ошибок, что текст обычно отображается на консоли. Путем перенаправления <xref:System.Diagnostics.Process.StandardError%2A> потока, можно управлять или подавлять вывод ошибок процесса. Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.  
  
> [!NOTE]
>  Необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> для `false` Если вы хотите установить <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> для `true`. В противном случае чтение из <xref:System.Diagnostics.Process.StandardError%2A> поток вызывает исключение.  
  
 Перенаправленный <xref:System.Diagnostics.Process.StandardError%2A> возможность чтения потока, синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A> и <xref:System.IO.StreamReader.ReadToEnd%2A> синхронной операции чтения в поток вывода ошибок в процессе выполнения. Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardError%2A> потока или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A> потока. Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.  
  
> [!NOTE]
>  Приложение, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A> метод, чтобы гарантировать записан выходной буфер.  
  
 Синхронное чтение операций устанавливают зависимость между считыванием вызывающего оператора из <xref:System.Diagnostics.Process.StandardError%2A> поток и дочерний процесс записи в поток. Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции чтения, пока дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции и не может быть продолжена. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.  
  
 Например следующий код C# показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardError.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например следующий код C# выполняет операции чтения в обоих потоках.  
  
```csharp  
// Do not perform a synchronous read to the end of both  
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке.  
  
   
  
## Examples  
 В следующем примере используется `net use` команду вместе с заданным пользователем аргументом для сопоставления сетевого ресурса. Затем считывается стандартный поток ошибок сетевой команды и записывается в консоль.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardInput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardInput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process command input is read from the Process instance's StandardInput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее определить, будут ли считываться входные данные приложения из потока <see cref="P:System.Diagnostics.Process.StandardInput" />.</summary>
        <value>Значение <see langword="true" />, если входные данные должны считываться из <see cref="P:System.Diagnostics.Process.StandardInput" />; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Diagnostics.Process> может считывать введенный текст из его стандартный входной поток, обычно клавиатуры. Путем перенаправления <xref:System.Diagnostics.Process.StandardInput%2A> потока, можно программно указать входной поток процесса. Например вместо ввода с клавиатуры, чтобы обеспечить текст из содержимого назначенного файла или выходных данных другого приложения.  
  
> [!NOTE]
>  Необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> для `false` Если вы хотите установить <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> для `true`. В противном случае запись в <xref:System.Diagnostics.Process.StandardInput%2A> поток вызывает исключение.  
  
   
  
## Examples  
 Следующий пример показывает, как перенаправлять <xref:System.Diagnostics.Process.StandardInput%2A> потока процесса. `sort` Команда является консольным приложением, которое считывает и сортирует ввода текста.  
  
 В примере запускается `sort` с перенаправленным вводом. Затем пользователю для текста и передает текст `sort` через перенаправленный <xref:System.Diagnostics.Process.StandardInput%2A> потока. `sort` Результаты отображаются пользователю на консоль.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardOutput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectStandardOutput : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process output is written to the Process instance's StandardOutput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее определить, записываются ли текстовые выходные данные приложения в поток <see cref="P:System.Diagnostics.Process.StandardOutput" />.</summary>
        <value>Значение <see langword="true" />, если выходные данные должны записываться в <see cref="P:System.Diagnostics.Process.StandardOutput" />; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Diagnostics.Process> записывает текст в его стандартный поток, что текст обычно отображается на консоли. Установив <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> для `true` для перенаправления <xref:System.Diagnostics.Process.StandardOutput%2A> потока, можно управлять или подавлять вывод процесса. Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.  
  
> [!NOTE]
>  Необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> для `false` Если вы хотите установить <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> для `true`. В противном случае чтение из <xref:System.Diagnostics.Process.StandardOutput%2A> поток вызывает исключение.  
  
 Перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A> возможность чтения потока, синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A> выполнения синхронных операций чтения в выходной поток процесса. Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process> записывает его <xref:System.Diagnostics.Process.StandardOutput%2A> потока или закрывает поток.  
  
 Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Этот метод позволяет назначенный обработчик событий (см. <xref:System.Diagnostics.Process.OutputDataReceived>) для выходного потока и сразу же возвращает вызывающему объекту, который может выполнять другую работу во время вывода потока направляется в обработчик событий.  
  
> [!NOTE]
>  Приложение, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A> метод, чтобы гарантировать записан выходной буфер.  
  
 Синхронное чтение операций устанавливают зависимость между считыванием вызывающего оператора из <xref:System.Diagnostics.Process.StandardOutput%2A> поток и дочерний процесс записи в поток. Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции чтения, пока дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции и не может быть продолжена. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.  
  
 Например следующий код C# показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardOutput.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardOutput.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardOutput%2A> потока.  
  
 Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например следующий код C# выполняет операции чтения в обоих потоках.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 В примере кода позволяет избежать состояния взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса его <xref:System.Diagnostics.Process.StandardOutput%2A> потока. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A> потока.  
  
 Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке.  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
      </Docs>
    </Member>
    <Member MemberName="StandardErrorEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardErrorEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardErrorEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardErrorEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardErrorEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardErrorEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает предпочтительную кодировку для вывода ошибок.</summary>
        <value>Объект, представляющий предпочтительную кодировку для вывода ошибок. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> свойство `null`, процесс использует стандартную ошибку кодировку для вывода ошибок. <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A> Свойство должно быть задано до запуска процесса. Задание этого свойства не гарантирует, что процесс будет использовать указанную кодировку; процесс будет использовать только кодировки, которые она поддерживает. Приложения должны быть проверены на наличие поддерживаемые кодировки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardInputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardInputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardInputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardInputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardInputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardInputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardOutputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardOutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardOutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardOutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardOutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutputEncoding : System.Text.Encoding with get, set" Usage="System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает предпочтительную кодировку для стандартного вывода.</summary>
        <value>Объект, представляющий предпочтительную кодировку для стандартного вывода. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> свойство `null`, процесс использует стандартный вывод кодировку для стандартного вывода. <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A> Свойство должно быть задано до запуска процесса. Задание этого свойства не гарантирует, что процесс будет использовать указанную кодировку. Чтобы определить, какие кодировки, поддерживаемые процессом следует выполнить проверку приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public string UserName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя пользователя, которое следует использовать при запуске процесса. Если используется формат имени субъекта-пользователя, <paramref name="user" /> @ <paramref name="DNS_domain_name" />, свойство <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> должно иметь значение <see langword="null" />.</summary>
        <value>Имя пользователя, используемое при запуске процесса. Если используется формат имени субъекта-пользователя, <paramref name="user" /> @ <paramref name="DNS_domain_name" />, свойство <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> должно иметь значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Свойства должны задаваться, если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A> предоставляются. Если свойство не задано, рабочим каталогом по умолчанию является % SYSTEMROOT%\system32.  
  
 Если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> свойство не `null` или является пустой строкой, <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойство должно быть `false`, или <xref:System.InvalidOperationException> возникает при <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> вызывается метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseShellExecute">
      <MemberSignature Language="C#" Value="public bool UseShellExecute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseShellExecute" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberSignature Language="VB.NET" Value="Public Property UseShellExecute As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseShellExecute { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseShellExecute : bool with get, set" Usage="System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to use the operating system shell to start the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, позволяющее определить, нужно ли использовать оболочку операционной системы для запуска процесса.</summary>
        <value>Значение <see langword="true" />, если оболочка должна использоваться при запуске процесса; значение <see langword="false" />, если процесс должен создаваться непосредственно из исполняемого файла. Значение по умолчанию — <see langword="true" /> в приложениях .NET Framework и <see langword="false" /> в приложениях .NET Core.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвоение этому свойству `false` можно перенаправлять потоки ввода, вывода и ошибки.  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> должно быть `false` Если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> свойство не `null` или является пустой строкой или <xref:System.InvalidOperationException> возникает при <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> вызывается метод.  
  
 При использовании оболочки операционной системы для запуска процессов можно запустить любой документ (который является любым типом зарегистрированный файл, связанный с исполняемым, имеющий активное действие по умолчанию) и выполнять операции над файлом, например печать, с помощью <xref:System.Diagnostics.Process> объект. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `false`, можно запускать только исполняемые файлы с помощью <xref:System.Diagnostics.Process> объекта.  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> должно быть `true` при установке <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> свойства `true`.  
  
 <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Свойство ведет себя по-разному в зависимости от значения <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> свойство. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> свойство определяет расположение исполняемого файла. Если <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> является пустой строкой, предполагается, что текущий каталог содержит исполняемый файл.  
  
 Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> свойство не используется для поиска исполняемого файла. Вместо этого он используется только процессом, который запущен и имеет смысл только в контексте нового процесса. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `false`, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство может быть полный путь к исполняемому файлу или простое имя исполняемого файла, который система будет пытаться найти внутри папки, указанные в переменной среды PATH.  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Выполняется попытка задать значение для <see langword="true" /> в приложениях универсальной платформы Windows (UWP).</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="Verb">
      <MemberSignature Language="C#" Value="public string Verb { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Verb" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberSignature Language="VB.NET" Value="Public Property Verb As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Verb { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Verb : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.VerbConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The verb to apply to the document specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает команду, которую необходимо использовать при открытии приложения или документа, указанного в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</summary>
        <value>Действие, которое необходимо выполнить с файлом, который открывается данным процессом. Значение по умолчанию — пустая строка (""), что означает "никаких действий".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждого расширения имени файла имеет собственный набор команд, которые могут быть получены с помощью <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> свойство. Например «`print`» распечатает документ, указанный с помощью <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Команду по умолчанию можно задать, используя пустую строку (»»). Примеры команд, которые являются «Изменить», «Открыть», «OpenAsReadOnly», «Печать» и «Printto». Следует использовать только те команды, которые появятся в наборе команд, возвращаемом в <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> свойство.  
  
 При использовании <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> свойства, необходимо включить расширение имени файла при установке значения для <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. Имя файла не обязательно иметь расширение, если вручную ввести значение для <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> свойства.  
  
   
  
## Examples  
 В следующем примере кода запускает новый процесс, используя указанную команду и имя файла. Данный пример кода является частью большего примера, приведенного для <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> свойства.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#4](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#4)]
 [!code-vb[ProcessVerbs_Diagnostics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      </Docs>
    </Member>
    <Member MemberName="Verbs">
      <MemberSignature Language="C#" Value="public string[] Verbs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Verbs" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Verbs As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Verbs { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Verbs : string[]" Usage="System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает набор команд, которые связаны с типом файла, заданным в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</summary>
        <value>Действия, которые система может применить к файлу, заданному в свойстве <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Свойство позволяет определить команд, которые могут использоваться с файлом, указанным по <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойство. Можно задать <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> значение любой команды в наборе. Примеры команд, которые являются «Изменить», «Открыть», «OpenAsReadOnly», «Печать» и «Printto».  
  
 При использовании <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> свойства, необходимо включить расширение имени файла при установке значения для <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> свойства. Расширение имени файла определяет набор возможных команд.  
  
   
  
## Examples  
 В следующем примере кода выводятся команды, заданные для выбранного имени файла. Если пользователь выбирает одну из указанных команд, в примере запускается новый процесс, использующий выбранную команду и имя входного файла.  
  
 [!code-csharp[ProcessVerbs_Diagnostics#3](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#3)]
 [!code-vb[ProcessVerbs_Diagnostics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verb" />
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessWindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As ProcessWindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessWindowStyle WindowStyle { System::Diagnostics::ProcessWindowStyle get(); void set(System::Diagnostics::ProcessWindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Diagnostics.ProcessWindowStyle with get, set" Usage="System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("How the main window should be created when the process starts.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessWindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает состояние окна, используемое при запуске процесса.</summary>
        <value>Одно из значений перечисления, позволяющее определить состояние окна, в котором был запущен процесс: во весь экран, свернутое, обычное (ни полноэкранное ни свернутое) или невидимое. Значение по умолчанию: <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Стиль окна не является одним из членов перечисления <see cref="T:System.Diagnostics.ProcessWindowStyle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkingDirectory">
      <MemberSignature Language="C#" Value="public string WorkingDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkingDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkingDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkingDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WorkingDirectory : string with get, set" Usage="System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The initial working directory for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Если свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> имеет значение <see langword="false" />, возвращает или задает рабочую папку для запускаемого процесса. Если параметру <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> присвоено значение <see langword="true" />, возвращает или задает каталог, содержащий процесс, который требуется запустить.</summary>
        <value>Если <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> имеет значение <see langword="true" />, полное имя каталога, в котором содержится запускаемый процесс. Если свойство <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> имеет значение <see langword="false" />, рабочая папка для запускаемого процесса. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Свойства должны задаваться, если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> и <xref:System.Diagnostics.ProcessStartInfo.Password%2A> предоставляются. Если свойство не задано, рабочим каталогом по умолчанию является % SYSTEMROOT%\system32.  
  
 Если каталог уже является частью переменной системного пути, у вас повторять местоположение каталога в этом свойстве.  
  
 <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Свойство ведет себя по-разному при <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true` сравнению со значением <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `false`. Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> свойство определяет расположение исполняемого файла. Если <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> является пустая строка, текущий каталог подразумевается содержащей исполняемый файл.  
  
> [!NOTE]
>  Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `true`, рабочий каталог приложения, которое запускает исполняемый файл — также рабочий каталог исполняемого файла.  
  
 Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> — `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> свойство не используется для поиска исполняемого файла. Вместо этого его значение применяется для процесса, который запускается и актуально только в контексте нового процесса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>