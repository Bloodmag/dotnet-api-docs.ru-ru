<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="048b7221c8f650af7e40e1fc748386ee05216b4b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30410548" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет базовый класс для указания динамического поведения в среде выполнения. Этот класс должен наследоваться; создать его экземпляр напрямую нельзя.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DynamicObject` Позволяет определить, какие операции могут быть выполнены для динамических объектов и способы выполнения этих операций. Например можно определить, что происходит при попытке получить или задать свойство объекта, вызовите метод и выполнять стандартные математических операций: сложения и умножения.  
  
 Этот класс может быть полезным, если требуется создать более удобный протокол для библиотеки. Например, если пользователи библиотеки должны использовать синтаксис, подобный `Scriptobj.SetProperty("Count", 1)`, можно предоставить возможность использовать гораздо более простой синтаксис, например `scriptobj.Count = 1`.  
  
 Невозможно непосредственно создать экземпляр `DynamicObject` класса. Чтобы реализовать динамическое поведение, можно наследовать от `DynamicObject` класса и переопределять необходимые методы. Например, если требуется только операции для задания и получения свойства, можно переопределить только <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы.  
  
 В C# для включения динамического поведения для экземпляров классов, производных от `DynamicObject` , необходимо использовать `dynamic` ключевое слово. Дополнительные сведения см. в разделе [Использование типа dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 В Visual Basic динамические операции поддерживаются с помощью позднего связывания. Дополнительные сведения см. в разделе [раннее и позднее связывание](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 В следующем примере кода показано, как создать экземпляр класса, который является производным от `DynamicObject` класса.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Можно также добавить собственные члены для классов, производных от `DynamicObject` класса. Если ваш класс определяет свойства, а также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод, выполнения динамического языка (DLR) сначала использует связыватель языка для поиска для определения статического свойства в классе. Если такого свойства нет, среды DLR вызывает <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод.  
  
 `DynamicObject` Класс реализует интерфейс DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, который позволяет совместно использовать экземпляры `DynamicObject` класс между языками, поддерживающими модель взаимодействия среды DLR. Например, можно создать экземпляр `DynamicObject` в C# и затем передать его функции IronPython. Дополнительные сведения см. в разделе [Обзор динамической среды CLR](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Если у вас есть простой сценарий, в котором требуется объект, можно только добавлять и удалять участников во время выполнения, но которое не нужно определять конкретные операции и не иметь статические члены, используйте <xref:System.Dynamic.ExpandoObject> класса.  
>   
>  При наличии более сложных сценариев, в которой необходимо определить как динамические объекты участвовать в протоколе взаимодействия, или необходимо управлять кэшированием DLR быструю динамическую отправку, создайте собственную реализацию <xref:System.Dynamic.IDynamicMetaObjectProvider> интерфейса.  
  
   
  
## Examples  
 Предположим, что вы хотите предоставить альтернативный синтаксис для доступа к значениям в словарь, таким образом, чтобы вместо записи `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того, требуется следующий синтаксис, без учета регистра, так что `sampleDictionary.Text` эквивалентно `sampleDictionary.text`.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от `DynamicObject` класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` типа (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение" и переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Count` содержит свойство, которое показывает, сколько динамических свойств словаря.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Дополнительные примеры см. в разделе [создание программы-оболочки с DynamicObject](http://go.microsoft.com/fwlink/?LinkId=169008) в блоге C# часто задаваемые вопросы.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Позволяет производным типам инициализировать новый экземпляр типа <see cref="T:System.Dynamic.DynamicObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Невозможно непосредственно создать экземпляр <xref:System.Dynamic.DynamicObject> класса. Чтобы реализовать динамическое поведение, необходимо наследовать от <xref:System.Dynamic.DynamicObject> класса и переопределять необходимые методы.  
  
 В C# для включения динамического поведения для экземпляров классов, производных от <xref:System.Dynamic.DynamicObject> , необходимо использовать `dynamic` ключевое слово. Дополнительные сведения см. в разделе [Использование типа dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 В Visual Basic динамические операции поддерживаются с помощью позднего связывания. Дополнительные сведения см. в разделе [раннее и позднее связывание](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 В следующем примере кода показано, как создавать экземпляры классов, которые являются производными от <xref:System.Dynamic.DynamicObject> класса.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает перечисление имен всех динамических членов.</summary>
        <returns>Последовательность, содержащая имена динамических членов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод существует только в целях отладки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">Выражение, представляющее объект <see cref="T:System.Dynamic.DynamicMetaObject" />, вызывающий динамические виртуальные методы.</param>
        <summary>Предоставляет объект <see cref="T:System.Dynamic.DynamicMetaObject" />, вызывающий динамические виртуальные методы. Объект можно инкапсулировать в другой объект <see cref="T:System.Dynamic.DynamicMetaObject" />, чтобы обеспечить пользовательское поведение для отдельных действий. Данный метод поддерживает инфраструктуру среды DLR для разработчиков языков и не предназначен для непосредственного использования из кода.</summary>
        <returns>Объект типа <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения о двоичной операции. Свойство <c>binder.Operation</c> возвращает объект <see cref="T:System.Linq.Expressions.ExpressionType" />. Например, для оператора <c>sum = аргумент1 + аргумент2</c>, в котором <c>аргумент1</c> и <c>аргумент2</c> являются производными от класса <see langword="DynamicObject" />, <c>binder.Operation</c> возвращает <c>ExpressionType.Add</c>.</param>
        <param name="arg">Правый операнд для двоичной операции. Например, для оператора <c>sum = аргумент1 + аргумент2</c>, в котором <c>аргумент1</c> и <c>аргумент2</c> являются производными от класса <see langword="DynamicObject" />, <c>arg</c> равно <c>аргумент2</c>.</param>
        <param name="result">Результат двоичной операции.</param>
        <summary>Предоставляет реализацию для двоичных операций. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как сложение и умножение.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять бинарные операции для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Этот метод вызывается при наличии бинарных операций, таких как сложение или умножение. Например если <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> метод переопределяется, он автоматически вызывается для операторов, таких как `sum = first + second` или `multiply = first*second`, где `first` является производным от `DynamicObject` класса.  
  
 Сведения о типе бинарной операции можно получить с помощью `Operation` свойство `binder` параметр.  
  
 Если динамический объект используется только в C# и Visual Basic, `binder.Operation` свойство может принимать одно из следующих значений из <xref:System.Linq.Expressions.ExpressionType> перечисления. Однако в других языках, таких как IronPython и IronRuby, могут иметь другие значения.
  
|Значение|Описание:|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Операция сложения без проверки переполнения для числовых операндов.|`a + b`|`a + b`|  
|`AddAssign`|Операция составного присваивания сложения без проверки переполнения для числовых операндов.|`a += b`|Не поддерживается.|  
|`And`|Побитовый `AND` операции.|`a & b`|`a And b`|  
|`AndAssign`|Побитовый `AND` Операция составного присваивания.|`a &= b`|Не поддерживается.|  
|`Divide`|Операцию арифметического деления.|`a / b`|`a / b`|  
|`DivideAssign`|Операция составного присваивания арифметического деления.|`a /= b`|Не поддерживается.|  
|`ExclusiveOr`|Побитовый `XOR` операции.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Побитовый `XOR` Операция составного присваивания.|`a ^= b`|Не поддерживается.|  
|`GreaterThan`|Сравнение объектов «больше чем».|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Сравнение «больше или равно».|`a >= b`|Не поддерживается.|  
|`LeftShift`|Операция побитового сдвига влево.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Операция составного присваивания побитового сдвига влево.|`a <<= b`|Не поддерживается.|  
|`LessThan`|Сравнение «меньше».|`a < b`|`a < b`|  
|`LessThanOrEqual`|«Меньше или равно» сравнение.|`a <= b`|Не поддерживается.|  
|`Modulo`|Операцию арифметического остатка.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Составное присваивание операцию арифметического остатка.|`a %= b`|Не поддерживается.|  
|`Multiply`|Операции умножения без проверки переполнения для числовых операндов.|`a * b`|`a * b`|  
|`MultiplyAssign`|Операция составного присваивания умножения без проверки переполнения для числовых операндов.|`a *= b`|Не поддерживается.|  
|`NotEqual`|Сравнение неравенства.|`a != b`|`a <> b`|  
|`Or`|Побитовое или логических `OR` операции.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Побитовое или логических `OR` Составное присваивание.|`a &#124;= b`|Не поддерживается.|  
|`Power`|Математическая операция возведения числа в степень.|Не поддерживается.|`a ^ b`|  
|`RightShift`|Операция побитового сдвига вправо.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Операция составного присваивания побитового сдвига вправо.|`a >>= b`|Не поддерживается.|  
|`Subtract`|Операции вычитания без проверки переполнения для числовых операндов.|`a - b`|`a - b`|  
|`SubtractAssign`|Операция составного присваивания вычитания без проверки переполнения для числовых операндов.|`a -= b`|Не поддерживается.|  
  
> [!NOTE]
>  Для реализации `OrElse` (`a || b`) и `AndAlso` (`a && b`) операций динамические объекты в C#, может потребоваться реализовать оба <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> метод и <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> метод.  
>   
>  `OrElse` Операция включает в себя унарный `IsTrue` операции и двоичный файл `Or` операции. `Or` Операция выполняется только в том случае, если результат `IsTrue` операция `false`.  
>   
>  `AndAlso` Операция включает в себя унарный `IsFalse` операции и двоичный файл `And` операции. `And` Операция выполняется только в том случае, если результат `IsFalse` операция `false`.  
  
   
  
## Examples  
 Предположим, что структура данных для хранения числовых и текстовых представлений чисел, и требуется определить базовые математические операции, такие как сложение и вычитание, для таких данных.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> способ включения математических операций. Оно также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к элементам.  
  
 В этом примере поддерживаются только операции сложения и вычитания. При попытке написать инструкцию как `resultNumber = firstNumber*secondNumber`, создается исключение времени выполнения.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции преобразования. Свойство <c>binder.Type</c> предоставляет тип, в который должен быть преобразован объект. Например, для оператора <c>(String)sampleObject</c> в C# (<c>CType(sampleObject, Type)</c> в Visual Basic), в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> возвращает тип <see cref="T:System.String" />. Свойство <c>binder.Explicit</c> предоставляет сведения о виде преобразования, который имеет место. Для явного преобразования возвращается значение <see langword="true" />, для неявного — значение <see langword="false" />.</param>
        <param name="result">Результат операции преобразования типа.</param>
        <summary>Предоставляет реализацию для операций преобразования типа. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для операций, преобразующих объект из одного типа в другой.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять преобразование типа для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 В C# Если этот метод переопределен, он автоматически вызывается при наличии явного или неявного преобразования, как показано в следующем примере кода.  
  
 В Visual Basic поддерживается только явное преобразование. При переопределении этого метода он вызывается с помощью <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> или <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> функции.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Предположим, что структура данных для хранения числовых и текстовых представлений чисел, и требуется определить преобразования этой структуры данных в строки и целые числа.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryConvert%2A> способ включения преобразования типов. Оно также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к элементам данных.  
  
 В этом примере поддерживается только преобразование в строки и целые числа. При попытке преобразовать объект с другим типом исключения во время выполнения.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции инициализации.</param>
        <param name="args">Аргументы, переданные объекту во время инициализации. Например, для операции <c>new SampleType(100)</c>, в которой <c>SampleType</c> является типом, производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> равно 100.</param>
        <param name="result">Результат инициализации.</param>
        <summary>Предоставляет реализацию для операций, инициализирующих новый экземпляр динамического объекта. Этот метод не предназначен для использования в C# или Visual Basic.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, каким образом следует инициализировать новый экземпляр динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 C# и Visual Basic компиляторы никогда не выпускают код для использования этого метода, поскольку они не поддерживают типы первого класса. Этот метод предназначен для языков, поддерживающих инициализацию динамических объектов с помощью синтаксиса, подобного `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об удалении.</param>
        <param name="indexes">Удаляемые индексы.</param>
        <summary>Предоставляет реализацию для операций, удаляющих объект по индексу. Этот метод не предназначен для использования в C# или Visual Basic.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует удалять значение с указанным индексом. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 C# и Visual Basic компиляторы никогда не выпускают код для использования этого метода, так как они не поддерживает данный тип операции. Этот метод предназначен для языков, которые поддерживают синтаксис для удаления объектов по индексу, такие как `del sampleObject[1,2]` на Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об удалении.</param>
        <summary>Предоставляет реализацию для операций, удаляющих элемент объекта. Этот метод не предназначен для использования в C# или Visual Basic.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует удалять элемент объекта. Если этот метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 C# и Visual Basic компиляторы никогда не выпускают код для использования этого метода, так как они не поддерживает данный тип операции. Этот метод предназначен для языков, которые поддерживают синтаксис удаление элементов, таких как `del sampleObject.SampleMember` на Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции.</param>
        <param name="indexes">Индексы, которые используются в операции. Например, для операции <c>sampleObject[3]</c> в C# (<c>sampleObject(3)</c> в Visual Basic), в которой <c>sampleObject</c> является производным от класса <see langword="DynamicObject" />, <c>indexes[0]</c> равно 3.</param>
        <param name="result">Результат операции индексации.</param>
        <summary>Предоставляет реализацию для операций, получающих значение по индексу. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для операций индексации.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как получать значение по индексу должно выполняться для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается исключение во время выполнения).  
  
 Если этот метод переопределен, он автоматически вызывается при наличии операцию, как `sampleObject[3]` в C# или `sampleObject(3)` в Visual Basic, где `sampleObject` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
   
  
## Examples  
 Предположим, например требуется создать объект, в котором свойства могут быть доступ либо по именам `Property0`, `Property1`, и т. д., или по индексу, чтобы, например, `sampleObject.Property0` эквивалентно `sampleObject[0]` в C# или `sampleObject(0)` в Visual Basic.  
  
 В следующем примере кода показано `SampleDynamicObject` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `SampleDynamicObject` Класс содержит объект `Dictionary<string, object>` типа (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение". `SampleDynamicObject` переопределяет <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> и <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> методы для доступа с помощью индекса. Он переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для разрешения доступа по имени свойства.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об объекте, вызвавшем динамическую операцию. Свойство <c>binder.Name</c> предоставляет имя члена, с которым выполняется динамическая операция. Например, для оператора <c>Console.WriteLine(sampleObject.SampleProperty)</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> возвращает "SampleProperty". Свойство <c>binder.IgnoreCase</c> задает, учитывается ли регистр в имени члена.</param>
        <param name="result">Результат операции получения. Например, если для свойства вызывается метод, можно присвоить свойству значение <c>result</c>.</param>
        <summary>Предоставляет реализацию для операций, получающих значения членов. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как получение значения свойства.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, которые получают значения членов, для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается исключение во время выполнения).  
  
 Этот метод вызывается при наличии таких инструкциях, как `Console.WriteLine(sampleObject.SampleProperty)`, где `sampleObject` является экземпляром класса, производного от <xref:System.Dynamic.DynamicObject> класса.  
  
 Можно также добавить собственные члены для классов, производных от `DynamicObject` класса. Если ваш класс определяет свойства, а также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод, выполнения динамического языка (DLR) сначала использует связыватель языка для поиска для определения статического свойства в классе. Если такого свойства нет, среды DLR вызывает <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод.  
  
   
  
## Examples  
 Предположим, что вы хотите предоставить альтернативный синтаксис для доступа к значениям в словарь, таким образом, чтобы вместо записи `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того, должны быть без учета регистра, этот синтаксис, чтобы `sampleDictionary.Text` эквивалентно `sampleDictionary.text`.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` типа (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение" и переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Count` содержит свойство, которое показывает, сколько динамических свойств словаря.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции вызова.</param>
        <param name="args">Аргументы, переданные объекту во время операции вызова. Например, для операции <c>sampleObject(100)</c>, в которой <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> равно 100.</param>
        <param name="result">Результат вызова объекта.</param>
        <summary>Предоставляет реализацию для операций, вызывающих объект. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как вызов объекта или делегата.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, вызывающие объект, для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается исключение во время выполнения).  
  
 Если этот метод переопределен, он автоматически вызывается при наличии операцию, как `sampleObject(100)`, где `sampleObject` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
 Операция для вызова объекта поддерживается в C#, но не в Visual Basic. Компилятор Visual Basic не выдает код для использования этого метода, и язык Visual Basic не поддерживает синтаксис, подобный `sampleObject(100)`.  
  
   
  
## Examples  
 Предположим, что структура данных для хранения текстовых и числовых представлений чисел. Вы хотите иметь возможность для указания значения для каждого свойства по отдельности и иметь возможность инициализировать все свойства в одной инструкции.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryInvoke%2A> способ включения инициализации все свойства за один раз. Оно также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к свойствам отдельного объекта.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения о динамической операции. Свойство <c>binder.Name</c> предоставляет имя члена, с которым выполняется динамическая операция. Например, для оператора <c>sampleObject.SampleMethod(100)</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> возвращает "SampleMethod". Свойство <c>binder.IgnoreCase</c> задает, учитывается ли регистр в имени члена.</param>
        <param name="args">Аргументы, переданные члену объекта во время операции вызова. Например, для оператора <c>sampleObject.SampleMethod(100)</c>, в котором <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> равно 100.</param>
        <param name="result">Результат вызова члена.</param>
        <summary>Предоставляет реализацию для операций, вызывающих член. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как вызов метода.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, вызывающие члены объекта, для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Если этот метод переопределен, он автоматически вызывается при выполнении операции, такие как `sampleObject.SampleMethod(100)`, где `sampleObject` является производным от `DynamicObject` класса.  
  
 Можно также добавить собственные методы для классов, производных от <xref:System.Dynamic.DynamicObject> класса. Например, если необходимо переопределить <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> метода динамическую отправку система сначала пытается определить, существует ли указанный метод в классе. Если метод не найден, он использует <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> реализацию.  
  
 Этот метод не поддерживает `ref` и `out` параметров. Все параметры в `args` массива, передаются по значению.  
  
   
  
## Examples  
 Предположим, что вы хотите предоставить альтернативный синтаксис для доступа к значениям в словарь, таким образом, чтобы вместо записи `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того необходимо иметь возможность вызывать все методы стандартного словаря в этом словаре.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` типа (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение". Он переопределяет <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> метод для поддержки методов <xref:System.Collections.Generic.Dictionary%602> класса и переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Print` метод, который выводит все словарь ключей и значений.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об операции.</param>
        <param name="indexes">Индексы, которые используются в операции. Например, для операции <c>sampleObject[3] = 10</c> в C# (<c>sampleObject(3) = 10</c> в Visual Basic), в которой <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> равно 3.</param>
        <param name="value">Значение, которое необходимо задать для объекта с заданным индексом. Например, для операции <c>sampleObject[3] = 10</c> в C# (<c>sampleObject(3) = 10</c> в Visual Basic), в которой <c>sampleObject</c> является производным от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>value</c> равно 10.</param>
        <summary>Предоставляет реализацию для операций, задающих значение по индексу. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для операций, осуществляющих доступ к объектам по заданному индексу.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, обращающиеся к объекту по индексу для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Если этот метод переопределен, он автоматически вызывается при наличии операцию, как `sampleObject[3] = 10` в C# или `sampleObject(3) = 10` в Visual Basic, где `sampleObject` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
   
  
## Examples  
 Предположим, например требуется создать объект, в котором свойства могут быть доступ либо по именам `Property0`, `Property1`, и т. д., или по индексу, чтобы, например, `sampleObject.Property0` эквивалентно `sampleObject[0]` в C# или `sampleObject(0)` в Visual Basic.  
  
 В следующем примере кода показано `SampleDynamicObject` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `SampleDynamicObject` Класс содержит объект `Dictionary<string, object>` типа (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение". `SampleDynamicObject` переопределяет <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> и <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> методы для доступа с помощью индекса. Он переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для разрешения доступа по имени свойства.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об объекте, вызвавшем динамическую операцию. Свойство <c>binder.Name</c> предоставляет имя члена, которому присваивается значение. Например, для оператора <c>sampleObject.SampleProperty = "Test"</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> возвращает "SampleProperty". Свойство <c>binder.IgnoreCase</c> задает, учитывается ли регистр в имени члена.</param>
        <param name="value">Значение, задаваемое для члена. Например, для оператора <c>sampleObject.SampleProperty = "Test"</c>, в котором <c>sampleObject</c> является экземпляром класса, производного от класса <see cref="T:System.Dynamic.DynamicObject" />, <c>value</c> равно "Test".</param>
        <summary>Предоставляет реализацию для операций, задающих значения членов. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как задание значения свойства.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять операции, которым присвоено значение члена для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Этот метод вызывается при наличии таких инструкциях, как `sampleObject.SampleProperty = "Test"`, где `sampleObject` является экземпляром класса, который является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
 Можно также добавить собственные члены для классов, производных от `DynamicObject` класса. Если ваш класс определяет свойства, а также переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод, выполнения динамического языка (DLR) сначала использует связыватель языка для поиска для определения статического свойства в классе. Если такого свойства нет, среды DLR вызывает <xref:System.Dynamic.DynamicObject.TrySetMember%2A> метод.  
  
   
  
## Examples  
 Предположим, что вы хотите предоставить альтернативный синтаксис для доступа к значениям в словарь, таким образом, чтобы вместо записи `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` в Visual Basic), можно написать `sampleDictionary.Text = "Sample text"`. Кроме того, должны быть без учета регистра, этот синтаксис, чтобы `sampleDictionary.Text` эквивалентно `sampleDictionary.text`.  
  
 В следующем примере кода показано `DynamicDictionary` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicDictionary` Класс содержит объект `Dictionary<string, object>` типа (`Dictionary(Of String, Object)` в Visual Basic) для хранения пар "ключ значение" и переопределяет <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для поддержки нового синтаксиса. Он также предоставляет `Count` содержит свойство, которое показывает, сколько динамических свойств словаря.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Предоставляет сведения об унарной операции. Свойство <c>binder.Operation</c> возвращает объект <see cref="T:System.Linq.Expressions.ExpressionType" />. Например, для оператора <c>negativeNumber = -number</c>, в котором <c>number</c> является производным от класса <see langword="DynamicObject" />, <c>binder.Operation</c> возвращает "Negate".</param>
        <param name="result">Результат унарной операции.</param>
        <summary>Предоставляет реализацию для унарных операций. Классы, производные от класса <see cref="T:System.Dynamic.DynamicObject" />, могут переопределять этот метод, чтобы задать динамическое поведение для таких операций, как вычитание, увеличение или уменьшение.</summary>
        <returns>
          Значение <see langword="true" />, если операция выполнена успешно; в противном случае — значение <see langword="false" />. Если данный метод возвращает значение <see langword="false" />, поведение определяется связывателем среды языка. (В большинстве случаев создается языковое исключение во время выполнения).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Dynamic.DynamicObject> класс может переопределить этот метод, чтобы указать, как следует выполнять унарные операции для динамического объекта. Если метод не переопределен, связыватель времени выполнения языка определяет поведение. (В большинстве случаев создается языковое исключение во время выполнения).  
  
 Этот метод вызывается, когда имеются унарные операции, такие как вычитание, увеличение или уменьшение. Например если <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> метод переопределяется, этот метод автоматически вызывается для операторов, таких как `negativeNumber = -number`, где `number` является производным от <xref:System.Dynamic.DynamicObject> класса.  
  
 Сведения о типе унарной операции можно получить с помощью `Operation` свойство `binder` параметр.  
  
 Если динамический объект используется только в C# и Visual Basic, `binder.Operation` свойство может принимать одно из следующих значений из <xref:System.Linq.Expressions.ExpressionType> перечисления. Однако в других языках, таких как IronPython и IronRuby, могут иметь другие значения.
  
|Значение|Описание:|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Унарная операция декремента.|`a--`|Не поддерживается.|  
|`Increment`|Унарная операция инкремента.|`a++`|Не поддерживается.|  
|`Negate`|Арифметического отрицания.|`-a`|`-a`|  
|`Not`|Логическое отрицание.|`!a`|`Not a`|  
|`OnesComplement`|Единицы дополнения до единицы.|`~a`|Не поддерживается.|  
|`IsFalse`|Значение false условия.|`a && b`|Не поддерживается.|  
|`IsTrue`|Значение true, условие.|`a &#124;&#124; b`|Не поддерживается.|  
|`UnaryPlus`|Оператор унарного сложения.|`+a`|`+a`|  
  
> [!NOTE]
>  Для реализации `OrElse` (`a || b`) и `AndAlso` (`a && b`) операций динамические объекты в C#, может потребоваться реализовать оба <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> метод и <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> метод.  
>   
>  `OrElse` Операция включает в себя унарный `IsTrue` операции и двоичный файл `Or` операции. `Or` Операция выполняется только в том случае, если результат `IsTrue` операция `false`.  
>   
>  `AndAlso` Операция включает в себя унарный `IsFalse` операции и двоичный файл `And` операции. `And` Операция выполняется только в том случае, если результат `IsFalse` операция `false`.  
  
   
  
## Examples  
 Предположим, что структура данных для хранения числовых и текстовых представлений чисел, и требуется определить операцию математического отрицания для таких данных.  
  
 В следующем примере кода показано `DynamicNumber` класс, который является производным от <xref:System.Dynamic.DynamicObject> класса. `DynamicNumber` переопределяет <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> способ включения операция математического отрицания. Также является переопределения <xref:System.Dynamic.DynamicObject.TrySetMember%2A> и <xref:System.Dynamic.DynamicObject.TryGetMember%2A> методы для доступа к элементам.  
  
 В этом примере поддерживается только операция математического отрицания. При попытке написать инструкцию как `negativeNumber = +number`, возникает исключение времени выполнения.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>