<Type Name="IsolatedStorageFile" FullName="System.IO.IsolatedStorage.IsolatedStorageFile">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9fce2a24bdba71b171b57bfe2a14d7b78672e4aa" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420968" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class IsolatedStorageFile : System.IO.IsolatedStorage.IsolatedStorage, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit IsolatedStorageFile extends System.IO.IsolatedStorage.IsolatedStorage implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFile" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class IsolatedStorageFile&#xA;Inherits IsolatedStorage&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFile sealed : System::IO::IsolatedStorage::IsolatedStorage, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.IsolatedStorage.IsolatedStorage</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет область изолированного хранилища, в которой содержатся файлы и каталоги.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот объект соответствует области конкретных изолированного хранилища, где файлы, представленные <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> объекты существуют. Приложения могут использовать изолированное хранилище для сохранения данных в своих собственных изолированной части файловой системы без указания конкретного пути в файловой системе. Поскольку изолированные хранилища ограничены в конкретных сборках, большая часть управляемого кода не будет иметь доступа к данным кода (Высоконадежный управляемый код и средства администрирования можно доступ к хранилищам из других сборок). Неуправляемый код может получить доступ к любой изолированных хранилищ.  
  
 Дополнительные сведения см. в разделе [изолированное хранилище](~/docs/standard/io/isolated-storage.md).  
  
 Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
> [!IMPORTANT]
>  Изолированное хранилище недоступно для приложений Windows [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]. Вместо этого используйте классы данных приложений в пространствах имен `Windows.Storage`, включенных в API [!INCLUDE[wrt](~/includes/wrt-md.md)] для хранения локальных данных и файлов. Дополнительные сведения см. в статье [Доступ к данным приложения](http://go.microsoft.com/fwlink/?LinkId=229175) в Центре разработки для Windows.  
  
   
  
## Examples  
 В примере кода ниже показано, как создавать файлы и каталоги в изолированном хранилище. Во-первых, извлекается и помещен в хранилище, изолированного по пользователю, домену и сборке `isoStore` переменной. <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> Затем вызывается метод для создания каталогов и двух экземпляров <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> класса создавать файлы в этих каталогах.  
  
 [!code-csharp[Conceptual.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.isolatedstorage/cs/source.cs#1)]
 [!code-vb[Conceptual.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.isolatedstorage/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AvailableFreeSpace">
      <MemberSignature Language="C#" Value="public override long AvailableFreeSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 AvailableFreeSpace" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.AvailableFreeSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AvailableFreeSpace As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long AvailableFreeSpace { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее объем свободного пространства, доступного для изолированного хранилища.</summary>
        <value>Доступное свободное пространство для изолированного хранилища в байтах.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище закрыто.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает хранилище, открытое ранее с помощью метода <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type,System.Type)" />, <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" /> или <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Close%2A>. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует существующий файл в новый файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Имя копируемого файла.</param>
        <param name="destinationFileName">Имя конечного файла. Это не может быть имя каталога или имя существующего файла.</param>
        <summary>Копирует существующий файл в новый файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName` и `destinationFileName` необходимо указать другие имена файлов. Используйте <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> перегрузка метода для перезаписи существующего файла.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую хотя бы один недопустимый символ, заданный методом <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          Не удалось найти <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.  
  
 - или -  
  
 <paramref name="destinationFileName" /> существует.  
  
 - или -  
  
 Произошла ошибка ввода-вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Имя копируемого файла.</param>
        <param name="destinationFileName">Имя конечного файла. Это не может быть имя каталога.</param>
        <param name="overwrite">
          <see langword="true" />, если конечный файл можно перезаписать; в противном случае — <see langword="false" />.</param>
        <summary>Копирует существующий файл в новый файл и, возможно, перезаписывает существующий файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName` и `destinationFileName` могут иметь то же имя файла, если `overwrite` — `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую хотя бы один недопустимый символ, заданный методом <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          Не удалось найти <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.  
  
 - или -  
  
 Произошла ошибка ввода-вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public void CreateDirectory (string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDirectory(string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDirectory (dir As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDirectory(System::String ^ dir);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dir">Относительный путь к папке для создания в области ограниченного действия изолированного хранения.</param>
        <summary>Создает в области ограниченного действия изолированного хранения папку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Созданная папка первоначально не содержит файлов. Если каталог уже существует, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> метод возвращается без создания нового каталога. [Как: создание файлов и каталогов в изолированном хранилище](~/docs/standard/io/how-to-create-files-and-directories-in-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> метод  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> метод. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Текущий код не имеет достаточно разрешений для создания папки изолированного хранения.</exception>
        <exception cref="T:System.ArgumentNullException">Путь к папке — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для доступа к области изолированного хранилища.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream CreateFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream CreateFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CreateFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateFile (path As String) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ CreateFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный путь к создаваемому файлу.</param>
        <summary>Создает файл в изолированном хранилище.</summary>
        <returns>Новый файл в изолированном хранилище.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен методу с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
        <exception cref="T:System.ArgumentException">
          Неверный формат параметра <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог в <paramref name="path" /> не существует.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentSize">
      <MemberSignature Language="C#" Value="public override ulong CurrentSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int64 CurrentSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.CurrentSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CurrentSize As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::UInt64 CurrentSize { System::UInt64 get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает текущий размер изолированного хранения.</summary>
        <value>Общее число байтов хранилища, используемых в текущий момент в области ограниченного действия изолированного хранения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представляет общее использование всех файлов и каталогов в рамках области изолированного хранилища.  
  
 Текущий размер невозможно определить точно для хранилищ, участвующих в перемещаемый профиль пользователя. Поскольку перемещаемые профили часто кэшируются в нескольких клиентских компьютерах и более поздней версии синхронизируются с сервером, квоты не может применяться для таких хранилищ и текущий размер, не указывается.  
  
 [Как: предугадать, условия нехватки места при изолированном хранении](~/docs/standard/io/how-to-anticipate-out-of-space-conditions-with-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CurrentSize%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CurrentSize%2A> свойство. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#5)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#5)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство недоступно. Текущее хранилище имеет перемещаемую область действия или не открыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Размер текущего объекта не определен.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDirectory(string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (dir As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ dir);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dir">Относительный путь к папке для удаления из области изолированного хранения.</param>
        <summary>Удаляет из области ограниченного действия изолированного хранилища папку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каталог должен быть пустым, перед его удалением. Удаленный каталог не может быть восстановлен.  
  
 [Как: удаление файлов и каталогов в изолированном хранилище](~/docs/standard/io/how-to-delete-files-and-directories-in-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteDirectory%2A> метод.  
  
   
  
## Examples  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#8)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#8)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Невозможно удалить папку.</exception>
        <exception cref="T:System.ArgumentNullException">Путь к папке — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для доступа к области изолированного хранилища.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Относительный путь к файлу для удаления из области ограниченного действия изолированного хранения.</param>
        <summary>Удаляет из области ограниченного действия изолированного хранилища файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Удаленный файл будет невозможно удалить один раз.  
  
 [Как: удаление файлов и каталогов в изолированном хранилище](~/docs/standard/io/how-to-delete-files-and-directories-in-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteFile%2A> метод.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteFile%2A> метод, чтобы удалить несколько файлов в изолированном хранилище.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#6)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#6)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Конечный файл открыт или путь неверен.</exception>
        <exception cref="T:System.ArgumentNullException">Путь к файлу — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для доступа к файлам в области изолированного хранилища.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public bool DirectoryExists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DirectoryExists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DirectoryExists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DirectoryExists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Проверяемый путь.</param>
        <summary>Определяет, указывает ли заданный путь на существующий каталог в изолированном хранилище.</summary>
        <returns>
          Значение <see langword="true" />, если параметр <paramref name="path" /> указывает на существующий каталог в изолированном хранилище и не равен <see langword="null" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, занятые модулем <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод `Dispose` по окончании использования класса <xref:System.IO.IsolatedStorage.IsolatedStorageFile>. Метод `Dispose` оставляет класс <xref:System.IO.IsolatedStorage.IsolatedStorageFile> в непригодном для использования состоянии. После вызова метода `Dispose`, необходимо освободить все ссылки на <xref:System.IO.IsolatedStorage.IsolatedStorageFile> , сборщик мусора мог освободить память, <xref:System.IO.IsolatedStorage.IsolatedStorageFile> занимаемую.  
  
> [!NOTE]
>  Всегда вызывайте метод Dispose перед освобождением последней ссылки на <xref:System.IO.IsolatedStorage.IsolatedStorageFile>. В противном случае ресурсы <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> — не будут освобождены до сборки мусора не будет <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> объекта <xref:System.Object.Finalize%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода открывается файл изолированного хранилища, он используется для записи сведений в поток, закрывает файл и затем использует <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Dispose%2A> метод для освобождения всех ресурсов.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public bool FileExists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool FileExists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileExists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FileExists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла для проверки.</param>
        <summary>Определяет, указывает ли заданный путь на существующий файл в изолированном хранилище.</summary>
        <returns>
          Значение <see langword="true" />, если параметр <paramref name="path" /> указывает на существующий файл в изолированном хранилище и не равен <see langword="null" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~IsolatedStorageFile ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!IsolatedStorageFile ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет объекту попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как он будет уничтожен во время сборки мусора.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCreationTime (path As String) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetCreationTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или каталогу, для которых требуется получить сведения о дате и времени создания.</param>
        <summary>Возвращает дату и время создания заданного файла или каталога.</summary>
        <returns>Дата и время создания заданного файла или каталога. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файл, описываемый путь не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 г. нашей эры (C.E.) По Гринвичу (UTC), откорректированное по местному времени.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой, содержит только пробел либо один или несколько недопустимых символов, определенных методом <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectoryNames">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перечисляет каталоги в корневой папке изолированного хранилища.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectoryNames">
      <MemberSignature Language="C#" Value="public string[] GetDirectoryNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDirectoryNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDirectoryNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перечисляет каталоги в корневой папке изолированного хранилища.</summary>
        <returns>Массив относительных путей каталогов в корневой папке изолированного хранилища. Массив нулевой длины указывает на отсутствие каталогов в корневой папке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен методу с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%28System.String%29?displayProperty=nameWithType> метод с «*» для шаблона поиска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище закрыто.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Вызывающий объект не имеет разрешения на перечисление каталогов.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Один или несколько каталогов не найдены.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryNames">
      <MemberSignature Language="C#" Value="public string[] GetDirectoryNames (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDirectoryNames(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryNames (searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDirectoryNames(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Шаблон поиска. Поддерживаются как одиночные ("?"), так и составные ("*") подстановочные знаки.</param>
        <summary>Перечисляет каталоги в области изолированного хранилища, соответствующие заданному шаблону поиска.</summary>
        <returns>Массив относительных путей к каталогам в области изолированного хранилища, соответствующих параметру <paramref name="searchPattern" />. Массив нулевой длины указывает на отсутствие соответствующих папок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подстановочные знаки должны присутствовать только в конечном элементе `searchPattern`. Для экземпляра «directory1 / * и т. д\*» имеет допустимую строку поиска, но "\*и т. д \* /directory» не.  
  
 `searchPattern` «Project\Data *» даст все вложенные папки проекта, начиная с данными в области изолированного хранилища. `searchPattern` «\*» Возвращает все папки, размещенные в корне. Полное описание условий строки поиска см. в разделе <xref:System.IO.Directory> класса.  
  
 Сведения о получении имен файлов см. в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%2A> метод.  
  
 [Как: поиск существующих файлов и каталогов в изолированном хранилище](~/docs/standard/io/how-to-find-existing-files-and-directories-in-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%2A> метод. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#16)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#16)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Вызывающий объект не имеет разрешения на перечисление каталогов, разрешенных из <paramref name="searchPattern" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог или каталоги, указанные параметром <paramref name="searchPattern" />, не найдены.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator GetEnumerator (System.IO.IsolatedStorage.IsolatedStorageScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator GetEnumerator(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator(System.IO.IsolatedStorage.IsolatedStorageScope)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnumerator (scope As IsolatedStorageScope) As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ GetEnumerator(System::IO::IsolatedStorage::IsolatedStorageScope scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
      </Parameters>
      <Docs>
        <param name="scope">Представляет область <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" />, для которой возвращаются изолированные хранилища. <see langword="User" /> и <see langword="User|Roaming" /> являются единственными поддерживаемыми комбинациями <see langword="IsolatedStorageScope" />.</param>
        <summary>Возвращает счетчик для хранилищ <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> в области ограниченного действия изолированного хранения.</summary>
        <returns>Счетчик для хранилищ <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> в указанной области ограниченного действия изолированного хранения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Как: перечисление хранилищ для изолированного хранения](~/docs/standard/io/how-to-enumerate-stores-for-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator%2A> метод.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileNames">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перечисляет имена файлов в корневой папке изолированного хранилища.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileNames">
      <MemberSignature Language="C#" Value="public string[] GetFileNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetFileNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetFileNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перечисляет имена файлов в корневой папке изолированного хранилища.</summary>
        <returns>Массив относительных путей файлов в корневой папке изолированного хранилища.  Массив нулевой длины указывает на отсутствие файлов в корневой папке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен методу с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%28System.String%29?displayProperty=nameWithType> метод с «*» для шаблона поиска.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Пути к файлам из корня изолированного хранилища не могут быть определены.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileNames">
      <MemberSignature Language="C#" Value="public string[] GetFileNames (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetFileNames(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileNames (searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetFileNames(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Шаблон поиска. Поддерживаются как одиночные ("?"), так и составные ("*") подстановочные знаки.</param>
        <summary>Получает имена файлов, соответствующие шаблону поиска.</summary>
        <returns>Массив относительных путей к файлам в области изолированного хранилища, соответствующим параметру <paramref name="searchPattern" />. Массив нулевой длины указывает на отсутствие соответствующих файлов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` «Project\Data * .txt» даст все файлы, «txt», начиная с данными в каталоге проекта области изолированного хранилища. Полное описание строк шаблона поиска см. в разделе <xref:System.IO.Directory?displayProperty=nameWithType>.  
  
 Сведения о том, как найти имена каталогов см. в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%2A> метод.  
  
 [Как: поиск существующих файлов и каталогов в изолированном хранилище](~/docs/standard/io/how-to-find-existing-files-and-directories-in-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%2A> метод. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#16)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#16)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="searchPattern" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Не удается найти путь к файлу, заданный параметром <paramref name="searchPattern" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastAccessTime (path As String) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetLastAccessTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или каталогу, для которых требуется получить сведения о дате и времени последнего обращения.</param>
        <summary>Возвращает дату и время последнего обращения к указанному файлу или каталогу.</summary>
        <returns>Дата и время последнего обращения к заданному файлу или каталогу. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файл описываемого `path` не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 г. нашей эры (C.E.) По Гринвичу (UTC), откорректированное по местному времени.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой, содержит только пробел либо один или несколько недопустимых символов, определенных методом <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastWriteTime (path As String) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetLastWriteTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или каталогу, для которых требуется получить сведения о дате и времени последней операции записи.</param>
        <summary>Возвращает дату и время последней операции записи в указанный файл или каталог.</summary>
        <returns>Дата и время последней операции записи в указанный файл или каталог. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если файл описываемого `path` не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 г. нашей эры (C.E.) По Гринвичу (UTC), откорректированное по местному времени.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой, содержит только пробел либо один или несколько недопустимых символов, определенных методом <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMachineStoreForApplication">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForApplication ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForApplication() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForApplication" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineStoreForApplication () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetMachineStoreForApplication();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает изолированное хранение с областью действия компьютера, соответствующее вызову удостоверения приложения кода.</summary>
        <returns>Объект, соответствующий области действия изолированного хранилища на основе вызова удостоверения приложения кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все сборки, связанные с приложением, используйте одного изолированного хранилища, при использовании этого метода.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForApplication%2A> функционально эквивалентно следующему коду:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#18)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#18)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Не удалось определить удостоверение приложения вызывающего объекта.  
  
 - или -  
  
 Не удалось определить набор предоставленных разрешений для домена приложения.  
  
 - или -  
  
 Расположение изолированного хранилища не может быть инициализировано.</exception>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMachineStoreForAssembly">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineStoreForAssembly () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetMachineStoreForAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает изолированное хранение с областью действия компьютера, соответствующее вызову удостоверения сборки кода.</summary>
        <returns>Объект, соответствующий области действия изолированного хранилища на основе вызова удостоверения сборки кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Той же сборки в различных приложениях всегда использует же изолированное хранилище, при использовании этого метода.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForAssembly%2A> функционально эквивалентно следующему коду:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#19)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#19)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#19)]  
  
> [!NOTE]
>  Различные сборки, выполняющиеся в том же домене приложения, всегда имеют отдельные изолированные хранилища.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Расположение изолированного хранилища не может быть инициализировано.</exception>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMachineStoreForDomain">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineStoreForDomain () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetMachineStoreForDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает изолированное хранение с областью действия компьютера, соответствующее удостоверению домена приложения и сборки.</summary>
        <returns>Объект, соответствующий <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" />, основывается на комбинации удостоверения домена приложения и удостоверения сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Один и тот же код сборки будет использовать различные изолированные используется в контексте различных приложений.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForDomain%2A> функционально эквивалентно следующему коду:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#20)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#20)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#20)]  
  
 Различные сборки, выполняющиеся в том же домене приложения, всегда имеют отдельные изолированные хранилища.  
  
> [!NOTE]
>  <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> Возвращает <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта без квоты, если домен приложения, в котором установлена сборка не имеет <xref:System.Security.Permissions.IsolatedStorageFilePermission>. Последующие попытки создания <xref:System.IO.IsolatedStorage.IsolatedStorageFile> с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта, имеющего квоты, будут завершаться <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> метод. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Хранилище не удалось открыть.  
  
 - или -  
  
 Указанная сборка не имеет достаточно разрешений для создания изолированных хранилищ.  
  
 - или -  
  
 Невозможно определить разрешения для домена приложений.  
  
 - или -  
  
 Расположение изолированного хранилища не может быть инициализировано.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetPermission">
      <MemberSignature Language="C#" Value="protected override System.Security.Permissions.IsolatedStoragePermission GetPermission (System.Security.PermissionSet ps);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Security.Permissions.IsolatedStoragePermission GetPermission(class System.Security.PermissionSet ps) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetPermission(System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetPermission (ps As PermissionSet) As IsolatedStoragePermission" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Security::Permissions::IsolatedStoragePermission ^ GetPermission(System::Security::PermissionSet ^ ps);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Permissions.IsolatedStoragePermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ps" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="ps">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStore">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает изолированное хранилище, соответствующее данным объектам свидетельств сборки и домена приложения и изолированной области хранения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, object applicationIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, object applicationIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, applicationIdentity As Object) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, System::Object ^ applicationIdentity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="applicationIdentity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="scope">Побитовое сочетание значений перечисления.</param>
        <param name="applicationIdentity">Объект, содержащий свидетельство для удостоверения приложения.</param>
        <summary>Получает изолированное хранение, соответствующее данному удостоверению приложения.</summary>
        <returns>Объект, представляющий параметры.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если `scope` параметр <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Application?displayProperty=nameWithType> и домена приложения, в котором установлена сборка не имеет <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> метод будет возвращать <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта без квоты. Последующие попытки создания <xref:System.IO.IsolatedStorage.IsolatedStorageFile> с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта, имеющего квоты, будут завершаться <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.ArgumentNullException">Идентификатор <paramref name="applicationIdentity" /> не был передан.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="scope" /> не является допустимым.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение перечисления <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, но идентификатор приложения вызывающего модуля не может быть определен, так как свойство <see cref="P:System.AppDomain.ActivationContext" /> для текущего домена приложения вернуло значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, но разрешения для домена приложения не могут быть определены.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, но разрешения для вызывающей сборки не могут быть определены.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, Type applicationEvidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, class System.Type applicationEvidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, applicationEvidenceType As Type) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, Type ^ applicationEvidenceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="applicationEvidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="scope">Побитовое сочетание значений перечисления.</param>
        <param name="applicationEvidenceType">Объект , который содержит удостоверение приложения.</param>
        <summary>Получает изолированное хранение, соответствующее области изоляции и объекту удостоверения приложения.</summary>
        <returns>Объект, представляющий параметры.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если `scope` параметр <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Application> и домена приложения, в котором установлена сборка не имеет <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> метод будет возвращать <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта без квоты. Последующие попытки создания <xref:System.IO.IsolatedStorage.IsolatedStorageFile> с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта, имеющего квоты, будут завершаться <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.ArgumentNullException">Идентификатор <paramref name="applicationEvidence" /> не был передан.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="scope" /> не является допустимым.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение перечисления <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, но идентификатор приложения вызывающего модуля не может быть определен, так как свойство <see cref="P:System.AppDomain.ActivationContext" /> для текущего домена приложения вернуло значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, но разрешения для домена приложения не могут быть определены.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, но разрешения для вызывающей сборки не могут быть определены.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, domainIdentity As Object, assemblyIdentity As Object) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, System::Object ^ domainIdentity, System::Object ^ assemblyIdentity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="domainIdentity" Type="System.Object" />
        <Parameter Name="assemblyIdentity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="scope">Побитовое сочетание значений перечисления.</param>
        <param name="domainIdentity">Объект, содержащий свидетельство для удостоверения домена приложения.</param>
        <param name="assemblyIdentity">Объект, содержащий свидетельство для удостоверения сборки кода.</param>
        <summary>Возвращает изолированное хранение, соответствующее объектам данного домена приложения и свидетельства сборки.</summary>
        <returns>Объект, представляющий параметры.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой форме `GetStore` наиболее полезна для администрирования код, который необходимо открыть хранилище, как если бы это был другой сборки. Хранилище открывается для предоставленного свидетельства, а не для текущей выполняемой сборке.  
  
> [!NOTE]
>  Если `scope` параметр <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Domain> и домена приложения, в котором установлена сборка не имеет <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> метод будет возвращать <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта без квоты. Последующие попытки создания <xref:System.IO.IsolatedStorage.IsolatedStorageFile> с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта, имеющего квоты, будут завершаться <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.ArgumentNullException">Ни <paramref name="domainIdentity" />, ни <paramref name="assemblyIdentity" /> не были переданы. Проверяет правильность используемого конструктора.  
  
 - или -  
  
 Либо <paramref name="domainIdentity" />, либо <paramref name="assemblyIdentity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="scope" /> не является допустимым.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение перечисления <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, но идентификатор приложения вызывающего модуля не может быть определен, так как свойство <see cref="P:System.AppDomain.ActivationContext" /> для текущего домена приложения вернуло значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, но разрешения для домена приложения не могут быть определены.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, но разрешения для вызывающей сборки не могут быть определены.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, class System.Type domainEvidenceType, class System.Type assemblyEvidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, domainEvidenceType As Type, assemblyEvidenceType As Type) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, Type ^ domainEvidenceType, Type ^ assemblyEvidenceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="domainEvidenceType" Type="System.Type" />
        <Parameter Name="assemblyEvidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="scope">Побитовое сочетание значений перечисления.</param>
        <param name="domainEvidenceType">Тип свидетельства <see cref="T:System.Security.Policy.Evidence" />, которое можно выбрать из списка свидетельств <see cref="T:System.Security.Policy.Evidence" />, присутствующих в домене вызывающего приложения. Значение <see langword="null" /> позволяет объекту <see cref="T:System.IO.IsolatedStorage.IsolatedStorage" /> выбирать свидетельство.</param>
        <param name="assemblyEvidenceType">Тип свидетельства <see cref="T:System.Security.Policy.Evidence" />, которое можно выбрать из списка свидетельств <see cref="T:System.Security.Policy.Evidence" />, присутствующих в домене вызывающего приложения. Значение <see langword="null" /> позволяет объекту <see cref="T:System.IO.IsolatedStorage.IsolatedStorage" /> выбирать свидетельство.</param>
        <summary>Получает изолированное хранение, соответствующее области ограниченного действия изолированного хранения, предоставляющей типы домена приложения и свидетельства сборки.</summary>
        <returns>Объект, представляющий параметры.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это перегруженный <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> скорее всего, должна вызываться из кода приложения.  
  
 Эта перегрузка <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> открывает для типов свидетельства, переданных в изолированном хранилище.  
  
> [!NOTE]
>  Если `scope` параметр <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Domain> и домена приложения, в котором установлена сборка не имеет <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> метод будет возвращать <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта без квоты. Последующие попытки создания <xref:System.IO.IsolatedStorage.IsolatedStorageFile> с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта, имеющего квоты, будут завершаться <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> метод. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="scope" /> не является допустимым.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Предоставленный тип свидетельства отсутствует в списке свидетельства сборки.  
  
 - или -  
  
 Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение перечисления <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, но идентификатор приложения вызывающего модуля не может быть определен, так как свойство <see cref="P:System.AppDomain.ActivationContext" /> для текущего домена приложения вернуло значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, но разрешения для домена приложения не могут быть определены.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, но разрешения для вызывающей сборки не могут быть определены.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, System.Security.Policy.Evidence domainEvidence, Type domainEvidenceType, System.Security.Policy.Evidence assemblyEvidence, Type assemblyEvidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, class System.Security.Policy.Evidence domainEvidence, class System.Type domainEvidenceType, class System.Security.Policy.Evidence assemblyEvidence, class System.Type assemblyEvidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Security.Policy.Evidence,System.Type,System.Security.Policy.Evidence,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, domainEvidence As Evidence, domainEvidenceType As Type, assemblyEvidence As Evidence, assemblyEvidenceType As Type) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, System::Security::Policy::Evidence ^ domainEvidence, Type ^ domainEvidenceType, System::Security::Policy::Evidence ^ assemblyEvidence, Type ^ assemblyEvidenceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="domainEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="domainEvidenceType" Type="System.Type" />
        <Parameter Name="assemblyEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="assemblyEvidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="scope">Побитовое сочетание значений перечисления.</param>
        <param name="domainEvidence">Объект, который содержит удостоверение домена приложения.</param>
        <param name="domainEvidenceType">Тип-идентификатор для выбора из свидетельства домена приложения.</param>
        <param name="assemblyEvidence">Объект, который содержит удостоверение сборки кода.</param>
        <param name="assemblyEvidenceType">Тип-идентификатор для выбора из свидетельства сборки кода приложения.</param>
        <summary>Возвращает изолированное хранение, соответствующее объектам и типам данного домена приложения и свидетельства сборки.</summary>
        <returns>Объект, представляющий параметры.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если `scope` параметр <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Domain> и домена приложения, в котором установлена сборка не имеет <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> метод будет возвращать <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта без квоты. Последующие попытки создания <xref:System.IO.IsolatedStorage.IsolatedStorageFile> с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта, имеющего квоты, будут завершаться <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 В следующем примере кода получает хранилище, исходя из свидетельства издателя.  
  
 [!code-csharp[System.IO.IsolatedStorage.GetStore#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.GetStore/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.GetStore#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.GetStore/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.ArgumentNullException">Удостоверение <paramref name="domainEvidence" /> или <paramref name="assemblyEvidence" /> не было передано.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="scope" /> не является допустимым.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение перечисления <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, но идентификатор приложения вызывающего модуля не может быть определен, так как свойство <see cref="P:System.AppDomain.ActivationContext" /> для текущего домена приложения вернуло значение <see langword="null" />.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, но разрешения для домена приложения не могут быть определены.  
  
 - или -  
  
 <paramref name="scope" /> содержит значение <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, но разрешения для вызывающей сборки не могут быть определены.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForApplication">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForApplication ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForApplication() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForApplication () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForApplication();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает изолированное хранение с областью действия пользователя, соответствующее вызову удостоверения приложения кода.</summary>
        <returns>Объект, соответствующий области действия изолированного хранилища на основе вызова удостоверения сборки кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все сборки, связанные с приложением, используйте одного изолированного хранилища, при использовании этого метода. Этот метод можно использовать только в том случае, если удостоверение приложения можно определить — например, при публикации развертывания ClickOnce или является приложением Silverlight приложения. При попытке использовать этот метод за пределами ClickOnce или приложение Silverlight, вы получите <xref:System.IO.IsolatedStorage.IsolatedStorageException> исключение, так как не удалось определить удостоверение приложения вызывающего объекта.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication%2A> функционально эквивалентно следующему коду:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#21](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#21)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#21)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#21)]  
  
 В этом коде `applicationIdentity` параметр `GetStore(IsolatedStorageScope scope, Object applicationIdentity)` — `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 Не удается установить идентификатор приложения вызывающего объекта, поскольку свойство <see cref="P:System.AppDomain.ActivationContext" /> вернуло значение <see langword="null" />.  
  
 - или -  
  
 Невозможно определить разрешения для домена приложений.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForAssembly">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForAssembly () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForAssembly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает изолированное хранение с областью действия пользователя, соответствующее вызову удостоверения сборки кода.</summary>
        <returns>Объект, соответствующий области действия изолированного хранилища на основе вызова удостоверения сборки кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Той же сборки в различных приложениях всегда использует же изолированное хранилище, при использовании этого метода.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly%2A> функционально эквивалентно следующему коду:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#22](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#22)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#22)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#22)]  
  
> [!NOTE]
>  Различные сборки, выполняющиеся в том же домене приложения, всегда имеют отдельные изолированные хранилища.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 невозможно определить разрешения для вызывающей сборки.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForDomain">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForDomain () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает изолированную область хранения с областью действия пользователя, соответствующую удостоверению домена приложения и удостоверению сборки.</summary>
        <returns>Объект, соответствующий <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" />, основывается на комбинации удостоверения домена приложения и удостоверения сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Один и тот же код сборки будет использовать различные изолированные используется в контексте различных приложений.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> функционально эквивалентно следующему коду:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#23](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#23)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#23)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#23)]  
  
 Различные сборки, выполняющиеся в том же домене приложения, всегда имеют отдельные изолированные хранилища.  
  
> [!NOTE]
>  <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> Возвращает <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта без квоты, если домен приложения, в котором установлена сборка не имеет <xref:System.Security.Permissions.IsolatedStorageFilePermission>. Последующие попытки создания <xref:System.IO.IsolatedStorage.IsolatedStorageFile> с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFile> объекта, имеющего квоты, будут завершаться <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> метод. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Недостаточно разрешений для изолированного хранения.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Хранилище не удалось открыть.  
  
 - или -  
  
 Указанная сборка не имеет достаточно разрешений для создания изолированных хранилищ.  
  
 - или -  
  
 Расположение изолированного хранилища не может быть инициализировано.  
  
 - или -  
  
 Невозможно определить разрешения для домена приложений.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForSite">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForSite ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForSite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForSite" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForSite () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForSite();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает изолированное хранилище с определенной пользователем областью действия для использования приложениями в домене виртуального узла.</summary>
        <returns>Файл изолированного хранилища, соответствующий области изолированного хранилища на основе удостоверения приложения вызывающего кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод поддерживается только в приложениях Silverlight.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncreaseQuotaTo">
      <MemberSignature Language="C#" Value="public override bool IncreaseQuotaTo (long newQuotaSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IncreaseQuotaTo(int64 newQuotaSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IncreaseQuotaTo (newQuotaSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IncreaseQuotaTo(long newQuotaSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newQuotaSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newQuotaSize">Запрошенный размер, в байтах.</param>
        <summary>Позволяет приложению в явной форме запросить больший размер квоты в байтах.</summary>
        <returns>
          Значение <see langword="true" />, если новая квота принята; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A> Метод позволяет приложению явным образом запросить больший размер квоты в байтах. Новый размер квоты не должно быть меньше, чем текущий размер квоты, из-за увеличения квоты только разрешены.  
  
 Каждый раз, когда <xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A> вызовы вызван, изолированное хранилище — метод <xref:System.AppDomainManager.CheckSecuritySettings%2A> метод.  
  
 Можно реализовать путем создания пользовательской принятия решений политики <xref:System.AppDomainManager> объекта, который переопределяет <xref:System.AppDomainManager.CheckSecuritySettings%2A> метод, чтобы объект мог выполнять принятия решений политики на основе <xref:System.IO.IsolatedStorage.IsolatedStorageSecurityState> объекта.  
  
 Если нет настраиваемых <xref:System.AppDomainManager> объекта, запрос увеличения квоты запрещен, поскольку реализация по умолчанию для <xref:System.AppDomainManager.CheckSecuritySettings%2A> возвращает `false`.  
  
 В настоящий момент ни один из узлов в .NET Framework предоставляют эту настройку, поэтому <xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A> всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newQuotaSize" /> меньше текущего размера квоты.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="newQuotaSize" /> меньше нуля, или же меньше либо равен текущему размеру квоты.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.NotSupportedException">Текущая область не предназначена для пользователя приложения.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public static bool IsEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, включено ли изолированное хранилище.</summary>
        <value>
          Значение <see langword="true" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изолированное хранилище для полных приложений .NET Framework, всегда включены.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override ulong MaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int64 MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MaximumSize As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::UInt64 MaximumSize { System::UInt64 get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, представляющее максимальный размер области, доступной для изолированного хранения в пределах, установленных квотой.</summary>
        <value>Ограничение области изолированного хранения в байтах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Число доступных байтов ограничен квотой изолированного хранилища, заданному администратором. Квота настраивается в политике безопасности на основе свидетельства, поэтому тот же код может получить разные квоты, если он выполняется с разными свидетельствами. Например приложение, которое запускается локально, а также из общей папки в локальной сети должен получать различные квоты.  
  
 [Как: предугадать, условия нехватки места при изолированном хранении](~/docs/standard/io/how-to-anticipate-out-of-space-conditions-with-isolated-storage.md) примере показано использование функции <xref:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize%2A> свойство. Полный контекст в этом примере в разделе <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Обзор.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#5)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#5)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство недоступно. <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize" /> невозможно определить без свидетельства от создания сборки. Свидетельство не может быть определено после создания объекта.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Произошла ошибка изолированного хранения.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Имя перемещаемого каталога.</param>
        <param name="destinationDirectoryName">Путь к новому местоположению <c>sourceDirectoryName</c>. Этот путь не может указывать на существующий каталог.</param>
        <summary>Перемещает указанный каталог и его содержимое в новое расположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName` и `destinationFileName` необходимо указать другие имена каталогов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую хотя бы один недопустимый символ, заданный методом <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="sourceDirectoryName" /> — не существует.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.  
  
 - или -  
  
 <paramref name="destinationDirectoryName" /> уже существует.  
  
 - или -  
  
 Параметры <paramref name="sourceDirectoryName" /> и <paramref name="destinationDirectoryName" /> ссылаются на один и тот же каталог.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Имя перемещаемого файла.</param>
        <param name="destinationFileName">Путь к новому расположению файла. Если путь включает имя файла, перемещенный файл будет иметь это имя.</param>
        <summary>Перемещает указанный файл в новое расположение и позволяет указать для файла новое имя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не вызывает исключение, если `sourceFileName` и `destinationFileName` совпадают.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую хотя бы один недопустимый символ, заданный методом <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="sourceFileName" /> или <paramref name="destinationFileName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает файл с указанными параметрами доступа и общего доступа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenFile (path As String, mode As FileMode) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ OpenFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Относительный путь к файлу внутри изолированного хранилища.</param>
        <param name="mode">Одно из значений перечисления, задающее способ открытия файла.</param>
        <summary>Открывает файл в заданном режиме.</summary>
        <returns>Файл, открытый в заданном режиме, с доступом для чтения и записи и без предоставления общего доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен методу с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
        <exception cref="T:System.ArgumentException">
          Неверный формат параметра <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог в <paramref name="path" /> не существует.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден, и <paramref name="mode" /> имеет значение <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenFile (path As String, mode As FileMode, access As FileAccess) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ OpenFile(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Относительный путь к файлу внутри изолированного хранилища.</param>
        <param name="mode">Одно из значений перечисления, задающее способ открытия файла.</param>
        <param name="access">Одно из значений перечисления, определяющее, с какими правами открывается файл: только для чтения, только для записи или для чтения и записи.</param>
        <summary>Открывает файл в заданном режиме с заданным доступом для чтения и записи.</summary>
        <returns>Файл, открытый в заданном режиме, с заданным уровнем доступа и без предоставления общего доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен методу с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
        <exception cref="T:System.ArgumentException">
          Неверный формат параметра <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог в <paramref name="path" /> не существует.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден, и <paramref name="mode" /> имеет значение <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenFile (path As String, mode As FileMode, access As FileAccess, share As FileShare) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ OpenFile(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Относительный путь к файлу внутри изолированного хранилища.</param>
        <param name="mode">Одно из значений перечисления, задающее способ открытия или создания файла.</param>
        <param name="access">Одно из значений перечисления, определяющее, с какими правами открывается файл: только для чтения, только для записи или для чтения и записи.</param>
        <param name="share">Побитовая комбинация значений перечисления, которые определяют тип доступа к файлу для других объектов <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Открывает файл в заданном режиме, с заданным уровнем доступа для чтения и записи и с разрешением на совместный доступ.</summary>
        <returns>Файл, открытый в заданном режиме, с заданным уровнем доступа и с указанными параметрами общего доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод эквивалентен методу с помощью <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
        <exception cref="T:System.ArgumentException">
          Неверный формат параметра <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Каталог в <paramref name="path" /> не существует.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не найден, и <paramref name="mode" /> имеет значение <see cref="M:System.IO.FileInfo.Open(System.IO.FileMode)" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
      </Docs>
    </Member>
    <Member MemberName="Quota">
      <MemberSignature Language="C#" Value="public override long Quota { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Quota" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.Quota" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Quota As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Quota { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, представляющее максимальный объем свободного пространства, доступного для изолированной памяти.</summary>
        <value>Ограничение объема изолированного хранилища в байтах.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.  
  
 - или -  
  
 Изолированное хранилище отключено.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет область ограниченного действия изолированного хранения со всем ее содержимым.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Remove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет область ограниченного действия изолированного хранения со всем ее содержимым.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Этот метод необратимо удаляет всю область и все вложенные каталоги и файлы.  
  
 Если каталоги или файлы из хранилища используются, попытка удаления хранилище и хранилище будет помечено для удаления. Все последующие попытки изменить хранилище throw <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A> метода для удаления файлов изолированного хранилища, после его содержимое был очищен. [Как: удаление хранилищ из области изолированного хранения](~/docs/standard/io/how-to-delete-stores-in-isolated-storage.md) пример также демонстрирует использование <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A> метода.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#16)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#16)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Невозможно удалить изолированное хранилище.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static void Remove (System.IO.IsolatedStorage.IsolatedStorageScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Remove(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Remove(System.IO.IsolatedStorage.IsolatedStorageScope)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Remove (scope As IsolatedStorageScope)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Remove(System::IO::IsolatedStorage::IsolatedStorageScope scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
      </Parameters>
      <Docs>
        <param name="scope">Поразрядное сочетание значений <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" />.</param>
        <summary>Удаляет для всех удостоверений указанную область ограниченного действия изолированного хранения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Этот метод необратимо удаляет всю область и все вложенные каталоги и файлы.  
  
 Если каталоги или файлы из хранилища используются, попытка удаления хранилище и хранилище будет помечено для удаления. Все последующие попытки изменить хранилище throw <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Невозможно удалить изолированное хранилище.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">для использования изолированного хранилища. Связанное перечисление: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове поздней привязкой, такие как <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UsedSize">
      <MemberSignature Language="C#" Value="public override long UsedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 UsedSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.UsedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UsedSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long UsedSize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее объем пространства, используемого для изолированного хранилища.</summary>
        <value>Объем пространства, используемого для изолированного хранилища, в байтах.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Изолированное хранилище было закрыто.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Изолированное хранилище было удалено.</exception>
        <exception cref="T:System.ObjectDisposedException">Изолированное хранилище было ликвидировано.</exception>
      </Docs>
    </Member>
  </Members>
</Type>