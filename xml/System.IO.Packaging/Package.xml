<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e633ba759596ecfd98d51e13ceacad970601b282" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37759523" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a container that can store multiple data objects.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> — Абстрактный класс, который может использоваться для упорядочивания объектов в одной сущности из определенного физического формата для обеспечения переносимости и эффективный доступ.  
  
 ZIP-файл является основным форматом физических <xref:System.IO.Packaging.Package>.  Другие <xref:System.IO.Packaging.Package> реализации может использовать другие физические форматы, например XML-документа, базы данных, или веб-службы.  
  
 Как и системные файлы, элементы, содержащиеся в <xref:System.IO.Packaging.Package> указываются в виде иерархической структуры папок и файлов.  
  
 Несмотря на то что <xref:System.IO.Packaging.Package> сам является абстрактным классом, <xref:System.IO.Packaging.ZipPackage> производном классе используется по умолчанию, <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Объект <xref:System.IO.Packaging.PackagePart> («часть») — это абстрактный класс, который представляет объект, который хранится в <xref:System.IO.Packaging.Package>.  
  
 Объект <xref:System.IO.Packaging.PackageRelationship> («отношение») определяет ассоциацию между исходным <xref:System.IO.Packaging.Package> или <xref:System.IO.Packaging.PackagePart> и целевым объектом.  Объект <xref:System.IO.Packaging.PackageRelationship> может принимать одно из двух типов, каждый из которых может принимать одно из двух форм:  
  
-   Отношение уровня пакета (созданные <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> метод) относится <xref:System.IO.Packaging.Package> либо:  
  
    -   Целевой части в пакете.  
  
    -   Целевой ресурс вне пакета.  
  
-   Отношение уровня части (созданные <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> метод) относится источник <xref:System.IO.Packaging.PackagePart> либо:  
  
    -   Другой целевой части в пакете.  
  
    -   Целевой ресурс вне пакета.  
  
 Источник отношений <xref:System.IO.Packaging.Package> или источника <xref:System.IO.Packaging.PackagePart> считается «владельцем» связи.  При удалении исходного объекта также удаляются все отношения, принадлежащие исходного объекта.  Процесс создания или удаления связи не изменяет физически исходных или целевых объектов любым способом.  
  
 Объект <xref:System.IO.Packaging.PackageDigitalSignature> («цифровая подпись») представляет собой сочетание частей и отношений, представляющий состав цифровой подписи <xref:System.IO.Packaging.Package>.  Цифровая подпись, определяющую отправителя и проверяет, что подписанные части и отношения содержится в <xref:System.IO.Packaging.Package> не были изменены.  
  
 Пакеты также поддерживают цифровыми правами (DRM), позволяющий элементами содержимого в <xref:System.IO.Packaging.Package> шифрование с конкретных прав доступа для авторизованных пользователей.  
  
 На основе <xref:System.IO.Packaging.Package> архитектуры, <xref:System.Windows.Xps.Packaging.XpsDocument> — это тип пакета, предназначенных для хранения документов, основанные на открытых [XML Paper Specification (XPS)](http://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework использует пакеты для хранения содержимого, ресурсы и связи для страниц и документов с помощью стандартного ZIP-файла по умолчанию. Как любой ZIP-файл, приложение может использовать <xref:System.IO.Packaging> классов для хранения и защиты любого типа или количество файлов данных в одном контейнере эффективный доступ.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано основные шаги для создания <xref:System.IO.Packaging.Package>.  В этом примере пакет создается для хранения документа и графического изображения, которое отображается как часть документа.  (Это похоже на случай, в котором содержит HTML-файл \<IMG > тег, который ссылается на внешний файл изображения.)  Два <xref:System.IO.Packaging.PackageRelationship> элементы также будут включены в пакет.  Во-первых, связь «на уровне пакета», определяет части документа как корневого элемента пакета.  Во-вторых, «уровня части» отношение определяет связи между части документа («источник» отношения уровня части) и его использование части изображения («target» отношения уровня части).  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор является защищенным из <xref:System.IO.Packaging.Package> абстрактного базового класса. При вызове в производном классе, <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор инициализирует новый экземпляр производного класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <param name="streaming">
          <see langword="true" /> to open the package for streaming; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" /> and streaming option.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор является защищенным из <xref:System.IO.Packaging.Package> абстрактный базовый абстрактный базовый класс. При вызове в производном классе, <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор инициализирует новый экземпляр производного класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves and closes the package plus all underlying part streams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.IO.Packaging.Package> класс <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> выполнить те же операции, нет причин для вызова <xref:System.IO.Packaging.Package.Dispose%2A> при вызове метода <xref:System.IO.Packaging.Package.Close%2A>, или наоборот.  
  
 <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> внутреннего вызова <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  `using` Инструкции (отличается от `using` директивы пространства имен) — это рекомендуемый способ <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> пакета.  [Пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055) и [пример чтения пакета](http://go.microsoft.com/fwlink/?LinkID=160034) показано, как закрыть и удалить пакет с помощью `using` инструкции.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new package part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Инициализирует пустой <xref:System.IO.Stream> для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод может использоваться для получения ссылки на экземпляр потока, связанного с частью.  
  
 Дополнительные сведения о части пакета в разделе 1.1 спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.PackagePart> и как сохранить данные в части.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод для создания части на основе физического формата реализации в производном классе.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <summary>Creates a new uncompressed part with a given URI and content type.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Инициализирует пустой <xref:System.IO.Stream> для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод может использоваться для получения ссылки на экземпляр потока, связанного с частью.  
  
 Часть <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> является <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Дополнительные сведения об элементах пакета в разделе 1.1 в спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.PackagePart> и как сохранить данные в части.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод для создания части на основе физического формата реализации в производном классе.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> or <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> compression.</param>
        <summary>Creates a new part with a given URI, content type, and compression option.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производного класса <xref:System.IO.Packaging.Package.CreatePart%2A> метод поддерживает два только `compressionOption` значения, <xref:System.IO.Packaging.CompressionOption.NotCompressed> или <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  Другие <xref:System.IO.Packaging.CompressionOption> значения <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, или <xref:System.IO.Packaging.CompressionOption.SuperFast> использовать <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Создает пустой <xref:System.IO.Stream> для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод может использоваться для получения ссылки на экземпляр потока, связанного с частью.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.PackagePart> и как сохранить данные в части.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="compressionOption" /> value is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод для создания части на основе физического формата реализации в производном классе.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] for the part being created.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream.</param>
        <summary>When overridden in a derived class, creates a new part in the package.</summary>
        <returns>The created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные <xref:System.IO.Packaging.Package.CreatePartCore%2A> вызывается метод <xref:System.IO.Packaging.Package.CreatePart%2A> метод для создания части на основе физического формата реализации в производном классе.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> реализация производного класса абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.CreatePart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.CreatePartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класс, чтобы создать новую часть в ZIP-файл.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производного класса <xref:System.IO.Packaging.Package.CreatePartCore%2A> метод поддерживает два только `compressionOption` значения, <xref:System.IO.Packaging.CompressionOption.NotCompressed> или <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  Другие <xref:System.IO.Packaging.CompressionOption> значения <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, или <xref:System.IO.Packaging.CompressionOption.SuperFast> использовать <xref:System.IO.Packaging.CompressionOption.Normal> сжатия.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Производные <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> метод, который ее вызывает.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a package-level relationship to a given part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевому объекту <xref:System.IO.Packaging.PackagePart> внутри пакета.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  Процесс создания или удаления связи не изменяет физически ни целевой части или ресурса любым способом.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано создание <xref:System.IO.Packaging.PackageRelationship> между <xref:System.IO.Packaging.Package> и корневой части документа.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, and relationship type.</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> не изменяет физически целевой части или ресурса любым способом.  
  
 Целевым объектом связи не может быть другая связь.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` должен быть относительный URI, сформированный в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  Внутренний относительный URI может быть либо абсолютный путь, который начинается с косой черты («/») символ например «/ page1.xaml» или «/ images/picture4.jpg», или относительный путь, например, «.. / imagespicture1.jpg», разрешающее относительно корня пакета («/») как базовый URI.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.External>, `targetUri` может быть либо абсолютный или относительный URI, сформированный в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  "http://www.microsoft.com/page2.xml" является примером абсолютный URI, который ссылается на ресурс внешний целевой объект «page2.xml».  «images/picture1.jpg» является примером относительный URI, который также ссылается на внешний целевой ресурс «1.jpg» но который разрешается относительно URI самого пакета.  
  
 `relationshipType` должно быть [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] , формируется в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  В следующей таблице показаны уровня пакета `relationshipType` коды URI, определенных в спецификации Open Packaging Conventions (OPC).  
  
|Связь уровня пакета|Тип связи URI|  
|---------------------------------|---------------------------|  
|Основные свойства|http://schemas.openxmlformats.org/package/2006/relationships/meta свойства/core данных|  
|Цифровая подпись|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подпись или подпись|  
|Цифровая подпись сертификата|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подписи и сертификатов|  
|Цифровая подпись источника|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подписи или исходный|  
|Эскиз|http://schemas.openxmlformats.org/package/2006/relationships/meta данные/эскиза|  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.CreateRelationship%2A> для создания <xref:System.IO.Packaging.PackageRelationship> между <xref:System.IO.Packaging.Package> и корневой части документа.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <param name="id">A unique XML identifier.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, relationship type, and [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> не изменяет физически целевой части или ресурса любым способом.  
  
 Целевым объектом связи не может быть другая связь.  
  
 `id` должен быть допустимым идентификатором XML.  `id` Тип xsd:ID и должно соответствовать соглашениям об именах, описанный в XML Schema Part 2: Datatypes specification (см. в разделе [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Если `id` указывается как `null` уникальный идентификатор создается автоматически.  `id` Определяемое пустая строка недопустима.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` должен быть относительный URI, сформированный в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  Внутренний относительный URI может быть либо абсолютный путь, который начинается с косой черты («/») символ например «/ page1.xaml» или «/ images/picture4.jpg», или относительный путь, например, «.. / imagespicture1.jpg», разрешающее относительно корня пакета («/») как базовый URI.  
  
 Если `targetMode` указывается как <xref:System.IO.Packaging.TargetMode.External>, `targetUri` может быть либо абсолютный или относительный URI, сформированный в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  "http://www.microsoft.com/page2.xml" является примером абсолютный URI, который ссылается на ресурс внешний целевой объект «page2.xml».  «images/picture1.jpg» является примером относительный URI, который также ссылается на внешний целевой ресурс «1.jpg» но который разрешается относительно URI самого пакета.  
  
 `relationshipType` должен быть URI, сформированный в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  В следующей таблице показаны уровня пакета `relationshipType` коды URI, определенных в спецификации Open Packaging Conventions (OPC).  
  
|Связь уровня пакета|Тип связи URI|  
|---------------------------------|---------------------------|  
|Основные свойства|http://schemas.openxmlformats.org/package/2006/relationships/meta свойства/core данных|  
|Цифровая подпись|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подпись или подпись|  
|Цифровая подпись сертификата|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подписи и сертификатов|  
|Цифровая подпись источника|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подписи или исходный|  
|Эскиз|http://schemas.openxmlformats.org/package/2006/relationships/meta данные/эскиза|  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.CreateRelationship%2A> для создания <xref:System.IO.Packaging.PackageRelationship> между <xref:System.IO.Packaging.Package> и корневой части документа.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier; or a part with the specified <paramref name="id" /> already occurs in the package.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the part to delete.</param>
        <summary>Deletes a part with a given URI from the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` должен быть относительным URI, который состоит из абсолютного пути, начинается с косой черты («/») символ.  Абсолютный путь задается относительно корневого каталога пакета и формируется в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) спецификации общий синтаксис универсальный код ресурса (URI).  «/ page1.xaml» и «/ images/picture4.jpg» являются примерами допустимой частью идентификаторы URI.  
  
 Исключение возникает в том случае, если часть с указанным `partUri` не находится в пакете.  (Можно использовать <xref:System.IO.Packaging.Package.PartExists%2A> метод, чтобы определить, является ли элемент с указанным `partUri` находится в пакете.)  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> метод фактически удалить части на основе физического формата реализации в производном классе.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="P:System.IO.Packaging.PackagePart.Uri" /> of the <see cref="T:System.IO.Packaging.PackagePart" /> to delete.</param>
        <summary>When overridden in a derived class, deletes a part with a given URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> реализация производного класса абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.DeletePart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.DeletePartCore%2A> из <xref:System.IO.Packaging.ZipPackage> классом для выполнения фактического удаления на основе формата физической реализации в производном классе.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Производный класс <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> вызывается реализация <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> метод с указанной частью на основе физического формата реализации в производном классе.  Производные <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> метод, который ее вызывает.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the <see cref="T:System.IO.Packaging.PackageRelationship" /> to delete.</param>
        <summary>Deletes a package-level relationship.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  
  
 Исключение возникает в том случае, если связь с указанным `id` не находится в пакете.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> не изменяет физически целевой части любым способом.  
  
 Дополнительные сведения о связях пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Flushes and saves the content of all parts and relationships, closes the package, and releases all resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы убедиться в том, что все изменения сохраняются правильно, <xref:System.IO.Packaging.Package.Dispose%2A> также завершает работу, очищает и закрывает всех частей и связей, которые содержатся в пакете.  
  
 Для <xref:System.IO.Packaging.Package> класс, <xref:System.IO.Packaging.Package.Dispose%2A> и <xref:System.IO.Packaging.Package.Close%2A> выполнить те же операции — нет причин для вызова <xref:System.IO.Packaging.Package.Dispose%2A> при вызове метода <xref:System.IO.Packaging.Package.Close%2A>, или наоборот.  
  
 <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> внутреннего вызова <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Производные классы, выделить ресурсы и управлять ими неоптимизированными для памяти, которые должны переопределять этот метод для освобождения ресурсов при <xref:System.IO.Packaging.Package.Dispose%2A> вызывается. Производный класс переопределяет вызывать <xref:System.IO.Packaging.Package.Flush%2A> и базовый класс <xref:System.IO.Packaging.Package.Dispose%2A> метод, чтобы убедиться в том, что очистка базового класса всегда выполняется.  
  
> [!NOTE]
>  `using` Инструкции (отличается от `using` директивы пространства имен) — это рекомендуемый способ <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> пакета. [Пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055) показано, как закрыть и удалить пакет с помощью `using` инструкции.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the file access setting for the package.</summary>
        <value>Один из <see cref="T:System.IO.FileAccess" /> значения: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, или <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.IO.Packaging.Package.FileOpenAccess%2A> не имеет значения по умолчанию.  Режима доступа к файлу указан в <xref:System.IO.Packaging.Package.%23ctor%2A> вызовите конструктор при создании нового пакета или в <xref:System.IO.Packaging.Package.Open%2A> вызова при открытии существующего пакета.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves the contents of all parts and relationships that are contained in the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> внутренне вызывает производного класса <xref:System.IO.Packaging.Package.FlushCore%2A> явная реализация для выполнения фактической операции записи на диск определенного формата.  Производный класс <xref:System.IO.Packaging.Package.FlushCore%2A> метод фактическое сохранение содержимого частей и связей в реализацию определенного физического производного класса.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используемый базовый класс. В ходе операции по умолчанию <xref:System.IO.Packaging.Package.Flush%2A> внутренне вызывает <xref:System.IO.Packaging.Package.FlushCore%2A> для сохранения частей и отношений в ZIP-файл пакета.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> автоматически вызывается <xref:System.IO.Packaging.Package.Close%2A> и <xref:System.IO.Packaging.Package.Dispose%2A> методы.  Когда <xref:System.IO.Packaging.Package.Close%2A> или <xref:System.IO.Packaging.Package.Dispose%2A> вызове нет необходимости вызывать <xref:System.IO.Packaging.Package.Flush%2A> отдельно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only and cannot be modified.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.FlushCore" /> метод фактически записать части на основе физического формата реализации в производном классе.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, saves the content of all parts and relationships to the derived class store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> вызывается <xref:System.IO.Packaging.Package.Flush%2A> метод для выполнения фактической операции записи на диск на основе физического формата реализации в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Производные <see cref="M:System.IO.Packaging.Package.FlushCore" /> реализация не должна делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.Flush" /> метод, который ее вызывает.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to return.</param>
        <summary>Returns the part with a given URI.</summary>
        <returns>The part with the specified <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> Возникает, если часть с указанным `partUri` не существует.  
  
 <xref:System.IO.Packaging.Package.PartExists%2A> Метод может использоваться для определения ли `partUri` ссылается на существующий элемент.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используемый базовый класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetPart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.GetPartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класса для возвращения запрашиваемой части из ZIP-файл.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Приведенный ниже показано, как находить, извлечь и прочитать части, содержащиеся в пакете.  Полный пример см. в разделе [пример чтения пакета](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> метод фактически записать части на основе физического формата реализации в производном классе.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to retrieve.</param>
        <summary>When overridden in a derived class, returns the part addressed by a given URI.</summary>
        <returns>The requested part; or <see langword="null" />, if a part with the specified <paramref name="partUri" /> is not in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetPart%2A> внутренне вызывает <xref:System.IO.Packaging.Package.GetPartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класса для извлечения элемента из ZIP-файла.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Производный класс <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> вызывается реализация <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> метод для доступа и возвращает указанную часть на основе физического формата реализации в производном классе.  Производные <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> метод, который ее вызывает.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the parts in the package.</summary>
        <returns>A collection of all the <see cref="T:System.IO.Packaging.PackagePart" /> elements that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Возвращает коллекцию всех частей, содержащихся в пакете, включая <xref:System.IO.Packaging.PackageRelationship> частей.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> никогда не будут возвращать `null`; тем не менее, возвращаемая коллекция будет содержать нуль элементов, если пакет содержит компоненты не.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используемый базовый класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetParts%2A> вызовы <xref:System.IO.Packaging.Package.GetPartsCore%2A> метод <xref:System.IO.Packaging.ZipPackage> класса для возвращения частей из ZIP-файл.  
  
 Дополнительные сведения о пакетах и частей пакета в разделе 1.1 спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.GetParts%2A> метод, чтобы получить коллекцию частей, содержащихся в <xref:System.IO.Packaging.Package>.  Полный исходный код программы, см. в разделе [Создание пакета с помощью цифровой подписи образца](http://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> внутренне вызывает производного класса <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> метод фактически записать части на основе физического формата реализации в производном классе.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns an array of all the parts in the package.</summary>
        <returns>An array of all the parts that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производный класс <xref:System.IO.Packaging.Package.GetPartsCore%2A> вызывается реализация <xref:System.IO.Packaging.Package.GetParts%2A> метод для доступа и возвращать массив частей на основе физического формата реализации в производном классе.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> производным реализацию абстрактного <xref:System.IO.Packaging.Package> предоставляется и используется класс.  В ходе операции по умолчанию <xref:System.IO.Packaging.Package.GetParts%2A> внутренне вызывает <xref:System.IO.Packaging.Package.GetPartCore%2A> из <xref:System.IO.Packaging.ZipPackage> класса для извлечения частей из ZIP-файла.  
  
 Дополнительные сведения о модели пакета и частей пакета приведены в главе 1 спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Производные <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> реализации следует делать никаких предположений о порядке или операции, выполняемые <see cref="M:System.IO.Packaging.Package.GetParts" /> метод, который ее вызывает.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to return.</param>
        <summary>Returns the package-level relationship with a given identifier.</summary>
        <returns>The package-level relationship with the specified <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` должен быть допустимым идентификатором XML.  `id` Тип xsd:ID и должно соответствовать соглашениям об именах, описанный в XML Schema Part 2: Datatypes specification (см. в разделе [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.InvalidOperationException">A relationship with the specified <paramref name="id" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the package-level relationships.</summary>
        <returns>A collection of all the package-level relationships that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> никогда не будут возвращать `null`; Однако Возвращенная коллекция может содержать нуль элементов, если пакет содержит не связей уровня пакета.  
  
 Отношение уровня пакета определяет ассоциацию между пакет и связанный целевой части или ресурса.  Отношение уровня пакета может принимать одно из двух форм.  
  
-   Между <xref:System.IO.Packaging.Package> к целевой части в пакете.  
  
-   Между <xref:System.IO.Packaging.Package> целевому ресурсу вне пакета.  
  
 В отношении пакета пакета считается «владелец» связи.  При удалении пакета также удаляются все отношения, принадлежащие пакета.  Процесс создания или удаления связи не изменяет физически ни целевой части или ресурса любым способом.  
  
 Дополнительные сведения об упаковке и связей пакета в разделе 1.3 спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">The <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> to match and return in the collection.</param>
        <summary>Returns a collection of all the package-level relationships that match a given <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>A collection of package-level relationships that match the specified <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> никогда не будут возвращать `null`; Однако Возвращенная коллекция может содержать нуль элементов, если нет связей уровня пакета, соответствующих указанному `relationshipType`.  
  
 В следующей таблице показаны уровня пакета `relationshipType` коды URI, определенных в спецификации Open Packaging Conventions (OPC).  
  
|Связь уровня пакета|Тип связи URI|  
|---------------------------------|---------------------------|  
|Основные свойства|http://schemas.openxmlformats.org/package/2006/relationships/meta свойства/core данных|  
|Цифровая подпись|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подпись или подпись|  
|Цифровая подпись сертификата|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подписи и сертификатов|  
|Цифровая подпись источника|http://schemas.openxmlformats.org/package/2006/relationships/digit Al подписи или исходный|  
|Эскиз|http://schemas.openxmlformats.org/package/2006/relationships/meta данные/эскиза|  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Приведенный ниже показано, как извлечь связи, определенные для пакета.  Полный пример см. в разделе [пример чтения пакета](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> is an empty string.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <summary>Opens a package on a given IO stream.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <summary>Opens a package at a given path and file name.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Это <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет с атрибутами по умолчанию <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, и <xref:System.IO.FileShare.None> (для указания различных атрибутов используйте один из других перегрузок метода Open).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package with a given IO stream and file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> value is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Это <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет с атрибутами по умолчанию <xref:System.IO.FileAccess.ReadWrite> и <xref:System.IO.FileShare.None> (для указания различных атрибутов используйте один из других перегрузок метода Open).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package with a given IO stream, file mode, and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Это <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет по умолчанию <xref:System.IO.FileShare.None> атрибут (для указания использования другой атрибут <xref:System.IO.Packaging.Package.Open%2A> перегрузка метода).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как открыть и прочитать <xref:System.IO.Packaging.Package> , содержащий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример чтения пакета](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <param name="packageShare">The file sharing mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode, file access, and file share setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> является типом пакета по умолчанию, который используется <xref:System.IO.Packaging.Package.Open%2A> метод.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 В следующем примере показано, как для создания нового <xref:System.IO.Packaging.Package> , включающий <xref:System.IO.Packaging.PackageRelationship> и <xref:System.IO.Packaging.PackagePart> элементов вместе с хранимых данных.  Полный пример см. в разделе [пример записи пакета](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" />, <paramref name="packageAccess" />, or <paramref name="packageShare" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the core properties of the package.</summary>
        <value>Основные свойства пакета.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о свойствах пакета core в разделе 3.1 в спецификации Open Packaging Conventions (OPC), можно загрузить в [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="T:System.Uri" /> of the part to check for.</param>
        <summary>Indicates whether a part with a given URI is in the package.</summary>
        <returns>
          <see langword="true" /> if a part with the specified <paramref name="partUri" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` Должно начинаться с косой черты «/» и представлять абсолютный путь от корня пакета.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only (information cannot be read).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to check for.</param>
        <summary>Indicates whether a package-level relationship with a given ID is contained in the package.</summary>
        <returns>
          <see langword="true" /> if a package-level relationship with the specified <paramref name="id" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), можно загрузить по адресу [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended for application use.  Use the type-safe <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> method instead.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>