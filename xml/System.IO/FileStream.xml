<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58f5a4e086d522af21fb819b0d4270088ef151f8" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36298990" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет <see cref="T:System.IO.Stream" /> в файле, поддерживая синхронные и асинхронные операции чтения и записи.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.FileStream> класса для чтения и записи, открытия и закрытия файлов в файловой системе и управлять других относящихся к файлам дескрипторов операционной системы, включая каналы, стандартный ввод и стандартные выходные данные. Можно использовать <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, и <xref:System.IO.FileStream.Flush%2A> методы для выполнения синхронных операций или <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A> методы для асинхронного выполнения операции. Используйте асинхронные методы для выполнения операций с файлами много ресурсов, не блокируя основной поток. Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает. <xref:System.IO.FileStream> Буферы ввода и вывода для лучшей производительности.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
 <xref:System.IO.FileStream.IsAsync%2A> Свойство определяет, является ли дескриптор был открыт асинхронно. Это значение указывается при создании экземпляра <xref:System.IO.FileStream> класса, используя конструктор, который имеет `isAsync`, `useAsync`, или `options` параметра. Если свойство не `true`, поток использует перекрывающегося ввода-вывода для асинхронного выполнения операций с файлами. Тем не менее <xref:System.IO.FileStream.IsAsync%2A> свойства не должен быть `true` для вызова <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, или <xref:System.IO.Stream.CopyToAsync%2A> метод. Когда <xref:System.IO.FileStream.IsAsync%2A> свойство `false` и вызова асинхронного чтения и записи операций, в поток пользовательского интерфейса не блокируется, но фактические операции ввода-вывода выполняется синхронно.  
  
 <xref:System.IO.FileStream.Seek%2A> Метод поддерживает произвольный доступ к файлам. <xref:System.IO.FileStream.Seek%2A> позволяет положение чтения или записи в любом месте внутри файла. Это делается с помощью байтов смещения параметров точки ссылки. Задается смещение в байтах относительно точки ссылки поиска, который может быть начало, текущая позиция или конец файла, три члена <xref:System.IO.SeekOrigin> перечисления.  
  
> [!NOTE]
>  Дисковые файлы всегда поддерживают произвольный доступ. Во время конструирования <xref:System.IO.FileStream.CanSeek%2A> имеет значение `true` или `false` в зависимости от базового типа файла. Если базовый тип файла равен FILE_TYPE_DISK, как определено в winbase.h <xref:System.IO.FileStream.CanSeek%2A> значение свойства `true`. В противном случае <xref:System.IO.FileStream.CanSeek%2A> значение свойства `false`.  
  
 Процесс завершается с частью файл заблокирован или закрывает файл с отложенными блокировками, поведение не определено.  
  
 Операции с каталогами и других операциях с файлами см. в разделе <xref:System.IO.File>, <xref:System.IO.Directory>, и <xref:System.IO.Path> классы. <xref:System.IO.File> Класс — это служебный класс, который содержит статические методы в первую очередь для создания <xref:System.IO.FileStream> объектов на основании путей к файлам. <xref:System.IO.MemoryStream> Класс создает поток из массива байтов и похож на <xref:System.IO.FileStream> класса.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Обнаружение изменений позиции потока  
 Если <xref:System.IO.FileStream> объект не имеет монопольно своим дескриптором, другой поток может одновременно обращаются к дескриптора файла и изменить положение указателя файла операционной системы, который связан с дескриптором файла. В этом случае кэшированное положение в <xref:System.IO.FileStream> объекта и кэшированные данные в буфер может быть нарушена. <xref:System.IO.FileStream> Объект обычно выполняет проверки для методов, обращающихся к кэшированному буферу, чтобы убедитесь, что положения дескриптора операционной системы таким же, как позицию кэшированного, используемые <xref:System.IO.FileStream> объекта.  
  
 Если в вызове обнаруживается непредвиденное изменение положения дескриптора <xref:System.IO.FileStream.Read%2A> , метод .NET Framework отменяет содержимое буфера и еще раз считывает поток из файла. Это может повлиять на производительность, в зависимости от размера файла и других процессов, которые могут повлиять на положение файлового потока.  
  
 Если в вызове обнаруживается непредвиденное изменение положения дескриптора <xref:System.IO.FileStream.Write%2A> метод содержимое буфера не учитываются и <xref:System.IO.IOException> исключения.  
  
 Объект <xref:System.IO.FileStream> объект не будет иметь монопольно своим дескриптором при либо <xref:System.IO.FileStream.SafeFileHandle%2A> доступ к свойству для предоставления дескриптора или <xref:System.IO.FileStream> объекту присваивается <xref:System.IO.FileStream.SafeFileHandle%2A> свойства в конструкторе.  
  
   
  
## Examples  
 В следующем примере демонстрируется часть <xref:System.IO.FileStream> конструкторы.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 В следующем примере показано, как асинхронно записывать в файл. Этот код выполняется в приложении WPF, которое имеет TextBlock с именем UserInput и кнопку Подключить к обработчик события Click, который называется Button_Click. Путь к файлу должно быть изменено в файле не завершает работу на компьютере.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор для файла, являющегося текущим объектом <see langword="FileStream" />, будет инкапсулирован.</param>
        <param name="access">Константа, которая задает свойства <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> для заданного дескриптора файла с указанными разрешениями на чтение и запись.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.IO.Stream.Close%2A> будет вызван, дескриптор также закрывается и уменьшается число дескрипторов файлов.  
  
 `FileStream` предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A> перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="access" /> не является полем <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного дескриптора файла, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а дескриптор файла установлен на доступ только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор для файла, являющегося текущим объектом <see langword="FileStream" />, будет инкапсулирован.</param>
        <param name="access">Константа, которая задает свойства <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> для заданного дескриптора файла с указанными разрешениями на чтение и запись.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.IO.Stream.Close%2A> будет вызван, дескриптор также закрывается и уменьшается число дескрипторов файлов.  
  
 `FileStream` предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A> перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="access" /> не является полем <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного дескриптора файла, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а дескриптор файла установлен на доступ только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see langword="FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> указанным путем и режимом создания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 Конструктор получает доступ на чтение и запись в файл, и он открыт общий доступ на чтение (то есть, запросы на открытие файла для записи от этого или другого процесса будут завершаться сбоем до `FileStream` был закрыт объект, но чтение будет успешно).  
  
 Этот конструктор не позволяет открывать файлы только для чтения; Вместо этого необходимо использовать конструктор, принимающий `FileAccess` параметр со значением, равным `FileAccess.Read`.  
  
 Размер буфера имеет значение по умолчанию размер 4096 байт (4 КБ).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
 Для конструкторов без <xref:System.IO.FileAccess> параметр, если `mode` параметра равным <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> доступ по умолчанию. В противном случае имеет значение доступ <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как записывать данные в файл, байт за байтом, и проверьте, правильно ли записаны данные.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор для файла, являющегося текущим объектом <see langword="FileStream" />, будет инкапсулирован.</param>
        <param name="access">Константа <see cref="T:System.IO.FileAccess" />, которая задает свойства <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> для заданного дескриптора файла, используя указанные разрешения на чтение и запись и размер буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A> перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора. Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="handle" /> является недействительным дескриптором.  -или-  Параметр <paramref name="handle" /> является синхронным дескриптором, но был использован асинхронно.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="bufferSize" /> является отрицательным.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного дескриптора файла, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а дескриптор файла установлен на доступ только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Связанные перечисления: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор для файла, являющегося текущим объектом <see langword="FileStream" />, будет инкапсулирован.</param>
        <param name="access">Константа, которая задает свойства <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />.</param>
        <param name="ownsHandle">Значение <see langword="true" />, если владельцем дескриптора файла будет этот экземпляр <see langword="FileStream" />; в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> для заданного дескриптора файла, используя указанные разрешения на чтение и запись и владельца экземпляра <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Объекту присваивается указанный доступ к файлу. Владение дескриптор может быть как указано. Если процесс владеет дескриптором, при вызове <xref:System.IO.Stream.Close%2A> метода также будет закрыт дескриптор и уменьшается значение счетчика дескриптора файла. `FileStream` Объекту присваивается размер буфера по умолчанию 4096 байт.  
  
 `FileStream` предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A> перед использованием дескриптора и избегать вызова методов не `Close` после завершения использования дескриптора.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="access" /> не является полем <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного дескриптора файла, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а дескриптор файла установлен на доступ только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see langword="FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <param name="access">Константа, определяющая способ доступа к файлу объекта <see langword="FileStream" />. Также определяет значения, возвращаемые свойствами <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />. Свойство <see cref="P:System.IO.FileStream.CanSeek" /> имеет значение <see langword="true" />, если параметр <c>path</c> задает файл на диске.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> заданным путем, режимом создания и разрешением на чтение и запись.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 Конструктор получает доступ на чтение и запись в файл, и он открыт общий доступ на чтение (то есть, запросы на открытие файла для записи от этого или другого процесса будут завершаться сбоем до `FileStream` был закрыт объект, но чтение будет успешно). Размер буфера имеет значение по умолчанию размер 4096 байт (4 КБ).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного <paramref name="path" />, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а файл или каталог установлены на доступ только для чтения.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор файла для файла, который будет инкапсулироваться с помощью объекта <see langword="FileStream" />.</param>
        <param name="access">Константа, которая задает свойства <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <param name="isAsync">Значение <see langword="true" />, если этот дескриптор был открыт асинхронно (т. е. в режиме перекрывающегося ввода-вывода); в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> для заданного дескриптора файла, используя указанные разрешения на чтение и запись, размер буфера и синхронное или асинхронное состояние.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задать `isAsync` параметр `true` для открытия дескриптора файла асинхронно. Если аргумент принимает значение `true`, поток использует перекрывающегося ввода-вывода для асинхронного выполнения операций с файлами. Тем не менее, параметр не обязательно должен быть `true` для вызова <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, или <xref:System.IO.Stream.CopyToAsync%2A> метод. Когда `isAsync` параметр `false` и вызова асинхронного чтения и записи операций, в поток пользовательского интерфейса не блокируется, но фактические операции ввода-вывода выполняется синхронно.  
  
 `FileStream` предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A> перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора. Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="handle" /> является недействительным дескриптором.  -или-  Параметр <paramref name="handle" /> является синхронным дескриптором, но был использован асинхронно.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="bufferSize" /> является отрицательным.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного дескриптора файла, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а дескриптор файла установлен на доступ только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода. Связанные перечисления: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор файла для файла, который будет инкапсулироваться с помощью объекта <see langword="FileStream" />.</param>
        <param name="access">Константа, которая задает свойства <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />.</param>
        <param name="ownsHandle">Значение <see langword="true" />, если владельцем дескриптора файла будет этот экземпляр <see langword="FileStream" />; в противном случае — <see langword="false" />.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> для заданного дескриптора файла, используя указанные разрешения на чтение и запись, владельца экземпляра <see langword="FileStream" /> и размер буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Объекту присваивается указанный доступ к файлу. Владение дескриптор может быть как указано. Если этот `FileStream` владеет дескриптором, при вызове <xref:System.IO.Stream.Close%2A> метода также будет закрыт дескриптор. В частности уменьшается количество дескрипторов файлов. `FileStream` Объекту присваивается заданный размер буфера.  
  
 `FileStream` предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A> перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора. Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> является отрицательным значением.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного дескриптора файла, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а дескриптор файла установлен на доступ только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see langword="FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <param name="access">Константа, определяющая способ доступа к файлу объекта <see langword="FileStream" />. Также определяет значения, возвращаемые свойствами <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />. Свойство <see cref="P:System.IO.FileStream.CanSeek" /> имеет значение <see langword="true" />, если параметр <c>path</c> задает файл на диске.</param>
        <param name="share">Константа, определяющая способ совместного использования файла процессами.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> заданным путем, режимом создания, разрешением на чтение и запись и разрешением на совместное использование.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 Конструктор получает доступ на чтение и запись в файл, и он открыт общий доступ на чтение (то есть, запросы на открытие файла для записи от этого или другого процесса будут завершаться сбоем до `FileStream` был закрыт объект, но чтение будет успешно). Размер буфера имеет значение по умолчанию размер 4096 байт (4 КБ).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.Lock%2A> метод.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Система работает под управлением Windows 98 или Windows 98 Second Edition, и для <paramref name="share" /> задано значение <see langword="FileShare.Delete" />.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного <paramref name="path" />, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а файл или каталог установлены на доступ только для чтения.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор файла для файла, который будет инкапсулироваться с помощью объекта <see langword="FileStream" />.</param>
        <param name="access">Константа, которая задает свойства <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />.</param>
        <param name="ownsHandle">Значение <see langword="true" />, если владельцем дескриптора файла будет этот экземпляр <see langword="FileStream" />; в противном случае — <see langword="false" />.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <param name="isAsync">Значение <see langword="true" />, если этот дескриптор был открыт асинхронно (т. е. в режиме перекрывающегося ввода-вывода); в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> для заданного дескриптора файла, используя указанные разрешения на чтение и запись, владельца экземпляра <see langword="FileStream" />, размер буфера и синхронное или асинхронное состояние.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` Объекту присваивается указанный доступ к файлу. Владение дескриптор может быть как указано. Если этот `FileStream` владеет дескриптором, при вызове <xref:System.IO.Stream.Close%2A> метода также будет закрыт дескриптор. В частности уменьшается количество дескрипторов файлов. `FileStream` Объекту присваивается заданный размер буфера.  
  
 `FileStream` предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A> перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора. Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.  
  
 `FileShare.Read` значение по умолчанию для тех, кто <xref:System.IO.FileStream> конструкторов без `FileShare` параметра.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="access" /> меньше чем <see langword="FileAccess.Read" /> или больше чем <see langword="FileAccess.ReadWrite" />, или параметр <paramref name="bufferSize" /> меньше или равен 0.</exception>
        <exception cref="T:System.ArgumentException">Дескриптор недействителен.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного дескриптора файла, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а дескриптор файла установлен на доступ только для чтения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для доступа к неуправляемому коду. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see langword="FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <param name="access">Константа, определяющая способ доступа к файлу объекта <see langword="FileStream" />. Также определяет значения, возвращаемые свойствами <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />. Свойство <see cref="P:System.IO.FileStream.CanSeek" /> имеет значение <see langword="true" />, если параметр <c>path</c> задает файл на диске.</param>
        <param name="share">Константа, определяющая способ совместного использования файла процессами.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> заданным путем, режимом создания, разрешениями на чтение и запись и на совместное использование, а также размером буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.  -или-  <paramref name="mode" />, <paramref name="access" /> или <paramref name="share" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Система работает под управлением Windows 98 или Windows 98 Second Edition, и для <paramref name="share" /> задано значение <see langword="FileShare.Delete" />.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного <paramref name="path" />, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а файл или каталог установлены на доступ только для чтения.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see langword="FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <param name="access">Константа, определяющая способ доступа к файлу объекта <see langword="FileStream" />. Также определяет значения, возвращаемые свойствами <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />. Свойство <see cref="P:System.IO.FileStream.CanSeek" /> имеет значение <see langword="true" />, если параметр <c>path</c> задает файл на диске.</param>
        <param name="share">Константа, определяющая способ совместного использования файла процессами.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию: 4096.</param>
        <param name="useAsync">Указывает, использовать ли асинхронный ввод-вывод или синхронный ввод-вывод. Однако обратите внимание, что базовая операционная система может не поддерживать асинхронный ввод-вывод, поэтому, когда задается значение <see langword="true" />, дескриптор может быть открыт синхронно в зависимости от платформы. При асинхронном открытии методы <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> и <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> выполняются лучше при чтении или записи больших объемов, но они могут работать намного медленнее при чтении или записи маленьких объемов данных. Если приложение разработано таким образом, чтобы получить преимущества асинхронного ввода-вывода, установите для параметра <c>useAsync</c> значение <see langword="true" />. При корректном использовании асинхронного ввода-вывода быстродействие приложения может возрасти вплоть до 10 раз, но использование такого режима ввода-вывода без переработки приложения может во столько же раз ухудшить быстродействие.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> заданным путем, режимом создания, разрешениями на чтение и запись и совместное использование, размером буфера и синхронным или асинхронным состоянием.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как асинхронно записывать данные в файл и убедитесь, что данные были записаны неправильно. Объект `State` объекта создается для передачи данных из основного потока в `EndReadCallback` и `EndWriteCallback` методы.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.  -или-  <paramref name="mode" />, <paramref name="access" /> или <paramref name="share" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Система работает под управлением Windows 98 или Windows 98 Second Edition, и для <paramref name="share" /> задано значение <see langword="FileShare.Delete" />.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного <paramref name="path" />, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а файл или каталог установлены на доступ только для чтения.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see langword="FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <param name="access">Константа, определяющая способ доступа к файлу объекта <see langword="FileStream" />. Также определяет значения, возвращаемые свойствами <see cref="P:System.IO.FileStream.CanRead" /> и <see cref="P:System.IO.FileStream.CanWrite" /> объекта <see langword="FileStream" />. Свойство <see cref="P:System.IO.FileStream.CanSeek" /> имеет значение <see langword="true" />, если параметр <c>path</c> задает файл на диске.</param>
        <param name="share">Константа, определяющая способ совместного использования файла процессами.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <param name="options">Значение, задающее дополнительные параметры файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> заданным путем, режимом создания, разрешениями на чтение, запись и совместное использование, доступом для других FileStreams к этому же файлу, размером буфера и дополнительными параметрами файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 `fileOptions` Параметр используется для предоставления доступа к более сложных операций, которые можно использовать при создании <xref:System.IO.FileStream> объекта.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере данные записываются в файл и затем считывает данные с помощью <xref:System.IO.FileStream> объекта.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.  -или-  <paramref name="mode" />, <paramref name="access" /> или <paramref name="share" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного <paramref name="path" />, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а файл или каталог установлены на доступ только для чтения.  -или-  Для <paramref name="options" /> указан режим <see cref="F:System.IO.FileOptions.Encrypted" />, но на текущей платформе шифрование файлов не поддерживается.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see cref="T:System.IO.FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <param name="rights">Константа, определяющая права доступа, используемые при создании правил доступа и аудита для файла.</param>
        <param name="share">Константа, определяющая способ совместного использования файла процессами.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <param name="options">Константа, задающая дополнительные параметры файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> заданным путем, режимом создания, разрешениями на чтение, запись и совместное использование, размером буфера и дополнительными параметрами файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 Этот метод следует использовать <xref:System.IO.FileStream.%23ctor%2A> правами конструктор, чтобы применить доступ во время создания файла. Для доступа или изменения прав на существующий файл, рассмотрите возможность использования <xref:System.IO.File.GetAccessControl%2A> и <xref:System.IO.File.SetAccessControl%2A> методы.  
  
 `fileOptions` Параметр используется для предоставления доступа к более сложных операций, которые можно использовать при создании <xref:System.IO.FileStream> объекта.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.  -или-  <paramref name="mode" />, <paramref name="access" /> или <paramref name="share" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версией.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного <paramref name="path" />, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а файл или каталог установлены на доступ только для чтения.  -или-  Для <paramref name="options" /> указан режим <see cref="F:System.IO.FileOptions.Encrypted" />, но на текущей платформе шифрование файлов не поддерживается.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный параметр <paramref name="path" />, имя файла или и то и другое превышает наибольшую возможную длину, определенную системой.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Абсолютный или относительный путь к файлу, который будет инкапсулироваться объектом <see cref="T:System.IO.FileStream" />.</param>
        <param name="mode">Константа, определяющая способ открытия или создания файла.</param>
        <param name="rights">Константа, определяющая права доступа, используемые при создании правил доступа и аудита для файла.</param>
        <param name="share">Константа, определяющая способ совместного использования файла процессами.</param>
        <param name="bufferSize">Положительное значение <see cref="T:System.Int32" />, большее 0, определяющее размер буфера. Размер буфера по умолчанию — 4096.</param>
        <param name="options">Константа, задающая дополнительные параметры файла.</param>
        <param name="fileSecurity">Константа, определяющая систему безопасности управления доступом и аудита доступа для файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileStream" /> заданными путем, режимом создания, правами на доступ и совместное использование, размером буфера, дополнительными параметрами файла, управлением доступом и аудитом безопасности.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа .NET Framework не поддерживает прямой доступ к физическим дискам по путям, которые являются именами устройств, таких как «\\\\. \PHYSICALDRIVE0».  
  
 Этот метод следует использовать <xref:System.IO.FileStream.%23ctor%2A> правами конструктор, чтобы применить доступ во время создания файла. Для доступа или изменения прав на существующий файл, рассмотрите возможность использования <xref:System.IO.File.GetAccessControl%2A> и <xref:System.IO.File.SetAccessControl%2A> методы.  
  
 `fileOptions` Параметр используется для предоставления доступа к более сложных операций, которые можно использовать при создании <xref:System.IO.FileStream> объекта.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
> [!NOTE]
>  `path` не обязательно должен быть файлом, хранящимся на диске; он может быть любой части системы, поддерживающей доступ через потоки. Например в зависимости от системы, этот класс имеет доступ к физическому устройству.  
  
 <xref:System.IO.Stream.CanSeek%2A> — `true` для всех <xref:System.IO.FileStream> объекты, которые инкапсулируют файлы. Если `path` указывает устройство, не поддерживает поиск, <xref:System.IO.FileStream.CanSeek%2A> в результате <xref:System.IO.FileStream> — `false`. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере данные записываются в файл и затем считывает данные с помощью <xref:System.IO.FileStream> объекта.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> представляет собой пустую строку (""), содержащую только пробел или хотя бы один недопустимый символ.  -или-  <paramref name="path" /> ссылается на устройство нефайлового типа, например "con:", "com1:", "lpt1:" и т. д., в среде NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> ссылается на устройство, которое не является файловым, например "con:", "com1:", "lpt1:" и т. д., в среде, отличной от NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="bufferSize" /> имеет отрицательное значение или равен нулю.  -или-  <paramref name="mode" />, <paramref name="access" /> или <paramref name="share" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Невозможно найти файл, например, когда <paramref name="mode" /> содержит <see langword="FileMode.Truncate" /> или <see langword="FileMode.Open" />, а файл, заданный в <paramref name="path" />, не существует. Файл должен уже существовать в этих режимах.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода, например, задано <see langword="FileMode.CreateNew" />, когда файл, указанный в <paramref name="path" />, уже существует.  -или-  Поток был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, ведущий на несопоставленный диск).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Запрошенный параметр <paramref name="access" /> не разрешен операционной системой для заданного <paramref name="path" />, например, когда параметр <paramref name="access" /> равен <see langword="Write" /> или <see langword="ReadWrite" />, а файл или каталог установлены на доступ только для чтения.  -или-  Для <paramref name="options" /> указан режим <see cref="F:System.IO.FileOptions.Encrypted" />, но на текущей платформе шифрование файлов не поддерживается.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный параметр <paramref name="path" />, имя файла или и то и другое превышает наибольшую возможную длину, определенную системой.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версией.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения, записи и добавления в файлы. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, и <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Буфер, в который должны считываться данные.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Смещение в <c>array</c> (в байтах), с которого начинается чтение.</param>
        <param name="numBytes">Максимальное число байтов, предназначенных для чтения.</param>
        <param name="count">To be added.</param>
        <param name="userCallback">Метод, вызываемый после завершения операции асинхронного чтения.</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на асинхронное чтение от других запросов.</param>
        <param name="state">To be added.</param>
        <summary>Начинает операцию асинхронного чтения. (Рекомендуется использовать <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Объект, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.FileStream.BeginRead%2A> и <xref:System.IO.FileStream.EndRead%2A> для реализации асинхронных операций. Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.  
  
 <xref:System.IO.FileStream.EndRead%2A> должен вызываться ровно по одному разу для каждого вызова <xref:System.IO.FileStream.BeginRead%2A>. Невозможность закончить процесс чтения до начала другой операции чтения может привести к нежелательным поведению, например взаимоблокировки.  
  
 <xref:System.IO.FileStream> предоставляет два различных режима работы: синхронный ввод-вывод и асинхронный ввод-вывод. Хотя может быть использована любая, основные ресурсы операционной системы могут разрешать доступ только в одном из следующих режимов. По умолчанию <xref:System.IO.FileStream> открывает дескриптор операционной системы синхронно. В Windows это замедляет асинхронные методы. Если применяются асинхронные методы, используйте <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
> [!NOTE]
>  Используйте <xref:System.IO.FileStream.CanRead%2A> свойство, чтобы определить, поддерживает ли текущий экземпляр чтение. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanRead%2A>.  
  
 Если поток закрыт или передается неверный аргумент, исключения создаются немедленно из <xref:System.IO.FileStream.BeginRead%2A>. Ошибки, возникающие при запросе асинхронного чтения, например ошибка диска в процессе запроса ввода-ВЫВОДА, возникают в потоке пула потоков и отображаются при вызове <xref:System.IO.FileStream.EndRead%2A>.  
  
 <xref:System.IO.Stream.EndRead%2A> должен вызываться с этим <xref:System.IAsyncResult> чтобы узнать, сколько байтов прочитано.  
  
 Несколько одновременных асинхронных запросов отрисовки неопределенное порядок выполнения запроса.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина массива минус <paramref name="offset" /> меньше <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> или <paramref name="numBytes" /> является отрицательным значением.</exception>
        <exception cref="T:System.IO.IOException">Предпринята попытка асинхронного чтения за пределами файла.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Буфер, содержащий данные для записи в текущий поток.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Отсчитываемое от нуля смещение байтов в буфере <c>array</c>, с которого начинается копирование байтов в текущий поток.</param>
        <param name="numBytes">Максимальное число байтов для записи.</param>
        <param name="count">To be added.</param>
        <param name="userCallback">Метод, вызываемый после завершения операции асинхронной записи.</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного запроса на асинхронную запись от других запросов.</param>
        <param name="state">To be added.</param>
        <summary>Начинает операцию асинхронной записи. (Рекомендуется использовать <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Объект, который ссылается на асинхронную запись.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.FileStream.BeginWrite%2A> и <xref:System.IO.FileStream.EndWrite%2A> для реализации асинхронных операций. Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.  
  
 <xref:System.IO.FileStream.EndWrite%2A> должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult> из <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> будет заблокирован до завершения операции ввода-вывода.  
  
 Этот метод переопределяет метод <xref:System.IO.Stream.BeginWrite%2A>.  
  
 <xref:System.IO.FileStream> предоставляет два различных режима работы: синхронный ввод-вывод и асинхронный ввод-вывод. Хотя может быть использована любая, основные ресурсы операционной системы могут разрешать доступ только в одном из следующих режимов. По умолчанию <xref:System.IO.FileStream> открывает дескриптор операционной системы синхронно. В Windows это замедляет асинхронные методы. Если применяются асинхронные методы, используйте <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
 Если поток закрыт или передается неверный аргумент, исключения создаются немедленно из <xref:System.IO.FileStream.BeginWrite%2A>. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-ВЫВОДА, возникают в потоке пула потоков и отображаются при вызове <xref:System.IO.FileStream.EndWrite%2A>.  
  
 Несколько одновременных асинхронных запросов отрисовки неопределенное порядок выполнения запроса.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина <paramref name="array" /> минус <paramref name="offset" /> меньше <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> или <paramref name="numBytes" /> является отрицательным значением.</exception>
        <exception cref="T:System.NotSupportedException">Поток не поддерживает запись.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток закрыт.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее в текущем потоке наличие поддержки операций чтения.</summary>
        <value>Значение <see langword="true" />, если в потоке поддерживаются операции чтения; значение <see langword="false" />, если поток закрыт или открыт только для записи.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если класс, производный от <xref:System.IO.Stream> не поддерживает чтение, при вызове <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, и <xref:System.IO.FileStream.BeginRead%2A> методы создают исключение <xref:System.NotSupportedException>.  
  
 Если поток закрыт, это свойство возвращает `false`.  
  
   
  
## Examples  
 В следующем примере показано использование `CanRead` свойство. Результат выполнения этого кода является «MyFile.txt недоступен для записи.» Для получения выходного сообщения «MyFile.txt допускает и записи и чтения из.», измените `FileAccess` параметр `ReadWrite` в `FileStream` конструктора.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее в текущем потоке наличие поддержки операций поиска.</summary>
        <value>Значение <see langword="true" />, если поток поддерживает поиск; значение <see langword="false" />, если поток закрыт или если <see langword="FileStream" /> был сконструирован из дескриптора операционной системы, такого как канал или вывод на консоль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если класс, производный от <xref:System.IO.Stream> не поддерживает поиск, при вызове <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, и <xref:System.IO.FileStream.Seek%2A> throw <xref:System.NotSupportedException>.  
  
 Если поток закрыт, это свойство возвращает `false`.  
  
   
  
## Examples  
 В следующем примере используется `CanSeek` свойство, чтобы проверить, поддерживает ли поток поиск.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее в текущем потоке наличие поддержки операций записи.</summary>
        <value>Значение <see langword="true" />, если поток поддерживает операции записи; значение <see langword="false" />, если поток закрыт или открыт только для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если класс, производный от <xref:System.IO.Stream> не поддерживает запись, при вызове <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, или <xref:System.IO.FileStream.WriteByte%2A> вызывает <xref:System.NotSupportedException>.  
  
 Если поток закрыт, это свойство возвращает `false`.  
  
   
  
## Examples  
 В следующем примере используется `CanWrite` свойство, чтобы проверить, поддерживает ли поток операции записи.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Ниже приведен пример с использованием `CanWrite` свойство. Результат выполнения этого кода выглядит «MyFile.txt для записи». Для получения выходного сообщения «MyFile.txt допускает и записи и чтения из.», измените `FileAccess` параметр `ReadWrite` в `FileStream` конструктора.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.IO.FileStream" />, а при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом открытые <xref:System.ComponentModel.Component.Dispose%2A> метод и <xref:System.Object.Finalize%2A> метод. <xref:System.ComponentModel.Component.Dispose%2A> вызывает защищенный <xref:System.IO.FileStream.Dispose%2A> метод с `disposing` равным `true`. <xref:System.Object.Finalize%2A> вызывает <xref:System.IO.FileStream.Dispose%2A> с `disposing` значение `false`.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.IO.FileStream>. Этот метод вызывает метод <xref:System.ComponentModel.Component.Dispose%2A> каждого объекта, на который есть ссылка.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see cref="M:System.ComponentModel.Component.Dispose" />. Дополнительные сведения о реализации <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, в разделе [реализация Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Дополнительные сведения о <see cref="M:System.ComponentModel.Component.Dispose" /> и <see cref="M:System.Object.Finalize" />, в разделе [Очистка Resources](~/docs/standard/garbage-collection/unmanaged.md) копирование неуправляемым.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ссылка на ожидаемый отложенный асинхронный запрос.</param>
        <summary>Ожидает завершения отложенной асинхронной операции чтения. (Рекомендуется использовать <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Число байтов, считанных из потока, находится между 0 и числом запрошенных байтов. Потоки возвращают 0 только в конце потока, в противном случае они должны блокироваться, пока не будет доступен по крайней мере 1 байт.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.FileStream.BeginRead%2A> и <xref:System.IO.FileStream.EndRead%2A> для реализации асинхронных операций. Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.  
  
 <xref:System.IO.FileStream.EndRead%2A> должен вызываться ровно при каждом вызове <xref:System.IO.FileStream.BeginRead%2A>. Невозможность закончить процесс чтения до начала другой операции чтения может привести к нежелательным поведению, например взаимоблокировки.  
  
 Этот метод переопределяет метод <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> может вызываться для каждого <xref:System.IAsyncResult> из <xref:System.IO.FileStream.BeginRead%2A>. Вызов <xref:System.IO.FileStream.EndRead%2A> сообщает, сколько байтов, считанных из потока. <xref:System.IO.FileStream.EndRead%2A> будет заблокирован до завершения операции ввода-вывода.  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Этот объект <see cref="T:System.IAsyncResult" /> не был создан путем вызова <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> для данного класса.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> вызывается несколько раз.</exception>
        <exception cref="T:System.IO.IOException">Поток закрыт, или произошла внутренняя ошибка.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Отложенный асинхронный запрос ввода-вывода.</param>
        <summary>Завершает асинхронную операцию записи и блокирует до тех пор, пока не будет завершена операция ввода-вывода. (Рекомендуется использовать <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.FileStream.BeginWrite%2A> и <xref:System.IO.FileStream.EndWrite%2A> для реализации асинхронных операций. Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/includes/net-v45-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.  
  
 Этот метод переопределяет метод <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult> из <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> будет заблокирован до завершения операции ввода-вывода.  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Этот объект <see cref="T:System.IAsyncResult" /> не был создан путем вызова <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> для данного класса.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> вызывается несколько раз.</exception>
        <exception cref="T:System.IO.IOException">Поток закрыт, или произошла внутренняя ошибка.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Гарантирует, что ресурсы освобождены и выполнены другие операции очистки, когда сборщик мусора восстанавливает <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборщик мусора вызывает `Finalize` когда текущий объект готов к завершению. `Finalize` закрывает `FileStream`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Очищает буферы для этого потока и вызывает запись всех буферизованных данных в файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает буферы для этого потока и вызывает запись всех буферизованных данных в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 При вызове <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> метод буфер операционной системы ввода-вывода также сбрасывается.  
  
 Кодировщик потока не сбрасывается, если только явным образом вызвать <xref:System.IO.FileStream.Flush%2A> или удаления объекта. Установка <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> для `true` означает, что данные будут сброшены из буфера в поток, но состояние кодировщика при этом не сбрасывается. Это позволяет кодировщику сохранить свое состояние (частичные символы), чтобы правильно выполнить кодировку следующего блока знаков. Этот сценарий влияет на кодировки UTF8 и UTF7, в которых определенные символы кодируются только после кодировщик получает соседние знаки.  
  
 Поскольку буфер можно использовать для чтения или записи, <xref:System.IO.FileStream.Flush> выполняет следующие две функции:  
  
-   Все данные, записанные ранее в буфер копируется в файл и буфер удаляется за исключением состояния кодировщика.  
  
-   Если <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> — `true` и данные ранее были скопированы из файла в буфер для чтения, текущее положение в файле уменьшается количество непрочитанных байтов в буфере. Буфер, затем удаляется.  
  
 Используйте <xref:System.IO.FileStream.Flush%28System.Boolean%29> перегрузка метода, если вы хотите убедиться, что все буферизованные данные в буферах промежуточный файл записывается на диск.  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.Lock%2A> метод.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток закрыт.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">Значение <see langword="true" /> для записи на диск  буферов всех промежуточных файлов; в противном случае — значение <see langword="false" />.</param>
        <summary>Очищает буферы для этого потока и вызывает запись всех буферизованных данных в файл, а также очищает все буферы промежуточных файлов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, когда вы хотите убедиться, что все буферизованные данные в буферах промежуточный файл записывается на диск.  
  
 При вызове <xref:System.IO.FileStream.Flush%2A> метод буфер операционной системы ввода-вывода также сбрасывается.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Токен для отслеживания запросов отмены.</param>
        <summary>Асинхронно очищает все буферы данного потока, вызывает запись буферизованных данных в базовое устройство и отслеживает запросы отмены.</summary>
        <returns>Задача, представляющая асинхронную операцию очистки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.IO.FileStream.FlushAsync%2A> метод буфер операционной системы ввода-вывода также сбрасывается.  
  
 Если операция отменена до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> свойства. При удалении дескриптора файла, возвращенная задача содержит <xref:System.ObjectDisposedException> исключение в <xref:System.Threading.Tasks.Task.Exception%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Поток был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Security.AccessControl.FileSecurity" />, который инкапсулирует записи списка управления доступом (ACL) для файла, описываемого текущим объектом <see cref="T:System.IO.FileStream" />.</summary>
        <returns>Объект, инкапсулирующий параметры управления доступом для файла, который описывается текущим объектом <see cref="T:System.IO.FileStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Хотя <xref:System.IO.FileStream> класса и <xref:System.IO.FileStream.GetAccessControl%2A> можно использовать для извлечения записи списка управления Доступом к существующему файлу, рассмотрите возможность использования <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> метода, как он проще в использовании.  
  
 Используйте <xref:System.IO.FileStream.GetAccessControl%2A> метод для извлечения записей списка управления Доступом для файла.  
  
 В ACL определяются пользователи и группы, имеющие или не имеющие права на выполнение определенных действий с данным файлом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Файл закрыт.</exception>
        <exception cref="T:System.IO.IOException">При открытии файла произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.SystemException">Не удалось найти файл.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Эта операция не поддерживается на текущей платформе.  -или- У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор файла операционной системы для файла, инкапсулируемого текущим объектом <see langword="FileStream" />.</summary>
        <value>Дескриптор файла операционной системы для файла, инкапсулируемого этим объектом <see langword="FileStream" />, или значение -1, если объект <see langword="FileStream" /> закрыт.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство представляет собой дескриптор операционной системы для использования с вызовами, предоставляемых операционной системой (например, `ReadFile` в Windows). Он не будет работать с помощью функции библиотеки C, в которых предполагается, что дескриптор файла, например `fread`.  
  
 Дескриптор операционной системы может быть открыт синхронно или асинхронно, в зависимости от того, что `FileStream` конструктор уже вызывался. Используйте <xref:System.IO.FileStream.IsAsync%2A> свойство для определения, является ли этот дескриптор был открыт асинхронно. В Win32, это означает этот дескриптор был открыт для перекрывающегося ввода-ВЫВОДА и требует другие параметры для `ReadFile` и `WriteFile`.  
  
> [!CAUTION]
>  Может произойти повреждение данных, если `FileStream` будет создан, его дескриптор был передан, некоторые операции указатель дескриптор файла, а затем `FileStream` снова используется. Несколько потоков не могут записывать в тот же файл одновременно, и `FileStream` буферизации кода предполагается, что исключительно управляет дескриптор. `FileStream` может вызывать <xref:System.IO.IOException> Если `FileStream` обнаруживает, что некоторые другой процесс переместил указатель файла. Чтобы избежать этого, не записывайте данные в части файла, `FileStream` может буферизировать и восстанавливайте указатель файла в папку, он находился перед последним вызовом методов на `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности доступа к неуправляемому коду. Соответствующее перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, как был открыт объект <see langword="FileStream" />: синхронно или асинхронно.</summary>
        <value>Значение <see langword="true" />, если <see langword="FileStream" /> был открыт асинхронно, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsAsync` Обнаруживает свойство ли `FileStream` дескриптор был открыт асинхронно, позволяя вашему коду использовать <xref:System.IO.FileStream.Handle%2A> свойство правильно. В Win32 `IsAsync` , значение true означает дескриптор был открыт для перекрывающегося ввода-вывода и поэтому требует другие параметры для `ReadFile` и `WriteFile`.  
  
 Это значение указывается при создании экземпляра <xref:System.IO.FileStream> класса, используя конструктор, который имеет `isAsync`, `useAsync`, или `options` параметра. Если свойство не `true`, поток использует перекрывающегося ввода-вывода для асинхронного выполнения операций с файлами. Тем не менее <xref:System.IO.FileStream.IsAsync%2A> свойства не должен быть `true` для вызова <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, или <xref:System.IO.Stream.CopyToAsync%2A> метод. Когда <xref:System.IO.FileStream.IsAsync%2A> свойство `false` и вызова асинхронного чтения и записи операций, в поток пользовательского интерфейса не блокируется, но фактические операции ввода-вывода выполняется синхронно.  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает длину потока в байтах.</summary>
        <value>Длинное значение, представляющее длину потока в байтах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере используется `Length` и `Position` свойства, чтобы проверить условие конечного файла.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.FileStream.CanSeek" /> для этого потока имеет значение <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, файл закрывается).</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Начало диапазона для блокировки. Значение этого параметра должно быть больше или равно нулю (0).</param>
        <param name="length">Диапазон, который нужно блокировать.</param>
        <summary>Запрещает другим процессам чтение объекта <see cref="T:System.IO.FileStream" /> и запись в этот объект.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Блокировка диапазона файлового потока предоставляет потокам блокировки монопольный доступ к процессу для этого диапазона файлового потока.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как заблокировать часть файла, поэтому другой процесс не может получить доступ к этой части файла даже при наличии доступа на чтение и запись в файл. Запустите программу одновременно в нескольких окнах команд и попробуйте использовать различные параметры ввода консоли.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> или <paramref name="length" /> является отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Файл закрыт.</exception>
        <exception cref="T:System.IO.IOException">Процессу не удается получить доступ к файлу, так как другой процесс заблокировал часть этого файла.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя объекта <see langword="FileStream" />, которое было передано в конструктор.</summary>
        <value>Строка, содержащая имя объекта <see langword="FileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> конструктор.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текущую позицию этого потока.</summary>
        <value>Текущая позиция потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поддерживается поиск в любом месте за пределами длины потока.  При выполнении поиска за пределами файла, размер файла увеличивается.  В Microsoft Windows NT и более новые данные, добавленные в конец файла равен нулю.  В Microsoft Windows 98 или более ранней версии данные, добавленные в конец файла не равно нулю, это означает, что ранее удаленные данных отображается в поток. Установка позицию в потоке большое значение за пределами конца потока в Windows 98 или более ранней версии может привести к созданию исключения.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере используется `Length` и `Position` свойства, чтобы проверить условие конечного файла.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Поток не поддерживает поиск.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.  \- или -  Для положения задано очень большое значение за пределами конца потока в Windows 98 или более ранней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Попытка установить для положения отрицательное значение.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Попытка поиска за пределами потока, который не поддерживает это.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">После завершения выполнения данного метода буфер содержит указанный массив байтов, в котором значения в интервале между <c>offset</c> и (<c>offset</c> + <c>count</c> – 1<c>)</c> заменены байтами, считанными из текущего источника.</param>
        <param name="offset">Смещение в байтах в массиве <c>array</c>, в который считанные байты будут помещены.</param>
        <param name="count">Максимальное число байтов, предназначенных для чтения.</param>
        <summary>Выполняет чтение блока байтов из потока и запись данных в заданный буфер.</summary>
        <returns>Общее количество байтов, считанных в буфер. Оно может быть меньше запрошенного числа байтов, если в настоящее время не имеется нужного количества байтов, или же равно нулю, если достигнут конец потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.Stream.Read%2A>.  
  
 `offset` Дает смещение байтов в `array` (индекс буфера) с которого начинается чтение и `count` дает максимальное число байтов, считанное из текущего потока. Возвращаемое значение является фактическое число считанных байтов, или нуль, если достигнут конец потока. При успешном выполнении операции чтения текущую позицию в потоке увеличивается на число считанных байтов. При возникновении исключения в текущей позиции потока не изменяется.  
  
 <xref:System.IO.FileStream.Read%2A> Метод возвращает нуль только по достижении конца потока. В противном случае <xref:System.IO.FileStream.Read%2A> всегда считывает хотя бы один байт из потока перед возвратом. Если данные недоступны в потоке при вызове <xref:System.IO.FileStream.Read%2A>, метод будет блокироваться, пока не могут быть возвращены хотя бы один байт данных. Реализация может вернуть меньше байтов, чем было запрошено, даже если не достигнут конец потока.  
  
 Используйте <xref:System.IO.BinaryReader> для чтения простых типов данных.  
  
 Не прерывайте потоков, который выполняет операции чтения. Несмотря на то, что приложение может возникнуть, для успешного выполнения после поток не заблокирован, прерывания может привести к снижению производительности и надежности приложения.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере считывается содержимое из <xref:System.IO.FileStream> и записывает его на другой <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.NotSupportedException">Поток не поддерживает чтение.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> и <paramref name="count" /> определяют неверный диапазон в <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Методы были вызваны после закрытия потока.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который записываются данные.</param>
        <param name="offset">Смещение байтов в <c>buffer</c>, с которого начинается запись данных, считанных из потока.</param>
        <param name="count">Максимальное число байтов, предназначенных для чтения.</param>
        <param name="cancellationToken">Токен для отслеживания запросов отмены.</param>
        <summary>Асинхронно считывает последовательность байтов из текущего потока, перемещает позицию в потоке на число считанных байтов и отслеживает запросы отмены.</summary>
        <returns>Задача, представляющая асинхронную операцию чтения. Значение параметра <paramref name="TResult" /> содержит общее число байтов, считанных в буфер. Значение результата может быть меньше запрошенного числа байтов, если число доступных в данный момент байтов меньше запрошенного числа, или результат может быть равен 0 (нулю), если был достигнут конец потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.ReadAsync%2A> Метод позволяет выполнять операции с файлами много ресурсов, не блокируя основной поток. Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает. Асинхронные методы используются в сочетании с `async` и `await` ключевые слова в Visual Basic и C#.  
  
 Используйте <xref:System.IO.FileStream.CanRead%2A> свойство, чтобы определить, поддерживает ли текущий экземпляр чтение.  
  
 Если операция отменена до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> свойства. При удалении дескриптора файла, возвращенная задача содержит <xref:System.ObjectDisposedException> исключение в <xref:System.Threading.Tasks.Task.Exception%2A> свойство.  
  
   
  
## Examples  
 В следующем примере показано, как для асинхронного чтения из файла.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException">Сумма <paramref name="offset" /> и <paramref name="count" /> больше, чем длина буфера.</exception>
        <exception cref="T:System.NotSupportedException">Поток не поддерживает чтение.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток был удален.</exception>
        <exception cref="T:System.InvalidOperationException">Поток в настоящее время используется предыдущей операцией чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает байт из файла и перемещает положение чтения на один байт.</summary>
        <returns>Байт приводится к типу <see cref="T:System.Int32" /> или -1, если достигнут конец потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Используйте <xref:System.IO.FileStream.CanRead%2A> свойство, чтобы определить, поддерживает ли текущий экземпляр чтение. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как записывать данные в файл, байт за байтом, и проверьте, правильно ли записаны данные.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текущий поток не поддерживает чтение.</exception>
        <exception cref="T:System.ObjectDisposedException">Текущий поток закрыт.</exception>
        <block subset="none" type="overrides">
          <para>Реализация по умолчанию в <see langword="Stream" /> создает новый однобайтовый массив и вызывает <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Это формально верно, но неэффективно. Любой поток с внутренним буфером следует переопределить этот метод и предоставить гораздо более эффективную версию, которая непосредственного чтения буфера, как избежать дополнительное размещение массива при каждом вызове.  Список общих файлов и операций с каталогами в разделе [Общие Tasks](~/docs/standard/io/common-i-o-tasks.md) ввода-вывода.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />, представляющий дескриптор файла операционной системы для файла, инкапсулируемого текущим объектом <see cref="T:System.IO.FileStream" />.</summary>
        <value>Объект, представляющий дескриптор файла операционной системы для файла, инкапсулируемого текущим объектом <see cref="T:System.IO.FileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.SafeFileHandle%2A> Свойство автоматически выполняет очистку потока и задает позицию в текущем потоке 0.  Это позволяет переместить файл или позицию в потоке, чтобы сбросить с помощью другого потока <xref:System.IO.FileStream.SafeFileHandle%2A> возвращенный этим свойством.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения на вызов неуправляемого кода.  Действие по обеспечению безопасности: перечисление связанных запросу ссылку: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Указатель относительно начальной точки <c>origin</c>, от которой начинается поиск.</param>
        <param name="origin">Описывает начальную, конечную или текущую позицию как опорную точку для <c>offset</c>, используя значение типа <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Устанавливает текущее положение этого потока на заданное значение.</summary>
        <returns>Новая позиция в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Используйте <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> свойство, чтобы определить, поддерживает ли текущий экземпляр поиск. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Поиск возможен в любом месте за пределами длины потока. При выполнении поиска за пределами файла, размер файла увеличивается. В Windows NT и более поздних версиях данные, добавленные в конец файла равен нулю. В Windows 98 или более ранних версий данные, добавленные в конец файла не равен нулю, это означает, что ранее удаленные данных отображается в поток.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано, как записывать данные в файл, байт за байтом, и убедитесь, что данные были записаны неправильно.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 В следующем примере считывается текст в обратном направлении от конца файла к началу файла, с помощью различных <xref:System.IO.SeekOrigin> значения <xref:System.IO.FileStream.Seek%2A> метод.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.NotSupportedException">Данный поток не поддерживает поиск, например, если <see langword="FileStream" /> сконструирован из канала или выхода консоли.</exception>
        <exception cref="T:System.ArgumentException">Попытка поиска выполняется до начала потока.</exception>
        <exception cref="T:System.ObjectDisposedException">Методы были вызваны после закрытия потока.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Объект, который описывает запись ACL, применяемую к текущему файлу.</param>
        <summary>Применяет записи списка управления доступом (ACL), описанные объектом <see cref="T:System.Security.AccessControl.FileSecurity" />, к файлу, который описывается текущим объектом <see cref="T:System.IO.FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Хотя <xref:System.IO.FileStream> класса и <xref:System.IO.FileStream.SetAccessControl%2A> могут быть использованы для существующего файла, рассмотрите возможность использования <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> метода, проще в использовании.  
  
 <xref:System.IO.FileStream.SetAccessControl%2A> Метод применяет записи списка управления Доступом в файл, представляющий noninherited список ACL.  
  
> [!CAUTION]
>  Указанный список управления Доступом для `fileSecurity` параметра заменяет существующий список ACL для файла. Чтобы добавить разрешения для нового пользователя, используйте <xref:System.IO.FileStream.GetAccessControl%2A> метод, чтобы получить существующий список ACL, изменить его и затем использовать <xref:System.IO.FileStream.SetAccessControl%2A> для применения их в файл.  
  
 В ACL определяются пользователи и группы, имеющие или не имеющие права на выполнение определенных действий с данным файлом. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Файл закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="fileSecurity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Не удалось найти или изменить файл.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий процесс не может открыть файл из-за отсутствия соответствующих прав доступа.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Новая длина потока.</param>
        <summary>Устанавливает длину этого потока на заданное значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.Stream.SetLength%2A>.  
  
 Если заданное значение меньше текущей длины потока, поток сокращается. В этом случае если текущая позиция превышает новую длину текущую позицию перемещается до получения последнего байта потока. Если заданное значение больше текущей длины потока, поток расширяется, и текущая позиция не меняется. Если поток расширяется, содержимое потока между старой и новой длиной не определено.  
  
 Поток должен поддерживать запись и поиск для `SetLength` для работы.  
  
> [!NOTE]
>  Используйте <xref:System.IO.FileStream.CanWrite%2A> свойства, чтобы определить, поддерживает ли текущий экземпляр запись и <xref:System.IO.FileStream.CanSeek%2A> свойства, чтобы определить, поддерживается ли поиск. Дополнительные сведения см. в разделах <xref:System.IO.Stream.CanWrite%2A> и <xref:System.IO.Stream.CanSeek%2A>.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.NotSupportedException">Поток не поддерживает запись и поиск.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Сделана попытка установить значение параметра <paramref name="value" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Начало диапазона, который должен быть разблокирован.</param>
        <param name="length">Диапазон, который должен быть разблокирован.</param>
        <summary>Разрешает доступ других процессов ко всему ранее заблокированному файлу или его части.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как заблокировать часть файла, поэтому другой процесс не может получить доступ к этой части файла, даже при наличии доступа на чтение и запись в файл и затем разблокировать указанную часть файла. Запустите программу одновременно в нескольких окнах команд и попробуйте использовать различные параметры ввода консоли.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> или <paramref name="length" /> является отрицательным значением.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Буфер, содержащий данные для записи в поток.</param>
        <param name="offset">Смещение байтов (начиная с нуля) в <c>array</c>, с которого начинается копирование байтов в поток.</param>
        <param name="count">Максимальное число байтов для записи.</param>
        <summary>Записывает блок байтов в файловый поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.Stream.Write%2A>.  
  
 `offset` Дает смещение байтов в `array` (индекс буфера) с которого начинается копирование и `count` дает число байтов, которые будут записаны в поток. При успешном выполнении операции записи в текущей позиции потока увеличивается на число записанных байтов. При возникновении исключения в текущей позиции потока не изменяется.  
  
> [!NOTE]
>  Используйте <xref:System.IO.FileStream.CanWrite%2A> свойство, чтобы определить, поддерживает ли текущий экземпляр запись. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanWrite%2A>.  
  
 Не прерывайте потоков, который выполняет операцию записи. Несмотря на то, что приложение может возникнуть, для успешного выполнения после поток не заблокирован, прерывания может привести к снижению производительности и надежности приложения.  
  
 Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Данный пример кода является частью большего примера, приведенного для <xref:System.IO.FileStream.Lock%2A> метод.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="array" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> и <paramref name="count" /> определяют неверный диапазон в <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.  \- или-  Возможно, другой поток вызвал непредвиденное изменение положения дескриптора файла операционной системы.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Текущий экземпляр потока не поддерживает запись.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, из которого записываются данные.</param>
        <param name="offset">Смещение байтов (начиная с нуля) в <c>buffer</c>, с которого начинается копирование байтов в поток.</param>
        <param name="count">Максимальное число байтов для записи.</param>
        <param name="cancellationToken">Токен для отслеживания запросов отмены.</param>
        <summary>Асинхронно записывает последовательность байтов в текущий поток, перемещает текущую позицию внутри потока на число записанных байтов и отслеживает запросы отмены.</summary>
        <returns>Задача, представляющая асинхронную операцию записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.WriteAsync%2A> Метод позволяет выполнять операции с файлами много ресурсов, не блокируя основной поток. Это соображение, связанное с производительностью, особенно важно в приложениях [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] и [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что приложение не работает. Асинхронные методы используются в сочетании с `async` и `await` ключевые слова в Visual Basic и C#.  
  
 Используйте <xref:System.IO.FileStream.CanWrite%2A> свойство, чтобы определить, поддерживает ли текущий экземпляр запись.  
  
 Если операция отменена до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus.Canceled> значение <xref:System.Threading.Tasks.Task.Status%2A> свойства. При удалении дескриптора файла, возвращенная задача содержит <xref:System.ObjectDisposedException> исключение в <xref:System.Threading.Tasks.Task.Exception%2A> свойство.  
  
   
  
## Examples  
 В следующем примере показано, как асинхронно записывать в файл.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException">Сумма <paramref name="offset" /> и <paramref name="count" /> больше, чем длина буфера.</exception>
        <exception cref="T:System.NotSupportedException">Поток не поддерживает запись.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток был удален.</exception>
        <exception cref="T:System.InvalidOperationException">Поток в настоящее время используется предыдущей операцией записи.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Байт, который необходимо записать в поток.</param>
        <summary>Запись байта в текущую позицию в потоке файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.Stream.WriteByte%2A>.  
  
 Используйте `WriteByte` для записи байта `FileStream` эффективно. Если поток закрыт или защищен от записи, будет создано исключение.  
  
> [!NOTE]
>  Используйте <xref:System.IO.FileStream.CanWrite%2A> свойство, чтобы определить, поддерживает ли текущий экземпляр запись. Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как записывать данные в файл, байт за байтом, и проверьте, правильно ли записаны данные.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Поток закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Поток не поддерживает запись.</exception>
        <block subset="none" type="overrides">
          <para>Реализация по умолчанию в <see langword="Stream" /> создает новый однобайтовый массив и вызывает <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Это формально верно, но неэффективно. Любой поток с внутренним буфером следует переопределить этот метод и предоставить гораздо более эффективную версию, которая непосредственного чтения буфера, как избежать дополнительное размещение массива при каждом вызове.  Список общих файлов и операций с каталогами в разделе [Общие Tasks](~/docs/standard/io/common-i-o-tasks.md) ввода-вывода.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>