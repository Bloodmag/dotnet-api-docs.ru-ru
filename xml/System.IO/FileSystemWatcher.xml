<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f524b1e2438cea1c3c824aa9514a36244ccff373" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420558" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ожидает уведомления файловой системы об изменениях и инициирует события при изменениях каталога или файла в каталоге.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.FileSystemWatcher> для отслеживания изменений в указанном каталоге. Вы можете отслеживать изменения в файлы и подкаталоги в указанном каталоге. Можно создать компонент, чтобы следить за файлами на локальном компьютере, на сетевом диске или удаленном компьютере.  
  
 Для отслеживания изменений во всех файлах, установите <xref:System.IO.FileSystemWatcher.Filter%2A> свойства равным пустой строке ("») или используйте подстановочные знаки (» *.\*»). Для отслеживания определенного файла установите <xref:System.IO.FileSystemWatcher.Filter%2A> свойство имени файла. Например, для отслеживания изменений в файле MyDoc.txt, установите <xref:System.IO.FileSystemWatcher.Filter%2A> свойства «MyDoc.txt». Также можно отслеживать изменения в файлах определенного типа. Например, для отслеживания изменений в текстовых файлах, задать <xref:System.IO.FileSystemWatcher.Filter%2A> свойства «\*.txt».  
  
 Существует несколько типов изменений, которые можно отслеживать в каталог или файл. Например, можно отслеживать изменения в `Attributes`, `LastWrite` даты и времени, или `Size` файлов или каталогов. Это можно сделать, настроив <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> в одно из <xref:System.IO.NotifyFilters> значения. Дополнительные сведения о типах изменений вы можете ознакомиться с разделе <xref:System.IO.NotifyFilters>.  
  
 Вы можете отслеживать переименование, удаление или создание файлов или каталогов. Например, для отслеживания имени текстовых файлов, установите <xref:System.IO.FileSystemWatcher.Filter%2A> свойство «*.txt» и вызовите <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> метод с <xref:System.IO.WatcherChangeTypes.Renamed> его параметра.  
  
 Операционная система Windows уведомляет компонент об изменениях файлов в буфере, созданных <xref:System.IO.FileSystemWatcher>. Если за короткое время большое количество изменений, буфер может переполниться. В результате этот компонент будет отслеживать изменения в каталоге и будет давать только общие уведомления. Увеличение размера буфера с <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойство является сложным, как он поступает из невыгружаемой памяти, который не может быть переключена диска, поэтому буфера как можно меньше еще больших достаточно, чтобы не упустить любого файла событий изменения. Чтобы избежать переполнения буфера, используйте <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> , вы можете фильтрации ненужных уведомлений об изменениях.  
  
 Список начальных значений свойств для экземпляра <xref:System.IO.FileSystemWatcher>, в разделе <xref:System.IO.FileSystemWatcher.%23ctor%2A> конструктор.  
  
 Необходимо учесть следующее при использовании <xref:System.IO.FileSystemWatcher> класса.  
  
-   Скрытые файлы не учитываются.  
  
-   В некоторых системах <xref:System.IO.FileSystemWatcher> отчеты изменений в файлы с помощью короткого формата имени файлов формата 8.3. Например, изменение «LongFileName.LongExtension» может отображаться как «LongFil ~. Lon».  
  
-   Этот класс содержит запрос компоновки и запрос наследования на уровне класса, который применяется ко всем элементам. Объект <xref:System.Security.SecurityException> возникает, когда непосредственного вызывающего или производного класса не имеет разрешения полного доверия. Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/docs/framework/misc/link-demands.md).  
  
-   Максимальный размер, можно задать для <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойства для наблюдения за каталогом по сети составляет 64 КБ.  
  
> [!NOTE]
>  Под управлением <xref:System.IO.FileSystemWatcher> в Windows 98 не поддерживается.  
  
## <a name="copying-and-moving-folders"></a>Копирование и перемещение папок  
 Операционная система и <xref:System.IO.FileSystemWatcher> объекта интерпретации действие вырезания и вставки или действие перемещения как действие переименования для папки и ее содержимого. Если вырезать и вставить папку с файлами в папке просматриваемым, <xref:System.IO.FileSystemWatcher> объект сообщает только в папке, как новые, но не его содержимое, поскольку они фактически было только переименовано.  
  
 Чтобы получить уведомление о том, что содержимое папок была перемещена или скопированы в отслеживаемую папку, укажите <xref:System.IO.FileSystemWatcher.OnChanged%2A> и <xref:System.IO.FileSystemWatcher.OnRenamed%2A> методы обработки событий, описанным в следующей таблице.  
  
|Обработчик событий|Обрабатывать события|Выполняет|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Отчеты об изменениях в атрибуты файлов, создаваемых файлов и удаленные файлы.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Перечислите старый и новый пути переименованных файлов и папок, рекурсивно расширяющихся в случае необходимости.|  
  
## <a name="events-and-buffer-sizes"></a>События и размеры буфера  
 Обратите внимание, что зависит от нескольких факторов события изменения файловой системы возникают, как описано далее.  
  
-   Общие операции файловой системы может вызвать несколько событий. Например, при перемещении файла из одной папки в другую несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A> события могут возникать. Поэтому при перемещении файла является сложной операцией, которая состоит из нескольких простых операций, создание нескольких событий. Аналогично некоторые приложения (например, антивирусное программное обеспечение) могут вызывать дополнительные события файловой системы, выявляемых <xref:System.IO.FileSystemWatcher>.  
  
-   <xref:System.IO.FileSystemWatcher> Может наблюдать за дисками, пока они не переключается или удалены. <xref:System.IO.FileSystemWatcher> Инициирует события для компакт-дисков и DVD-дисков, так как временные метки и свойства невозможно изменить. Удаленных компьютерах должна быть установлена одна из необходимых платформ для компонента, чтобы работать правильно.  
  
-   При наличии нескольких <xref:System.IO.FileSystemWatcher> отслеживаемых объектов же UNC-путь в Windows XP без пакета обновления 1 или Windows 2000 с пакетом обновления 2 или более ранней, тогда и только один из объектов вызовет возникновение события. На компьютерах под управлением Windows XP с пакетом обновления 1 и более поздних версиях Windows 2000 с пакетом обновления 3 или более поздней версии или Windows Server 2003, все <xref:System.IO.FileSystemWatcher> объектов создает соответствующие события.  
  
 Обратите внимание, что <xref:System.IO.FileSystemWatcher> пропустить событие, если Превышен размер буфера. Чтобы предотвратить отсутствие событий, необходимо выполните следующее:  
  
-   Увеличить размер буфера, установив <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойство.  
  
-   Избегайте отслеживать файлы с длинными именами файлов, так как позволяет переполнения буфера длинное имя файла. Рассмотрите возможность переименования эти файлы, используя более короткие имена.  
  
-   Сохраните как можно более коротким код обработки событий.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для отслеживания каталога, задаваемого во время выполнения. Этот компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` время создания, удаления или переименования текстовых файлов в каталоге. Изменение, создать или удалить файл, путь к файлу выводит на консоль. При переименовании файла на консоль выводятся старого и нового пути.  
  
 Используйте <xref:System.Diagnostics> и <xref:System.IO> пространства имен для этого примера.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">для создания класса, производного от <see cref="T:System.Diagnostics.ProcessStartInfo" /> класса. Требовать значение: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Именованные наборы разрешений: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не может отслеживать удаленный компьютер не поддерживает Windows NT или Windows 2000. Не может отслеживать удаленный компьютер Windows NT 4.0 с компьютера Windows NT 4.0.  
  
 Следующей таблице представлены исходные значения свойств для экземпляра класса <xref:System.IO.FileSystemWatcher>.  
  
|Свойство.|Начальное значение|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|Побитовое сочетание OR `LastWrite`, `FileName`, и `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*«(Отслеживаются все файлы.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|Пустая строка (»»)|  
  
> [!NOTE]
>  Компонент не будет отслеживать заданную папку до <xref:System.IO.FileSystemWatcher.Path%2A> имеет значение, и <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> — `true`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> объект для отслеживания каталога, задаваемого во время выполнения. <xref:System.IO.FileSystemWatcher> Объекта наблюдает за `LastWrite` и `LastAccess` время, а также для создания, удаления или переименования текста файлы в каталоге. Изменение, создать или удалить файл, путь к файлу выводит на консоль. При переименовании файла старого и нового пути вывода на консоль.  
  
 В этом примере используется <xref:System.Diagnostics> и <xref:System.IO> пространства имен.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Контролируемый каталог в стандартной записи или в записи UNC.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" /> с заданным каталогом для контроля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Компонент не будет отслеживать заданную папку до <xref:System.IO.FileSystemWatcher.Path%2A> имеет значение, и <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> — `true`.  
  
 Компонент может следить за файлами на персональном компьютере, на сетевом диске или удаленном компьютере.  
  
 Не может отслеживать удаленный компьютер не поддерживает Windows NT или Windows 2000. Не может отслеживать удаленный компьютер Windows NT 4.0 с компьютера Windows NT 4.0. <xref:System.IO.FileSystemWatcher.Filter%2A> Свойство имеет значение по умолчанию отслеживаются все файлы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> представляет собой пустую строку ("").  
  
 - или -  
  
 Путь, заданный параметром <paramref name="path" />, не существует.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          Параметр <paramref name="path" /> имеет слишком большую длину.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Контролируемый каталог в стандартной записи или в записи UNC.</param>
        <param name="filter">Тип отслеживаемых файлов. Например, *.txt означает отслеживание изменений во всех текстовых файлах.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.FileSystemWatcher" /> с заданным каталогом и типом файлов для контроля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Компонент не будет отслеживать заданную папку до <xref:System.IO.FileSystemWatcher.Path%2A> имеет значение, и <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> — `true`.  
  
 Компонент может следить за файлами на персональном компьютере, на сетевом диске или удаленном компьютере.  
  
 Не может отслеживать удаленный компьютер не поддерживает Windows NT или Windows 2000. Не может отслеживать удаленный компьютер Windows NT 4.0 с компьютера Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="filter" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="path" /> представляет собой пустую строку ("").  
  
 - или -  
  
 Путь, заданный параметром <paramref name="path" />, не существует.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          Параметр <paramref name="path" /> имеет слишком большую длину.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию класса <see cref="T:System.IO.FileSystemWatcher" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Разработки, среда использует этот метод для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.IO.FileSystemWatcher.EndInit%2A> Метод завершает инициализацию. С помощью <xref:System.IO.FileSystemWatcher.BeginInit%2A> и <xref:System.IO.FileSystemWatcher.EndInit%2A> методы предотвращает использование до полной инициализации элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed> Событие возникает при изменении размера, системных атрибутов, последней записи времени, время последнего доступа или разрешений безопасности файла или каталога в контролируемом.  
  
> [!NOTE]
>  Общие операции файловой системы может вызвать несколько событий. Например, при перемещении файла из одной папки в другую несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A> события могут возникать. Поэтому при перемещении файла является сложной операцией, которая состоит из нескольких простых операций, создание нескольких событий. Аналогично некоторые приложения (например, антивирусное программное обеспечение) могут вызывать дополнительные события файловой системы, выявляемых <xref:System.IO.FileSystemWatcher>.  
  
 Используйте <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> для ограничения числа уведомлений, возникающих при обработке этого события.  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed> События неожиданно при файл будет переименован, но не возникает при переименовании каталога. Для отслеживания переименований используйте <xref:System.IO.FileSystemWatcher.Renamed> событий.  
  
> [!NOTE]
>  Порядок, в котором <xref:System.IO.FileSystemWatcher.Changed> события соединенных <xref:System.IO.FileSystemWatcher> события может измениться при <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> свойство не `null`.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.FileSystemWatcher.Changed> события на консоли отображается путь к файлу каждый раз при изменении контролируемых файла.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при создании файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые распространенные процессы, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно к событию, но они приводят к возникновению событий. При копировании файла или каталога, система инициирует <xref:System.IO.FileSystemWatcher.Created> событие в каталоге, в который копируется файл, если этот каталог контролируется. Если каталог, из которого производится копирование, контролируется другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не возникнет. Например, создайте два экземпляра модуля <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлено наблюдение «C:\My Documents» и FileSystemWatcher2 установлено наблюдение «C:\Your документы». При копировании файла из «Мои документы» в «Документов», <xref:System.IO.FileSystemWatcher.Created> событие будет вызываться по FileSystemWatcher2, но не события для FileSystemWatcher1. В отличие от копирования, перемещение файла или каталога приведет к возникновению двух событий. Из предыдущего примера, если файл перемещен из «Мои документы» «Документов» <xref:System.IO.FileSystemWatcher.Created> событие может генерироваться FileSystemWatcher2 и <xref:System.IO.FileSystemWatcher.Deleted> событие может генерироваться FileSystemWatcher1.  
  
> [!NOTE]
>  Общие операции файловой системы может вызвать несколько событий. Например, при перемещении файла из одной папки в другую несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A> события могут возникать. Поэтому при перемещении файла является сложной операцией, которая состоит из нескольких простых операций, создание нескольких событий. Аналогично некоторые приложения (например, антивирусное программное обеспечение) могут вызывать дополнительные события файловой системы, выявляемых <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Порядок, в котором <xref:System.IO.FileSystemWatcher.Created> события соединенных <xref:System.IO.FileSystemWatcher> события может измениться при <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> свойство не `null`.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Событие возникает сразу после создания файла. Если файл копируется или перемещается в контролируемому каталогу, <xref:System.IO.FileSystemWatcher.OnCreated%2A> событие будет вызываться немедленно, следуют одна или несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> события.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.FileSystemWatcher.Created> на консоли отображается путь к файлу каждый раз, когда создается файл контролируемые события.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые распространенные процессы, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно к событию, но они приводят к возникновению событий. При копировании файла или каталога, система инициирует <xref:System.IO.FileSystemWatcher.Created> событие в каталоге, в который копируется файл, если этот каталог контролируется. Если каталог, из которого производится копирование, контролируется другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не возникнет. Например, создайте два экземпляра модуля <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлено наблюдение «C:\My Documents» и FileSystemWatcher2 установлено наблюдение «C:\Your документы». При копировании файла из «Мои документы» в «Документов», <xref:System.IO.FileSystemWatcher.Created> событие будет вызываться по FileSystemWatcher2, но не события для FileSystemWatcher1. В отличие от копирования, перемещение файла или каталога приведет к возникновению двух событий. Из предыдущего примера, если файл перемещен из «Мои документы» «Документов» <xref:System.IO.FileSystemWatcher.Created> событие может генерироваться FileSystemWatcher2 и <xref:System.IO.FileSystemWatcher.Deleted> событие может генерироваться FileSystemWatcher1.  
  
> [!NOTE]
>  Общие операции файловой системы может вызвать несколько событий. Например, при перемещении файла из одной папки в другую несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A> события могут возникать. Поэтому при перемещении файла является сложной операцией, которая состоит из нескольких простых операций, создание нескольких событий. Аналогично некоторые приложения (например, антивирусное программное обеспечение) могут вызывать дополнительные события файловой системы, выявляемых <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Порядок, в котором <xref:System.IO.FileSystemWatcher.Deleted> события соединенных <xref:System.IO.FileSystemWatcher> события может измениться при <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> свойство не `null`.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.FileSystemWatcher.Deleted> события на консоли отображается путь к файлу каждый раз, когда контролируемые файл удаляется.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.IO.FileSystemWatcher" />, а при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом открытые <xref:System.ComponentModel.Component.Dispose%2A> метод и <xref:System.Object.Finalize%2A> метод. <xref:System.ComponentModel.Component.Dispose%2A> вызывает защищенный <xref:System.IO.FileSystemWatcher.Dispose%2A> метод с `disposing` равным `true`. <xref:System.Object.Finalize%2A> вызывает <xref:System.IO.FileSystemWatcher.Dispose%2A> с `disposing` значение `false`.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.IO.Compression.DeflateStream>. Этот метод вызывает метод <xref:System.ComponentModel.Component.Dispose%2A> каждого объекта, на который есть ссылка.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Метод <see cref="M:System.ComponentModel.Component.Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see cref="M:System.ComponentModel.Component.Dispose" />. Дополнительные сведения о реализации <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, в разделе [метода](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Дополнительные сведения о <see cref="M:System.ComponentModel.Component.Dispose" /> и <see cref="M:System.Object.Finalize" />, в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, доступен ли данный компонент.</summary>
        <value>
          Значение <see langword="true" />, если данный компонент разрешен; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />. При использовании этого компонента в конструкторе в [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], значение по умолчанию равно <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Компонент не вызывает события, если задать <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> для `true`.  
  
> [!NOTE]
>  Компонент не будет отслеживать заданную папку до <xref:System.IO.FileSystemWatcher.Path%2A> свойства и <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> — `true`.  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> Метод позволяет обработчиков событий для реагирования на изменения файла, даже если это свойство имеет значение `false`.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для отслеживания каталога, задаваемого во время выполнения. Этот компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` время создания, удаления или переименования текстовых файлов в каталоге. Изменение, создать или удалить файл, путь к файлу выводит на консоль. При переименовании файла на консоль выводятся старого и нового пути.  
  
 Используйте <xref:System.Diagnostics> и <xref:System.IO> пространства имен для этого примера.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.IO.FileSystemWatcher" /> был удален.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Microsoft Windows NT или более поздней версии.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удалось найти каталог, указанный в <see cref="P:System.IO.FileSystemWatcher.Path" />.</exception>
        <exception cref="T:System.ArgumentException">
          Объект <see cref="P:System.IO.FileSystemWatcher.Path" /> не был задан или является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заканчивает инициализацию объекта <see cref="T:System.IO.FileSystemWatcher" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Разработки среды использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.IO.FileSystemWatcher.BeginInit%2A> Метод начинает инициализацию. С помощью <xref:System.IO.FileSystemWatcher.BeginInit%2A> и <xref:System.IO.FileSystemWatcher.EndInit%2A> методы предотвращает использование до полной инициализации элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда экземпляру <see cref="T:System.IO.FileSystemWatcher" /> не удается продолжить отслеживание изменений, или при переполнении внутреннего буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает каждый раз, когда что-нибудь предотвращает <xref:System.IO.FileSystemWatcher> объект отслеживания изменений. Например, если подключение к этому каталогу теряются, и объект наблюдает за изменениями в удаленном каталоге <xref:System.IO.FileSystemWatcher.Error> события.  
  
 Система уведомляет вас об изменениях файлов и сохраняет эти изменения в буфере, который компонент создает и передает в API-интерфейсы. Если за короткое время большое количество изменений, буфер может переполниться. В результате этот компонент будет отслеживать изменения в каталоге и будет давать только общие уведомления. Увеличение размера буфера является сложным, так как он поступает из не разбиением на страницы памяти, который не может быть переключен на диск, поэтому сохранить как можно меньший буфер. Чтобы избежать переполнения буфера, используйте <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> для фильтрации ненужных уведомлений об изменениях.  
  
> [!NOTE]
>  Общие операции файловой системы может вызвать несколько событий. Например, при перемещении файла из одной папки в другую несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> и некоторые <xref:System.IO.FileSystemWatcher.OnCreated%2A> и <xref:System.IO.FileSystemWatcher.OnDeleted%2A> события могут возникать. Поэтому при перемещении файла является сложной операцией, которая состоит из нескольких простых операций, создание нескольких событий. Аналогично некоторые приложения (например, антивирусное программное обеспечение) могут вызывать дополнительные события файловой системы, выявляемых <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращае или задает строку фильтра, используемую для определения файлов, контролируемых в каталоге.</summary>
        <value>Строка фильтра. Значение по умолчанию — «*. \*«(Отслеживаются все файлы.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для отслеживания изменений во всех файлах установите <xref:System.IO.FileSystemWatcher.Filter%2A> свойства равным пустой строке (»»). Для отслеживания определенного файла установите <xref:System.IO.FileSystemWatcher.Filter%2A> свойство имени файла. Например, для отслеживания изменений в файле MyDoc.txt, установите <xref:System.IO.FileSystemWatcher.Filter%2A> свойства «MyDoc.txt». Также можно отслеживать изменения в файлах определенного типа. Например, для отслеживания изменений в текстовых файлах, задать <xref:System.IO.FileSystemWatcher.Filter%2A> свойства «*.txt». Использование нескольких фильтров, таких как «\*.txt&#124;\*.doc» не поддерживается.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> Свойство может быть изменено после <xref:System.IO.FileSystemWatcher> начала получения событий объекта.  
  
 Дополнительные сведения о фильтрации нежелательных уведомлений см. в разделе <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, и <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойства.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> принимает подстановочные знаки для сопоставления файлов, как показано в следующих примерах.  
  
|Строка фильтра|Отслеживание следующих файлов|  
|-------------------|---------------------------------|  
|*.\*|Все файлы (по умолчанию). Пустая строка ("») также отслеживает все файлы.|  
|*.txt|Все файлы с расширением «txt».|  
|*recipe.doc|Все файлы, заканчивающиеся на «рецепт» с расширением «документ».|  
|win*.xml|Все файлы, начиная с win, с расширением «xml».|  
|Продажи * 200?. xls|Соответствует следующим:<br /><br /> Продажи июля 2001.xlsSales августа 2002.xlsSales марта 2004.xls<br /><br /> но не соответствует:<br /><br /> Продажи ноября 1999.xls|  
|MyReport.Doc|Отслеживает только MyReport.doc|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для отслеживания каталога, задаваемого во время выполнения. Этот компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` время создания, удаления или переименования текстовых файлов в каталоге. Изменение, создать или удалить файл, путь к файлу выводит на консоль. При переименовании файла на консоль выводятся старого и нового пути.  
  
 Используйте <xref:System.Diagnostics> и <xref:System.IO> пространства имен для этого примера.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее необходимость контроля вложенных каталогов по указанному пути.</summary>
        <value>
          Значение <see langword="true" />, если требуется контроль вложенных каталогов; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задать <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> для `true` , если требуется отслеживать уведомления об изменениях для файлов и папок, содержащихся в каталоге, заданном через <xref:System.IO.FileSystemWatcher.Path%2A> свойство и его подкаталогах. Установка <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> свойства `false` помогает снизить количество уведомлений, отправляемых внутреннего буфера. Дополнительные сведения о фильтрации нежелательных уведомлений см. в разделе <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> и <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойства.  
  
 Когда `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> рекурсивное всего поддерева, не только непосредственных дочерних каталогов. Возвращает относительный путь к файлу или каталогу в ветви в <xref:System.IO.FileSystemEventArgs.Name%2A> свойство <xref:System.IO.FileSystemEventArgs> и <xref:System.IO.RenamedEventArgs.OldName%2A> свойство <xref:System.IO.RenamedEventArgs>, в зависимости от отслеживаемых изменений. Можно получить полный путь от <xref:System.IO.FileSystemEventArgs.FullPath%2A> свойство <xref:System.IO.FileSystemEventArgs> и <xref:System.IO.RenamedEventArgs.OldFullPath%2A> свойство <xref:System.IO.RenamedEventArgs>, в зависимости от отслеживаемых изменений.  
  
 Если создается каталог в ветви отслеживаемой каталога и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> — `true`, этот каталог будет автоматически отслеживаться.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер (в байтах) внутреннего буфера.</summary>
        <value>Размер внутреннего буфера в байтах. Значение по умолчанию — 8192 (8 КБ).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно задать буфер размером 4 КБ или большего размера, но не должна превышать 64 КБ. Если вы попытаетесь установить <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойство с длиной не более 4096 байт, значение удаляется и <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойство имеет значение 4 096 байт. Для повышения производительности рекомендуется используйте кратен 4 КБ на компьютерах с процессорами Intel.  
  
 Системные уведомления об изменении файла и сохраняет эти изменения в буфере, который компонент создает и передает в API-интерфейсы. Каждое событие может использовать до 16 байтов памяти, не указывая имя файла. Если за короткое время большое количество изменений, буфер может переполниться. В результате этот компонент будет отслеживать изменения в каталоге и будет давать только общие уведомления. Увеличение размера буфера предотвращает отсутствует файловой системы событий изменения. Тем не менее увеличение размера буфера расходуется, так как он поступает из невыгружаемой памяти, который не может быть переключен на диск, поэтому сохраните как можно меньший буфер. Чтобы избежать переполнения буфера, используйте <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> и <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> для фильтрации ненужных уведомлений об изменениях.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип отслеживаемых изменений.</summary>
        <value>Одно из значений перечисления <see cref="T:System.IO.NotifyFilters" />. По умолчанию это побитовое сочетание OR-значений <see langword="LastWrite" />, <see langword="FileName" /> и <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно объединять элементы <xref:System.IO.NotifyFilters> перечисления для наблюдения за более чем один тип изменений одновременно. Например, можно отслеживать изменения размера файла, а также для изменения в `LastWrite` времени. Это событие возникает есть изменения в размере файла или папки или изменении `LastWrite` время из файла или папки.  
  
 Это один из способов отфильтровывайте нежелательные уведомления об. Дополнительные сведения о фильтрации нежелательных уведомлений см. в разделе <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, и <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> свойства.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для отслеживания каталога, задаваемого во время выполнения. Этот компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` время создания, удаления или переименования текстовых файлов в каталоге. Изменение, создать или удалить файл, путь к файлу выводит на консоль. При переименовании файла на консоль выводятся старого и нового пути.  
  
 Используйте <xref:System.Diagnostics> и <xref:System.IO> пространства имен для этого примера.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Эта величина не является действительным побитовым сочетанием OR-значений <see cref="T:System.IO.NotifyFilters" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Задаваемое значение является недопустимым.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.FileSystemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Changed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> вызывается при изменении размера, системных атрибутов, время последней записи, время последнего доступа или разрешений безопасности файла или каталога в контролируемом.  
  
 Используйте <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> ограничивает количество событий возникает, когда <xref:System.IO.FileSystemWatcher.Changed> обработано событие.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Событие возникает сразу после создания файла. Если файл копируется или перемещается в контролируемому каталогу, <xref:System.IO.FileSystemWatcher.OnCreated%2A> событие будет вызываться немедленно, следуют одна или несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> события.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> метод.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.FileSystemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> вызывается при создании файла или каталога в контролируемом.  
  
 Некоторые распространенные процессы, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно к событию, но они приводят к возникновению событий. При копировании файла или каталога, система инициирует <xref:System.IO.FileSystemWatcher.Created> событие в каталоге, в который копируется файл, если этот каталог контролируется. Если каталог, из которого производится копирование, контролируется другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не возникнет. Например, создайте два экземпляра модуля <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлено наблюдение «C:\My Documents» и FileSystemWatcher2 установлено наблюдение «C:\Your документы». При копировании файла из «Мои документы» и вставьте его в «Документов», <xref:System.IO.FileSystemWatcher.Created> событие будет вызываться в FileSystemWatcher2, но не события для FileSystemWatcher1. В отличие от копирования, перемещение файла или каталога вызывает два события. Из предыдущего примера, если файл перемещен из «Мои документы» «Документов» <xref:System.IO.FileSystemWatcher.Created> событие будет вызываться в FileSystemWatcher2 и <xref:System.IO.FileSystemWatcher.Deleted> событие будет вызываться в FileSystemWatcher1.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Событие возникает сразу после создания файла. Если файл копируется или перемещается в контролируемому каталогу, <xref:System.IO.FileSystemWatcher.OnCreated%2A> событие будет вызываться немедленно, следуют одна или несколько <xref:System.IO.FileSystemWatcher.OnChanged%2A> события.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> метод.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.FileSystemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Deleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> вызывается при удалении файла или папки в контролируемом.  
  
 Некоторые распространенные процессы, такие как копирование или перемещение файла или каталога, не соответствуют непосредственно к событию, но они приводят к возникновению событий. При копировании файла или каталога, система инициирует <xref:System.IO.FileSystemWatcher.Created> событие в каталоге, в который копируется файл, если этот каталог контролируется. Если каталог, из которого производится копирование, контролируется другим экземпляром <xref:System.IO.FileSystemWatcher>, событие не возникнет. Например, создайте два экземпляра модуля <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 установлено наблюдение «C:\My Documents» и FileSystemWatcher2 установлено наблюдение «C:\Your документы». При копировании файла из «Мои документы» в «Документов», <xref:System.IO.FileSystemWatcher.Created> событие будет вызываться по FileSystemWatcher2, но не события для FileSystemWatcher1. В отличие от копирования, перемещение файла или каталога вызывает два события. Из предыдущего примера, если файл перемещен из «Мои документы» «Документов» <xref:System.IO.FileSystemWatcher.Created> событие может генерироваться FileSystemWatcher2 и <xref:System.IO.FileSystemWatcher.Deleted> событие может генерироваться FileSystemWatcher1.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> метод.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.IO.ErrorEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Error" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> вызывается при возникновении ошибки.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> метод.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.IO.RenamedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.IO.FileSystemWatcher.Renamed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> вызывается при переименовании файла или каталога в контролируемом. Его <xref:System.IO.RenamedEventArgs> аргумент содержит сведения об операции переименования, такие как тип изменений, путь старое и новое и старое и новое имя. Обратите внимание, что его <xref:System.IO.FileSystemEventArgs.Name> свойство может принимать значение null для переименован события, если <xref:System.IO.FileSystemWatcher> не получить сопоставления старое и новое имя события из операционной системы. 
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> метод.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает путь отслеживаемого каталога.</summary>
        <value>Путь для отслеживания. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это полный путь к каталогу. Если <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> свойство `true`, этот каталог является корневым, с которой система отслеживает изменения; в противном случае это единственный отслеживаемый каталог. Для отслеживания определенного файла установите <xref:System.IO.FileSystemWatcher.Path%2A> свойство в полное, правильный каталог и <xref:System.IO.FileSystemWatcher.Filter%2A> свойство имени файла.  
  
 <xref:System.IO.FileSystemWatcher.Path%2A> Свойство поддерживает пути универсального соглашения об именах (UNC).  
  
> [!NOTE]
>  Это свойство необходимо задать перед компонента можно отслеживать изменения.  
  
 При переименовании каталога <xref:System.IO.FileSystemWatcher> автоматически перестраивается на только что переименованный элемент. Например, если задать <xref:System.IO.FileSystemWatcher.Path%2A> свойства «C:\My Documents» и вручную переименовать каталоге «Documents C:\Your», этот компонент продолжает прослушивание уведомлений об изменениях в папке. Тем не менее, при запросе <xref:System.IO.FileSystemWatcher.Path%2A> свойство, оно содержит старый путь. Это происходит потому, что данный компонент определяет контролируемый каталог на основе дескриптор, а не имя каталога. Переименование не влияет на дескриптор. Таким образом, при уничтожении этого компонента, а затем создать его повторно без обновления <xref:System.IO.FileSystemWatcher.Path%2A> свойство, приложение не будет работать, так как каталог не существует.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.IO.FileSystemWatcher> для отслеживания каталога, задаваемого во время выполнения. Этот компонент настроен для отслеживания изменений в `LastWrite` и `LastAccess` время создания, удаления или переименования текстовых файлов в каталоге. Изменение, создать или удалить файл, путь к файлу выводит на консоль. При переименовании файла на консоль выводятся старого и нового пути.  
  
 Используйте <xref:System.Diagnostics> и <xref:System.IO> пространства имен для этого примера.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Заданный путь не существует или не может быть найден.  
  
 - или -  
  
 Заданный путь содержит подстановочные знаки.  
  
 - или -  
  
 Заданный путь содержит недопустимые символы.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при переименовании файла или каталога по заданному пути <see cref="P:System.IO.FileSystemWatcher.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed` Событие <xref:System.IO.RenamedEventHandler> делегат, который имеет следующую сигнатуру:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs> Объект предоставляет сведения об операции переименования, такие как тип переименования ( <xref:System.IO.FileSystemEventArgs.ChangeType> свойства), старое и новое имя и старый и новый путь. Обратите внимание, что <xref:System.IO.FileSystemEventArgs.Name> свойство может принимать значение null для переименован события, если <xref:System.IO.FileSystemWatcher> не получить сопоставления старое и новое имя события из операционной системы.

 Переименование каталога, к которому вы смотрите не приведет к уведомление. Уведомления возникают только для элементов каталога, к которому просмотре.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.FileSystemWatcher.Renamed> события на консоли отображается путь к файлу каждый раз, когда контролируемые файл будет переименован.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип <see cref="T:System.ComponentModel.ISite" /> для объекта <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>Интерфейс <see cref="T:System.ComponentModel.ISite" /> для <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узлы связывают <xref:System.ComponentModel.Component> для <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> и разрешить связь между ними, а также предоставляют способ для управления компонентами в контейнере.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, используемый для маршалинга вызовов обработчика событий, инициированных в результате изменения каталога.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, который описывает объект, используемый для маршалинга вызовов обработчика событий, инициированных в результате изменения каталога. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> — `null`, методы, обрабатывающие <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, и <xref:System.IO.FileSystemWatcher.Renamed> события вызываются в поток из пула потоков системы. Дополнительные сведения о системной группе потоков см. в разделе <xref:System.Threading.ThreadPool>.  
  
 Когда <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, и <xref:System.IO.FileSystemWatcher.Renamed> события обрабатываются компонентом Windows Forms, такие как <xref:System.Windows.Forms.Button>, обращение к компоненту через пул потоков системы могут не работать или может привести к возникновению исключения. Этого можно избежать, установив <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> в компонент Windows Forms, которое вызывает методы, обрабатывающие <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, и <xref:System.IO.FileSystemWatcher.Renamed> событий для вызова в том же потоке, в котором был создан компонент.  
  
 Если <xref:System.IO.FileSystemWatcher> используется внутри [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] в конструкторе Windows Forms, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> автоматически устанавливает в элемент управления, содержащий <xref:System.IO.FileSystemWatcher>. Например, если поместить <xref:System.IO.FileSystemWatcher> в конструкторе Form1 (наследуется от класса <xref:System.Windows.Forms.Form>) <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> свойство <xref:System.IO.FileSystemWatcher> устанавливается на экземпляр Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Синхронный метод, возвращающий структуру, содержащую сведения о произошедших изменениях.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Отслеживаемый объект <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <summary>Синхронный метод, возвращающий структуру, содержащую сведения о произошедших изменениях, с заданным типом изменений, которые вы хотите контролировать.</summary>
        <returns>Объект <see cref="T:System.IO.WaitForChangedResult" />, содержащий сведения о произошедших изменениях.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ожидает бесконечно, пока выполняется первое изменение и затем возвращает. Это то же самое, что и использование <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> с `timeout` равным-1.  
  
> [!NOTE]
>  Этот метод позволяет обработчик событий, вызываемый реагировать на файле даже в случае изменения <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> свойству `false`.  
  
 В некоторых системах <xref:System.IO.FileSystemWatcher> отчеты изменений в файлы с помощью короткого формата имени файлов формата 8.3. Например, изменение «LongFileName.LongExtension» может отображаться как «LongFi ~. Lon».  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Отслеживаемый объект <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <param name="timeout">Время ожидания (в миллисекундах).</param>
        <summary>Синхронный метод, возвращающий структуру, содержащую сведения о произошедших изменениях, с заданным типом изменений, которые вы хотите контролировать, и временем ожидания (в мс) до блокировки по ожиданию.</summary>
        <returns>Объект <see cref="T:System.IO.WaitForChangedResult" />, содержащий сведения о произошедших изменениях.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ожидает, пока происходит изменение, или истечет время. Значение -1 для `timeout` параметр означает неограниченное время ожидания.  
  
> [!NOTE]
>  Этот метод позволяет обработчик событий, вызываемый реагировать на файле даже в случае изменения <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> свойству `false`.  
  
 В некоторых системах <xref:System.IO.FileSystemWatcher> отчеты изменений в файлы с помощью короткого формата имени файлов формата 8.3. Например, изменение «LongFileName.LongExtension» может отображаться как «LongFi ~. Lon».  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>