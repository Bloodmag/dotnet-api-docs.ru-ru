<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eaa27dae19046fabd638ca567a16e9b0c52a25ff" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420678" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Реализует объект <see cref="T:System.IO.TextReader" />, который считывает символы из потока байтов в определенной кодировке.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader> предназначен для ввода знаков в определенной кодировке, тогда как <xref:System.IO.Stream> класс предназначен для ввода и вывода байтов. Используйте <xref:System.IO.StreamReader> для чтения строк данных из стандартного текстового файла.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейса. После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable> разделе интерфейса.  
  
 <xref:System.IO.StreamReader> по умолчанию используется кодировка UTF-8, если не указано иное, а не значения кодовой страницы ANSI для текущей системы. UTF-8 правильно обрабатывает символы Юникода и предоставляет согласованные результаты в локализованных версиях операционной системы. Если вы получаете текущую кодировку с помощью <xref:System.IO.StreamReader.CurrentEncoding%2A> свойства, значение не является надежным до после первого <xref:System.IO.StreamReader.Read%2A> метод, поскольку автоматическое определение кодировки не выполняется до первого вызова <xref:System.IO.StreamReader.Read%2A> метод.  
  
 По умолчанию <xref:System.IO.StreamReader> не является потокобезопасным. В разделе <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> для потокобезопасной оболочки.  
  
 <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> И <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегрузки методов чтения и записи число знаков, указанное в `count` параметра. Они отличаются от <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> и <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, которые считывают и записывают число байтов, указанное в `count` параметра. Используйте <xref:System.IO.BufferedStream> методы только для чтения и записи на целое число байтов элементов массива.  
  
> [!NOTE]
>  При чтении из <xref:System.IO.Stream>, целесообразно использовать буфер такого же размера, как и внутренний буфер потока.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере используется экземпляр <xref:System.IO.StreamReader> прочитать текст из файла. Конструктор, используемый в этом примере не поддерживается для использования в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложений.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 В следующем примере создается <xref:System.IO.StreamReader> и вызывает его <xref:System.IO.StreamReader.ReadAsync%2A> метод для чтения файла асинхронно.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного потока.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, который нужно считать.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует кодировку для <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> с использованием параметра `stream` параметр и размер внутреннего буфера 1024 байта.  
  
 <xref:System.IO.StreamReader> Вызывает <xref:System.IO.Stream.Dispose> в предоставленном <xref:System.IO.Stream> объекта при <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> вызывается.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> не поддерживает чтение.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к файлу для чтения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для указанного имени файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Полный путь к файлу указывается по `path` параметр. Этот конструктор инициализирует кодировку <xref:System.Text.UTF8Encoding> и размер буфера 1024 байта.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 `path` Не является обязательным для файла, который хранится на диске; он может быть любой части системы, поддерживающей доступ с помощью потоков.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.IO.IOException">
          Параметр <paramref name="path" /> включает неверный или недопустимый синтаксис имени файла, имени каталога или метки тома.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, который нужно считать.</param>
        <param name="detectEncodingFromByteOrderMarks">Указывает, следует ли выполнять поиск меток порядка байтов с начала файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для указанного потока, используя заданный параметр обнаружения метки порядка следования байтов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует кодировку для <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> с использованием параметра `stream` параметр и размер внутреннего буфера 1024 байта.  
  
 `detectEncodingFromByteOrderMarks` Обнаруживает кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader> Вызывает <xref:System.IO.Stream.Dispose> в предоставленном <xref:System.IO.Stream> объекта при <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> вызывается.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> не поддерживает чтение.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, который нужно считать.</param>
        <param name="encoding">Кодировка символов, которую нужно использовать.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного потока, используя указанную кодировку символов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка символов `encoding` значение параметра, а также размером буфера 1024 байта. <xref:System.IO.StreamReader> Объект пытается определить кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае используется пользовательская кодировка. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader> Вызывает <xref:System.IO.Stream.Dispose> в предоставленном <xref:System.IO.Stream> объекта при <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> вызывается.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> не поддерживает чтение.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="stream" /> или <paramref name="encoding" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к файлу для чтения.</param>
        <param name="detectEncodingFromByteOrderMarks">Указывает, следует ли выполнять поиск меток порядка байтов с начала файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного имени файла, используя указанный параметр обнаружения меток порядка байтов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует кодировку для <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> с использованием параметра `stream` параметр и размер внутреннего буфера 1024 байта.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 `path` Не является обязательным для файла, который хранится на диске; он может быть любой части системы, поддерживающей доступ с помощью потоков.  
  
 `detectEncodingFromByteOrderMarks` Обнаруживает кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае <xref:System.Text.UTF8Encoding> используется. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.IO.IOException">
          Параметр <paramref name="path" /> включает неверный или недопустимый синтаксис имени файла, имени каталога или метки тома.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к файлу для чтения.</param>
        <param name="encoding">Кодировка символов, которую нужно использовать.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного имени файла, используя указанную кодировку символов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует кодировку в соответствии с `encoding` параметра и размер внутреннего буфера 1024 байта. <xref:System.IO.StreamReader> Объект пытается определить кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае используется пользовательская кодировка. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 `path` Не является обязательным для файла, который хранится на диске; он может быть любой части системы, поддерживающей доступ с помощью потоков.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="path" /> или <paramref name="encoding" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.NotSupportedException">
          Параметр <paramref name="path" /> включает неверный или недопустимый синтаксис имени файла, имени каталога или метки тома.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, который нужно считать.</param>
        <param name="encoding">Кодировка символов, которую нужно использовать.</param>
        <param name="detectEncodingFromByteOrderMarks">Указывает, следует ли выполнять поиск меток порядка байтов с начала файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного потока, используя указанную кодировку символов и параметр обнаружения метки порядка байтов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует кодировку в соответствии с `encoding` параметр <xref:System.IO.StreamReader.BaseStream%2A> с использованием параметра `stream` параметр и размер внутреннего буфера 1024 байта.  
  
 `detectEncodingFromByteOrderMarks` Обнаруживает кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае используется пользовательская кодировка. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader> Вызывает <xref:System.IO.Stream.Dispose> в предоставленном <xref:System.IO.Stream> объекта при <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> вызывается.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> не поддерживает чтение.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="stream" /> или <paramref name="encoding" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к файлу для чтения.</param>
        <param name="encoding">Кодировка символов, которую нужно использовать.</param>
        <param name="detectEncodingFromByteOrderMarks">Указывает, следует ли выполнять поиск меток порядка байтов с начала файла.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного имени файла, используя указанную кодировку символов и параметр обнаружения меток порядка байтов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует кодировку в соответствии с `encoding` параметра и размер внутреннего буфера 1024 байта.  
  
 `detectEncodingFromByteOrderMarks` Обнаруживает кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае используется пользовательская кодировка. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 `path` Не является обязательным для файла, который хранится на диске; он может быть любой части системы, поддерживающей доступ с помощью потоков.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="path" /> или <paramref name="encoding" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.NotSupportedException">
          Параметр <paramref name="path" /> включает неверный или недопустимый синтаксис имени файла, имени каталога или метки тома.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Поток, который нужно считать.</param>
        <param name="encoding">Кодировка символов, которую нужно использовать.</param>
        <param name="detectEncodingFromByteOrderMarks">Указывает, следует ли выполнять поиск меток порядка байтов с начала файла.</param>
        <param name="bufferSize">Минимальный размер буфера.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного потока, используя указанную кодировку символов, параметр обнаружения метки порядка байтов и размер буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер буфера в символах 16-разрядное задается `bufferSize` параметра. Если `bufferSize` меньше, чем минимальный допустимый размер (128 символов), используется минимальный допустимый размер.  
  
 Этот конструктор позволяет изменять кодировку при первом чтении из <xref:System.IO.StreamReader> объекта. `detectEncodingFromByteOrderMarks` Обнаруживает кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае используется пользовательская кодировка. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader> Вызывает <xref:System.IO.Stream.Dispose> в предоставленном <xref:System.IO.Stream> объекта при <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> вызывается.  
  
> [!NOTE]
>  При чтении из <xref:System.IO.Stream>, целесообразно использовать буфер такого же размера, как и внутренний буфер потока.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Поток не поддерживает чтение.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="stream" /> или <paramref name="encoding" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к файлу для чтения.</param>
        <param name="encoding">Кодировка символов, которую нужно использовать.</param>
        <param name="detectEncodingFromByteOrderMarks">Указывает, следует ли выполнять поиск меток порядка байтов с начала файла.</param>
        <param name="bufferSize">Минимальный размер буфера (в 16-разрядных символах).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для заданного имени файла, используя указанную кодировку символов, параметр обнаружения меток порядка байтов и размер буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует кодировку в соответствии с `encoding` параметра.  
  
 Этот конструктор позволяет изменять кодировку при первом чтении из <xref:System.IO.StreamReader> объекта. `detectEncodingFromByteOrderMarks` Обнаруживает кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае используется пользовательская кодировка. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
 Размер буфера в символах 16-разрядное задается `bufferSize` параметра. Если `bufferSize` меньше, чем минимальный допустимый размер (128 символов), используется минимальный допустимый размер.  
  
 `path` Параметр может быть именем файла, включая файл в общей папке соглашения об универсальных именах (UNC).  
  
 `path` Не является обязательным для файла, который хранится на диске; он может быть любой части системы, поддерживающей доступ с помощью потоков.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы будет невозможно и может вызвать исключение, создаваемое исключение.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Это показано в следующем примере кода <xref:System.IO.StreamReader> конструктор.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> является пустой строкой ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="path" /> или <paramref name="encoding" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.NotSupportedException">
          Параметр <paramref name="path" /> включает неверный или недопустимый синтаксис имени файла, имени каталога или метки тома.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение <paramref name="buffersize" /> не больше нуля.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Считываемый поток.</param>
        <param name="encoding">Кодировка символов, которую нужно использовать.</param>
        <param name="detectEncodingFromByteOrderMarks">
          Значение <see langword="true" />, если метки порядка байтов необходимо искать в начале файла; в противном случае — значение <see langword="false" />.</param>
        <param name="bufferSize">Минимальный размер буфера.</param>
        <param name="leaveOpen">
          Значение <see langword="true" />, чтобы оставить поток открытым после удаления объекта <see cref="T:System.IO.StreamReader" />; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.StreamReader" /> для указанного потока на основе заданной кодировки символов, параметра обнаружения меток порядка байтов и размера буфера, а также при необходимости оставляет поток открытым.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы не задали `leaveOpen` параметр `true`, <xref:System.IO.StreamReader> вызывает <xref:System.IO.Stream.Dispose> в предоставленном <xref:System.IO.Stream> объекта при <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> вызывается.  
  
 Размер буфера в символах 16-разрядное задается `bufferSize` параметра. Если `bufferSize` меньше, чем минимальный допустимый размер (128 символов), используется минимальный допустимый размер.  
  
 Этот конструктор позволяет изменять кодировку при первом чтении из <xref:System.IO.StreamReader> объекта. Если `detectEncodingFromByteOrderMarks` параметр `true`, конструктор определяет кодировку, просмотрев первые три байта потока. Он автоматически распознает Юникод UTF-8, с обратным порядком байтов и текст в кодировке Юникод с обратным порядком байтов, если файл начинается с порядком следования байтов в соответствующий меток. В противном случае используется пользовательская кодировка. Дополнительные сведения см. в описании метода <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  При чтении из <xref:System.IO.Stream>, целесообразно использовать буфер такого же размера, как и внутренний буфер потока.  
  
> [!CAUTION]
>  При компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символы могут интерпретироваться неправильно и может вызвать исключение, создаваемое исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает основной поток.</summary>
        <value>Основной поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте это свойство для доступа к основной поток. <xref:System.IO.StreamReader> Класс буферов ввода из базового потока, при вызове одного из <xref:System.IO.StreamReader.Read%2A> методы. Положение базового потока управления после считывания данных в буфер, положение базового потока, может не соответствовать позиции внутреннего буфера. Чтобы сбросить во внутреннем буфере, вызовите <xref:System.IO.StreamReader.DiscardBufferedData%2A> метода; тем не менее, этот метод снижает производительность и должен вызываться только в случае крайней необходимости. <xref:System.IO.StreamReader> Конструкторы, которые имеют `detectEncodingFromByteOrderMarks` параметр можно изменять кодировку при первом чтении из <xref:System.IO.StreamReader> объекта.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает объект <see cref="T:System.IO.StreamReader" /> и основной поток и освобождает все системные ресурсы, связанные с устройством чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> метод.  
  
 Эта реализация <xref:System.IO.StreamReader.Close%2A> вызовы <xref:System.IO.StreamReader.Dispose%2A> метод передачи `true` значение.  
  
 Сброс потока его основной кодировщик не очищается, пока не будет явно вызван метод <xref:System.IO.StreamReader.Close%2A>. Установка <xref:System.IO.StreamWriter.AutoFlush%2A> для `true` означает, что данные будут сброшены из буфера в поток, но состояние кодировщика при этом не сбрасывается. Это позволяет кодировщику сохранить свое состояние (частичные символы), чтобы правильно выполнить кодировку следующего блока знаков. Этот сценарий влияет на кодировки UTF8 и UTF7, в которых определенные символы кодируются только после кодировщик получает соседние знаки.  
  
 После вызова <xref:System.IO.StreamReader.Close%2A>, все операции чтения могут вызывать исключения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущую кодировку символов, используемую текущим объектом <see cref="T:System.IO.StreamReader" />.</summary>
        <value>Текущая кодировка символов, используемая текущим устройством чтения. После первого вызова любого метода <see cref="Overload:System.IO.StreamReader.Read" /> объекта <see cref="T:System.IO.StreamReader" /> значение может измениться, поскольку до первого вызова метода <see cref="Overload:System.IO.StreamReader.Read" /> автоматическое определение кодировки не выполняется.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода возвращает кодировку указанного <xref:System.IO.StreamReader> объекта.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает внутренний буфер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.StreamReader.DiscardBufferedData%2A> метод для сброса внутреннего буфера для <xref:System.IO.StreamReader> объекта. Необходимо вызвать этот метод только если позиция внутреннего буфера и <xref:System.IO.StreamReader.BaseStream%2A> не совпадают. Эти позиции может сопровождаться несоответствие данных, считанных в буфер и затем поиска на новое место в базовый поток. Этот метод снижает производительность и должен использоваться только при крайней необходимости, например, если вы хотите прочитать часть содержимого <xref:System.IO.StreamReader> объекта более одного раза.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано сценарий где <xref:System.IO.StreamReader.DiscardBufferedData%2A> метод должен вызываться для синхронизации внутреннего буфера и основной поток. Файл, в примере используется для демонстрации позиции и состоит из текста `abcdefghijklmnopqrstuvwxyz`. Путем вызова <xref:System.IO.StreamReader.DiscardBufferedData%2A> после считывания данных в примере работает должным образом. После прочтения первые 15 символов, положение сбрасывается в значение смещения 2, и все остальные символы доступны для чтения. Если вы удалите вызов <xref:System.IO.StreamReader.DiscardBufferedData%2A>, пример не работает должным образом. Первые 15 символов считываются, но сбросить позицию базового потока. Внутренний буфер <xref:System.IO.StreamReader> объект по-прежнему подключен 16 символов. Таким образом <xref:System.IO.StreamReader.ReadToEnd%2A> возвращает все символы в буфере, а также символы в основной поток, начиная с позиции сброса.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Закрывает основной поток, освобождает неуправляемые ресурсы, используемые <see cref="T:System.IO.StreamReader" />, и при необходимости освобождает управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом открытые <xref:System.IDisposable.Dispose%2A> метод и <xref:System.Object.Finalize%2A> метод. <xref:System.IDisposable.Dispose%2A> вызывает защищенный <xref:System.IO.StreamReader.Dispose%2A> метод с `disposing` равным true. <xref:System.Object.Finalize%2A> вызывает <xref:System.IO.StreamReader.Dispose%2A> с `disposing` значение false.  
  
 Когда `disposing` параметр `true`, этот метод освобождает все ресурсы, занятые любыми управляемыми объектами, <xref:System.IO.StreamReader> ссылки на объекты. Этот метод вызывает метод <xref:System.IDisposable.Dispose%2A> каждого объекта, на который есть ссылка.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Метод Dispose может вызываться несколько раз другими объектами. При переопределении метода <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода Dispose [cref,...]. Дополнительные сведения о реализации <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> разделе [метода](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Дополнительные сведения о <see cref="M:System.IDisposable.Dispose" /> и <see cref="M:System.Object.Finalize" />, в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, находится ли позиция текущего потока в конце потока.</summary>
        <value>
          Значение <see langword="true" />, если текущее положение находится в конце потока; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Базовый поток был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Объект <see cref="T:System.IO.StreamReader" /> для пустого потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При считывании методы вызываются для <xref:System.IO.StreamReader.Null>, всегда возвращается нуль. Когда <xref:System.IO.StreamReader.ReadLine%2A> вызывается на <xref:System.IO.StreamReader.Null>, `null` возвращается.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает следующий доступный символ, но не использует его.</summary>
        <returns>Целое число, представляющее следующий символ для прочтения или значение -1, если доступных для чтения символов нет или поток не поддерживает поиск.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader.Peek%2A> Метод возвращает целочисленное значение, чтобы определить, произошла ли конец файла или другой ошибки. Это позволяет пользователям, сначала проверьте, является ли возвращенное значение -1 до приведения его в <xref:System.Char> типа.  
  
 Этот метод переопределяет метод <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 Текущее положение <xref:System.IO.StreamReader> объекта не изменяется <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 В следующем примере кода считывает строки из файла, пока не будет достигнут конец файла.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает следующий символ или следующий набор символов из входного потока.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет чтение следующего символа из входного потока и перемещает положение символа на одну позицию вперед.</summary>
        <returns>Следующий символ из входного потока, представленный в виде объекта <see cref="T:System.Int32" />, или значение -1, если больше нет доступных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Этот метод возвращает целое число, чтобы она может возвращать значение -1, если достигнут конец потока. Положение базового потока управления после считывания данных в буфер, положение базового потока, может не соответствовать позиции внутреннего буфера. Чтобы сбросить во внутреннем буфере, вызовите <xref:System.IO.StreamReader.DiscardBufferedData%2A> метода; тем не менее, этот метод снижает производительность и должен вызываться только в случае крайней необходимости.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода показано простое использование <xref:System.IO.StreamReader.Read%2A> метода.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 В следующем примере кода демонстрируется чтение одного символа с помощью <xref:System.IO.StreamReader.Read> перегрузка метода, форматирование вывода в виде десятичным и шестнадцатеричным представлением целого числа ASCII.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">При возвращении данного метода содержит заданный массив знаков, в котором значения в интервале между <c>index</c> и (<c>index + count – 1</c>) заменены знаками, считанными из текущего источника.</param>
        <param name="index">Индекс <c>buffer</c>, с которого требуется начать запись.</param>
        <param name="count">Максимальное число считываемых символов.</param>
        <summary>Считывает заданное максимальное количество символов из текущего потока в буфер начиная с заданного индекса.</summary>
        <returns>Число символов, которые были считаны, или значение 0, если к концу потока не было считано никаких данных. Это число будет не больше параметра <paramref name="count" />, в зависимости от доступности данных в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Этот метод возвращает целое число, чтобы она возвращает 0, если был достигнут конец потока.  
  
 При использовании <xref:System.IO.StreamReader.Read%2A> , он является более эффективно использовать буфер такого же размера, как и внутренний буфер потока, где внутреннего буфера равным желаемый размер блоков и всегда считывать меньше, чем размер блока. Если размер внутреннего буфера не был определен при создании потока, его размер по умолчанию — 4 килобайта (4096 байт). Положение базового потока управления после считывания данных в буфер, положение базового потока, может не соответствовать позиции внутреннего буфера. Чтобы сбросить во внутреннем буфере, вызовите <xref:System.IO.StreamReader.DiscardBufferedData%2A> метода; тем не менее, этот метод снижает производительность и должен вызываться только в случае крайней необходимости.  
  
 Этот метод возвращает после того, как число знаков, указанное в `count` параметра доступны для чтения, или достигнут конец файла. <xref:System.IO.TextReader.ReadBlock%2A> версия блокировки <xref:System.IO.StreamReader.Read%2A>.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода считывает пять символов во время, пока не будет достигнут конец файла.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Длина буфера минус <paramref name="index" /> меньше <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода, например "Поток закрыт".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">При возвращении этого метода содержит заданный массив символов, в котором значения в интервале от <c>index</c> до (<c>index</c> + <c>count</c> – 1) заменены символами, считанными из текущего источника.</param>
        <param name="index">Позиция в массиве <c>buffer</c>, с которой начинается запись.</param>
        <param name="count">Максимальное число считываемых символов. Если конец потока достигнут, прежде чем указанное количество символов записывается в буфер, возвращается текущий метод.</param>
        <summary>Асинхронно считывает указанное максимальное количество символов из текущего потока и записывает данные в буфер, начиная с заданного индекса.</summary>
        <returns>Задача, представляющая асинхронную операцию чтения. Значение параметра <paramref name="TResult" /> содержит общее число символов (в байтах), считанных в буфер. Результирующее значение может быть меньше запрошенного числа символов, если число доступных в данный момент символов меньше запрошенного числа, или результат может быть равен 0 (нулю), если достигнут конец потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задача завершается после того, как число знаков, указанное в `count` параметра доступны для чтения или не будет достигнут конец потока.  
  
   
  
## Examples  
 Приведенный ниже показано, как прочитать все символы в файле с помощью <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод. Он проверяет, является ли каждый символ буквы, цифры или символы-разделители перед добавлением символ экземпляр <xref:System.Text.StringBuilder> класса.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException">Сумма <paramref name="index" /> и <paramref name="count" /> больше, чем длина буфера.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток был удален.</exception>
        <exception cref="T:System.InvalidOperationException">Модуль чтения в настоящее время используется предыдущей операцией чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">При возвращении данного метода содержит заданный массив знаков, в котором значения в интервале между <c>index</c> и (<c>index + count – 1</c>) заменены знаками, считанными из текущего источника.</param>
        <param name="index">Позиция в массиве <c>buffer</c>, с которой начинается запись.</param>
        <param name="count">Максимальное число считываемых символов.</param>
        <summary>Считывает указанное максимальное количество символов из текущего потока и записывает данные в буфер, начиная с заданного индекса.</summary>
        <returns>Количество считанных символов. Число будет меньше или равно значению <paramref name="count" />, в зависимости от того, считаны ли все входящие символы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Положение базового потока, увеличивается число символов, считанных в `buffer`.  
  
 Метод блокируется, пока не будет `count` символы доступны для чтения, или достигнут конец потока. Это блокировки версия <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Длина буфера минус <paramref name="index" /> меньше <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.IO.StreamReader" /> закрыт.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">При возвращении этого метода содержит заданный массив символов, в котором значения в интервале от <c>index</c> до (<c>index</c> + <c>count</c> – 1) заменены символами, считанными из текущего источника.</param>
        <param name="index">Позиция в массиве <c>buffer</c>, с которой начинается запись.</param>
        <param name="count">Максимальное число считываемых символов. Если конец потока достигнут, прежде чем в буфер записано указанное количество символов, метод возвращает управление.</param>
        <summary>Асинхронно считывает указанное максимальное количество символов из текущего потока и записывает данные в буфер, начиная с заданного индекса.</summary>
        <returns>Задача, представляющая асинхронную операцию чтения. Значение параметра <paramref name="TResult" /> содержит общее число символов (в байтах), считанных в буфер. Результирующее значение может быть меньше запрошенного числа символов, если число доступных в данный момент символов меньше запрошенного числа, или результат может быть равен 0 (нулю), если достигнут конец потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задача не завершается до либо число знаков, указанное в `count` параметра доступны для чтения, или достигнут конец потока.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> или <paramref name="count" /> является отрицательным значением.</exception>
        <exception cref="T:System.ArgumentException">Сумма <paramref name="index" /> и <paramref name="count" /> больше, чем длина буфера.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток был удален.</exception>
        <exception cref="T:System.InvalidOperationException">Модуль чтения в настоящее время используется предыдущей операцией чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет чтение строки символов из текущего потока и возвращает данные в виде строки.</summary>
        <returns>Следующая строка из входного потока или значение <see langword="null" />, если достигнут конец входного потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка определяется как последовательность символов, за которым следует строка веб-канала («\n»), возврат каретки («\r») или знак возврата каретки, сразу за строка перевода («\r\n»). Возвращаемая строка не содержит завершающий символ возврата каретки или перевода строки. Возвращаемое значение — `null` если достигнут конец входного потока.  
  
 Этот метод переопределяет метод <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Если текущий метод вызывает <xref:System.OutOfMemoryException>, позиция средства чтения в основном потоке <xref:System.IO.Stream> объекта увеличивается число знаков, которое может считывать метод, но знаки, уже считанные во внутренний <xref:System.IO.StreamReader.ReadLine%2A> буфера не учитываются . Положение базового потока управления после считывания данных в буфер, положение базового потока, может не соответствовать позиции внутреннего буфера. Чтобы сбросить во внутреннем буфере, вызовите <xref:System.IO.StreamReader.DiscardBufferedData%2A> метода; тем не менее, этот метод снижает производительность и должен вызываться только в случае крайней необходимости.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода считывает строки из файла, пока не будет достигнут конец файла.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для выделения буфера под возвращаемую строку.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно выполняет чтение строки символов из текущего потока и возвращает данные в виде строки.</summary>
        <returns>Задача, представляющая асинхронную операцию чтения. Значение параметра <paramref name="TResult" /> содержит следующую строку из потока или значение <see langword="null" />, если все знаки прочитаны.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Приведенный ниже показано, как прочитать первую строку файла с помощью <xref:System.IO.StreamReader.ReadLineAsync> метод.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Количество символов в следующей строке больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток был удален.</exception>
        <exception cref="T:System.InvalidOperationException">Модуль чтения в настоящее время используется предыдущей операцией чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает все символы, начиная с текущей позиции до конца потока.</summary>
        <returns>Остальная часть потока в виде строки (от текущего положения до конца). Если текущее положение находится в конце потока, возвращается пустая строка ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> лучше всего работает, когда необходимо считать все входные данные, начиная с текущей позиции до конца потока. Если требуется больший контроль над количество символов, считанных из потока, используйте <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> перегруженный метод обычно обеспечивает лучшую производительность.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> предполагается, что знает, когда был достигнут конец потока. Для интерактивных протоколов, по которым сервер отправляет данные только в том случае, если запроса и не закрывает соединение <xref:System.IO.StreamReader.ReadToEnd%2A> может выполняться бесконечно, так как он не достигает end и его следует избегать.  
  
 Обратите внимание, что при использовании <xref:System.IO.StreamReader.Read%2A> , он является более эффективно использовать буфер такого же размера, как и внутренний буфер потока. Если размер буфера не был определен при создании потока, его размер по умолчанию — 4 килобайта (4096 байт).  
  
 Если текущий метод вызывает <xref:System.OutOfMemoryException>, позиция средства чтения в основном потоке <xref:System.IO.Stream> объекта увеличивается число знаков, которое может считывать метод, но знаки, уже считанные во внутренний <xref:System.IO.StreamReader.ReadLine%2A> буфера не учитываются . Положение базового потока управления после считывания данных в буфер, положение базового потока, может не соответствовать позиции внутреннего буфера. Чтобы сбросить во внутреннем буфере, вызовите <xref:System.IO.StreamReader.DiscardBufferedData%2A> метода; тем не менее, этот метод снижает производительность и должен вызываться только в случае крайней необходимости.  
  
 Список задач ввода-вывода см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере кода считывает вплоть до конца файла в одной операции.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для выделения буфера под возвращаемую строку.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает все символы, начиная с текущей позиции до конца потока, и возвращает их в виде одной строки.</summary>
        <returns>Задача, представляющая асинхронную операцию чтения. Значение параметра <paramref name="TResult" /> содержит строку с символами от текущего положения до конца потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Приведенный ниже показано, как считать содержимое файла с помощью <xref:System.IO.StreamReader.ReadToEndAsync> метод.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Количество символов больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Поток был удален.</exception>
        <exception cref="T:System.InvalidOperationException">Модуль чтения в настоящее время используется предыдущей операцией чтения.</exception>
      </Docs>
    </Member>
  </Members>
</Type>