<Type Name="ClaimsPrincipalPermission" FullName="System.IdentityModel.Services.ClaimsPrincipalPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="83e7d38da992c06fbcfa631ea8af70aebe6366f0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30419398" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClaimsPrincipalPermission : System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit ClaimsPrincipalPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClaimsPrincipalPermission&#xA;Implements IPermission, ISecurityEncodable, IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClaimsPrincipalPermission sealed : System::Security::IPermission, System::Security::ISecurityEncodable, System::Security::Permissions::IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет разрешение, которое использует реализацию <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" />, чтобы определить, следует ли дать доступ к ресурсу активному субъекту. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Класс предоставляет возможность выполнения проверки принудительного доступа с помощью <xref:System.Security.Claims.ClaimsAuthorizationManager> , настроенного для приложения. С помощью вызова <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> метод или статическое <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> метода, вы можете обеспечить защиту к ресурсам из пути выполнения кода в соответствии с политикой авторизации, определенный для диспетчера проверки подлинности утверждений. Проверку можно выполнить с помощью декларативной доступа <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute> класса.  
  
> [!IMPORTANT]
>  <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Класс с помощью диспетчера авторизации утверждений, настроенные с <xref:System.IdentityModel.Configuration.IdentityConfiguration> , заданной в разделе <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> свойство. Это верно во всех случаях, даже в случаях, когда WS-Federation не используется; Например active () веб-приложений WCF и консольных приложений. Можно указать диспетчера авторизации утверждений в конфигурации или программным путем. Чтобы использовать диспетчер авторизации утверждений в файле конфигурации, установите [ &lt;claimsAuthorizationManager&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager.md) элемента под [ &lt;identityConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/identityconfiguration.md) элемента и обеспечить ссылается эта конфигурация удостоверения [ &lt;federationConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration.md) элемент, который загружается средой выполнения (например, с параметр `identityConfigurationName` атрибута). Чтобы установить диспетчер авторизации утверждений программными средствами, добавьте обработчик для <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> события.  
  
 На одном уровне функциональные возможности, предоставляемые <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> похож на проверку доступа на основе ролей (RBAC), предоставленные с помощью <xref:System.Security.Permissions.PrincipalPermission> класса; Однако <xref:System.Security.Claims.ClaimsAuthorizationManager> класс выполняет проверку на основе утверждений, представленных активного участника. Это позволяет гораздо более гранулярности, чем доступно через чистые RBAC, где много разрешений обычно собираются в рамках одной роли. Возможно, что более важно, авторизации на основе утверждений включает лучшего разделения бизнес-логики и авторизации политика, так как для определенных действий на ресурс в коде можно затребовать разрешение и внутренней политики можно использовать для настройки какие утверждения Презентация сущности должны обладать для удовлетворения требования. Как RBAC <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> выполняет проверку доступа на основе пользователя, то есть, в отличие от управления доступом для кода реализован классами, которые являются производными от <xref:System.Security.CodeAccessPermission> класса и позволяет убедиться, что все вызывающие объекты кода были предоставлены разрешения, обход стека <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>выполняет проверку только на текущий участник.  
  
 Статический <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> метод выполняет проверку доступа для указанного действия в указанном ресурсе. Ресурс и действия представляют собой строки и обычно представляют собой URI. Можно также инициализировать экземпляр <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> с действие, ресурсов и вызов <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> метод. Несмотря на то, что конструктор принимает только один ресурс и действие, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> объектов могут быть объединены по <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> и <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> методы. Разрешение, созданные с помощью этих методов может содержать несколько пар действие ресурса.  
  
 Оба метода определяют доступ путем вызова <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> метод диспетчера авторизации утверждений, настроенный с <xref:System.Security.Claims.AuthorizationContext> , состоящие из активного участника (<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>), ресурс и действие. Они создают <xref:System.Security.SecurityException> Если текущий участник не авторизован для выполнения действия с ресурсом; в противном случае выполнение в дополнительной продолжается.  
  
 В случае использования <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> , содержащий несколько пар действие ресурса <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> метод вызывается для каждой пары действие ресурса, который содержится в разрешении.  Для вызова <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> для успешного выполнения, активный участник должен быть авторизован для всех пар действие ресурса в разрешение.  
  
   
  
## Examples  
 В следующем примере показано, как для защиты ресурса с помощью <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> метода <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> метод, или <xref:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute> объявления. В каждом случае настроенного <xref:System.Security.Claims.ClaimsAuthorizationManager> вызывается для вычисления текущего участника для указанного ресурса и действия. Если текущий участник не авторизован для указанного действия с указанным ресурсом <xref:System.Security.SecurityException> будет вызываться исключение; в противном случае выполнение продолжается.  
  
 [!code-csharp[WifCppWithCam#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#1)]  
  
 Следующий код XML показывает минимальная конфигурация, необходимая для использования авторизации настраиваемые утверждения диспетчер с <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> класса. Необходимо как минимум, объявить оба `system.identityModel` и `system.identityModel.services` разделы в `<configSection>` элемент и укажите ваш диспетчера авторизации в [ &lt;claimsAuthorizationManager&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/claimsauthorizationmanager.md)элемент Конфигурация по умолчанию удостоверение. Это позволит гарантировать, что ссылки на ваш диспетчера авторизации из конфигурации федерации по умолчанию. Кроме того, можно указать имя конфигурации удостоверение, под которой ваш диспетчера авторизации указывается в `identityConfigurationName` атрибут [ &lt;federationConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/federationconfiguration.md) элемента.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <configSections>  
    <!-- WIF configuration sections -->  
    <section name="system.identityModel" type="System.IdentityModel.Configuration.SystemIdentityModelSection, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
    <section name="system.identityModel.services" type="System.IdentityModel.Services.Configuration.SystemIdentityModelServicesSection, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=B77A5C561934E089"/>  
  </configSections>  
  
  <startup>  
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
  </startup>  
  
  <system.identityModel>  
    <identityConfiguration>  
      <claimsAuthorizationManager type ="MyClaimsAuthorizationManager.MyClaimsAuthorizationManager, MyClaimsAuthorizationManager"/>  
    </identityConfiguration>  
  </system.identityModel>  
  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Services.ClaimsPrincipalPermissionAttribute" />
    <altmember cref="P:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration" />
    <altmember cref="T:System.Security.Claims.ClaimsAuthorizationManager" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ClaimsPrincipalPermission (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ClaimsPrincipalPermission(System::String ^ resource, System::String ^ action);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">Ресурс, на котором должен быть авторизован субъект.</param>
        <param name="action">Действие, для которого должен быть авторизован субъект.</param>
        <summary>Создает новый экземпляр класса <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> Объект инициализируется с помощью указанного ресурса и действия. Можно вызвать <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> метод, чтобы выполнить проверку доступа.  
  
 Несмотря на то, что конструктор принимает только один ресурс и действие, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> объектов могут быть объединены по <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> и <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> методы. Разрешение, созданные с помощью этих методов может содержать несколько пар действие ресурса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="resource" /> имеет значение <see langword="null" /> или является пустой строкой.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="action" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public static void CheckAccess (string resource, string action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CheckAccess(string resource, string action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CheckAccess (resource As String, action As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CheckAccess(System::String ^ resource, System::String ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="action" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resource">Ресурс, на котором должен быть авторизован субъект.</param>
        <param name="action">Действие, для которого должен быть авторизован субъект.</param>
        <summary>Проверяет, является ли текущий субъект авторизованным для выполнения указанного действия с указанным ресурсом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Участник должен быть авторизован для указанного действия с указанным ресурсом или <xref:System.Security.SecurityException> исключения.  
  
 <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> Будет вызван метод диспетчера авторизации утверждений, настроенный с <xref:System.Security.Claims.AuthorizationContext> , состоящие из активного участника (<xref:System.Threading.Thread.CurrentPrincipal%2A>), ресурс и действие.  
  
   
  
## Examples  
 В следующем примере показано, как для защиты ресурса с помощью <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.CheckAccess%2A> метод. Диспетчер авторизации утверждений настроенных вызывается для вычисления текущего участника для указанного ресурса и действия. Если текущий участник не авторизован для указанного действия с указанным ресурсом <xref:System.Security.SecurityException> будет вызываться исключение; в противном случае выполнение продолжается.  
  
 [!code-csharp[WifCppWithCam#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий субъект не может быть назначен из объекта <see cref="T:System.Security.Claims.ClaimsPrincipal" />.  
  
 - или -  
  
 <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> не настроен.</exception>
        <exception cref="T:System.Security.SecurityException">Проверка авторизации завершилась с ошибкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2103:ReviewImperativeSecurity", Justification="It is expected that the runtime’s behavior would rely on changing data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает копию текущего экземпляра <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</summary>
        <returns>Объект <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, скопированный из текущего экземпляра.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, является ли текущий субъект авторизованным для пар ресурс-действие, связанных с текущим экземпляром.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий участник должен быть авторизован для всех пар действие ресурса, связанного с этим экземпляром или <xref:System.Security.SecurityException> исключения.  
  
 Несмотря на то, что конструктор принимает только один ресурс и действие, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission> объектов могут быть объединены по <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Union%2A> и <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect%2A> методы. Разрешение, созданные с помощью этих методов может содержать несколько пар действие ресурса.  
  
 <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> Вызывает метод <xref:System.Security.Claims.ClaimsAuthorizationManager.CheckAccess%2A?displayProperty=nameWithType> метод диспетчера авторизации утверждений, настроенный с <xref:System.Security.Claims.AuthorizationContext> , состоящие из активного участника (<xref:System.Threading.Thread.CurrentPrincipal%2A>), ресурс и действие для каждой пары действие ресурса содержится в разрешение. Для <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> для успешного выполнения активных участника должен быть авторизован для всех пар действие ресурсов, содержащихся в разрешении.  
  
   
  
## Examples  
 В следующем примере показано, как для защиты ресурса с помощью <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> метод. Диспетчер авторизации утверждений настроенных вызывается для вычисления текущего участника для указанного ресурса и действия. Если текущий участник не авторизован для указанного действия с указанным ресурсом <xref:System.Security.SecurityException> будет вызываться исключение; в противном случае выполнение продолжается.  
  
 [!code-csharp[WifCppWithCam#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcppwithcam/cs/wifcppwithcam/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий субъект не может быть назначен из объекта <see cref="T:System.Security.Claims.ClaimsPrincipal" />.  
  
 - или -  
  
 <see cref="T:System.Security.Claims.ClaimsAuthorizationManager" /> не настроен.</exception>
        <exception cref="T:System.Security.SecurityException">Проверка авторизации завершилась с ошибкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public void FromXml (System.Security.SecurityElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXml (element As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void FromXml(System::Security::SecurityElement ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="element">Кодировка XML, используемая для восстановления разрешения.</param>
        <summary>Восстанавливает текущее разрешение и его состояние из указанного XML-кодирования.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Восстанавливает разрешение из кодировки XML, созданные с помощью вызова <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="element" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Кодировка содержит нераспознанные элементы или атрибуты или неправильно сформированный XML-код.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Разрешение, которое должно пересекаться с текущим разрешением. Должен быть экземпляром <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</param>
        <summary>Возвращает разрешение, представляющее пересечение объединение текущего и заданного разрешений.</summary>
        <returns>Новый объект <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, представляющий пересечение текущего и заданного разрешений; либо значение <see langword="null" />, если <paramref name="target" /> имеет значение <paramref name="null" /> или не является экземпляром <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Разрешение, которое возвращается имеет только пары действие ресурса, которые присутствовали в текущего разрешения и указанного разрешения. Действие ресурса пары, которые существовали в только одно из них разрешения, не включаются. Для <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> для успешного выполнения на новое разрешение, текущий участник только должен быть авторизован для пары действие ресурса, которые были распространены для текущего разрешения и указанного разрешений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Разрешение, для которого требуется проверить отношение подмножества. Должен быть экземпляром <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</param>
        <summary>Возвращает значение, указывающее, является ли текущее разрешение подмножеством заданного разрешения.</summary>
        <returns>
          Значение <see langword="true" />, если текущее разрешение является подмножеством заданного разрешения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущее разрешение является подмножеством указанного разрешения, если все пары действие ресурсов, содержащихся в текущем разрешении также присутствуют в заданном разрешении. Если `target` — `null` или не является экземпляром <xref:System.IdentityModel.Services.ClaimsPrincipalPermission>, <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.IsSubsetOf%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли разрешение неограниченным.</summary>
        <returns>
          Значение <see langword="true" />, если разрешение является неограниченным. В противном случае — значение <see langword="false" />. Всегда возвращает значение <see langword="true" />, указывающее, что разрешение неограниченное.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает XML в формате текущего разрешения и его состояние.</summary>
        <returns>XML в формате текущего разрешения и его состояние.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Участнику можно восстановить из формы XML-кодировке, вызвав <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.FromXml%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.ClaimsPrincipalPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Разрешение, используемое в сочетании с текущим разрешением. Он должен иметь тип <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</param>
        <summary>Возвращает новое разрешение, представляющее объединение текущего и заданного разрешений. Объект <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, который содержит все пары ресурс-действие, присутствующие в текущем экземпляре и целевом экземпляре.</summary>
        <returns>Новый объект <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />, представляющий объединение текущего и заданного разрешений; либо значение <see langword="null" />, если <paramref name="target" /> имеет значение <paramref name="null" /> или не является экземпляром <see cref="T:System.IdentityModel.Services.ClaimsPrincipalPermission" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имеет разрешение, которое возвращается все пары действие ресурса, которые присутствуют в текущее разрешение и все пары действие ресурса, предоставление указанного разрешения. Для <xref:System.IdentityModel.Services.ClaimsPrincipalPermission.Demand%2A> для успешного выполнения на новое разрешение, текущий участник должен быть авторизован для всех пар действие ресурса, которые существовали в текущее разрешение и всех пар действие ресурса, которые существовали в указанное разрешение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>