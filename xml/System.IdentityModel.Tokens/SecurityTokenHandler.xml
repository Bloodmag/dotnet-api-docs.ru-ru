<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24ee9e0178965939d224c31ccbd71a445222d09c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36480600" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Абстрактный базовый класс для обработчиков токенов безопасности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Класс — это базовый класс, производными от которого все параметры безопасности обработчиков маркеров. Обработчик маркеров безопасности отвечает за:  
  
-   Проверку маркеров безопасности (<xref:System.IdentityModel.Tokens.SecurityToken>) типа, он предназначен для процесса и утверждения, содержащиеся в маркере в упаковку <xref:System.Security.Claims.ClaimsIdentity> объекта.  
  
-   Сериализацию и десериализацию маркеров безопасности типа он предназначен для обработки.  
  
-   Сериализация и десериализация предложений идентификатора ключа (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), указывают на маркеры предназначен для обработки в и из типа `<wsse:SecurityTokenReference>` элементов.  
  
-   Создание токены безопасности от <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> объекта, передаваемого по реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
-   Создание предложений идентификатора ключа с токеном безопасности для реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 Windows Identity Foundation (WIF) поставляется следующие обработчики токенов безопасности без дополнительной настройки:  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 Большинство из этих классов предоставляют дополнительные элементы, которые реализуют функции, связанные с обработкой токены, для которых класс предназначен. Во многих случаях может быть лучше являются производными от одного из этих классов, а не непосредственно из <xref:System.IdentityModel.Tokens.SecurityTokenHandler> класса.  
  
 Обработчик маркеров безопасности можно добавлять или удалять из коллекции, обработчик маркеров, указав [ &lt;добавить&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;удалить&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md), или [ &lt;снимите&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) элементы [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) элемент в файле конфигурации. <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> Объект, содержащий параметры конфигурации в коллекцию обработчиков может осуществляться через <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойство и коллекцию обработчиков, членом которых является обработчик токенов может осуществляться из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> свойство. Можно переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> метод для обработки все пользовательские элементы конфигурации, который принимает обработчиком.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Класс предоставляет несколько свойств и методов. В зависимости от реализации функциональных возможностей можно переопределить некоторые или все из этих элементов.  
  
 Необходимо переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> свойство и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> метод для предоставления инфраструктуры WIF со сведениями о тип маркера безопасности, класс предназначен для обработки.  
  
 Проверка, сериализации и десериализации функциональность предоставляется через свойства или методы, которые указывают, может ли обработчик выполнять определенную функцию в сочетании с метод или методы, которые реализуют функции. Следующий список пар свойства или методы, которые указывают на функции с методами, которые реализуют эти функциональные возможности:  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> Свойство и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод: проверяет токен и пакеты утверждений, содержащихся в маркере в <xref:System.Security.Claims.ClaimsIdentity>.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Свойство и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> методов: токен сериализации.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> Методы и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> методов: токен десериализации.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> Метод и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> метод: десериализации предложения идентификатора ключа.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> Метод и <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> метод: сериализация предложений идентификатора ключа.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> И <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> методы вызываются из конвейера в реализациях <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> Метод вызывается инфраструктурой WIF, чтобы определить, является ли указанный токен уже получен. По умолчанию этот метод возвращает `false`, указывающая, что маркер уже не был получен. Можно переопределить метод и предоставить логику для воспроизводимой маркеры.  
  
   
  
## Examples  
 В примерах кода во всех <xref:System.IdentityModel.Tokens.SecurityTokenHandler> разделы взяты из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md). Следующий код XML показано, как добавить в коллекцию обработчиков токенов обработчик маркеров SWT.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Вызывается из конструкторов в производных классах для инициализации класса <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе. Средство чтения не должно предваряться этим методом.</param>
        <summary>Возвращает значение, указывающее, является ли элемент xml, на которое ссылается указанное средство чтения XML, предложением идентификатора ключа, которое может десериализоваться этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `false` для указания, что не удается прочитать предложение идентификатора ключа.  
  
 Производном классе проверяет элемент, который ссылается средство чтения, чтобы определить, может ли экземпляр выполнить десериализацию конструкции идентификатора ключа. Обычно это выполняется путем вызова <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> метод с соответствующие строки элемента и пространства имен указан. При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> метод для предоставления логики для десериализации предложения идентификатора ключа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, показывающее, может ли указанный токен десериализоваться как токен типа, обработанного этим экземпляром.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Строка токена для чтения</param>
        <summary>Возвращает значение, показывающее, может ли указанная строка десериализоваться как токен типа, обработанного этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 При переопределении этого метода необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод для предоставления логики для десериализации маркер.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе. Средство чтения не должно предваряться этим методом.</param>
        <summary>Возвращает значение, указывающее, является ли элемент xml, на которое ссылается указанное средство чтения XML, считываемым, как токен типа, обрабатываемого этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" /> может считывать элемент; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 Производном классе проверяет элемент, который ссылается средство чтения, чтобы определить, является ли экземпляр может десериализовать маркер безопасности. Обычно это выполняется путем вызова <xref:System.Xml.XmlReader.IsStartElement%2A> метод с соответствующие строки элемента и пространства имен указан. При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метода или <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод для предоставления логики для десериализации предложения идентификатора ключа.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> метод, чтобы определить, можно ли выполнить считывание токена обработчиком. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли этот обработчик поддерживать проверку токенов безопасности.</summary>
        <value>Значение <see langword="true" />, если класс может проверять токены безопасности; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для проверки реализации в производном классе, переопределять это свойство для возврата `true` и Переопределите <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод, чтобы реализовать логику проверки.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> свойство для указания пользовательского обработчика можно проверить правильность токенов. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Предложение идентификатора ключа для проверки.</param>
        <summary>Возвращает значение, показывающее, может ли указанная конструкция идентификатора ключа быть сериализована этим экземпляром.</summary>
        <returns>Значение <see langword="true" />, если можно сериализовать конструкцию идентификатора ключа; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию всегда возвращает значение `false`.  
  
 При переопределении <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>, необходимо также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> метод для предоставления логики для сериализации конструкции идентификатора ключа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли этот обработчик сериализовать токены безопасности.</summary>
        <value>
          <see langword="true" />, если класс может выполнять сериализацию токенов; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для сериализации реализации в производном классе, переопределять это свойство для возврата `true` и Переопределите <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> методы для реализации логики сериализации.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство, указывающее, что пользовательский обработчик может сериализовать маркеры. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" />, который предоставляет конфигурацию для текущего экземпляра.</summary>
        <value>Объект конфигурации для текущего экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> Свойство обычно задается с помощью конфигурации инфраструктуры из [ &lt;securityTokenHandlerConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) элемент в файле конфигурации во время применения запуска.  
  
 В производных классах, используйте <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойство для доступа к параметрам конфигурации, например реестр имен поставщиков для использования в <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод может осуществляться из <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> свойства объекта конфигурации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию обработчиков токена, содержащую текущий экземпляр.</summary>
        <value>коллекция обработчиков токена, содержащая текущий экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При добавлении обработчика токенов <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> экземпляра, это свойство автоматически устанавливается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">Токен, для которого требуется создать ссылку.</param>
        <param name="attached">Значение <see langword="true" />, если должна быть создана присоединенная ссылка; значение <see langword="false" />, если должна быть создана неприсоединенная ссылка.</param>
        <summary>При переопределении в производном классе создает ссылку токена безопасности для токенов, обрабатываемых этим классом. Этот метод обычно вызывается службой токенов безопасности (STS).</summary>
        <returns>Предложение идентификатора ключа, ссылающееся на указанный токен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Производные классы переопределять этот метод для возврата конструкции идентификатора ключа (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), может быть использован для создания `<wsse:SecurityTokenReference>` элемента для указанного токена.  
  
 Вызывается из реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
 Как правило <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> не нужно будет использовать только при создании пользовательской службы маркеров безопасности. Когда служба маркеров безопасности возвращает маркер безопасности, выданный маркер безопасности содержит ссылки на прикрепленные и неприкрепленные маркеры безопасности. Прикрепленные ссылки указывают на маркеры безопасности, содержащиеся в заголовке безопасности сообщения SOAP, а неприкрепленные ссылки указывают на маркеры безопасности, не входящие в заголовок безопасности сообщения SOAP. Обычно эти ссылки подтверждают подлинность выданного маркера безопасности.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> метод, чтобы создать предложение идентификатора ключа с указанным токеном. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Дескриптор токена безопасности, на основании которого создается токен. Свойства дескриптора токена задаются до вызова этого метода.</param>
        <summary>При переопределении в производном классе создает токен безопасности с помощью заданного дескриптора токена. Этот метод вызывается службой токенов безопасности (STS).</summary>
        <returns>токен безопасности, соответствующий свойствам дескриптора токена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Вызывается из реализации <xref:System.IdentityModel.SecurityTokenService> класса.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> метод для создания и возвращает маркер из маркера дескриптора. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для проверки воспроизведения.</param>
        <summary>При переопределении в производном классе вызывает исключение, если обнаруживается, что указанный токен используется повторно.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию не выполняет никаких действий.  
  
 Производные классы должны вызывать <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> Если токен уже используется.  
  
 Windows Identity Foundation (WIF) предоставляет <xref:System.IdentityModel.Tokens.TokenReplayCache> какие воспроизведения кэши могут быть производными от класса и [ &lt;tokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) элемента конфигурации, который можно использовать для настройки кэш воспроизведения, используемых обработчиков маркеров в приложении; Тем не менее конкретная реализация данных <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> метод зависит от конструктора производного класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает набор универсальных кодов ресурса (URI), которые используются в запросах для идентификации токена обрабатываемого этим классом типа.</summary>
        <returns>Набор универсальных кодов ресурсов (URI), определяющих тип токенов, поддерживаемый этим обработчиком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> Токена, обрабатываемым текущим экземпляром осуществляется с помощью <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> свойство. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> Метод возвращает набор допустимых идентификаторов, которые могут использоваться в сообщениях для ссылки на тип маркера. Например, значение URI используется в `<wst:TokenType>` элемента под `<wst:RequestSecurityToken>` элемент для запроса определенного типа маркера (представленного <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> свойства в модели объектов).  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> метод для возврата идентификаторов тип маркера для пользовательского маркера. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">XML-элемент конфигурации. Каждый узел в списке имеет тип <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>При переопределении в производном классе загружает пользовательскую конфигурацию из XML-кода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> Метод вызывается инфраструктурой конфигурации. При вызове этого метода `nodelist` будет содержать верхнего уровня дочерних элементов этого обработчика токенов [ &lt;добавить&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) элемент из файла конфигурации. Каждый из них может в свою очередь, содержат атрибуты или дочерние элементы в зависимости от схемы конфигурации, определенных для производного класса.  
  
 Реализация по умолчанию создает <xref:System.NotImplementedException>. Переопределите этот метод в производном классе позволяет включить инициализацию из файла конфигурации обработчика маркеров безопасности.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, расположенный в начальном элементе XML, который десериализуется в предложение идентификатора ключа.</param>
        <summary>При переопределении в производном классе десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в конструкцию идентификатора ключа, который ссылается на токен, обрабатываемый производным классом.</summary>
        <returns>Предложение идентификатора ключа, десериализованное из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для десериализации предложения идентификатора ключа из XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе десериализует заданный XML-код в токен обрабатываемого этим производным классом типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Строка, подлежащая десериализации.</param>
        <summary>При переопределении в производном классе десериализует заданную строку в токен обрабатываемого этим производным классом типа.</summary>
        <returns>Токен безопасности, который был десериализован из указанной строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Вызов этого метода с недоверенными данными представляет угрозу безопасности. Этот метод используется только с надежными данными. Дополнительные сведения см. в разделе [проверки данных](https://www.owasp.org/index.php/Data_Validation).  
  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод для предоставления функциональных возможностей, который может десериализовать маркер безопасности из строки. При переопределении, этот метод необходимо переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе токена.</param>
        <summary>При переопределении в производном классе десериализует десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в токен обрабатываемого этим производным классом типа.</summary>
        <returns>Токен безопасности, который был десериализован из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Вызов этого метода с недоверенными данными представляет угрозу безопасности. Этот метод используется только с надежными данными. Дополнительные сведения см. в разделе [проверки данных](https://www.owasp.org/index.php/Data_Validation).  
  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для десериализации маркера безопасности из XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод. Как правило, в производных классах, если метод не удается выполнить десериализацию маркера из XML, на которую указывает ссылка, он выдает <xref:System.Xml.XmlException>.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> метод для чтения пользовательский маркер из указанного средства чтения XML. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения XML, размещаемое на начальном элементе токена.</param>
        <param name="tokenResolver">сопоставитель токена, содержащий внештатные и кэшированных токены.</param>
        <summary>При переопределении в производном классе десериализует XML-код, на который имеется ссылка в указанном модуле чтения XML, в токен, обрабатываемый производным классом, путем использования заданного сопоставителя токенов.</summary>
        <returns>Токен безопасности, который был десериализован из XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Вызов этого метода с недоверенными данными представляет угрозу безопасности. Этот метод используется только с надежными данными. Дополнительные сведения см. в разделе [проверки данных](https://www.owasp.org/index.php/Data_Validation).  
  
 Реализация по умолчанию не обрабатывает `tokenResolver` параметр и делегирует вызов <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> метод.  
  
 Переопределите этот метод, чтобы предоставить логику для десериализации маркера безопасности из XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> метод. Как правило, в производных классах, если метод не удается выполнить десериализацию маркера из XML, на которую указывает ссылка, он выдает <xref:System.Xml.XmlException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает тип токена безопасности, обрабатываемого этим экземпляром.</summary>
        <value>Тип токена безопасности, обрабатываемого этим экземпляром.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо переопределить это свойство в производных классах и вернуть <xref:System.Type> маркера безопасности (<xref:System.IdentityModel.Tokens.SecurityToken>), обрабатываемого производного класса.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> возвращаемое свойство <xref:System.Type> маркеров безопасности, которые обрабатываются пользовательского обработчика. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Токен безопасности, который проверяется.</param>
        <param name="errorMessage">Сообщение для записи в трассировку.</param>
        <summary>Трассирует событие сбоя во время проверки токенов безопасности, если трассировка включена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует вызывать из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод при сбое проверки токена.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Проверенный токен.</param>
        <summary>Трассирует успешную проверку событий токен безопасности, если трассировка включена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует вызывать из <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод после успешной проверки токена.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для проверки.</param>
        <summary>При переопределении в производном классе проверяет указанный токен безопасности. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <returns>Идентификаторы, содержащееся в токене.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Метод вызывается инфраструктурой для проверки и извлечения утверждений из токена десериализованный безопасности. Эти утверждения возвращаются в коллекции <xref:System.Security.Claims.ClaimsIdentity> объекты, возвращаемые этим методом. В типичных ситуаций эта коллекция будет содержать одно удостоверение.  
  
 В производных классах проверки обычно включает в себя проверка целевая аудитория, указанный в токене для аудитории, кодов URI, заданных в <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> свойства объекта конфигурации обработчика токенов, указанные на <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойство. Эти URI обычно задаются в файле конфигурации в разделе [ &lt;audienceUris&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) элемента. Если не удается проверить аудитории, <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> создавалось исключение.  
  
 При обработке лексемы, издателя обычно проверяется путем передачи маркера издателя к одному из <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> методы <xref:System.IdentityModel.Tokens.IssuerNameRegistry> , настроенный для обработчика через <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> свойство. Реестр имен поставщиков обычно настраивается с помощью [ &lt;issuerNameRegistry&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) элемент в файле конфигурации. <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> Возвращает имя издателя. Это имя должно использоваться для задания <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> свойство в утверждения, содержащиеся в маркере. Если реестр имен поставщиков не содержит запись для маркера издателя <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> возвращает `null`. В этом случае <xref:System.IdentityModel.Tokens.SecurityTokenException> обычно вызывается в производных классах, но это поведение зависит от конструктора класса.  
  
   
  
## Examples  
 В следующем коде показано переопределение <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод обработчика маркеров безопасности, обрабатывающего простой веб-токены (SWT). Код будет браться из `CustomToken` образца. Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 В следующем коде показано `CreateClaims` метод, вызываемый из переопределение метода <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метод в предыдущем примере. Этот метод возвращает <xref:System.Security.Claims.ClaimsIdentity> объект, созданный на основе утверждений в токене. Код будет браться из `CustomToken` образца. Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 В следующем коде показано `ValidateSignature` метод, вызываемый из переопределение метода <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода в обработчик маркеров простой веб. Этот метод проверяет подпись токена с помощью настроенного <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. Код будет браться из `CustomToken` образца. Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 В следующем коде показано `ValidateAudience` метод, вызываемый из переопределение метода <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> метода в обработчик маркеров простой веб. Этот метод проверяет audience, содержащиеся в маркере для аудитории URI, которые были указаны в конфигурации. Код будет браться из `CustomToken` образца. Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Модуль записи XML.</param>
        <param name="securityKeyIdentifierClause">Конструкция идентификатора ключа для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанную конструкцию идентификатора ключа в формат XML. Предложения идентификатора ключа должно иметь тип, поддерживаемый производным классом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для сериализации конструкции идентификатора ключа в XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности. Токен должен иметь тип, обрабатываемый производным классом.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Токен для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности в строку. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <returns>Сериализованный токен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для сериализации маркера безопасности в XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Модуль записи XML.</param>
        <param name="token">Токен для сериализации.</param>
        <summary>При переопределении в производном классе сериализует указанный токен безопасности в формат XML. Токен должен иметь тип, обрабатываемый производным классом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию этот метод создает исключение <xref:System.NotImplementedException> исключение.  
  
 Переопределите этот метод, чтобы предоставить логику для сериализации маркера безопасности в XML. При переопределении этого метода следует также переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> свойство.  
  
   
  
## Examples  
 Следующий код показывает, как переопределить <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> метод сериализации пользовательский маркер. Код будет браться из `Custom Token` образца. В этом примере пользовательские классы, позволяющие обработки токены Simple Web (SWT). Сведения в этом примере и другие примеры для WIF и где можно загрузить их см. в разделе [индекс образцов кода WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>