<Type Name="Queryable" FullName="System.Linq.Queryable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13719170e2133e7fbb42e8ece41222c4d8008027" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37651815" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Queryable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Queryable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Queryable" />
  <TypeSignature Language="VB.NET" Value="Public Module Queryable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Queryable abstract sealed" />
  <TypeSignature Language="F#" Value="type Queryable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Queryable</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides a set of <see langword="static" /> (<see langword="Shared" /> in Visual Basic) methods for querying data structures that implement <see cref="T:System.Linq.IQueryable`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Набор методов, объявленных в <xref:System.Linq.Queryable> класс предоставляет реализацию стандартные операторы запросов для выполнения запросов к данным источников, реализующие <xref:System.Linq.IQueryable%601>. Стандартные операторы запросов представляют методами общего назначения, которые следуют [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] шаблонов и позволяют данных в любом языке операции обхода, фильтрации и проекции. На основе NET язык программирования.  
  
 Большинство методов в классе определяются как методы расширения, которые расширяют <xref:System.Linq.IQueryable%601> типа. Это означает, что их можно вызывать как метод экземпляра для любого объекта, который реализует <xref:System.Linq.IQueryable%601>. Эти методы, расширяющие <xref:System.Linq.IQueryable%601> выполните любые непосредственных запросов. Вместо этого их функциональные возможности для построения <xref:System.Linq.Expressions.Expression> объект, являющийся дерево выражения, представляющее собой совокупное запрос. Методы передать новое дерево выражений либо <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод или <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод ввода <xref:System.Linq.IQueryable%601>. Вызываемый метод зависит от того <xref:System.Linq.Queryable> метод возвращает одноэлементное значение, в этом случае <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> вызывается или имеет перечисляемые результаты в этом случае <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> вызывается.  
  
 Фактическое выполнение запроса на целевых данных осуществляется класс, реализующий <xref:System.Linq.IQueryable%601>. Исходя из предположения любого <xref:System.Linq.IQueryable%601> реализации является то, что в результате выполнения дерева выражений, которое было создано с <xref:System.Linq.Queryable> методов стандартных операторов запросов эквивалентно результат вызова соответствующего метода <xref:System.Linq.Enumerable> класс, если источник данных представляет <xref:System.Collections.Generic.IEnumerable%601>.  
  
 В дополнение к методы стандартных операторов запросов, которые работают с <xref:System.Linq.IQueryable%601> объектов, этот класс также содержит метод <xref:System.Linq.Queryable.AsQueryable%2A>, какие типы <xref:System.Collections.IEnumerable> объектов как <xref:System.Linq.IQueryable> объектов.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TSource,TSource&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IQueryable(Of TSource), func As Expression(Of Func(Of TSource, TSource, TSource))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TSource, TSource&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Source, 'Source&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TSource,TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence to aggregate over.</param>
        <param name="func">An accumulator function to apply to each element.</param>
        <summary>Applies an accumulator function over a sequence.</summary>
        <returns>The final accumulator value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является, указанную функцию, `func`, применяется к каждому значению в исходной коллекции и накопленных возвращаемое значение. Первое значение в `source` используется в качестве начального значения для совокупное значение, соответствующее первому параметру в `func`.  
  
 Чтобы упростить общие операции статистической обработки, набор стандартных операторов запросов также включает два метода инвентаризации, <xref:System.Linq.Queryable.Count%2A> и <xref:System.Linq.Queryable.LongCount%2A>и четыре метода числовые статистической обработки, а именно <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>и <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> для создания предложения на основе массива строк.  
  
 [!code-csharp[System.Linq.Queryable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#1)]
 [!code-vb[System.Linq.Queryable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="func" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``2(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate))) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; -&gt; 'Accumulate" Usage="System.Linq.Queryable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TAccumulate">Тип агрегатного значения.</typeparam>
        <param name="source">A sequence to aggregate over.</param>
        <param name="seed">The initial accumulator value.</param>
        <param name="func">An accumulator function to invoke on each element.</param>
        <summary>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.</summary>
        <returns>The final accumulator value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является, указанную функцию, `func`, применяется к каждому значению в исходной коллекции и накопленных возвращаемое значение. `seed` Параметр используется в качестве начального значения для совокупное значение, соответствующее первому параметру в `func`.  
  
 Чтобы упростить общие операции статистической обработки, набор стандартных операторов запросов также включает два метода инвентаризации, <xref:System.Linq.Queryable.Count%2A> и <xref:System.Linq.Queryable.LongCount%2A>и четыре метода числовые статистической обработки, а именно <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>и <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> для применения Агрегатная функция, если начальное значение в функцию.  
  
 [!code-csharp[System.Linq.Queryable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#2)]
 [!code-vb[System.Linq.Queryable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="func" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TAccumulate, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``3(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate)), selector As Expression(Of Func(Of TAccumulate, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Aggregate (source, seed, func, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TAccumulate">Тип агрегатного значения.</typeparam>
        <typeparam name="TResult">Тип результирующего значения.</typeparam>
        <param name="source">A sequence to aggregate over.</param>
        <param name="seed">The initial accumulator value.</param>
        <param name="func">An accumulator function to invoke on each element.</param>
        <param name="selector">A function to transform the final accumulator value into the result value.</param>
        <summary>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.</summary>
        <returns>The transformed final accumulator value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является, указанную функцию, `func`, применяется к каждому значению в исходной коллекции и накопленных возвращаемое значение. `seed` Параметр используется в качестве начального значения для совокупное значение, соответствующее первому параметру в `func`. Конечное совокупное значение передается `selector` для получения результирующего значения.  
  
 Чтобы упростить общие операции статистической обработки, набор стандартных операторов запросов также включает два метода инвентаризации, <xref:System.Linq.Queryable.Count%2A> и <xref:System.Linq.Queryable.LongCount%2A>и четыре метода числовые статистической обработки, а именно <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>и <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> для применения Агрегатная функция и Селектор результата.  
  
 [!code-csharp[System.Linq.Queryable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#3)]
 [!code-vb[System.Linq.Queryable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="func" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.All``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence whose elements to test for a condition.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Determines whether all the elements of a sequence satisfy a condition.</summary>
        <returns>
          <see langword="true" /> if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации `source` тип параметра. Ожидаемым поведением является проверка, если все элементы в `source` удовлетворяла условию, в `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> для определения ли все элементы последовательности удовлетворяют условию.  
  
 [!code-csharp[System.Linq.Queryable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#4)]
 [!code-vb[System.Linq.Queryable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#4)]  
  
 Логическое значение, которое <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> метод возвращает, как правило, используется в предикате `where` предложение (`Where` предложение в Visual Basic) или прямой вызов <xref:System.Linq.Queryable.Where%2A> метод. В следующем примере показано такое использование `All` метод.  
  
 [!code-csharp[System.Linq.Queryable#134](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#134)]
 [!code-vb[System.Linq.Queryable#134](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#134)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determines whether any element of an <see cref="T:System.Linq.IQueryable`1" /> sequence exists or satisfies a condition.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence to check for being empty.</param>
        <summary>Determines whether a sequence contains any elements.</summary>
        <returns>
          <see langword="true" /> if the source sequence contains any elements; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является проверка, если `source` содержит какие-либо элементы.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для определения, содержит ли последовательность какие-либо элементы.  
  
 [!code-csharp[System.Linq.Queryable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#5)]
 [!code-vb[System.Linq.Queryable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#5)]  
  
 Логическое значение, которое <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> метод возвращает, как правило, используется в предикате `where` предложение (`Where` предложение в Visual Basic) или прямой вызов <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> метод. В следующем примере показано такое использование `Any` метод.  
  
 [!code-csharp[System.Linq.Queryable#135](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#135)]
 [!code-vb[System.Linq.Queryable#135](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#135)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence whose elements to test for a condition.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Determines whether any element of a sequence satisfies a condition.</summary>
        <returns>
          <see langword="true" /> if any elements in the source sequence pass the test in the specified predicate; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является проверка, если какие-либо элементы `source` удовлетворяют условию, указанному `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> для определения, является ли любой элемент в последовательности удовлетворяют условию.  
  
 [!code-csharp[System.Linq.Queryable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#6)]
 [!code-vb[System.Linq.Queryable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Append``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Append(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable AsQueryable (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable AsQueryable(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable (source As IEnumerable) As IQueryable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable ^ AsQueryable(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : System.Collections.IEnumerable -&gt; System.Linq.IQueryable" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence to convert.</param>
        <summary>Converts an <see cref="T:System.Collections.IEnumerable" /> to an <see cref="T:System.Linq.IQueryable" />.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable" /> that represents the input sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип `source` реализует <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%28System.Collections.IEnumerable%29> возвращает его напрямую. В противном случае возвращается <xref:System.Linq.IQueryable%601> , выполняет запросы путем вызова методов операторов в эквивалентный запрос <xref:System.Linq.Enumerable> а не в <xref:System.Linq.Queryable>.  
  
 Этот метод предполагает, что `source` реализует <xref:System.Collections.Generic.IEnumerable%601> для некоторых `T`. Во время выполнения, результат имеет тип <xref:System.Linq.IQueryable%601> для того же `T`. Этот метод полезен в динамических сценариев, если вы не знаете статически тип `T`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> does not implement <see cref="T:System.Collections.Generic.IEnumerable`1" /> for some <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TElement&gt; AsQueryable&lt;TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TElement&gt; AsQueryable&lt;TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable(Of TElement) (source As IEnumerable(Of TElement)) As IQueryable(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TElement&gt; ^ AsQueryable(System::Collections::Generic::IEnumerable&lt;TElement&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : seq&lt;'Element&gt; -&gt; System.Linq.IQueryable&lt;'Element&gt;" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence to convert.</param>
        <summary>Converts a generic <see cref="T:System.Collections.Generic.IEnumerable`1" /> to a generic <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that represents the input sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если тип `source` реализует <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> возвращает его напрямую. В противном случае возвращается <xref:System.Linq.IQueryable%601> , выполняет запросы путем вызова методов операторов в эквивалентный запрос <xref:System.Linq.Enumerable> а не в <xref:System.Linq.Queryable>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> для преобразования <xref:System.Collections.Generic.IEnumerable%601> для <xref:System.Linq.IQueryable%601>.  
  
 [!code-csharp[System.Linq.Queryable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#125)]
 [!code-vb[System.Linq.Queryable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#125)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Computes the average of a sequence of numeric values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Decimal" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Decimal" /> values.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Double" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Double" /> values.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Int32" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Int32" /> values.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int64&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Int64" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Int64" /> values.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Double" /> values.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Single" /> values.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Single" /> values to calculate the average of.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Single" /> values.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> сам. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> для которого требуется вычислить среднее для последовательности значений.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values that are used to calculate an average.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of nullable <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to calculate the average of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the average of a sequence of <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The average of the sequence of values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он вычисляет среднее арифметическое значений в `source` после вызова `selector` для каждого значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> для вычисления среднего <xref:System.String> длины в последовательности значений типа <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> contains no elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Cast``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Cast(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Целевой тип преобразования элементов <c>источника</c> для.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable" /> that contains the elements to be converted.</param>
        <summary>Converts the elements of an <see cref="T:System.Linq.IQueryable" /> to the specified type.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains each element of the source sequence converted to the specified type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является преобразование значения в `source` ввода `TResult`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> для преобразования объектов в последовательности в тип <xref:System.String>.  
  
 [!code-csharp[System.Linq.Queryable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#19)]
 [!code-vb[System.Linq.Queryable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">An element in the sequence cannot be cast to type <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Concat``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Concat(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Concat (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">The first sequence to concatenate.</param>
        <param name="source2">The sequence to concatenate to the first sequence.</param>
        <summary>Concatenates two sequences.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the concatenated elements of the two input sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является элементы в `source2` с элементами из `source1` для создания новой последовательности.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> для объединения двух последовательностей.  
  
 [!code-csharp[System.Linq.Queryable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#20)]
 [!code-vb[System.Linq.Queryable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determines whether an <see cref="T:System.Linq.IQueryable`1" /> contains a specified element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> in which to locate <c>item</c>.</param>
        <param name="item">The object to locate in the sequence.</param>
        <summary>Determines whether a sequence contains a specified element by using the default equality comparer.</summary>
        <returns>
          <see langword="true" /> if the input sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является проверка, если `source` содержит `item`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> для определения, содержит ли последовательность конкретного элемента.  
  
 [!code-csharp[System.Linq.Queryable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#21)]
 [!code-vb[System.Linq.Queryable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> in which to locate <c>item</c>.</param>
        <param name="item">The object to locate in the sequence.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
        <summary>Determines whether a sequence contains a specified element by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>
          <see langword="true" /> if the input sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является проверка, если `source` содержит `item` с помощью `comparer` для сравнения значений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the number of elements in a sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; -&gt; int" Usage="System.Linq.Queryable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
        <summary>Returns the number of elements in a sequence.</summary>
        <returns>The number of elements in the input sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является подсчет числа элементов в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для подсчета элементов в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#22)]
 [!code-vb[System.Linq.Queryable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The number of elements in <paramref name="source" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Returns the number of elements in the specified sequence that satisfies a condition.</summary>
        <returns>The number of elements in the sequence that satisfies the condition in the predicate function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является подсчет числа элементов в `source` удовлетворяют условию, указанному `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> для подсчета элементов в последовательности, удовлетворяющих условию.  
  
 [!code-csharp[System.Linq.Queryable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#23)]
 [!code-vb[System.Linq.Queryable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The number of elements in <paramref name="source" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the elements in a sequence or a default valued singleton collection if the sequence is empty.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return a default value for if empty.</param>
        <summary>Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains <see langword="default" />(<paramref name="TSource" />) if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение `source` не является пустым. В противном случае возвращается <xref:System.Linq.IQueryable%601> , содержащий `default(TSource)`.  
  
   
  
## Examples  
 В следующих примерах кода демонстрируется использование <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> предоставлять значение по умолчанию, если исходная последовательность пуста.  
  
 [!code-csharp[System.Linq.Queryable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#24)]
 [!code-vb[System.Linq.Queryable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource), defaultValue As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return the specified value for if empty.</param>
        <param name="defaultValue">The value to return if the sequence is empty.</param>
        <summary>Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains <paramref name="defaultValue" /> if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение `source` не является пустым. В противном случае возвращается <xref:System.Linq.IQueryable%601> , содержащий `defaultValue`.  
  
   
  
## Examples  
 В следующем примере кода показаны ситуации, в котором возникает необходимость вызывать <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> в [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] запроса. Значение по умолчанию передается <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> в этом примере.  
  
 [!code-csharp[System.Linq.Queryable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#25)]
 [!code-vb[System.Linq.Queryable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns distinct elements from a sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to remove duplicates from.</param>
        <summary>Returns distinct elements from a sequence by using the default equality comparer to compare values.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains distinct elements from <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение неупорядоченной последовательности уникальных элементов в последовательности `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для возврата различающиеся элементы из последовательности.  
  
 [!code-csharp[System.Linq.Queryable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#27)]
 [!code-vb[System.Linq.Queryable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to remove duplicates from.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
        <summary>Returns distinct elements from a sequence by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains distinct elements from <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение неупорядоченной последовательности уникальных элементов в последовательности `source` с помощью `comparer` для сравнения значений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAt``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
        <param name="index">The zero-based index of the element to retrieve.</param>
        <summary>Returns the element at a specified index in a sequence.</summary>
        <returns>The element at the specified position in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение элемент в позиции `index` в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> требуется возвратить элемент заданной позиции в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#28)]
 [!code-vb[System.Linq.Queryable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAtOrDefault``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
        <param name="index">The zero-based index of the element to retrieve.</param>
        <summary>Returns the element at a specified index in a sequence or a default value if the index is out of range.</summary>
        <returns>
          <c>default</c>(<paramref name="TSource" />) if <paramref name="index" /> is outside the bounds of <paramref name="source" />; otherwise, the element at the specified position in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение элемент в позиции `index` в `source`, или `default(TSource)` Если `index` выходит за границы `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование метода <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29>. В этом примере используется значение для `index` , находится за пределами исходной последовательности.  
  
 [!code-csharp[System.Linq.Queryable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#29)]
 [!code-vb[System.Linq.Queryable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produces the set difference of two sequences.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements that are not also in <c>source2</c> will be returned.</param>
        <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that also occur in the first sequence will not appear in the returned sequence.</param>
        <summary>Produces the set difference of two sequences by using the default equality comparer to compare values.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the set difference of the two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство`source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является все элементы в `source1` кроме тех, которые также присутствуют в `source2`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> для возвращения тех элементов, которые появляются только в первой последовательности.  
  
 [!code-csharp[System.Linq.Queryable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#34)]
 [!code-vb[System.Linq.Queryable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements that are not also in <c>source2</c> will be returned.</param>
        <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that also occur in the first sequence will not appear in the returned sequence.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
        <summary>Produces the set difference of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the set difference of the two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство`source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является все элементы в `source1` кроме тех, которые также присутствуют в `source2`, и `comparer` используется для сравнения значений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the first element of a sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return the first element of.</param>
        <summary>Returns the first element of a sequence.</summary>
        <returns>The first element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он возвращает первый элемент в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для возвращения первого элемента в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#35)]
 [!code-vb[System.Linq.Queryable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The source sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Returns the first element of a sequence that satisfies a specified condition.</summary>
        <returns>The first element in <paramref name="source" /> that passes the test in <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он возвращает первый элемент в `source` , удовлетворяющий условию, указанному `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> для возвращения первого элемента последовательности, удовлетворяющий условию.  
  
 [!code-csharp[System.Linq.Queryable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#36)]
 [!code-vb[System.Linq.Queryable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.  -or-  The source sequence is empty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the first element of a sequence, or a default value if no element is found.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return the first element of.</param>
        <summary>Returns the first element of a sequence, or a default value if the sequence contains no elements.</summary>
        <returns>
          <c>default</c>(<paramref name="TSource" />) if <paramref name="source" /> is empty; otherwise, the first element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он возвращает первый элемент в `source`, или значение по умолчанию, если `source` пуст.  
  
 <xref:System.Linq.Queryable.FirstOrDefault%2A> Метод не предоставляет способ указать значение по умолчанию, возвращаемое, если `source` пуст. Если вы хотите указать значение по умолчанию, отличное от `default(TSource)`, используйте <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> метод, как описано в разделе "Пример".  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> на пустую последовательность.  
  
 [!code-csharp[System.Linq.Queryable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#37)]
 [!code-vb[System.Linq.Queryable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#37)]  
  
 Иногда значение `default(TSource)` не является значением по умолчанию, который вы хотите использовать, если коллекция не содержит элементов. Вместо проверки результата на предмет нежелательного по умолчанию, а затем изменить его при необходимости, можно использовать <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> метод, чтобы задать значение по умолчанию, который вы хотите использовать, если коллекция пуста. Затем вызовите метод <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для получения первого элемента. В следующем примере кода использует оба способа получить значение по умолчанию, равное 1, если коллекция числовых месяцев пуст. Так как значение по умолчанию для целого — 0, не соответствует ни одному месяцу, значение по умолчанию необходимо указать вместо как 1. Первая переменная результата проверяется нежелательного по умолчанию после завершения запроса. Второй переменной результат получается путем вызова <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Указание значения по умолчанию 1.  
  
 [!code-csharp[System.Linq.Queryable#131](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#131)]
 [!code-vb[System.Linq.Queryable#131](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#131)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Returns the first element of a sequence that satisfies a specified condition or a default value if no such element is found.</summary>
        <returns>
          <c>default</c>(<paramref name="TSource" />) if <paramref name="source" /> is empty or if no element passes the test specified by <paramref name="predicate" />; otherwise, the first element in <paramref name="source" /> that passes the test specified by <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он возвращает первый элемент в `source` , удовлетворяющий условию предиката `predicate`, или значение по умолчанию, если элемент не удовлетворяет условию.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> путем передачи в предикате. Во втором запросе отсутствует элемент в последовательности, удовлетворяющий условию.  
  
 [!code-csharp[System.Linq.Queryable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#38)]
 [!code-vb[System.Linq.Queryable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Groups the elements of a sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <summary>Groups the elements of a sequence according to a specified key selector function.</summary>
        <returns>An <c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> in C# or <c>IQueryable(Of IGrouping(Of TKey, TSource))</c> in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> object contains a sequence of objects and a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по ключевому значению, получаемой в результате применения `keySelector` для каждого элемента.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> для группирования элементов в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#14)]
 [!code-vb[System.Linq.Queryable#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
        <summary>Groups the elements of a sequence according to a specified key selector function and compares the keys by using a specified comparer.</summary>
        <returns>An <c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> in C# or <c>IQueryable(Of IGrouping(Of TKey, TSource))</c> in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> contains a sequence of objects and a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по ключевому значению. Значение ключа получается путем вызова `keySelector` для каждого элемента и значения ключей сравниваются с помощью `comparer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement))) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Тип элементов в каждом <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.</summary>
        <returns>An <c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> in C# or <c>IQueryable(Of IGrouping(Of TKey, TElement))</c> in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> contains a sequence of objects of type <paramref name="TElement" /> and a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по ключевому значению, получаемой в результате применения `keySelector` для каждого элемента. Он вызывает `elementSelector` каждый элемент для получения результирующего элемента.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> для группирования элементов в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#39)]
 [!code-vb[System.Linq.Queryable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Тип элементов в каждом <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
        <summary>Groups the elements of a sequence and projects the elements for each group by using a specified function. Key values are compared by using a specified comparer.</summary>
        <returns>An <c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> in C# or <c>IQueryable(Of IGrouping(Of TKey, TElement))</c> in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> contains a sequence of objects of type <paramref name="TElement" /> and a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по ключевому значению, получаемой в результате применения `keySelector` для каждого элемента. Значения ключей сравниваются с помощью `comparer`. `elementSelector` Вызывается для каждого элемента, для получения результирующего элемента.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">Тип результирующего значения, возвращаемые <c>resultSelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <param name="resultSelector">A function to create a result value from each group.</param>
        <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key.</summary>
        <returns>An <c>T:System.Linq.IQueryable`1</c> that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по ключевому значению, получаемой в результате применения `keySelector` для каждого элемента. `resultSelector` Параметр используется для получения результирующего значения для каждой группы и ее ключа.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> для группирования элементов в последовательности и проекта последовательность результатов типа `TResult`.  
  
 [!code-csharp[System.Linq.Queryable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#15)]
 [!code-vb[System.Linq.Queryable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">Тип результирующего значения, возвращаемые <c>resultSelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <param name="resultSelector">A function to create a result value from each group.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
        <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Keys are compared by using a specified comparer.</summary>
        <returns>An <c>T:System.Linq.IQueryable`1</c> that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по значениям ключей, получаемой в результате применения `keySelector` для каждого элемента. `comparer` Параметр используется для сравнения ключей и `resultSelector` параметр используется для получения результирующего значения для каждой группы и ее ключа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="resultSelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Тип элементов в каждом <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Тип результирующего значения, возвращаемые <c>resultSelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">A function to create a result value from each group.</param>
        <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function.</summary>
        <returns>An <c>T:System.Linq.IQueryable`1</c> that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по значениям ключей, получаемой в результате применения `keySelector` для каждого элемента. `elementSelector` Параметр используется для проецирования элементов каждой группы и `resultSelector` параметр используется для получения результирующего значения для каждой группы и ее ключа.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> для группирования элементов в последовательности и проекта последовательность результатов типа `TResult`.  
  
 [!code-csharp[System.Linq.Queryable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#130)]
 [!code-vb[System.Linq.Queryable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной в <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">Тип элементов в каждом <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Тип результирующего значения, возвращаемые <c>resultSelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
        <param name="keySelector">A function to extract the key for each element.</param>
        <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">A function to create a result value from each group.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
        <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Keys are compared by using a specified comparer and the elements of each group are projected by using a specified function.</summary>
        <returns>An <c>T:System.Linq.IQueryable`1</c> that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он группирует элементы `source` по значениям ключей, получаемой в результате применения `keySelector` для каждого элемента. `comparer` Параметр используется для сравнения значений ключей. `elementSelector` Параметр используется для проецирования элементов каждой группы и `resultSelector` параметр используется для получения результирующего значения для каждой группы и ее ключа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> or <paramref name="resultSelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correlates the elements of two sequences based on key equality and groups the results.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Тип элементов первой последовательности.</typeparam>
        <typeparam name="TInner">Тип элементов второй последовательности.</typeparam>
        <typeparam name="TKey">Тип ключей, возвращаемых функциями селектора ключа.</typeparam>
        <typeparam name="TResult">Тип результирующих элементов.</typeparam>
        <param name="outer">The first sequence to join.</param>
        <param name="inner">The sequence to join to the first sequence.</param>
        <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
        <summary>Correlates the elements of two sequences based on key equality and groups the results. The default equality comparer is used to compare keys.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements of type <paramref name="TResult" /> obtained by performing a grouped join on two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `outer` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> зависит от реализации типа `outer` параметра. Ожидаемым поведением является `outerKeySelector` и `innerKeySelector` функции используются для извлечения ключей из `outer` и `inner`, соответственно. Эти ключи проверяются на равенство для сопоставления каждого элемента в `outer` с нуля или более элементов из `inner`. Затем `resultSelector` функция вызывается для проецирования результирующего объекта из каждой группы связанных элементов.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> для выполнения группированное соединение двух последовательностей.  
  
 [!code-csharp[System.Linq.Queryable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#40)]
 [!code-vb[System.Linq.Queryable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Тип элементов первой последовательности.</typeparam>
        <typeparam name="TInner">Тип элементов второй последовательности.</typeparam>
        <typeparam name="TKey">Тип ключей, возвращаемых функциями селектора ключа.</typeparam>
        <typeparam name="TResult">Тип результирующих элементов.</typeparam>
        <param name="outer">The first sequence to join.</param>
        <param name="inner">The sequence to join to the first sequence.</param>
        <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
        <param name="comparer">A comparer to hash and compare keys.</param>
        <summary>Correlates the elements of two sequences based on key equality and groups the results. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements of type <paramref name="TResult" /> obtained by performing a grouped join on two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `outer` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> зависит от реализации типа `outer` параметра. Ожидаемым поведением является `outerKeySelector` и `innerKeySelector` функции используются для извлечения ключей из `outer` и `inner`, соответственно. Эти ключи проверяются на равенство с помощью `comparer`. Результаты сравнения используются для сопоставления каждого элемента в `outer` с нуля или более элементов из `inner`. Затем `resultSelector` функция вызывается для проецирования результирующего объекта из каждой группы связанных элементов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produces the set intersection of two sequences.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">A sequence whose distinct elements that also appear in <c>source2</c> are returned.</param>
        <param name="source2">A sequence whose distinct elements that also appear in the first sequence are returned.</param>
        <summary>Produces the set intersection of two sequences by using the default equality comparer to compare values.</summary>
        <returns>A sequence that contains the set intersection of the two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является все элементы в `source1` , которые также являются в `source2` возвращаются.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> для получения элементов, отображающихся в каждом из двух последовательностей.  
  
 [!code-csharp[System.Linq.Queryable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#41)]
 [!code-vb[System.Linq.Queryable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose distinct elements that also appear in <c>source2</c> are returned.</param>
        <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements that also appear in the first sequence are returned.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
        <summary>Produces the set intersection of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the set intersection of the two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является все элементы в `source1` , которые также являются в `source2` возвращаются. `comparer` Параметр используется для сравнения элементов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correlates the elements of two sequences based on matching keys.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Тип элементов первой последовательности.</typeparam>
        <typeparam name="TInner">Тип элементов второй последовательности.</typeparam>
        <typeparam name="TKey">Тип ключей, возвращаемых функциями селектора ключа.</typeparam>
        <typeparam name="TResult">Тип результирующих элементов.</typeparam>
        <param name="outer">The first sequence to join.</param>
        <param name="inner">The sequence to join to the first sequence.</param>
        <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        <param name="resultSelector">A function to create a result element from two matching elements.</param>
        <summary>Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that has elements of type <paramref name="TResult" /> obtained by performing an inner join on two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `outer` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> зависит от реализации типа `outer` параметра. Ожидаемым поведением является выполнение внутреннего соединения. `outerKeySelector` И `innerKeySelector` функции используются для извлечения ключей из `outer` и `inner`, соответственно. Эти ключи проверяются на равенство для сопоставления элементов из каждой последовательности. Пара элементов хранится для каждого элемента в `inner` , соответствующий элемент в `outer`. Затем `resultSelector` функция вызывается для проецирования результирующего объекта из каждой пары соответствующих элементов.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> для выполнения внутреннего соединения двух последовательностей, в соответствии с общим ключом.  
  
 [!code-csharp[System.Linq.Queryable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#42)]
 [!code-vb[System.Linq.Queryable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Тип элементов первой последовательности.</typeparam>
        <typeparam name="TInner">Тип элементов второй последовательности.</typeparam>
        <typeparam name="TKey">Тип ключей, возвращаемых функциями селектора ключа.</typeparam>
        <typeparam name="TResult">Тип результирующих элементов.</typeparam>
        <param name="outer">The first sequence to join.</param>
        <param name="inner">The sequence to join to the first sequence.</param>
        <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        <param name="resultSelector">A function to create a result element from two matching elements.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to hash and compare keys.</param>
        <summary>Correlates the elements of two sequences based on matching keys. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that has elements of type <paramref name="TResult" /> obtained by performing an inner join on two sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `outer` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> зависит от реализации типа `outer` параметра. Ожидаемым поведением является выполнение внутреннего соединения. `outerKeySelector` И `innerKeySelector` функции используются для извлечения ключей из `outer` и `inner`, соответственно. Эти ключи проверяются на равенство с помощью `comparer`. Результаты сравнения используется для создания пары для каждого элемента в `inner` , соответствующий элемент в `outer`. Затем `resultSelector` функция вызывается для проецирования результирующего объекта из каждой пары соответствующих элементов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the last element in a sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the last element of.</param>
        <summary>Returns the last element in a sequence.</summary>
        <returns>The value at the last position in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение последнего элемента в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для возвращения последнего элемента массива.  
  
 [!code-csharp[System.Linq.Queryable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#43)]
 [!code-vb[System.Linq.Queryable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The source sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Returns the last element of a sequence that satisfies a specified condition.</summary>
        <returns>The last element in <paramref name="source" /> that passes the test specified by <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение последнего элемента в `source` , удовлетворяющий условию, указанному `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> для возвращения последнего элемента массива, удовлетворяющий условию.  
  
 [!code-csharp[System.Linq.Queryable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#44)]
 [!code-vb[System.Linq.Queryable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.  -or-  The source sequence is empty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the last element of a sequence, or a default value if no element is found.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the last element of.</param>
        <summary>Returns the last element in a sequence, or a default value if the sequence contains no elements.</summary>
        <returns>
          <c>default</c>(<paramref name="TSource" />) if <paramref name="source" /> is empty; otherwise, the last element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение последнего элемента в `source`, или значение по умолчанию, если `source` пуст.  
  
 <xref:System.Linq.Queryable.LastOrDefault%2A> Метод не предоставляет способ указать значение по умолчанию. Если вы хотите указать значение по умолчанию, отличное от `default(TSource)`, используйте <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> метод, как описано в разделе "Пример".  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> на пустой массив.  
  
 [!code-csharp[System.Linq.Queryable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#45)]
 [!code-vb[System.Linq.Queryable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#45)]  
  
 Иногда значение `default(TSource)` не является значением по умолчанию, который вы хотите использовать, если коллекция не содержит элементов. Вместо проверки результата на предмет нежелательного по умолчанию, а затем изменить его при необходимости, можно использовать <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> метод, чтобы задать значение по умолчанию, который вы хотите использовать, если коллекция пуста. Затем вызовите метод <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для получения последнего элемента. В следующем примере кода используются оба способа получить значение по умолчанию, равное 1, если коллекция числовых дни месяца пуст. Так как значение по умолчанию для целого — 0, не соответствует ни одному дню месяца, значение по умолчанию необходимо указать вместо как 1. Первая переменная результата проверяется нежелательного по умолчанию после завершения запроса. Второй переменной результат получается путем вызова <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Указание значения по умолчанию 1.  
  
 [!code-csharp[System.Linq.Queryable#132](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#132)]
 [!code-vb[System.Linq.Queryable#132](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#132)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Returns the last element of a sequence that satisfies a condition or a default value if no such element is found.</summary>
        <returns>
          <c>default</c>(<paramref name="TSource" />) if <paramref name="source" /> is empty or if no elements pass the test in the predicate function; otherwise, the last element of <paramref name="source" /> that passes the test in the predicate function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение последнего элемента в `source` , удовлетворяющий условию, указанному `predicate`. Возвращает значение по умолчанию, если такой элемент в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> путем передачи в предикате. Во втором вызове метода отсутствует элемент в последовательности, удовлетворяющий условию.  
  
 [!code-csharp[System.Linq.Queryable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#46)]
 [!code-vb[System.Linq.Queryable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an <see cref="T:System.Int64" /> that represents the number of elements in sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
        <summary>Returns an <see cref="T:System.Int64" /> that represents the total number of elements in a sequence.</summary>
        <returns>The number of elements in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является подсчет числа элементов в `source` и возвращает <xref:System.Int64>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> для подсчета элементов в массиве.  
  
 [!code-csharp[System.Linq.Queryable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#47)]
 [!code-vb[System.Linq.Queryable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The number of elements exceeds <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Returns an <see cref="T:System.Int64" /> that represents the number of elements in a sequence that satisfy a condition.</summary>
        <returns>The number of elements in <paramref name="source" /> that satisfy the condition in the predicate function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является подсчет числа элементов в `source` удовлетворяют условию, указанному `predicate` и возвращает <xref:System.Int64>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> для подсчета элементов в массиве, удовлетворяющие условию.  
  
 [!code-csharp[System.Linq.Queryable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#48)]
 [!code-vb[System.Linq.Queryable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The number of matching elements exceeds <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to determine the maximum of.</param>
        <summary>Returns the maximum value in a generic <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>The maximum value in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение максимального значения в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> определяется максимальное значение в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#52)]
 [!code-vb[System.Linq.Queryable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TResult">Тип значения, возвращаемого функцией, заданной по <c>селектор</c>.</typeparam>
        <param name="source">A sequence of values to determine the maximum of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Invokes a projection function on each element of a generic <see cref="T:System.Linq.IQueryable`1" /> and returns the maximum resulting value.</summary>
        <returns>The maximum value in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента в `source` и возвращает максимальное значение.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> чтобы определить максимальное значение в последовательности прогнозируемых значений.  
  
 [!code-csharp[System.Linq.Queryable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#58)]
 [!code-vb[System.Linq.Queryable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to determine the minimum of.</param>
        <summary>Returns the minimum value of a generic <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>The minimum value in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение минимальному значению `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> определяется минимальное значение в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#60)]
 [!code-vb[System.Linq.Queryable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TResult">Тип значения, возвращаемого функцией, заданной по <c>селектор</c>.</typeparam>
        <param name="source">A sequence of values to determine the minimum of.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Invokes a projection function on each element of a generic <see cref="T:System.Linq.IQueryable`1" /> and returns the minimum resulting value.</summary>
        <returns>The minimum value in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента в `source` и возвращает минимальное значение.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> чтобы определить минимальное значение в последовательности прогнозируемых значений.  
  
 [!code-csharp[System.Linq.Queryable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#68)]
 [!code-vb[System.Linq.Queryable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OfType``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ OfType(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Тип, по которому фильтруются элементы последовательности.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable" /> whose elements to filter.</param>
        <summary>Filters the elements of an <see cref="T:System.Linq.IQueryable" /> based on a specified type.</summary>
        <returns>A collection that contains the elements from <paramref name="source" /> that have type <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `OfType` Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов `OfType` себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов `OfType` зависит от реализации типа `source` параметра. Ожидаемым поведением является отфильтровывает все элементы в `source` , не являющиеся `TResult`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование `OfType` для фильтрации элементов, которые не имеют тип <xref:System.Reflection.PropertyInfo> из списка элементов типа <xref:System.Reflection.MemberInfo>.  
  
 [!code-csharp[System.Linq.Queryable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#69)]
 [!code-vb[System.Linq.Queryable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sorts the elements of a sequence in ascending order.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, представленный <c>keySelector</c>.</typeparam>
        <param name="source">A sequence of values to order.</param>
        <param name="keySelector">A function to extract a key from an element.</param>
        <summary>Sorts the elements of a sequence in ascending order according to a key.</summary>
        <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является сортировка элементов `source` на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> для сортировки элементов последовательности.  
  
 [!code-csharp[System.Linq.Queryable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#70)]
 [!code-vb[System.Linq.Queryable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, представленный <c>keySelector</c>.</typeparam>
        <param name="source">A sequence of values to order.</param>
        <param name="keySelector">A function to extract a key from an element.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
        <summary>Sorts the elements of a sequence in ascending order by using a specified comparer.</summary>
        <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является сортировка элементов `source` на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`. `comparer` Параметр используется для сравнения ключей.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sorts the elements of a sequence in descending order.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, представленный <c>keySelector</c>.</typeparam>
        <param name="source">A sequence of values to order.</param>
        <param name="keySelector">A function to extract a key from an element.</param>
        <summary>Sorts the elements of a sequence in descending order according to a key.</summary>
        <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted in descending order according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является сортировка элементов `source` в порядке убывания, выбираются на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, представленный <c>keySelector</c>.</typeparam>
        <param name="source">A sequence of values to order.</param>
        <param name="keySelector">A function to extract a key from an element.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
        <summary>Sorts the elements of a sequence in descending order by using a specified comparer.</summary>
        <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted in descending order according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является сортировка элементов `source` в порядке убывания, выбираются на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`. `comparer` Параметр используется для сравнения ключей.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> для сортировки элементов последовательности в порядке убывания с использованием пользовательского модуля сравнения.  
  
 [!code-csharp[System.Linq.Queryable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#71)]
 [!code-vb[System.Linq.Queryable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Prepend``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Prepend(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Reverse``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Reverse(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values to reverse.</param>
        <summary>Inverts the order of the elements in a sequence.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements correspond to those of the input sequence in reverse order.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он обращает порядок элементов в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Чтобы изменить порядок элементов в массиве.  
  
 [!code-csharp[System.Linq.Queryable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#74)]
 [!code-vb[System.Linq.Queryable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projects each element of a sequence into a new form.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TResult">Тип значения, возвращаемого функцией, заданной по <c>селектор</c>.</typeparam>
        <param name="source">A sequence of values to project.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Projects each element of a sequence into a new form by incorporating the element's index.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a projection function on each element of <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> зависят от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` проецировать его в другую форму.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> проекта вычисления для последовательности значений и использовать индекс каждого элемента в проецированной форме.  
  
 [!code-csharp[System.Linq.Queryable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#76)]
 [!code-vb[System.Linq.Queryable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TResult">Тип значения, возвращаемого функцией, заданной по <c>селектор</c>.</typeparam>
        <param name="source">A sequence of values to project.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Projects each element of a sequence into a new form.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a projection function on each element of <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` проецировать его в другую форму.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> требуется спроецировать последовательность значений.  
  
 [!code-csharp[System.Linq.Queryable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#75)]
 [!code-vb[System.Linq.Queryable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and combines the resulting sequences into one sequence of type <see cref="T:System.Linq.IQueryable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TResult">Тип элементов последовательности, возвращаемых функцией, заданной по <c>селектор</c>.</typeparam>
        <param name="source">A sequence of values to project.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and combines the resulting sequences into one sequence.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` проецировать его в форму enumerable. Затем он объединяет перечисляемые результаты в одну одномерную последовательность.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> для выполнения проекции один ко многим к массиву.  
  
 [!code-csharp[System.Linq.Queryable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#77)]
 [!code-vb[System.Linq.Queryable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TResult">Тип элементов последовательности, возвращаемых функцией, заданной по <c>селектор</c>.</typeparam>
        <param name="source">A sequence of values to project.</param>
        <param name="selector">A projection function to apply to each element; the second parameter of this function represents the index of the source element.</param>
        <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and combines the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` проецировать его в форму enumerable. Каждый перечислимый результат включает индекс исходного элемента. Затем он объединяет перечисляемые результаты в одну одномерную последовательность.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> для выполнения проекции один ко многим к массиву и использовать индекс каждого элемента исходной последовательности.  
  
 [!code-csharp[System.Linq.Queryable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#78)]
 [!code-vb[System.Linq.Queryable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TCollection">Тип промежуточных элементов, собранных функцией, заданной по <c>collectionSelector</c>.</typeparam>
        <typeparam name="TResult">Тип элементов результирующей последовательности.</typeparam>
        <param name="source">A sequence of values to project.</param>
        <param name="collectionSelector">A projection function to apply to each element of the input sequence.</param>
        <param name="resultSelector">A projection function to apply to each element of each intermediate sequence.</param>
        <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and invokes a result selector function on each element therein. The resulting values from each intermediate sequence are combined into a single, one-dimensional sequence and returned.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking the one-to-many projection function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping each of those sequence elements and their corresponding <paramref name="source" /> element to a result element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `collectionSelector` для каждого элемента `source` проецировать его в форму enumerable. Затем функция представленный `resultSelector` вызывается для каждого элемента каждой промежуточной последовательности. Полученные значения объединяются в одну одномерную последовательность.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> для выполнения проекции один ко многим к массиву. В этом примере использует функцию селектора результата для сохранения исходного элемента, соответствующий каждой промежуточной последовательности, в области для финального вызова `Select`.  
  
 [!code-csharp[System.Linq.Queryable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#124)]
 [!code-vb[System.Linq.Queryable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="collectionSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TCollection">Тип промежуточных элементов, собранных функцией, заданной по <c>collectionSelector</c>.</typeparam>
        <typeparam name="TResult">Тип элементов результирующей последовательности.</typeparam>
        <param name="source">A sequence of values to project.</param>
        <param name="collectionSelector">A projection function to apply to each element of the input sequence; the second parameter of this function represents the index of the source element.</param>
        <param name="resultSelector">A projection function to apply to each element of each intermediate sequence.</param>
        <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> that incorporates the index of the source element that produced it. A result selector function is invoked on each element of each intermediate sequence, and the resulting values are combined into a single, one-dimensional sequence and returned.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking the one-to-many projection function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping each of those sequence elements and their corresponding <paramref name="source" /> element to a result element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `collectionSelector` для каждого элемента `source` проецировать его в форму enumerable. Каждый перечислимый результат включает индекс исходного элемента. Затем функция представленный `resultSelector` вызывается для каждого элемента каждой промежуточной последовательности. Полученные значения объединяются в одну одномерную последовательность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="collectionSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determines whether two sequences are equal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to compare to those of <c>source2</c>.</param>
        <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to compare to those of the first sequence.</param>
        <summary>Determines whether two sequences are equal by using the default equality comparer to compare elements.</summary>
        <returns>
          <see langword="true" /> if the two source sequences are of equal length and their corresponding elements compare equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является то, что он определяет, равны ли две исходные последовательности.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> для определения, равны ли две последовательности. В этом примере последовательности равны.  
  
 [!code-csharp[System.Linq.Queryable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#32)]
 [!code-vb[System.Linq.Queryable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#32)]  
  
 В следующем примере кода сравнивает две последовательности, которые не равны.  
  
 [!code-csharp[System.Linq.Queryable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#33)]
 [!code-vb[System.Linq.Queryable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to compare to those of <c>source2</c>.</param>
        <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to compare to those of the first sequence.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to use to compare elements.</param>
        <summary>Determines whether two sequences are equal by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare elements.</summary>
        <returns>
          <see langword="true" /> if the two source sequences are of equal length and their corresponding elements compare equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является проверка, если два источника последовательностей совпадают, используя `comparer` для сравнения элементов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a single, specific element of a sequence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the single element of.</param>
        <summary>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</summary>
        <returns>The single element of the input sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение единственный элемент в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> единственный элемент массива.  
  
 [!code-csharp[System.Linq.Queryable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#79)]
 [!code-vb[System.Linq.Queryable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> has more than one element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return a single element from.</param>
        <param name="predicate">A function to test an element for a condition.</param>
        <summary>Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more than one such element exists.</summary>
        <returns>The single element of the input sequence that satisfies the condition in <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение единственный элемент в `source` , удовлетворяющий условию, указанному `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> единственный элемент массива, удовлетворяющий условию.  
  
 [!code-csharp[System.Linq.Queryable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#81)]
 [!code-vb[System.Linq.Queryable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.  -or-  More than one element satisfies the condition in <paramref name="predicate" />.  -or-  The source sequence is empty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a single, specific element of a sequence, or a default value if no such element is found.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the single element of.</param>
        <summary>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</summary>
        <returns>The single element of the input sequence, or <c>default</c>(<paramref name="TSource" />) if the sequence contains no elements.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение единственный элемент в `source`, или значение по умолчанию, если `source` пуст.  
  
 <xref:System.Linq.Queryable.SingleOrDefault%2A> Метод не предоставляет способ указать значение по умолчанию. Если вы хотите указать значение по умолчанию, отличное от `default(TSource)`, используйте <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> метод, как описано в разделе "Пример".  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> единственный элемент массива. Второй запрос показывает, что <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> возвращает значение по умолчанию, если последовательность не содержит ровно один элемент.  
  
 [!code-csharp[System.Linq.Queryable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#83)]
 [!code-vb[System.Linq.Queryable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#83)]  
  
 Иногда значение `default(TSource)` не является значением по умолчанию, который вы хотите использовать, если коллекция не содержит элементов. Вместо проверки результата на предмет нежелательного по умолчанию, а затем изменить его при необходимости, можно использовать <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> метод, чтобы задать значение по умолчанию, который вы хотите использовать, если коллекция пуста. Затем вызовите <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> получить элемент. В следующем примере кода используются оба способа получить значение по умолчанию, равное 1, если коллекция номеров страниц пуста. Так как значение по умолчанию для целого — 0, обычно не допустимый номер страницы, значение по умолчанию необходимо указать вместо как 1. Первая переменная результата проверяется нежелательного по умолчанию после завершения запроса. Второй переменной результат получается путем вызова <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Указание значения по умолчанию 1.  
  
 [!code-csharp[System.Linq.Queryable#133](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#133)]
 [!code-vb[System.Linq.Queryable#133](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#133)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> has more than one element.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return a single element from.</param>
        <param name="predicate">A function to test an element for a condition.</param>
        <summary>Returns the only element of a sequence that satisfies a specified condition or a default value if no such element exists; this method throws an exception if more than one element satisfies the condition.</summary>
        <returns>The single element of the input sequence that satisfies the condition in <paramref name="predicate" />, or <c>default</c>(<paramref name="TSource" />) if no such element is found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение единственный элемент в `source` , удовлетворяющий условию, указанному `predicate`, или значение по умолчанию, если такого элемента не существует.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> единственный элемент массива, удовлетворяющий условию. Второй запрос показывает, что <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> возвращает значение по умолчанию, если последовательность не содержит ровно один элемент, удовлетворяющий условию.  
  
 [!code-csharp[System.Linq.Queryable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#85)]
 [!code-vb[System.Linq.Queryable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">More than one element satisfies the condition in <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Skip``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Skip(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return elements from.</param>
        <param name="count">The number of elements to skip before returning the remaining elements.</param>
        <summary>Bypasses a specified number of elements in a sequence and then returns the remaining elements.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements that occur after the specified index in the input sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что она пропускает первый `count` элементов в `source` и возвращает остальные элементы.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> пропустить указанное число элементов в отсортированном массиве и возвращает остальные элементы.  
  
 [!code-csharp[System.Linq.Queryable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#87)]
 [!code-vb[System.Linq.Queryable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return elements from.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from <paramref name="source" /> starting at the first element in the linear series that does not pass the test specified by <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является применение `predicate` к каждому элементу в `source` до обнаружения элемента, для которого `predicate` возвращает значение false. Этот элемент и все остальные элементы возвращаются.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> пропускаемых элементов в массиве до тех пор, пока условие имеет значение true.  
  
 [!code-csharp[System.Linq.Queryable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#88)]
 [!code-vb[System.Linq.Queryable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return elements from.</param>
        <param name="predicate">A function to test each element for a condition; the second parameter of this function represents the index of the source element.</param>
        <summary>Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from <paramref name="source" /> starting at the first element in the linear series that does not pass the test specified by <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является применение `predicate` к каждому элементу в `source` до обнаружения элемента, для которого `predicate` возвращает значение false. Этот элемент и все остальные элементы возвращаются. Индекс каждого элемента исходной предоставляется в качестве второго аргумента `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> пропускаемых элементов в массиве до тех пор, пока условие, которое зависит от индекс этого элемента имеет значение true.  
  
 [!code-csharp[System.Linq.Queryable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#89)]
 [!code-vb[System.Linq.Queryable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Computes the sum of a sequence of numeric values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Decimal" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of <see cref="T:System.Decimal" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Double" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of <see cref="T:System.Double" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int&gt; -&gt; int" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Int32" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of <see cref="T:System.Int32" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int64&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Int64" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of <see cref="T:System.Int64" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of nullable <see cref="T:System.Double" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> для суммирования значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of nullable <see cref="T:System.Single" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> для суммирования значений последовательности.  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">A sequence of <see cref="T:System.Single" /> values to calculate the sum of.</param>
        <summary>Computes the sum of a sequence of <see cref="T:System.Single" /> values.</summary>
        <returns>The sum of the values in the sequence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение суммы значений в `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> для суммирования значений последовательности.  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> зависит от реализации типа он `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of nullable <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of nullable <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of nullable <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of nullable <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of nullable <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">A sequence of values of type <c>TSource</c>.</param>
        <param name="selector">A projection function to apply to each element.</param>
        <summary>Computes the sum of the sequence of <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
        <returns>The sum of the projected values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является вызов `selector` для каждого элемента `source` и возвращает сумму результирующие значения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> для суммирования проецированных значений последовательности.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Take``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Take(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The sequence to return elements from.</param>
        <param name="count">The number of elements to return.</param>
        <summary>Returns a specified number of contiguous elements from the start of a sequence.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the specified number of elements from the start of <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение первый `count` элементы от начала `source`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> требуется возвратить элементы с начала последовательности.  
  
 [!code-csharp[System.Linq.Queryable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#99)]
 [!code-vb[System.Linq.Queryable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns elements from a sequence as long as a specified condition is true, and then skips the remaining elements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The sequence to return elements from.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Returns elements from a sequence as long as a specified condition is true.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence occurring before the element at which the test specified by <paramref name="predicate" /> no longer passes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является применение `predicate` к каждому элементу в `source` до обнаружения элемента, для которого `predicate` возвращает `false`. Он возвращает все элементы вплоть до этого момента.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> требуется возвратить элементы в начале последовательности до тех пор, пока условие имеет значение true.  
  
 [!code-csharp[System.Linq.Queryable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#100)]
 [!code-vb[System.Linq.Queryable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">The sequence to return elements from.</param>
        <param name="predicate">A function to test each element for a condition; the second parameter of the function represents the index of the element in the source sequence.</param>
        <summary>Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence occurring before the element at which the test specified by <paramref name="predicate" /> no longer passes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является применение `predicate` к каждому элементу в `source` до обнаружения элемента, для которого `predicate` возвращает `false`. Он возвращает все элементы вплоть до этого момента. Индекс каждого элемента исходной предоставляется в качестве второго аргумента `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> требуется возвратить элементы в начале последовательности до тех пор, пока условие, которое использует индекс элемента имеет значение true.  
  
 [!code-csharp[System.Linq.Queryable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#101)]
 [!code-vb[System.Linq.Queryable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Performs a subsequent ordering of the elements in a sequence in ascending order.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной по <c>keySelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
        <param name="keySelector">A function to extract a key from each element.</param>
        <summary>Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.</summary>
        <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он выполняет Дополнительная сортировка элементов `source` на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`. Все ранее установленные порядки сортировки сохраняются.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> для выполнения вторичную сортировку элементов в последовательности.  
  
 [!code-csharp[System.Linq.Queryable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#102)]
 [!code-vb[System.Linq.Queryable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной по <c>keySelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
        <param name="keySelector">A function to extract a key from each element.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
        <summary>Performs a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.</summary>
        <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он выполняет Дополнительная сортировка элементов `source` на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`. Все ранее установленные порядки сортировки сохраняются. `comparer` Параметр используется для сравнения значений ключей.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Performs a subsequent ordering of the elements in a sequence in descending order.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, возвращаемого функцией, заданной по <c>keySelector</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
        <param name="keySelector">A function to extract a key from each element.</param>
        <summary>Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.</summary>
        <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted in descending order according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он выполняет Дополнительная сортировка элементов `source` в порядке убывания, выбираются на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`. Все ранее установленные порядки сортировки сохраняются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <typeparam name="TKey">Тип ключа, который возвращается <c>keySelector</c> функции.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
        <param name="keySelector">A function to extract a key from each element.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
        <summary>Performs a subsequent ordering of the elements in a sequence in descending order by using a specified comparer.</summary>
        <returns>A collection whose elements are sorted in descending order according to a key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр. Результат вызова метода <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> приведенное к типу <xref:System.Linq.IOrderedQueryable%601> и возвращаются.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является то, что он выполняет Дополнительная сортировка элементов `source` в порядке убывания, выбираются на основе ключа, получаемой в результате применения `keySelector` для каждого элемента `source`. Все ранее установленные порядки сортировки сохраняются. `comparer` Параметр используется для сравнения значений ключей.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> для выполнения вторичную сортировку элементов последовательности в порядке убывания с использованием пользовательского модуля сравнения.  
  
 [!code-csharp[System.Linq.Queryable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#103)]
 [!code-vb[System.Linq.Queryable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produces the set union of two sequences.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">A sequence whose distinct elements form the first set for the union operation.</param>
        <param name="source2">A sequence whose distinct elements form the second set for the union operation.</param>
        <summary>Produces the set union of two sequences by using the default equality comparer.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements from both input sequences, excluding duplicates.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является объединение элементов в `source1` и `source2` возвращается.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> для получения объединение множеств, представленных двумя последовательностями.  
  
 [!code-csharp[System.Linq.Queryable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#109)]
 [!code-vb[System.Linq.Queryable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов входных последовательностей.</typeparam>
        <param name="source1">A sequence whose distinct elements form the first set for the union operation.</param>
        <param name="source2">A sequence whose distinct elements form the second set for the union operation.</param>
        <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
        <summary>Produces the set union of two sequences by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements from both input sequences, excluding duplicates.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> зависит от реализации типа `source1` параметра. Ожидаемым поведением является объединение элементов в `source1` и `source2` возвращается. `comparer` Параметр используется для сравнения значений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filters a sequence of values based on a predicate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to filter.</param>
        <param name="predicate">A function to test each element for a condition.</param>
        <summary>Filters a sequence of values based on a predicate.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence that satisfy the condition specified by <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение элементы из `source` удовлетворяют условию, указанному `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> для фильтрации последовательности.  
  
 [!code-csharp[System.Linq.Queryable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#110)]
 [!code-vb[System.Linq.Queryable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Тип элементов <c>источника</c>.</typeparam>
        <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to filter.</param>
        <param name="predicate">A function to test each element for a condition; the second parameter of the function represents the index of the element in the source sequence.</param>
        <summary>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence that satisfy the condition specified by <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет по крайней мере один параметр типа <xref:System.Linq.Expressions.Expression%601> аргументом типа является одним из <xref:System.Func%602> типов. Для этих параметров можно передать лямбда-выражение и компилируется в <xref:System.Linq.Expressions.Expression%601>.  
  
 <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source` параметр.  
  
 Поведение запросов, которые происходят в результате выполнения дерева выражения, представляющее вызов <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> зависит от реализации типа `source` параметра. Ожидаемым поведением является возвращение элементы из `source` удовлетворяют условию, указанному `predicate`. Индекс каждого элемента исходной предоставляется в качестве второго аргумента `predicate`.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> для фильтрации на основе предиката, который включает индекс каждого элемента последовательности.  
  
 [!code-csharp[System.Linq.Queryable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#111)]
 [!code-vb[System.Linq.Queryable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2, System.Linq.Expressions.Expression&lt;Func&lt;TFirst,TSecond,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``3(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (source1 As IQueryable(Of TFirst), source2 As IEnumerable(Of TSecond), resultSelector As Expression(Of Func(Of TFirst, TSecond, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Zip(System::Linq::IQueryable&lt;TFirst&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ source2, System::Linq::Expressions::Expression&lt;Func&lt;TFirst, TSecond, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.IQueryable&lt;'First&gt; * seq&lt;'Second&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'First, 'Second, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Zip (source1, source2, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TFirst,TSecond,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Тип элементов первой входной последовательности.</typeparam>
        <typeparam name="TSecond">Тип элементов второй входной последовательности.</typeparam>
        <typeparam name="TResult">Тип элементов результирующей последовательности.</typeparam>
        <param name="source1">The first sequence to merge.</param>
        <param name="source2">The second sequence to merge.</param>
        <param name="resultSelector">A function that specifies how to merge the elements from the two sequences.</param>
        <summary>Merges two sequences by using the specified predicate function.</summary>
        <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains merged elements of two input sequences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Queryable.Zip%2A> Метод создает <xref:System.Linq.Expressions.MethodCallExpression> , представляющий вызов <xref:System.Linq.Queryable.Zip%2A> себя в качестве сконструированному универсальному методу. Затем он передает <xref:System.Linq.Expressions.MethodCallExpression> для <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> метод <xref:System.Linq.IQueryProvider> представленный <xref:System.Linq.IQueryable.Provider%2A> свойство `source1` параметр.  
  
 Метод объединяет каждого элемента первой последовательности с элемент, имеющий тот же индекс во второй последовательности. Если последовательности имеет одинаковое количество элементов, метод объединяет последовательности, пока не будет достигнут конец одного из них. Например если одна последовательность имеет три элемента, а второй имеет четыре, результирующая последовательность содержит только три элемента.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Linq.Queryable.Zip%2A> метод для объединения двух последовательностей.  
  
 [!code-csharp[System.Linq.Queryable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#200)]
 [!code-vb[System.Linq.Queryable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>