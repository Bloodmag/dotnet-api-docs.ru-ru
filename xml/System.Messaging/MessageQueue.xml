<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f362dd97709b65574ff7b9474682818d0cb2c4b1" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038298" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к очереди на сервере MSMQ.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Технология очереди сообщений позволяет приложениям, запускаются в разное время, для обмена данными через разнородных сетей и систем, которые могут быть временно отключены. Приложения отправки, получения или просматривать (считывать без удаления) сообщения из очередей. Служба Message Queuing является необязательным компонентом [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] и Windows NT и должно устанавливаться отдельно.  
  
 <xref:System.Messaging.MessageQueue> Класс является оболочкой вокруг очереди сообщений. Существует несколько версий очереди сообщений и использования <xref:System.Messaging.MessageQueue> класса может привести к немного по-разному, в зависимости от операционной системы с помощью. Дополнительные сведения о конкретных функциях каждой версии службы очереди сообщений см. в разделе, «Новые возможности в очередь сообщений» в Platform SDK в MSDN.  
  
 <xref:System.Messaging.MessageQueue> Класс предоставляет ссылку на очередь MSMQ. Можно указать путь в <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор для подключения существующий ресурс, или можно создать новую очередь на сервере. Перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, или <xref:System.Messaging.MessageQueue.Receive%2A>, необходимо связать новый экземпляр <xref:System.Messaging.MessageQueue> класса существующую очередь. На этом этапе можно изменить свойства очереди, такие как <xref:System.Messaging.MessageQueue.Category%2A> и <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> поддерживает два типа методов извлечения сообщений: синхронные и асинхронные. Синхронные методы <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.Receive%2A>, поток процесса указанный интервал времени для нового сообщения прибывают в очередь ожидания. Асинхронные методы, <xref:System.Messaging.MessageQueue.BeginPeek%2A> и <xref:System.Messaging.MessageQueue.BeginReceive%2A>, задачи основного приложения продолжают выполняться в отдельном потоке, до прибытия сообщения в очереди. Эти методы работают с помощью объекты обратного вызова и состояние объектов для передачи данных между потоками.  
  
 При создании нового экземпляра <xref:System.Messaging.MessageQueue> класса, не создается новая очередь Message Queuing. Вместо этого можно использовать <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, и <xref:System.Messaging.MessageQueue.Purge%2A> методы управления очередей на сервере.  
  
 В отличие от <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> и <xref:System.Messaging.MessageQueue.Delete%28System.String%29> , `static` членами, поэтому их можно вызывать без создания нового экземпляра <xref:System.Messaging.MessageQueue> класса.  
  
 Можно задать <xref:System.Messaging.MessageQueue> объекта <xref:System.Messaging.MessageQueue.Path%2A> с одним из трех имен: понятное имя <xref:System.Messaging.MessageQueue.FormatName%2A>, или <xref:System.Messaging.MessageQueue.Label%2A>. Понятное имя, которое определено в очереди <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> свойства, является <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> для общей очереди, и <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> для частной очереди. <xref:System.Messaging.MessageQueue.FormatName%2A> Свойство предоставляет доступ к очереди сообщений. Наконец, можно использовать очереди <xref:System.Messaging.MessageQueue.Label%2A> свойство для задания в очередь <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Список начальных значений свойств для экземпляра <xref:System.Messaging.MessageQueue>, в разделе <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> объекты с различными типами синтаксиса имени пути. В каждом случае он отправляет сообщение в очередь, путь, определенный в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 В следующем примере кода отправляет сообщение в очередь и получает сообщение из очереди, с помощью конкретного приложения класс с именем `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Только <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> метод является потокобезопасным.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />. После того как используемый по умолчанию конструктор инициализирует новый экземпляр, необходимо задать свойство <see cref="P:System.Messaging.MessageQueue.Path" /> экземпляра, прежде чем можно будет использовать этот экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нового экземпляра <xref:System.Messaging.MessageQueue> класс, который не привязан непосредственно в очередь на сервер очередей сообщений. Перед использованием этого экземпляра его необходимо подключить к существующей очереди Message Queuing, задав <xref:System.Messaging.MessageQueue.Path%2A> свойство. Кроме того, можно задать <xref:System.Messaging.MessageQueue> ссылка на <xref:System.Messaging.MessageQueue.Create%28System.String%29> возвращаемого значения метода, тем самым создавая новая очередь Message Queuing.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Конструктор создает новый экземпляр <xref:System.Messaging.MessageQueue> класса; не создается новая очередь Message Queuing.  
  
 Следующей таблице представлены исходные значения свойств для экземпляра класса <xref:System.Messaging.MessageQueue>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные по умолчанию <xref:System.Messaging.DefaultPropertiesToSend> класса.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные по умолчанию <xref:System.Messaging.MessagePropertyFilter> класса. Все значения фильтра устанавливаются в значение `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />, который ссылается на очередь MSMQ по указанному пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, если требуется привязать новый <xref:System.Messaging.MessageQueue> экземпляр для определенной очереди Message Queuing, для которой известно, что путь, имя формата или метка. Если вы хотите предоставить монопольный доступ первому приложению, которое ссылается на очередь, необходимо задать <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> свойства `true` или используйте конструктор, который передает параметр ограничения доступа для чтения.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Конструктор создает новый экземпляр <xref:System.Messaging.MessageQueue> класса; не создается новая очередь Message Queuing. Чтобы создать новую очередь в очереди сообщений, используйте <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметра зависит от типа очереди он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Машины транзакционную очередь недоставленных сообщений|`MachineName`\\`XactDeadletter$`|  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди, как показано в следующей таблице.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Метка|`Label:` [ *метка* ]|`Label:` TheLabel|  
  
 Для работы в автономном режиме необходимо использовать синтаксис имени формата не синтаксис имени пути для конструктора. В противном случае — исключение, так как основной контроллер домена недоступен для разрешения пути в имя формата.  
  
 Следующей таблице представлены исходные значения свойств для экземпляра класса <xref:System.Messaging.MessageQueue>. Эти значения определяются свойства очереди сообщений с путем, указанным в `path` параметра.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные по умолчанию <xref:System.Messaging.DefaultPropertiesToSend> класса.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, если уровень конфиденциальности очереди MSMQ «Текст»; в противном случае `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Значение свойства имени компьютера очереди MSMQ.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные по умолчанию <xref:System.Messaging.MessagePropertyFilter> класса.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, если не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, если не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, если включен параметр журнала объект очереди сообщений; в противном случае `false`.|  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> объекты с различными типами синтаксиса имени пути. В каждом случае он отправляет сообщение в очередь, путь, определенный в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> имеет неверное значение. Возможно, оно просто не задано.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">
          Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />, который ссылается на очередь MSMQ по указанному пути и с указанным ограничением доступа на чтение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, если требуется привязать новый <xref:System.Messaging.MessageQueue> для определенной очереди Message Queuing, для которой известно, что путь, имя формата или метка. Если вы хотите предоставить монопольный доступ первому приложению, которое ссылается на очередь, установите `sharedModeDenyReceive` параметр `true`. В противном случае `sharedModeDenyReceive` для `false` или используйте конструктор, который содержит только `path` параметра.  
  
 Установка `sharedModeDenyReceive` для `true` влияет на все объекты, которые обращаются к очереди сообщений, включая другие приложения. Влияние параметра не только на это приложение.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Конструктор создает новый экземпляр <xref:System.Messaging.MessageQueue> класса; не создается новая очередь Message Queuing. Чтобы создать новую очередь в очереди сообщений, используйте <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметр зависит от типа очереди.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Машины транзакционную очередь недоставленных сообщений|`MachineName`\\`XactDeadletter$`|  
  
 Кроме того можно использовать имя формата или метку очереди, очереди сообщений для описания пути к очереди.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Метка|`Label:` [ *метка* ]|`Label:` TheLabel|  
  
 Для работы в автономном режиме необходимо использовать синтаксис имени формата, а не синтаксис понятного имени. В противном случае исключение недоступности основного контроллера домена (на котором установлена Active Directory) для разрешения пути в имя формата.  
  
 Если <xref:System.Messaging.MessageQueue> открывает очередь `sharedModeDenyReceive` равным `true`, любые <xref:System.Messaging.MessageQueue> , в последующем попытается прочитать данные из очереди, создаст <xref:System.Messaging.MessageQueueException> из-за нарушения совместного доступа. Объект <xref:System.Messaging.MessageQueueException> также вызывается, если <xref:System.Messaging.MessageQueue> пытается получить доступ к очереди в монопольном режиме, то время как другой <xref:System.Messaging.MessageQueue> уже имеет монопольного доступа к очереди.  
  
 Следующей таблице представлены исходные значения свойств для экземпляра класса <xref:System.Messaging.MessageQueue>. Эти значения определяются свойства очереди MSMQ с путем, указанным в `path` параметра.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные по умолчанию <xref:System.Messaging.DefaultPropertiesToSend> класса.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, если уровень конфиденциальности очереди MSMQ «Текст»; в противном случае `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Значение свойства имени компьютера очереди MSMQ.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные по умолчанию <xref:System.Messaging.MessagePropertyFilter> класса.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, если не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, если не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Значение параметра `sharedModeDenyReceive`.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, если включен параметр журнала объект очереди сообщений; в противном случае `false`.|  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> с монопольным доступом задает путь к нему и отправляет сообщение в очередь.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> имеет неверное значение. Возможно, оно просто не задано.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="accessMode">Одно из значений перечисления <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">
          Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <param name="enableCache">
          Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> с монопольным доступом для чтения и с включенным кэшированием подключений.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">
          Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <param name="enableCache">
          Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</param>
        <param name="accessMode">Одно из значений перечисления <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее режим доступа для очереди.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию режим доступа для очереди не `QueueAccessMode.SendAndReceive`, если не указано иное при вызове конструктора.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, принимает ли очередь только сообщения, прошедшие проверку подлинности.</summary>
        <value>
          Значение <see langword="true" />, если очередь принимает только сообщения, прошедшие проверку подлинности; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверка подлинности сообщений предоставляет способ для проверки целостности сообщений и проверки отправителя сообщения. Чтобы запросить проверку подлинности, передающее приложение задает уровень проверки подлинности сообщения.  
  
 При задании <xref:System.Messaging.MessageQueue.Authenticate%2A> для `true`, ограничен доступ к очереди на сервере, а не только к этому <xref:System.Messaging.MessageQueue> экземпляра. Затрагивает все клиентам, работающим с той же очереди, очереди сообщений.  
  
 В очередь, принимающую только сообщения, прошедшие проверку подлинности будут отклонять сообщения без проверки подлинности. Чтобы запросить уведомление об отклонении сообщения, приложение может задать <xref:System.Messaging.Message.AcknowledgeType%2A> свойства сообщения. Поскольку существует других признаков отклонения сообщения, передающее приложение может потерять сообщение, если запросить его отправки в очередь недоставленных сообщений.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.Authenticate%2A> свойство.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает базовый приоритет, используемый службой очереди сообщений для маршрутизации сообщений общей очереди по сети.</summary>
        <value>Элементарный базовый приоритет для всех сообщений, переданных в общую очередь. Значение по умолчанию равно нулю (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый приоритет очереди сообщений указывает порядок обработки прохождения сообщения, обрабатывается очереди, передаваемого по сети. Можно задать <xref:System.Messaging.MessageQueue.BasePriority%2A> свойства на основании приоритет выше или ниже на все сообщения, отправленные в указанную очередь, отправленными в другие очереди. Задание этого свойства изменяет очереди сообщений. Таким образом, любые другие <xref:System.Messaging.MessageQueue> экземпляры являются повлияло изменение.  
  
 Очередь сообщений <xref:System.Messaging.MessageQueue.BasePriority%2A> не относится к <xref:System.Messaging.Message.Priority%2A> свойства сообщения, которое указывает порядок, в котором входящее сообщение помещается в очередь.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> применяется только к общим очередям, пути которых задаются с помощью имени формата. Базовый приоритет частной очереди всегда равно нулю (0).  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.BasePriority%2A> свойство.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для базового приоритета задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Инициирует асинхронную операцию считывания, указывая службе MSMQ на необходимость запуска операции считывания сообщения и уведомления обработчика событий о завершении операции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует асинхронную операцию считывания, не имеющую тайм-аута. Операция остается незавершенной, пока сообщение не станет доступным в очереди.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется в асинхронной обработке <xref:System.Messaging.MessageQueue.BeginPeek%2A> для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событие, если сообщение не станет доступным в очереди.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Инициирует асинхронную операцию; <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.PeekCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или путем извлечения результата с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, можно вызвать для просмотра очереди без блокировки текущего потока выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginPeek%2A> Чтобы инициировать асинхронную операцию в очереди, расположенный по пути «. \myQueue». При <xref:System.Messaging.MessageQueue.PeekCompleted> события, в примере считывает сообщение и выводит его текст на экране. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <summary>Инициирует асинхронную операцию считывания с заданным тайм-аутом. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется в асинхронной обработке <xref:System.Messaging.MessageQueue.BeginPeek%2A> для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событие, если сообщение не станет доступным в очереди, или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Инициирует асинхронную операцию; <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.PeekCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или путем извлечения результата с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, можно вызвать для просмотра очереди без блокировки текущего потока выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка задает тайм-аут. Если время, заданное параметром `timeout` истекло, компонент инициирует <xref:System.Messaging.MessageQueue.PeekCompleted> событий. Поскольку сообщения отсутствуют, следующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызовет исключение.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию, используя путь к очереди «. \myQueue». Создает обработчик событий `MyPeekCompleted`и прикрепляет его к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается с указанием времени ожидания до одной минуты для запуска асинхронной операции считывания. При <xref:System.Messaging.MessageQueue.PeekCompleted> события или тайм-аут, сообщение возвращается в том случае, если он существует, а основной текст выводится на экран. Затем <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается повторно и инициировать асинхронную операцию просмотра с помощью того же тайм-аута.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <summary>Инициирует асинхронную операцию считывания с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется в асинхронной обработке <xref:System.Messaging.MessageQueue.BeginPeek%2A> для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событие, если сообщение не станет доступным в очереди, или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Используйте эту перегрузку, чтобы связать сведения с операцией, которые будут сохраняться в течение всего времени выполнения операции. Обработчик событий может доступа к этой информации, просмотрев <xref:System.IAsyncResult.AsyncState%2A> свойство <xref:System.IAsyncResult> , связанного с операцией.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Инициирует асинхронную операцию; <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.PeekCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или путем извлечения результата с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, можно вызвать для просмотра очереди без блокировки текущего потока выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает <xref:System.IAsyncResult> , определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка задает время ожидания и объект состояния. Если время, заданное параметром `timeout` истекло, компонент инициирует <xref:System.Messaging.MessageQueue.PeekCompleted> событий. Поскольку сообщения отсутствуют, следующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызовет исключение.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, при вызове метода <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении. Пример такого сценария см. в разделе.  
  
 Можно также использовать объект состояния для передачи сведений между потоками процесса. При запуске этого потока, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалинг и передается обратно вместе со сведениями события.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию, используя путь к очереди «. \myQueue». Создает обработчик событий `MyPeekCompleted`и прикрепляет его к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается, с указанием времени ожидания до одной минуты. Каждый вызов <xref:System.Messaging.MessageQueue.BeginPeek%2A> имеет уникальный целочисленный идентификатор, определяющий данную операцию. При <xref:System.Messaging.MessageQueue.PeekCompleted> события или истечения тайм-аута, сообщение, если оно существует, извлекается и тело и относящиеся к операции целочисленный идентификатор записываются на экране. Затем <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается повторно и инициировать асинхронную операцию просмотра с того же времени ожидания и с целочисленным идентификатором только что завершенной операции.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию считывания с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки обратный вызов, указанный в параметре обратного вызова инициируется, сообщение не станет доступным в очереди, или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.PeekCompleted> событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginPeek%2A> полагаются на этот компонент для формирования <xref:System.Messaging.MessageQueue.PeekCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, можно вызвать для просмотра очереди без блокировки текущего потока выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает <xref:System.IAsyncResult> , определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, при вызове метода <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию. Пример кода отправке сообщения в очередь сообщений на локальном, а затем вызывает <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, передавая: значение времени ожидания 10 секунд; уникальный целочисленный идентификатор конкретного сообщения; и новый экземпляр <xref:System.AsyncCallback> , определяющий обработчик событий `MyPeekCompleted`. Если <xref:System.Messaging.MessageQueue.PeekCompleted> событие, обработчик событий считывает сообщение и выводит на экран текст сообщения и целочисленный идентификатор сообщения.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="action">Одно из значений перечисления <see cref="T:System.Messaging.PeekAction" />. Указывает, следует ли считывать текущее сообщение в очереди или следующее сообщение.</param>
        <param name="state">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию считывания, которая имеет заданный тайм-аут и использует заданный курсор, заданную операцию считывания и заданный объект состояния. Объект состояния предоставляет связанные сведения в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки обратный вызов, указанный в параметре обратного вызова инициируется сообщение не станет доступным в очереди, или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.PeekCompleted> Событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginPeek%2A> полагаются на этот компонент для формирования <xref:System.Messaging.MessageQueue.PeekCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, можно вызвать для просмотра очереди без блокировки текущего потока выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает <xref:System.IAsyncResult> , определяющий асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае использовать <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, при вызове метода <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для параметра <paramref name="action" /> было задано значение, отличное от <see langword="PeekAction.Current" /> или <see langword="PeekAction.Next" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Инициирует асинхронную операцию получения, указывая службе MSMQ на необходимость запуска операции получения сообщения и уведомления обработчика событий о завершении операции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует асинхронную операцию получения без тайм-аута. Операция остается незавершенной, пока сообщение не станет доступным в очереди.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется в асинхронной обработке <xref:System.Messaging.MessageQueue.BeginReceive%2A> для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, когда сообщение было удалено из очереди.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Для синхронного получения сообщений, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, можно создать для данной операции считывания. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается цепочка асинхронных запросов. Предполагается, что есть очередь на локальном компьютере, именем «myQueue». `Main` Функция начинает асинхронную операцию, которая обрабатывается `MyReceiveCompleted` подпрограммы. `MyReceiveCompleted` обрабатывает текущее сообщение и начинает новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 В следующем примере кода создается очередь асинхронных запросов. Вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> использует <xref:System.IAsyncResult.AsyncWaitHandle%2A> результирующее значение. `Main` Процедура ожидает завершения перед выходом из всех асинхронных операций.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется в асинхронной обработке <xref:System.Messaging.MessageQueue.BeginReceive%2A> для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, если сообщение не станет доступным в очереди, или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Для синхронного получения сообщений, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка задает тайм-аут. Если время, заданное параметром `timeout` истекло, компонент инициирует <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий. Поскольку сообщения отсутствуют, следующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызовет исключение.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, можно создать для данной операции считывания. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию получения. В примере кода создается обработчик событий `MyReceiveCompleted`и прикрепляет его к <xref:System.Messaging.MessageQueue.ReceiveCompleted> делегата обработчика событий. Отправляет пример кода сообщение очереди сообщений на локальном, затем вызывает метод <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, передавая значение времени ожидания 10 секунд. Если <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, обработчик событий получает сообщение и выводит на экран текста сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, было введено отрицательное число.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется в асинхронной обработке <xref:System.Messaging.MessageQueue.BeginReceive%2A> для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, если сообщение не станет доступным в очереди, или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Используйте эту перегрузку, чтобы связать сведения с операцией, которые будут сохраняться в течение всего времени выполнения операции. Обработчик событий может обнаружить эти сведения, просмотрев <xref:System.IAsyncResult.AsyncState%2A> свойство <xref:System.IAsyncResult> , связанного с операцией.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Для синхронного получения сообщений, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка задает время ожидания и объект состояния. Если время, заданное параметром `timeout` истекло, компонент инициирует <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий. Поскольку сообщения отсутствуют, следующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызовет исключение.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, при вызове метода <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Можно также использовать объект состояния для передачи сведений между потоками процесса. При запуске этого потока, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалинг и передается обратно вместе со сведениями события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, можно создать для данной операции считывания. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию получения. В примере кода создается обработчик событий `MyReceiveCompleted`и прикрепляет его к <xref:System.Messaging.MessageQueue.ReceiveCompleted> делегата обработчика событий. Отправляет пример кода сообщение очереди сообщений на локальном, затем вызывает метод <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, передавая значение времени ожидания 10 секунд и уникальный целочисленный идентификатор конкретного сообщения. Если <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, обработчик событий получает сообщение и выводит на экран текст сообщения и целочисленный идентификатор сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки обратный вызов, указанный в параметре обратного вызова инициируется, сообщение не станет доступным в очереди, или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginReceive%2A> полагаются на этот компонент для формирования <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Для синхронного получения сообщений, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, при вызове метода <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Можно также использовать объект состояния для передачи сведений между потоками процесса. При запуске этого потока, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалинг и передается обратно вместе со сведениями события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, можно создать для данной операции считывания. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию получения. Пример кода отправке сообщения в очередь сообщений на локальном, а затем вызывает <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, передавая: значение времени ожидания 10 секунд; уникальный целочисленный идентификатор конкретного сообщения; и новый экземпляр <xref:System.AsyncCallback> , определяющий обработчик событий `MyReceiveCompleted`. Если <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, обработчик событий получает сообщение и выводит на экран текст сообщения и целочисленный идентификатор сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="state">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию получения, которая имеет заданный тайм-аут и использует заданный курсор и заданный объект состояния. Объект состояния предоставляет связанные сведения в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки обратный вызов, указанный в параметре обратного вызова инициируется, сообщение не станет доступным в очереди, или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginReceive%2A> полагаются на этот компонент для формирования <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и связывания его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> увидит формирование <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод возвращается немедленно, но асинхронной операции не будет завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Для синхронного получения сообщений, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Эту функцию можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Однако если запускается несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значениям в массиве и укажите, следует ли ожидать все операции или для выполнения любой операции. В этом случае использовать <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, при вызове метода <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Можно также использовать объект состояния для передачи сведений между потоками процесса. При запуске этого потока, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалинг и передается обратно вместе со сведениями события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, можно создать для данной операции считывания. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли быть прочитан объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>
          Значение <see langword="true" />, если класс <see cref="T:System.Messaging.MessageQueue" /> существует, и приложение может прочитать данные из него; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Указывает, является ли приложение может просматривать и получать сообщения из очереди. Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `true`, <xref:System.Messaging.MessageQueue> может получать и считывать сообщения из очереди. В противном случае невозможно.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> — `false` Если очередь уже открыта с монопольным доступом для чтения (или если он открыт монопольного доступа, и этот <xref:System.Messaging.MessageQueue> запрашивает монопольный доступ), или если приложение не имеет достаточных прав для доступа к нему. При попытке чтения из очереди приложения при <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, отказано в доступе.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередью сообщений <xref:System.Messaging.MessageQueue.CanRead%2A> свойство.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли быть выполнена запись в <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>
          Значение <see langword="true" />, если класс <see cref="T:System.Messaging.MessageQueue" /> существует, и приложение может записать в него данные; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Указывает, является ли приложение может отправлять сообщения в очередь. Если <xref:System.Messaging.MessageQueue.CanWrite%2A> — `true`, <xref:System.Messaging.MessageQueue> могут отправлять сообщения в очередь. В противном случае невозможно.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> — `false` Если очереди уже был открыт монопольный доступ на запись (или если он открыт монопольного доступа, и этот <xref:System.Messaging.MessageQueue> запрашивает монопольный доступ), или если приложение не имеет достаточных прав для доступа к нему. Если приложение пытается выполнить запись в очередь при <xref:System.Messaging.MessageQueue.CanWrite%2A> — `false`, отказано в доступе.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередью сообщений <xref:System.Messaging.MessageQueue.CanWrite%2A> свойство.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает категорию очереди.</summary>
        <value>Объект <see cref="T:System.Guid" />, представляющий категорию очереди (идентификатор типа очереди сообщений), которая позволяет приложению классифицировать его очереди. Значение по умолчанию: <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Категория очереди позволяет приложению классифицировать его очереди. Например можно поместить все очереди выставление счетов в одной категории, а все очереди заказа в другой.  
  
 <xref:System.Messaging.MessageQueue.Category%2A> Свойство предоставляет доступ к свойству идентификатора типов очередей сообщений (который доступен для чтения и записи), доступные через **свойства очереди** диалоговое окно в консоли управления компьютером. Можно определить новую категорию. Несмотря на то, что можно использовать <xref:System.Guid.NewGuid%2A> для создания значения категории, которое является уникальным для всех <xref:System.Guid> значения, это действие не требуется. Значение категории должно отличаться только от других категорий, а не от всех других <xref:System.Guid> значения. Например, можно назначить {00000000-0000-0000-0000-000000000001} как <xref:System.Messaging.MessageQueue.Category%2A> для одного набора очередей и {00000000-0000-0000-0000-000000000002} как <xref:System.Messaging.MessageQueue.Category%2A> для другого набора.  
  
 Нет необходимости задать <xref:System.Messaging.MessageQueue.Category%2A>. Допускается значение `null`.  
  
 Задание этого свойства изменяет очереди сообщений. Таким образом, любые другие <xref:System.Messaging.MessageQueue> экземпляры являются повлияло изменение.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.Category%2A> свойство.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для категории очереди задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает кэш подключений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, удаляются имена форматов, хранящиеся в кэше и закрытия дескрипторов открытые и хранящиеся в кэше.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В приведенном ниже примере кода вызывается <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, выделенные классом <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> Освобождает все ресурсы, связанные с <xref:System.Messaging.MessageQueue>, включая общие ресурсы, если это необходимо. Система возвращает себе ресурсы автоматически, если они по-прежнему доступны, например при вызове <xref:System.Messaging.MessageQueue.Send%28System.Object%29> метода, как в следующем коде C#.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 При вызове <xref:System.Messaging.MessageQueue.Close%2A>, что все <xref:System.Messaging.MessageQueue> свойства, которые напрямую обращаются к очереди сообщений, очищаются. <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, И <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> все остается прежним.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> не всегда освободить чтения и записи в очередь, так как они могут быть общими. Можно использовать любой из следующих действий, чтобы убедиться, что <xref:System.Messaging.MessageQueue.Close%2A> освобождает дескрипторы чтения и записи в очередь:  
  
-   Создание <xref:System.Messaging.MessageQueue> с монопольным доступом. Чтобы сделать это, вызовите <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> или <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и задайте `sharedModeDenyReceive` параметр `true`.  
  
-   Создание <xref:System.Messaging.MessageQueue> с отключенным кэшированием соединения. Чтобы сделать это, вызовите <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> конструктор и задайте `enableConnectionCache` параметр `false`.  
  
-   Отключите кэширование подключения. Чтобы сделать это, установите <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> свойства `false`.  
  
 Следует вызвать <xref:System.Messaging.MessageQueue.Close%2A> для очереди, прежде чем удалять очереди сервера очереди сообщений. В противном случае сообщения, отправленные в очередь может вызывать исключения или отображаются в очереди недоставленных сообщений.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода закрывает очередь MSMQ.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новую очередь на сервере очереди сообщений по указанному пути.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь создаваемой очереди.</param>
        <summary>Создает нетранзакционную очередь сообщений по указанному пути.</summary>
        <returns>Класс <see cref="T:System.Messaging.MessageQueue" />, представляющий новую очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для создания нетранзакционной очереди MSMQ.  
  
 Чтобы создать новый экземпляр <xref:System.Messaging.MessageQueue> класса в приложении и привязать его к существующей очереди, используйте <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор. Чтобы создать новую очередь в очереди сообщений, вызовите <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметра зависит от типа очереди он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
  
 Используйте «.» для локального компьютера. Дополнительные сведения о синтаксисе см. <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода создается общая и частная очереди. Он отправляет сообщение в выбранной очереди.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">По указанному пути уже существует очередь.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Путь создаваемой очереди.</param>
        <param name="transactional">
          Значение <see langword="true" />, если необходимо создать транзакционную очередь; значение <see langword="false" />, если необходимо создать нетранзакционную очередь.</param>
        <summary>Создает транзакционную или нетранзакционную очередь сообщений по указанному пути.</summary>
        <returns>Класс <see cref="T:System.Messaging.MessageQueue" />, представляющий новую очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эту перегрузку можно использовать для создания транзакционной очереди в очереди сообщений. Нетранзакционная очередь, можно создать, присвоив `transactional` параметр `false` или вызвав другая перегрузка метода <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Чтобы создать новый экземпляр <xref:System.Messaging.MessageQueue> класса в приложении и привязать его к существующей очереди, используйте <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор. Чтобы создать новую очередь в очереди сообщений, вызовите <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметра зависит от типа очереди он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
  
 Используйте «.» для локального компьютера. Дополнительные сведения о синтаксисе см. <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода создаются открытых и закрытых транзакций очереди. Он отправляет сообщение в выбранной очереди.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">По указанному пути уже существует очередь.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Messaging.Cursor" /> для текущей очереди сообщений.</summary>
        <returns>Новый объект <see cref="T:System.Messaging.Cursor" /> для текущей очереди сообщений. Этот курсор используется для сохранения определенного положения в очереди при чтении сообщений очереди.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время и дату создания очереди в службе очереди сообщений.</summary>
        <value>Объект <see cref="T:System.DateTime" /> представляющий дату и время создания очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> относится к очереди на сервере очереди сообщений не <xref:System.Messaging.MessageQueue> экземпляра.  
  
 Если очередь существует, это свойство представляет время создания очереди, скорректированное в местное время сервера, на котором существует очередь.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередью сообщений <xref:System.Messaging.MessageQueue.CreateTime%2A> свойство.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значения свойств сообщения, которые будут использоваться по умолчанию, когда приложение будет отправлять сообщения в очередь.</summary>
        <value>Свойство <see cref="T:System.Messaging.DefaultPropertiesToSend" />, содержащее используемые по умолчанию значения свойств сообщений очереди сообщений, которые применяются, когда приложение отправляет в очередь объекты, отличные от экземпляров <see cref="T:System.Messaging.Message" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При отправке любой объект, который не относится к типу <xref:System.Messaging.Message> в очередь <xref:System.Messaging.MessageQueue> вставляет объект в сообщение Message Queuing. В этот момент <xref:System.Messaging.MessageQueue> применяет к этому сообщению значения свойств, указанные в <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> свойство. И наоборот при отправке <xref:System.Messaging.Message> в очередь, эти свойства уже заданы для самого экземпляра, поэтому <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> учитывается для <xref:System.Messaging.Message>.  
  
 Несмотря на то, что значение свойства с помощью <xref:System.Messaging.MessageQueue> объекта, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ссылается на свойства сообщения, которые отправляются в очередь, а не саму очередь.  
  
 В следующей таблице показаны значения по умолчанию для свойства.  
  
|Свойство.|Значение по умолчанию|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Ноль (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Пустая строка (»»)|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода используется приоритет сообщения для определения свойств по умолчанию для отправки сообщения.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для очереди нельзя задать использующиеся по умолчанию свойства. Возможно, потому что неправильно задано одно из свойств.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение удаляемой очереди.</param>
        <summary>Удаляет очередь с сервера очереди сообщений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Синтаксис `path` параметр зависит от типа очереди.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
  
 Дополнительные сведения о синтаксисе см. <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди.  
  
|Ссылка|Синтаксис|  
|---------------|------------|  
|Название формата|FormatName: [ *имя формата* ]|  
|Метка|Метка: [ *метка* ]|  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода удаляется очередь MSMQ, если он существует.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Для параметра <paramref name="path" /> используется неправильный синтаксис.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, имеет ли этот объект <see cref="T:System.Messaging.MessageQueue" /> монопольный доступ на получение сообщений из очереди сообщений.</summary>
        <value>
          Значение <see langword="true" />, если этот класс <see cref="T:System.Messaging.MessageQueue" /> имеет права монопольного доступа для получения сообщений из очереди; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Указывает режим создания общих очереди, упоминаемой в этом <xref:System.Messaging.MessageQueue>. Задать <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> для `true` , только это <xref:System.Messaging.MessageQueue> должны иметь доступ на просмотр и получение сообщений из очереди с указанным <xref:System.Messaging.MessageQueue.Path%2A>. Если другой <xref:System.Messaging.MessageQueue> или другое приложение связано с тем же ресурсом очереди, этот экземпляр или приложение не сможет просматривать и получать сообщения, но она по-прежнему отправлять их.  
  
 Если <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> — `false`, очередь доступна для нескольких приложений для отправки, просмотра или получения сообщений.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> свойство.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Уничтожает ресурсы (кроме памяти), используемые классом <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> по окончании использования класса <xref:System.Messaging.MessageQueue>. Метод <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> оставляет класс <xref:System.Messaging.MessageQueue> в непригодном для использования состоянии. После вызова метода <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, необходимо освободить все ссылки на <xref:System.Messaging.MessageQueue> , занимаемая ими память можно удалять его сборщику мусора.  
  
 Необходимо вызвать <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> перед освобождением последней ссылки на <xref:System.Messaging.MessageQueue>. В противном случае ресурсы <xref:System.Messaging.MessageQueue> — не будут освобождены до сборки мусора не будет <xref:System.Messaging.MessageQueue> деструктор объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, будет ли приложение поддерживать кэш подключений.</summary>
        <value>
          Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кэш подключений приведен список ссылок на структуры, содержащие чтения или записи в очереди. При <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> — `true`, <xref:System.Messaging.MessageQueue> занимает маркеры из кэша при каждом вызове <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, или <xref:System.Messaging.MessageQueue.Receive%2A>, а не создает новые дескрипторы. Это может повысить производительность. Использование кэша подключений также изолирует <xref:System.Messaging.MessageQueue> от изменений топологии сети.  
  
 Если создать новое соединение в очередь, когда кэш подключений заполнен <xref:System.Messaging.MessageQueue> перезаписывает бы недавно использовавшихся структуры с новым соединением. Очистку кэша можно провести с помощью метода <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, например, если имена формата очередей, вы работаете с были изменены, чтобы предыдущие чтения и записи, дескрипторы становятся недействительными.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> свойство.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, будет ли очередь принимать только неконфиденциальные (незашифрованные) сообщения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.EncryptionRequired" />. Значение по умолчанию: <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании, что шифрование является обязательным для сообщений, отправленных в очередь, шифруются только тел сообщений. Другие члены (например, <xref:System.Messaging.Message.Label%2A> и <xref:System.Messaging.Message.SenderId%2A> свойства) не могут быть зашифрованы.  
  
 Задание этого свойства изменяет очереди сообщений. Таким образом, любые другие <xref:System.Messaging.MessageQueue> экземпляры являются повлияло изменение.  
  
 Если сообщение зашифровано, автоматически делает закрытый. Можно указать требования шифрования очереди `None`, `Body`, или `Optional` , установив <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> свойство соответствующим образом. <xref:System.Messaging.Message.UseEncryption%2A> Требования шифрования очереди должно соответствовать сообщение. Если сообщение не зашифровано, но очередь не указывает `Body`, или если сообщение зашифровано, но очередь не указывает `None`, сообщение будет отклонено очередью. Если отправляющее приложение запрашивает сообщение отрицательного подтверждения в этом событии, очереди сообщений указывает отправляющего приложения, что сообщение было отвергнуто. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> свойство `true`, завершаются с ошибкой шифрования помещается в очередь недоставленных сообщений. В противном случае сообщение теряется.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> свойство.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, определяющий асинхронную операцию считывания, которая завершается и из которой извлекается конечный результат.</param>
        <summary>Завершает указанную асинхронную операцию считывания.</summary>
        <returns>Класс <see cref="T:System.Messaging.Message" />, связанный с завершенной асинхронной операцией.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> завершает операцию, которая была начата <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызова. Чтобы сделать это, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> считывает сообщение.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> можно указать время ожидания, что приведет к тому <xref:System.Messaging.MessageQueue.PeekCompleted> событие при возникновении тайм-аута до появления сообщения в очереди. При возникновении тайм-аута без сообщений, поступающих в очередь в последующем вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> приводит к возникновению исключения.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> используется для чтения сообщения, которое вызвало <xref:System.Messaging.MessageQueue.PeekCompleted> вызова события.  
  
 Если вы хотите продолжить асинхронный просмотр сообщений, можно снова вызвать метод <xref:System.Messaging.MessageQueue.BeginPeek%2A> после вызова <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginPeek%2A> Чтобы инициировать асинхронную операцию в очереди, расположенный по пути «. \myQueue». При <xref:System.Messaging.MessageQueue.PeekCompleted> события, в примере считывает сообщение и выводит его текст на экране. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="asyncResult" /> используется неправильный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, определяющий асинхронную операцию получения, которая завершается и из которой извлекается конечный результат.</param>
        <summary>Завершает указанную асинхронную операцию получения.</summary>
        <returns>Класс <see cref="T:System.Messaging.Message" />, связанный с завершенной асинхронной операцией.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Messaging.MessageQueue.ReceiveCompleted> события <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> завершает операцию, которая была начата <xref:System.Messaging.MessageQueue.BeginReceive%2A> вызова. Чтобы сделать это, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> получает сообщение.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> можно указать время ожидания, что приведет к тому <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие при возникновении тайм-аута до появления сообщения в очереди. При возникновении тайм-аута без сообщений, поступающих в очередь в последующем вызове <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> приводит к возникновению исключения.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> используется для чтения (с удалением из очереди) сообщения, которое вызвало <xref:System.Messaging.MessageQueue.ReceiveCompleted> вызова события.  
  
 Если вы хотите продолжить асинхронное получение сообщений, можно снова вызвать метод <xref:System.Messaging.MessageQueue.BeginReceive%2A> после вызова <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается цепочка асинхронных запросов. Предполагается, что есть очередь на локальном компьютере, именем «myQueue». `Main` Функция начинает асинхронную операцию, которая обрабатывается `MyReceiveCompleted` подпрограммы. `MyReceiveCompleted` обрабатывает текущее сообщение и начинает новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="asyncResult" /> используется неправильный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение искомой очереди.</param>
        <summary>Определяет, существует ли по указанному пути очередь сообщений.</summary>
        <returns>
          Значение <see langword="true" />, если очередь по указанному пути существует; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Метод определяет, существует ли очередь Message Queuing по указанному пути. Метод не существует в том, чтобы определить, существует ли очередь с указанным именем формата. Дополнительные сведения о синтаксисе имени формата и других формах синтаксиса пути см. в разделе <xref:System.Messaging.MessageQueue.Path%2A> свойство.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> является ресурсоемкой операцией. Используйте только в том случае, когда это необходимо в приложении.  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Метод не поддерживает <xref:System.Messaging.MessageQueue.FormatName%2A> префикс.  
  
 Синтаксис `path` параметр зависит от типа очереди, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> не может вызываться для проверки существования удаленной частной очереди.  
  
 Дополнительные сведения о синтаксисе см. <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди.  
  
|Ссылка|Синтаксис|  
|---------------|------------|  
|Метка|Метка: [ `label` ]|  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода проверяет, является ли очередь MSMQ существует, а затем удаляет его.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Неправильный синтаксис параметра <paramref name="path" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
 - или -  
  
 Метод <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> вызывается на удаленной частной очереди.</exception>
        <exception cref="T:System.InvalidOperationException">При проверке существования очереди приложение использовало синтаксис имени формата.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальное имя очереди, созданное службой очереди сообщений в момент создания очереди.</summary>
        <value>Имя очереди, которое является уникальным в сети.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> Свойство содержит имя формата очереди. Служба Message Queuing использует имя формата для определения открываемой очереди и способа доступа к ней. В отличие от большинства характеристик очереди имя формата не свойством очереди приложения Message Queuing, поэтому они недоступны через средство управления очереди сообщений. Имя формата — это уникальное имя для очереди, который создается службой Message Queuing при создании очереди или создается приложением позднее.  
  
 При указании пути, используя синтаксис имени пути (например, `myComputer\myQueue`) вместо того чтобы использовать синтаксис имени формата при чтении или записи в очередь, основной контроллер домена (с использованием Active Directory) преобразует <xref:System.Messaging.MessageQueue.Path%2A> в связанных <xref:System.Messaging.MessageQueue.FormatName%2A> перед получением доступа к очереди. Если приложение работает в автономном режиме, необходимо использовать синтаксис имени формата; в противном случае основной контроллер домена будет недоступен для выполнения преобразования путь.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередью сообщений <xref:System.Messaging.MessageQueue.FormatName%2A> свойство.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> не указывается.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает модуль форматирования, используемый для сериализации объекта в текст сообщения или десериализации из текста сообщения, прочитанного из очереди или записанного в очередь.</summary>
        <value>Объект <see cref="T:System.Messaging.IMessageFormatter" />, создающий поток, записываемый в текст сообщения или считываемый из него. Значение по умолчанию: <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> Свойство содержит экземпляр объекта модуля форматирования, который преобразует сообщения, когда приложение считывает или записывает в очередь.  
  
 Когда приложение отправляет сообщение в очередь, модуль форматирования сериализует объект в поток и вставляет его в тело сообщения. При чтении из очереди форматер десериализует данные из <xref:System.Messaging.Message.Body%2A> свойство <xref:System.Messaging.Message>.  
  
 <xref:System.Messaging.XmlMessageFormatter> Слабо связанный, поэтому нет необходимости иметь объект того же типа на отправителя и получателя, при применении этого формата. <xref:System.Messaging.ActiveXMessageFormatter> И <xref:System.Messaging.BinaryMessageFormatter> сериализации данных в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке и получении COM-компонентов.  
  
 <xref:System.Messaging.BinaryMessageFormatter> и <xref:System.Messaging.ActiveXMessageFormatter> обеспечивают более высокую производительность, чем <xref:System.Messaging.XmlMessageFormatter>. <xref:System.Messaging.ActiveXMessageFormatter> Обеспечивает возможность взаимодействия с приложениями очереди сообщений Visual Basic 6.0.  
  
 Когда приложение отправляет сообщения в очередь <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> применяется только для тех сообщений, которые используются свойства сообщения по умолчанию <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. При отправке <xref:System.Messaging.Message> для очереди, очереди сообщений использует модуль форматирования, определенные в <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойства вместо сериализации текста сообщения.  
  
 <xref:System.Messaging.MessageQueue> Всегда будет использоваться классом <xref:System.Messaging.Message> для получения и просмотра сообщения из очереди. Сообщение сериализуется с помощью <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода демонстрируется, форматирование текста сообщения с помощью <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 В следующем примере кода демонстрируется, форматирование текста сообщения с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все сообщения из очереди.</summary>
        <returns>Массив типа <see cref="T:System.Messaging.Message" />, который представляет все сообщения очереди в том же порядке, в каком они располагаются в очереди сообщений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Возвращает статический снимок сообщений в очереди, не динамические ссылки на эти сообщения. Таким образом массив нельзя использовать для изменения сообщений в очереди. Если требуется, чтобы в режиме реального времени, динамическое взаимодействие с очередью (например, возможность удаления сообщений), вызовите <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> метод, который возвращает динамический список сообщений в очереди.  
  
 Поскольку <xref:System.Messaging.MessageQueue.GetAllMessages%2A> возвращает копию сообщения в очереди на момент вызова метода, массив не отражает новые сообщения, поступающие в очередь или сообщений, удаленных из очереди.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Получает только свойства, не отфильтрованные <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перечисляет сообщения в очереди. Параметр <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> использовать не рекомендуется. Вместо него следует использовать метод <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, обеспечивающий динамическое подключение к сообщениям очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Имя компьютера, на котором расположена очередь, без двух обратных косых черт (\\\\) в начале.</param>
        <summary>Получает идентификатор компьютера, на котором расположена очередь, на которую ссылается этот класс <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <returns>Объект <see cref="T:System.Guid" />, который представляет уникальный идентификатор компьютера, на котором расположена очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификатор компьютера можно использовать для двух целей, в частности: для чтения журнала компьютера и задания сертификатов безопасности. Тем не менее, не может вызвать <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> на удаленном компьютере, при работе вне сети, так как оно должно иметь доступ к службе каталогов на контроллере домена.  
  
 Идентификатор компьютера (или идентификаторы компьютеров) является <xref:System.Guid> , служба Message Queuing создает при добавлении компьютера в среде предприятия. Служба Message Queuing объединяет идентификатор компьютера с `Machine` и `Journal` ключевые слова, чтобы создать журнал компьютера формат имени, которое имеет синтаксис `Machine=<computeridentifier>;Journal`. Журнал компьютера, который также известен как очередь журнала, является очередь системы, в которой хранятся копии создаваемые приложением сообщения, когда <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> свойство `true`.  
  
 Этот синтаксис журнала является допустимым только при создании имени формата очереди. Синтаксис имени пути `MachineName` \\ `Journal$`.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В приведенном ниже примере кода вызывается <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Не удается извлечь идентификатор компьютера. Возможной причиной может быть недоступность службы каталогов: например, при работе в автономном режиме.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект перечислителя для всех сообщений очереди. Параметр <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> использовать не рекомендуется. Вместо него следует использовать метод <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageEnumerator" /> содержащий сообщения, которые находятся в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> Создает динамический список всех сообщений в очереди. Можно удалить из очереди сообщений в текущей позиции перечислителя в путем вызова <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> для <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> возвращает.  
  
 Поскольку курсор связан с динамическим списком сообщений в очереди, перечисление отражает все изменения, внесенные в сообщения в очереди, если сообщение находится за текущей позицией курсора. Например перечислитель может автоматически получить доступ к сообщению с более низким приоритетом, размещенному за текущей позицией курсора, но не более высокий приоритет сообщения вставлена до этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым наведя курсор назад в начало списка, путем вызова <xref:System.Messaging.MessageEnumerator.Reset%2A> для <xref:System.Messaging.MessageEnumerator>.  
  
 Порядок сообщений в перечислении отражает их порядок в очереди, поэтому появятся сообщения с более высоким приоритетом перед более низким приоритетом.  
  
 Если требуется статический снимок сообщений в очереди, а не динамическое подключение к ним, вызовите <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Этот метод возвращает массив <xref:System.Messaging.Message> объектов, которые представляют сообщения на момент вызова метода.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода возвращает динамический список сообщений в очереди и пересчет всех сообщений <xref:System.Messaging.Message.Priority%2A> свойство <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект перечислителя для всех сообщений очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageEnumerator" /> содержащий сообщения, которые находятся в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Создает динамический список всех сообщений в очереди. Можно удалить из очереди сообщений в текущей позиции перечислителя в путем вызова <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> для <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> возвращает.  
  
 Поскольку курсор связан с динамическим списком сообщений в очереди, перечисление отражает все изменения, внесенные в сообщения в очереди, если сообщение находится за текущей позицией курсора. Например перечислитель может автоматически получить доступ к сообщению с более низким приоритетом, размещенному за текущей позицией курсора, но не более высокий приоритет сообщения вставлена до этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым наведя курсор назад в начало списка, путем вызова <xref:System.Messaging.MessageEnumerator.Reset%2A> для <xref:System.Messaging.MessageEnumerator>.  
  
 Порядок сообщений в перечислении отражает их порядок в очереди, поэтому появятся сообщения с более высоким приоритетом перед более низким приоритетом.  
  
 Если требуется статический снимок сообщений в очереди, а не динамическое подключение к ним, вызовите <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Этот метод возвращает массив <xref:System.Messaging.Message> объектов, которые представляют сообщения на момент вызова метода.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает объект перечислителя для динамического списка общих очередей сети.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает семантику курсора последовательного доступа для перечисления во всех общих очередях сети.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageQueueEnumerator" />, обеспечивающий динамическое перечисление всех общих очередей сообщений в сети.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> возвращает перечисление общих очередей, которые находятся в сети.  
  
 Поскольку курсор связан с динамическим перечислением, перечисление отражаются все изменения, внесенные в список очередей удалены или добавлены за текущей позицией курсора. Добавление и удаление очередей, расположенных до текущей позиции курсора, не отражаются. Например перечислитель позволяет автоматически обращаться к очереди, добавленной за позицией курсора, но не вставлена до этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым наведя курсор назад в начало списка, путем вызова <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> для <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Нет, не определен порядок очередей в сети. Перечислитель не упорядочивает их по компьютера, метки, открытые или закрытые состояния или любому другому доступному критерию.  
  
 Если требуется статический снимок очередей в сети, а не динамическое подключение к ним, вызовите <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> или <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Каждый из этих двух методов возвращает массив <xref:System.Messaging.MessageQueue> объектов, которые представлены очереди на момент вызова метода.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выполняется итерация по всем очередям сообщений в сети и исследуются пути каждой очереди. Наконец он отображает число общих очередей в сети.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Объект <see cref="T:System.Messaging.MessageQueueCriteria" />, содержащий критерии фильтрации доступных очередей сообщений.</param>
        <summary>Обеспечивает семантику курсора последовательного доступа для перечисления во всех общих очередях сети, удовлетворяющих указанным критериям.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageQueueEnumerator" />, обеспечивающий динамическое перечисление общих очередей сообщений сети, удовлетворяющих ограничениям, заданным параметром <paramref name="criteria" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> возвращает список всех общих очередей в сети, которые удовлетворяют критериям, заданным в критериях приложения. Можно указать критерии, которые включают, например, очереди, время создания или изменения, имя компьютера, метки, категории или любое сочетание этих.  
  
 Поскольку курсор связан с динамическим перечислением, перечисление отражаются все изменения, вносимые в очередь, находящихся за текущей позицией курсора. Изменение очередей, расположенных до текущей позиции курсора, не отражаются. Например перечислитель позволяет автоматически обращаться к очереди, добавленной за позицией курсора, но не вставлена до этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым наведя курсор назад в начало списка, путем вызова <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> для <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Нет, не определен порядок очередей в сети. Перечислитель не упорядочивает их по компьютера, метки, открытые или закрытые состояния или любому другому доступному критерию.  
  
 Статический снимок очередей в сети, а не динамическое подключение к ним, укажите критерии для <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> или вызвать <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Каждый из этих двух методов возвращает массив <xref:System.Messaging.MessageQueue> объектов, которые представлены очереди на момент вызова метода. Вызов <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, или <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> дает тот же результат, что и вызов метода <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> с критериями фильтра свойств <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, и <xref:System.Messaging.MessageQueue.MachineName%2A>соответственно.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выполняется итерация по очереди сообщений и отображаются пути всех очередей сообщений, созданных за последний день и который существует на компьютере «Мойкомпьютер».  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, из которого извлекаются частные очереди.</param>
        <summary>Извлекает все частные очереди на указанном компьютере.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные частные очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Извлекает статический снимок очередей на указанном компьютере.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="machineName" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает все общие очереди сети.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает все общие очереди сети.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, если требуется полный список всех общих очередей в сети. Если вы хотите ограничить список по определенным критериям, такие как <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, или время последнего изменения используйте другую перегрузку этого метода. (Кроме того, можно использовать <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, или <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Извлекает статический снимок очередей. Для взаимодействия с динамический список очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Объект <see cref="T:System.Messaging.MessageQueueCriteria" />, содержащий критерии фильтрации очередей.</param>
        <summary>Извлекает все общие очереди сети, удовлетворяющие указанным критериям.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если требуется отфильтровать все общие очереди сети метки, категории или имя компьютера, <xref:System.Messaging.MessageQueue> класс содержит конкретные методы, которые предоставляют эти функциональные возможности (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, и <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>соответственно). Используйте эту перегрузку, чтобы получить список всех общих очередей сети, удовлетворяющих более одного из этих критериев (например, если вы хотите указать метку и категорию). Можно также осуществлять фильтрацию по критериям сообщение отличный от <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, и <xref:System.Messaging.MessageQueue.MachineName%2A>. Например Эта перегрузка используется для фильтрации по времени последнего изменения очереди. Просто создайте новый экземпляр <xref:System.Messaging.MessageQueueCriteria> класса, задайте соответствующие свойства экземпляра и сделать этот экземпляр `criteria` параметра.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Извлекает статический снимок очередей. Для взаимодействия с динамический список очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Класс <see cref="T:System.Guid" />, который группирует набор очередей для извлечения.</param>
        <summary>Извлекает все общие очереди сети, принадлежащие к указанной категории.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для фильтрации общих очередей по категории. <xref:System.Messaging.MessageQueue.Category%2A> Свойство предоставляет доступ к очереди сообщений типа свойства ID (который является чтение и запись) определенной очереди. Несмотря на то, что можно использовать <xref:System.Guid.NewGuid%2A> для создания значения категории, которое является уникальным для всех <xref:System.Guid> значения, нет необходимости. Значение категории должно отличаться только от других категорий, а не от всех других <xref:System.Guid> значения. Например, можно назначить {00000000-0000-0000-0000-000000000001} как <xref:System.Messaging.MessageQueue.Category%2A> для одного набора очередей и {00000000-0000-0000-0000-000000000002} как <xref:System.Messaging.MessageQueue.Category%2A> для другого набора.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Извлекает статический снимок очередей. Для взаимодействия с динамический список очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Можно указать категорию в рамках <xref:System.Messaging.MessageQueueCriteria> передачи в метод.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Метка, которая группирует набор очередей для извлечения.</param>
        <summary>Извлекает все общие очереди сети с указанной меткой.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для фильтрации общих очередей по метке.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Извлекает статический снимок очередей. Для взаимодействия с динамический список очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Метки можно указать как часть <xref:System.Messaging.MessageQueueCriteria> передачи в метод.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Имя компьютера, на котором располагается набор извлекаемых общих очередей.</param>
        <summary>Извлекает все общие очереди, находящиеся на указанном компьютере.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на общие очереди, находящиеся на компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для фильтрации общих очередей на компьютере.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Извлекает статический снимок очередей. Для взаимодействия с динамический список очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Можно указать имя компьютера в рамках <xref:System.Messaging.MessageQueueCriteria> передачи в метод.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> имеет неверный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает контекст безопасности, который служба MSMQ связывает с текущим пользователем (удостоверением потока) на момент этого вызова.</summary>
        <returns>Объект <see cref="T:System.Messaging.SecurityContext" />, содержащий контекст безопасности.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор очереди сообщений.</summary>
        <value>Свойство <see cref="P:System.Messaging.MessageQueue.Id" />, представляющее идентификатор сообщения, создаваемый приложением очереди сообщений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing присваивает <xref:System.Messaging.MessageQueue.Id%2A> свойства при создании очереди. Это свойство доступно только для общих очередей.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередью сообщений <xref:System.Messaging.MessageQueue.Id%2A> свойство.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для очереди нет ограничений по размеру.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот элемент часто используется при задании <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> или <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Messaging.MessageQueue.InfiniteQueueSize> член.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для методов считывания и получения сообщений не существует тайм-аута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> поддерживает два типа методов извлечения сообщений: синхронные и асинхронные. Синхронные методы <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.Receive%2A>, поток процесса указанный интервал времени для нового сообщения прибывают в очередь ожидания. Если за указанный временной интервал <xref:System.Messaging.MessageQueue.InfiniteTimeout>, поток процесса остается заблокированных, пока не будет доступно новое сообщение. С другой стороны <xref:System.Messaging.MessageQueue.BeginPeek%2A> и <xref:System.Messaging.MessageQueue.BeginReceive%2A> (асинхронные методы), на выполнение задач основного приложения продолжают выполняться в отдельном потоке, до прибытия сообщения в очереди.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Messaging.MessageQueue.InfiniteTimeout> член.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает описание очереди.</summary>
        <value>Метка очереди сообщения. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальная длина метки очереди сообщений — 124 символам.  
  
 <xref:System.Messaging.MessageQueue.Label%2A> Свойство необязательно должен быть уникальным для всех очередей. Однако если несколько очередей одного и того же <xref:System.Messaging.MessageQueue.Label%2A>, нельзя использовать <xref:System.Messaging.MessageQueue.Send%28System.Object%29> метод для передачи сообщения для всех из них. Если используется синтаксис метки для <xref:System.Messaging.MessageQueue.Path%2A> свойство при отправке сообщения, будет создано исключение при <xref:System.Messaging.MessageQueue.Label%2A> не является уникальным.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.Label%2A> свойство.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для метки задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время последнего изменения свойств очереди.</summary>
        <value>Объект <see cref="T:System.DateTime" />, который указывает, когда свойства очереди были изменены в последний раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Время последнего изменения включает при создании этой очереди, а также <xref:System.Messaging.MessageQueue> свойство, которое изменяет очередь Message Queuing, такие как <xref:System.Messaging.MessageQueue.BasePriority%2A>. Значение <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство представляет собой системное время на локальном компьютере.  
  
 Необходимо вызвать <xref:System.Messaging.MessageQueue.Refresh%2A> перед получением <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство; в противном случае время изменения, связанные с этим <xref:System.Messaging.MessageQueue> могут устареть.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередью сообщений <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя компьютера, на котором расположена очередь Message Queuing.</summary>
        <value>Имя компьютера, на котором расположена очередь. По умолчанию службой Message Queuing используется значение ".", т. е. локальный компьютер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A> — Это Неотъемлемый компонент синтаксиса понятного имени очереди <xref:System.Messaging.MessageQueue.Path%2A>. В следующей таблице показаны синтаксис, который следует использовать для очереди заданного типа, когда нужно определить путь к очереди, используя его понятное имя.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Машины транзакционную очередь недоставленных сообщений|`MachineName`\\`XactDeadletter$`|  
  
 Используйте «.» для локального компьютера, при указании <xref:System.Messaging.MessageQueue.MachineName%2A>. Только имя компьютера является для этого свойства, например, `Server0`. <xref:System.Messaging.MessageQueue.MachineName%2A> Свойство не поддерживает формат IP-адреса.  
  
 Если определить <xref:System.Messaging.MessageQueue.Path%2A> на основе <xref:System.Messaging.MessageQueue.MachineName%2A>, приложение вызывает исключение при работе в автономном режиме, поскольку для перевода пути необходим контроллер домена. Таким образом, необходимо использовать <xref:System.Messaging.MessageQueue.FormatName%2A> для <xref:System.Messaging.MessageQueue.Path%2A> синтаксис при работе в автономном режиме.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, И <xref:System.Messaging.MessageQueue.QueueName%2A> связанных свойств. Изменение <xref:System.Messaging.MessageQueue.MachineName%2A> свойству <xref:System.Messaging.MessageQueue.Path%2A> изменение свойства. Формируется на основе нового <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A>. Изменение <xref:System.Messaging.MessageQueue.Path%2A> (например, чтобы использовать синтаксис имени формата) сбрасывает <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> свойства, чтобы ссылаться на новую очередь. Если <xref:System.Messaging.MessageQueue.QueueName%2A> свойство пусто, <xref:System.Messaging.MessageQueue.Path%2A> присвоено очередь журнала указанного вами компьютера.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.MachineName%2A> свойство.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое имя компьютера. Причиной может быть неверный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный размер очереди журнала.</summary>
        <value>Максимальный размер очереди журнала в килобайтах. По умолчанию службой Message Queuing не устанавливаются ограничения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> предоставляет доступ к ограничению в хранилища очереди сообщений. Это значение, только если <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> — `true`. Задание этого свойства изменяет очереди сообщений. Таким образом, любые другие <xref:System.Messaging.MessageQueue> экземпляров затрагиваемые изменением  
  
 Если хранение сообщений в журнале или в очереди недоставленных сообщений, необходимо периодически очищать очередь для удаления сообщений, которые больше не нужны. Сообщений в такой очереди учитываются квоты для компьютера, на котором находится очередь сообщений. (Администратор устанавливает квота компьютера).  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> свойство.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для максимального размера очереди журнала установлено недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный размер очереди.</summary>
        <value>Максимальный размер очереди в килобайтах. По умолчанию службой Message Queuing не устанавливаются ограничения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Предоставляет доступ к очереди сообщений сообщения ограничение хранилища, которая отделена от квоты сообщений на компьютере, администратор определяет. Дополнительные сведения о квоты сообщений см. в разделе <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Задание этого свойства изменяет очереди сообщений. Таким образом, любые другие <xref:System.Messaging.MessageQueue> экземпляров затрагиваемые изменением  
  
 Если попытка превышает максимальный размер очереди или квоты сообщений компьютера, сообщения могут быть утеряны. При достижении квоты очереди, служба Message Queuing уведомляет в очередь администрирования, отправляющего приложения, чтобы указать, что очередь заполнена, возвращая отрицательное подтверждение. Служба Message Queuing продолжает отправлять отрицательные подтверждения, пока общий размер сообщений в очереди не станет меньше значения.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> свойство.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Максимальный размер очереди содержит отрицательное значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает фильтр свойств для получения и считывания сообщений.</summary>
        <value>Объект <see cref="T:System.Messaging.MessagePropertyFilter" />, который очередь использует для фильтрации набора свойств, получаемого или считываемого ею для каждого сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот фильтр представляет собой набор логических значений, ограничивающих свойства сообщения, <xref:System.Messaging.MessageQueue> Получает или просматривает. Когда <xref:System.Messaging.MessageQueue> получения или выбирает сообщение из очереди сервера, он извлекает только те свойства, для которого <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> значение `true`.  
  
 Ниже представлены исходные значения свойств для <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> свойства. Эти параметры являются идентичными с вызовом метода <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> на <xref:System.Messaging.MessagePropertyFilter>.  
  
|Свойство.|Значение по умолчанию|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> для ограничения полученных свойств сообщения.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение фильтра — <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает или задает адрес многоадресной рассылки, связанный с данной очередью.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий допустимый групповой адрес (в виде, показанном ниже) или значение <see langword="null" />, которое указывает, что очередь не связана с групповым адресом.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Свойство используется для связывания с адресом многоадресной рассылки, который может использоваться при отправке сообщений нетранзакционную очередь. Не удалось связать транзакционной очереди с адресом многоадресной рассылки. Если отправляющее приложение отправляет сообщения многоадресной рассылки, служба Message Queuing передает копию сообщения в каждую очередь, связанную с этим адресом.  
  
 Многоадресная рассылка адреса должны быть в диапазоне класса D от 224.0.0.0 до 239.255.255.255, который соответствует установке первых четырех старших битов, равных 1110. Однако только определенные диапазоны адресов в этом диапазоне не зарезервированы и доступны для отправки многоадресных сообщений. Новейший список зарезервированных адресов многоадресной рассылки, в разделе [адресов многоадресной рассылки Internet Assigned номер Authority (IANA)](http://go.microsoft.com/fwlink/?linkid=3859) веб-страницы. Не ограничены по номеру порта.  
  
 Если несколько исходных компьютерах отправляют сообщения многоадресной рассылки и требуется конкретная очередь получения сообщений от только с одного компьютера, каждом компьютере-источнике необходимо отправлять сообщения на разные комбинации IP адрес и номер порта.  
  
 Чтобы отменить связь очереди с адресом многоадресной рассылки, задайте <xref:System.Messaging.MessageQueue.MulticastAddress%2A> строку нулевой длины. Не устанавливайте значение `null`, как это приведет к <xref:System.ArgumentNullException>.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает путь очереди. После задания свойства <see cref="P:System.Messaging.MessageQueue.Path" /> объект <see cref="T:System.Messaging.MessageQueue" /> будет указывать на новую очередь.</summary>
        <value>Очередь, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Значение по умолчанию зависит от того, какой используется конструктор <see cref="M:System.Messaging.MessageQueue.#ctor" />. Значение равно либо <see langword="null" />, либо задается параметром <paramref name="path" /> конструктора.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Синтаксис <xref:System.Messaging.MessageQueue.Path%2A> свойство зависит от типа очереди его точек в, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Машины транзакционную очередь недоставленных сообщений|`MachineName`\\`XactDeadletter$`|  
  
 Используйте «.» для представления локального компьютера.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, И <xref:System.Messaging.MessageQueue.QueueName%2A> связанных свойств. Изменение <xref:System.Messaging.MessageQueue.MachineName%2A> свойству <xref:System.Messaging.MessageQueue.Path%2A> изменение свойства. Формируется на основе нового <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A>. Изменение <xref:System.Messaging.MessageQueue.Path%2A> (например, чтобы использовать синтаксис имени формата) сбрасывает <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> свойства, чтобы ссылаться на новую очередь.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди, как показано в следующей таблице.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Метка|`Label:` [ *метка* ]|`Label:` TheLabel|  
  
 Если используется синтаксис метки для <xref:System.Messaging.MessageQueue.Path%2A> свойство при отправке сообщения, будет создано исключение при <xref:System.Messaging.MessageQueue.Label%2A> не является уникальным.  
  
 Для работы в автономном режиме необходимо использовать синтаксис имени формата, а не синтаксис понятного имени из первой таблицы. В противном случае исключение недоступности основного контроллера домена (на котором установлена Active Directory) для разрешения пути в имя формата.  
  
 После задания нового пути закрывается очередь сообщений и освобождаются все дескрипторы.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
> [!NOTE]
>  В режиме рабочей группы можно использовать только частные очереди. Укажите путь, используя синтаксис частной очереди `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> объекты с различными типами синтаксиса имени пути. В каждом случае он отправляет сообщение в очередь, путь, определенный в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый путь. Возможно из-за неправильного синтаксиса.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Возвращает копию первого сообщения в очереди, не удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает, не удаляя (считывает), первое сообщение в очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий первое сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для считывания очереди или ожидания поступления сообщения в очереди.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Метод считывает, но не удаляет первого сообщения из очереди. Таким образом, повторные вызовы <xref:System.Messaging.MessageQueue.Peek%2A> возвращают одно и то же сообщение, пока не поступит сообщение с более высоким приоритетом в очередь. <xref:System.Messaging.MessageQueue.Receive%2A> Метод, с другой стороны, читает и удаляет из очереди первое сообщение. Повторные вызовы <xref:System.Messaging.MessageQueue.Receive%2A>, таким образом, возвращают различные сообщения.  
  
 Служба Message Queuing упорядочивает сообщения в очередь в порядке приоритета и временем поступления. Новое сообщение помещается перед более старым, только если он имеет более высокий приоритет.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Поскольку эта перегрузка не тайм-аут, приложение может ожидать неопределенное время. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>. Кроме того, можно указать время ожидания для сообщения прибывают в очередь, используя перегруженный <xref:System.Messaging.MessageQueue.Peek%2A> , указывающее время ожидания.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующих примерах используется <xref:System.Messaging.MessageQueue.Peek%2A> метод в очередь.  
  
 В первом примере приложение ожидает, пока сообщение не станет доступным в очереди. Обратите внимание, что первый пример не осуществляет доступ к сообщение, поступающее; он просто останавливается обработка до прибытия сообщения. Если сообщение уже существует в очереди, будет возвращено немедленно.  
  
 Во втором примере сообщение, содержащее определяемые приложением `Order` класса отправляются в очередь и затем считывается из очереди.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, показывающий максимальное время ожидания появления первого сообщения в очереди.</param>
        <summary>Возвращает, не удаляя (считывает), первое сообщение в очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным или пока не истечет заданный тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий первое сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для считывания очереди или ожидания указанного периода времени поступления сообщения в очереди. Метод возвращает немедленно, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Метод считывает, но не удаляет первого сообщения из очереди. Таким образом, повторные вызовы <xref:System.Messaging.MessageQueue.Peek%2A> возвращают одно и то же сообщение, пока не поступит сообщение с более высоким приоритетом в очередь. <xref:System.Messaging.MessageQueue.Receive%2A> Метод, с другой стороны, читает и удаляет из очереди первое сообщение. Повторные вызовы <xref:System.Messaging.MessageQueue.Receive%2A>, таким образом, возвращают различные сообщения.  
  
 Служба Message Queuing упорядочивает сообщения в очередь в порядке приоритета и временем поступления. Новое сообщение помещается перед более старым, только если он имеет более высокий приоритет.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Поток будет заблокирован в течение указанного периода времени или на неопределенное время, если вы указываете <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Messaging.MessageQueue.Peek%2A> метода с указанием времени ожидания, равную нулю, чтобы проверить, пуста ли очередь.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, показывающий максимальное время ожидания появления первого сообщения в очереди.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="action">Одно из значений перечисления <see cref="T:System.Messaging.PeekAction" />. Указывает, следует ли считывать текущее сообщение в очереди или следующее сообщение.</param>
        <summary>Возвращает, не удаляя (считывает), текущее или следующее сообщение в очереди, используя заданный курсор. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным или пока не истечет заданный тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для считывания очереди или ожидания указанного периода времени поступления сообщения в очереди. Метод возвращает немедленно, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Метод считывает, но не удаляет сообщение из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод, с другой стороны, читает и удаляет сообщение из очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Поток заблокирован в течение указанного периода времени или на неопределенное время, если вы указываете <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для параметра <paramref name="action" /> было задано значение, отличное от <see langword="PeekAction.Current" /> или <see langword="PeekAction.Next" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> считываемого сообщения.</param>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в очереди, на который указывает <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют просматривать сообщения из очереди. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод используется для извлечения сообщения путем указания его уникального идентификатора.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее заказ в и из очереди. Он специально запрашивается положительное подтверждение, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> считываемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в очереди, на который указывает <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, а новое сообщение прибывает в очереди в течение времени, заданного свойством `timeout` параметра, возникает исключение.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, если он соответствует `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют просматривать сообщения из очереди. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод используется для извлечения сообщения путем указания его уникального идентификатора.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщений до истечения тайм-аута не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает копию сообщения с указанным идентификатором сообщения, не удаляя это сообщение из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> считываемого сообщения.</param>
        <summary>Считывает сообщение, идентификатор которого соответствует параметру <paramref name="id" />.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> для чтения, не удаляя его из очереди сообщения с известным идентификатором сообщения. Идентификатор сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра. Эта перегрузка вызывает исключение, если в настоящий момент очереди нет сообщений.  
  
 Два дополнительных метода позволяют просматривать сообщения из очереди: <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> возвращает подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Нет сообщения с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> считываемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Считывает сообщение, идентификатор которого соответствует параметру <paramref name="id" />. Ожидает, пока сообщение не появится в очереди, или не возникнет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> для чтения, не удаляя его из очереди сообщения с известным идентификатором сообщения. Идентификатор сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра. Эта перегрузка создает исключение, если в настоящий момент очереди нет сообщений, а новое сообщение не поступило до истечения времени ожидания.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, если он соответствует `id` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 Два дополнительных метода позволяют просматривать сообщения из очереди: <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> возвращает подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение с заданным параметром <paramref name="id" /> не существует в очереди и не поступило до истечения периода времени, установленного параметром <paramref name="timeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Считывает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> считываемого сообщения.</param>
        <summary>Представлено в MSMQ 3.0. Считывает сообщение, соответствующее заданному идентификатору просмотра, из нетранзакционной очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.LookupId" /> которого соответствует переданному в объект параметру <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра, не удаляя его из очереди. Этот метод вызывает исключение немедленно, если сообщение не находится в очереди.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди которой находится сообщение, таким образом, не более одного сообщения в очереди, которое соответствует данной `lookupId` параметра.  
  
 Для чтения сообщения с указанным кодом просмотра и удалите его из очереди, используйте <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> метод.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений:  
  
 <see langword="MessageLookupAction.Current" />: считывает сообщение, заданное параметром <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Next" />: считывает сообщение, следующее за сообщением, заданным параметром <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Previous" />: считывает сообщение, предшествующее сообщению, заданному параметром <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.First" />: считывает первое сообщение в очереди. Параметр <c>lookupId</c> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />: считывает последнее сообщение в очереди. Параметр <c>lookupId</c> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> считываемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <summary>Представлено в MSMQ 3.0. Считывает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="action" /> и <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра, не удаляя его из очереди. Этот метод вызывает исключение немедленно, если сообщение не находится в очереди.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди которой находится сообщение, таким образом, не более одного сообщения в очереди, которое соответствует данной `lookupId` параметра.  
  
 Для чтения сообщения с указанным идентификатором и удалите его из очереди, используйте <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> метод.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда сообщение читается без удаления из очереди. Это результат асинхронной операции — <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> используется при асинхронной обработке, чтобы вызвать <xref:System.Messaging.MessageQueue.PeekCompleted> событие, если сообщение не станет доступным в очереди.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> используется для завершения операции, запущенной с помощью вызова <xref:System.Messaging.MessageQueue.BeginPeek%2A> и просмотра сообщения при <xref:System.Messaging.MessageQueue.PeekCompleted> события.  
  
 При создании делегата <xref:System.Messaging.PeekCompletedEventHandler> необходимо указать метод, обрабатывающий событие. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается всякий раз, когда происходит событие, если делегат не удален. Дополнительные сведения о делегатах обработчиков событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginPeek%2A> Чтобы инициировать асинхронную операцию в очереди, расположенный по пути «. \myQueue». При <xref:System.Messaging.MessageQueue.PeekCompleted> события, в примере считывает сообщение и выводит его текст на экране. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все сообщения, содержащиеся в очереди.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очистка очереди вызывает сервер Message Queuing устанавливает флаг изменения очереди, который влияет на <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство. Удаленные из очереди сообщения утрачиваются. они не отправляются в очередь недоставленных сообщений или очередь журнала.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает понятное имя, определяющее очередь.</summary>
        <value>Имя, определяющее очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Значение <see langword="null" /> недопустимо.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно объединять <xref:System.Messaging.MessageQueue.QueueName%2A> с <xref:System.Messaging.MessageQueue.MachineName%2A> Создание понятное <xref:System.Messaging.MessageQueue.Path%2A> имя для очереди. Синтаксис понятное имя разновидность <xref:System.Messaging.MessageQueue.Path%2A> свойство зависит от типа очереди, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Используйте «.» для представления локального компьютера.  
  
 Изменение <xref:System.Messaging.MessageQueue.QueueName%2A> свойства влияет на <xref:System.Messaging.MessageQueue.Path%2A> свойство. Если задать <xref:System.Messaging.MessageQueue.QueueName%2A> без параметра <xref:System.Messaging.MessageQueue.MachineName%2A> свойства <xref:System.Messaging.MessageQueue.Path%2A> свойство становится.\\ `QueueName`. В противном случае <xref:System.Messaging.MessageQueue.Path%2A> становится `MachineName` \\ `QueueName`.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.QueueName%2A> свойство.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение имени очереди — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор, предназначенный для чтения сообщений из очереди сообщений.</summary>
        <value>Дескриптор собственного объекта очереди, который используется для считывания и получения сообщений из очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> Предоставляет собственный дескриптор Windows для объекта очереди сообщений, который используется для просмотра и получения сообщений из очереди. Если изменить путь к очереди, дескриптор закрыт и открыт повторно с новым значением.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Получает первое сообщение в очереди, удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди, или подождать, пока в очереди имеются сообщения.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди, или новые сообщения с более высоким приоритетом.  
  
 Для чтения первого сообщения в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поскольку в этой перегрузке <xref:System.Messaging.MessageQueue.Receive%2A> метод задает неограниченное время ожидания, приложение может ожидать в течение неограниченного времени. Если работа приложения должна продолжать выполнение без ожидания для сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода получает сообщение из очереди и выводит сведения о сообщении на экране.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает первое доступное в транзакционной очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного `transaction` параметра или подождите, пока в очереди имеются сообщения.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Поскольку этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Для чтения первого сообщения в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует для отката при вызове <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поскольку в этой перегрузке <xref:System.Messaging.MessageQueue.Receive%2A> метод задает неограниченное время ожидания, приложение может ожидать в течение неограниченного времени. Если работа приложения должна продолжать выполнение без ожидания для сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода осуществляется подключение к транзакционной очереди на локальном компьютере и отправляет сообщение в очередь. Затем он получает сообщение, содержащее заказ. Если встретится нетранзакционная очередь, вызовет исключение и производится откат транзакции.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
 - или -  
  
 Очередь является нетранзакционной.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди с помощью контекста транзакции, определенного `transactionType` параметра или подождите, пока в очереди имеются сообщения.  
  
 Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Для чтения первого сообщения в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует для отката при вызове <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поскольку в этой перегрузке <xref:System.Messaging.MessageQueue.Receive%2A> метод задает неограниченное время ожидания, приложение может ожидать в течение неограниченного времени. Если работа приложения должна продолжать выполнение без ожидания для сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает первое сообщение, доступное в очереди, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />, и ожидает пока в очереди не появится сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщений и их возврата в течение указанного срока, если в очереди нет сообщений.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаление его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди, или новые сообщения с более высоким приоритетом.  
  
 Для чтения первого сообщения в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток будет заблокирован за указанный период времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если работа приложения должна продолжить работу без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода получает сообщение из очереди и выводит сведения о сообщении на экране. В примере приостанавливается выполнение до пяти секунд, пока ожидается поступление в очередь сообщения.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.  
  
 Используйте эту перегрузку для получения сообщений и их возврата в течение указанного срока, если в очереди нет сообщений.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает первое сообщение, доступное в транзакционной очереди, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />, и ожидает, пока в очереди не появится сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного `transaction` и возврата в указанный период времени, если нет сообщений в очереди.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Поскольку этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Для чтения первого сообщения в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует для отката при вызове <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток будет заблокирован за указанный период времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если работа приложения должна продолжить работу без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода показано использование этого метода.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Данный вызов является синхронным, и он ожидает, пока в очереди не появится сообщение, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди с помощью контекста транзакции, определенного `transactionType` и возврата в указанный период времени, если нет сообщений в очереди.  
  
 Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Для чтения первого сообщения в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует для отката при вызове <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток будет заблокирован за указанный период времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если работа приложения должна продолжить работу без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода показано использование этого метода.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного `transaction` и возврата в указанный период времени, если нет сообщений в очереди.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращают сообщения, которые расположены в очереди.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение возвращается в очередь, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Чтобы прочитать сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, не требуется откатить путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток заблокирован за указанный период времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если работа приложения должна продолжить работу без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди с помощью контекста транзакции, определенного `transactionType` и возврата в указанный период времени, если нет сообщений в очереди.  
  
 Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет осуществлять синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращают сообщения, которые расположены в очереди.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение возвращается в очередь, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Чтобы прочитать сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, не требуется откатить путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Использовать вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток заблокирован за указанный период времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если работа приложения должна продолжить работу без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из нетранзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в нетранзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается в приложение.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод получает сообщение, указав его идентификатор.  
  
 Для чтения сообщения с указанным кодом корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее заказ в и из очереди. Он специально запрашивается положительное подтверждение, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из транзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается в приложение с помощью контекста внутренней транзакции, определенного `transaction` параметра.  
  
 Поскольку этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для извлечения сообщения путем указания его уникального идентификатора.  
  
 Для чтения сообщения с указанным кодом корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в очереди, на который указывает <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается приложению, используя контекст транзакции, определяемый параметром `transactionType` параметр.  
  
 Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для извлечения сообщения путем указания его уникального идентификатора.  
  
 Для чтения сообщения с указанным кодом корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из нетранзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в нетранзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Этот метод возвращает немедленно, если сообщение с кодом корреляции, указанным `correlationId` параметр находится в очереди. В противном случае метод ожидает в течение заданного периода времени поступления нового сообщения. Если новое сообщение не пришло до истечения времени ожидания, создается исключение.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, если он соответствует `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для извлечения сообщения путем указания его уникального идентификатора.  
  
 Для чтения сообщения с указанным кодом корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из транзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Этот метод возвращает немедленно, если сообщение с кодом корреляции, указанным `correlationId` параметр находится в очереди, с помощью контекста внутренней транзакции, определенного `transaction` параметра. В противном случае метод ожидает в течение заданного периода времени поступления нового сообщения. Если новое сообщение не пришло до истечения времени ожидания, создается исключение.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, если он соответствует `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра.  
  
 Поскольку этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для извлечения сообщения путем указания его уникального идентификатора.  
  
 Для чтения сообщения с указанным кодом корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
 - или -  
  
 Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод ищет в очереди, на который указывает <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Этот метод возвращает немедленно, если сообщение с кодом корреляции, указанным `correlationId` параметр находится в очереди, используя контекст транзакции, определяемый параметром `transactionType` параметр. В противном случае метод ожидает в течение заданного периода времени поступления нового сообщения. Если новое сообщение не пришло до истечения времени ожидания, создается исключение.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, если он соответствует `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра. Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь на связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для извлечения сообщения путем указания его уникального идентификатора.  
  
 Для чтения сообщения с указанным кодом корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <summary>Получает из нетранзакционной очереди сообщение, которое соответствует заданному идентификатору, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод вызывает исключение немедленно, если сообщение не находится в очереди.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для получения подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из транзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удалите его из очереди, с помощью контекста внутренней транзакции, определенного `transaction` параметра. Этот метод немедленно создает исключение, если сообщение не находится в очереди  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра.  
  
 Поскольку этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для получения подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод вызывает исключение немедленно, если сообщение не находится в очереди. В противном случае сообщение удаляется из очереди и возвращается приложению, используя контекст транзакции, определяемый параметром `transactionType` параметр.  
  
 Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра. Если сообщение с указанным идентификатором в очереди, не связанную с этим <xref:System.Messaging.MessageQueue> экземпляра, сообщение не будет найден.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для получения подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из нетранзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод возвращает немедленно, если сообщение с идентификатором, указанным параметром `id` параметр находится в очереди. В противном случае метод ожидает в течение заданного периода времени поступления нового сообщения. Если новое сообщение не пришло до истечения времени ожидания, создается исключение.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, если он соответствует `id` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Если текущий поток можно заблокировать, пока новые сообщения продолжают поступать в очереди в течение времени ожидания, заданного по `timeout` параметр. Поток будет заблокирован для по крайней мере заданного периода времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра, или если новые сообщения продолжают поступать в очереди в течение времени ожидания, заданного по `timeout` параметр.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для получения подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из транзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удалите его из очереди, с помощью контекста внутренней транзакции, определенного `transaction` параметра. Этот метод возвращает немедленно, если сообщение с идентификатором, указанным параметром `id` параметр находится в очереди. В противном случае метод ожидает в течение заданного периода времени поступления нового сообщения. Если новое сообщение не пришло до истечения времени ожидания, создается исключение.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, если он соответствует `id` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Если текущий поток можно заблокировать, пока новые сообщения продолжают поступать в очереди в течение времени ожидания, заданного по `timeout` параметр. Поток будет заблокирован для по крайней мере заданного периода времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра, или если новые сообщения по-прежнему поступление в очередь до истечения времени ожидания, определяемое `timeout` параметр.  
  
 Поскольку этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для получения подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
 - или -  
  
 Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод возвращает немедленно, если сообщение с идентификатором, указанным `id` параметр находится в очереди, используя контекст транзакции, определяемый параметром `transactionType` параметр. В противном случае метод ожидает в течение заданного периода времени поступления нового сообщения. Если новое сообщение не пришло до истечения времени ожидания, создается исключение.  
  
 `timeout` Не указывает общее время выполнения для этого метода. Вместо этого он задает время ожидания для нового сообщения прибывают в очередь. Каждый раз при поступлении сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, если он соответствует `id` параметра. В противном случае этот метод запускает ожидания через и ожидает поступления нового сообщения. Таким образом, если новые сообщения по-прежнему поступления до истечения времени ожидания, возможна данный метод может продолжать выполняться неопределенно долго, до истечения времени ожидания без новых сообщений, поступающих или до прибытия сообщения которого <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным во всей организации очереди сообщений, таким образом, не более одного сообщения в очереди, которое соответствует данной `id` параметра. Если сообщение с указанным идентификатором в очереди, не связанную с этим <xref:System.Messaging.MessageQueue> экземпляра, сообщение не будет найден.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> Если текущий поток можно заблокировать, пока новые сообщения продолжают поступать в очереди в течение времени ожидания, заданного по `timeout` параметр. Поток будет заблокирован для по крайней мере заданного периода времени или неопределенно долго, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра, или если новые сообщения продолжают поступать в очереди в течение времени ожидания, заданного по `timeout` параметр.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для получения подтверждения, отчета или сформированные ответного сообщения, который был создан в результате сообщение, отправленное в очередь.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения.</param>
        <summary>Представлено в MSMQ 3.0. Получает сообщение, соответствующее заданному идентификатору просмотра, из нетранзакционной очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.LookupId" /> которого соответствует переданному в объект параметру <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра и удаления его из очереди. Этот метод вызывает исключение немедленно, если сообщение не находится в очереди.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди которой находится сообщение, таким образом, не более одного сообщения в очереди, которое соответствует данной `lookupId` параметра.  
  
 Для чтения сообщения с указанным кодом просмотра, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> метод.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений:  
  
 <see langword="MessageLookupAction.Current" />: получает сообщение, заданное в параметре <c>lookupId</c>, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Next" />: получает сообщение, следующее за сообщением, заданным в параметре <c>lookupId</c>, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Previous" />: получает сообщение, предшествующее сообщению, заданному в параметре <c>lookupId</c>, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.First" />: получает первое сообщение в очереди и удаляет его из очереди. Параметр <c>lookupId</c> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />: получает последнее сообщение в очереди и удаляет его из очереди. Параметр <c>lookupId</c> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Представлено в MSMQ 3.0. Получает конкретное сообщение из транзакционной очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="lookupId" /> и <paramref name="action" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра и удаления его из очереди, используя контекст транзакции, определяемый параметром `transaction` параметр. Этот метод вызывает исключение немедленно, если сообщение не находится в очереди.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди которой находится сообщение, таким образом, не более одного сообщения в очереди, которое соответствует данной `lookupId` параметра.  
  
 Поскольку этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> метод. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Поскольку <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
 - или -  
  
 Очередь является нетранзакционной.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений:  
  
 <see langword="MessageLookupAction.Current" />: получает сообщение, заданное в параметре <c>lookupId</c>, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Next" />: получает сообщение, следующее за сообщением, заданным в параметре <c>lookupId</c>, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Previous" />: получает сообщение, предшествующее сообщению, заданному в параметре <c>lookupId</c>, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.First" />: получает первое сообщение в очереди и удаляет его из очереди. Параметр <c>lookupId</c> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />: получает последнее сообщение в очереди и удаляет его из очереди. Параметр <c>lookupId</c> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Представлено в MSMQ 3.0. Получает из очереди определенное сообщение, используя заданный контекст транзакции. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="action" /> и <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра и удаления его из очереди, используя контекст транзакции, определяемый параметром `transactionType` параметр. Этот метод вызывает исключение немедленно, если сообщение не находится в очереди.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди которой находится сообщение, таким образом, не более одного сообщения в очереди, которое соответствует данной `lookupId` параметра.  
  
 Для чтения сообщения с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> метод. Отсутствует контекст транзакции, связанный с сообщение, возвращенное вызовом <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Поскольку <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> удаляет сообщения из очереди, существует необходимость откатывается, если транзакция прервана.  
  
 Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получить сообщение в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получать сообщения из транзакционной очереди вне контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено очереди, если транзакция прерывается. Сообщение не удаляется окончательно из очереди до фиксации транзакции.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.  
  
 - или -  
  
 Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если сообщение было удалено из очереди. Это событие инициируется асинхронной операцией, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> используется при асинхронной обработке, чтобы вызвать <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, если сообщение не станет доступным в очереди.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> используется для завершения операции, запущенной с помощью вызова <xref:System.Messaging.MessageQueue.BeginReceive%2A> и просмотра сообщения при <xref:System.Messaging.MessageQueue.ReceiveCompleted> события.  
  
 При создании делегата <xref:System.Messaging.ReceiveCompletedEventHandler> необходимо указать метод, обрабатывающий событие. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается всякий раз, когда происходит событие, если делегат не удален. Дополнительные сведения о делегатах обработчиков событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyReceiveCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.ReceiveCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginReceive%2A> Чтобы инициировать асинхронную операцию в очереди, расположенный по пути «. \myQueue». При <xref:System.Messaging.MessageQueue.ReceiveCompleted> события, в примере получает сообщение и выводит его текст на экране. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginReceive%2A> еще раз, чтобы начать новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обновляет свойства, представленные объектом <see cref="T:System.Messaging.MessageQueue" /> для отражения текущего состояния ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> синхронизирует свойства <xref:System.Messaging.MessageQueue> с его связанный ресурс очереди сообщений сервера. Если любые свойства, такие как <xref:System.Messaging.MessageQueue.Label%2A> или <xref:System.Messaging.MessageQueue.Category%2A>, был изменен на сервере со времени <xref:System.Messaging.MessageQueue> был создан <xref:System.Messaging.MessageQueue.Refresh%2A> обновления <xref:System.Messaging.MessageQueue> новыми данными.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Присваивает списку разрешений значения по умолчанию операционной системы. Удаляет все разрешения очередей, добавленные в список по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, возвращают список разрешений на значения по умолчанию. Как правило, это предоставляет создатель очереди все разрешения и предоставляет группе всем пользователям следующие права:  
  
-   Получение свойств очереди.  
  
-   Получение разрешения очереди.  
  
-   Запись в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Отправляет объект в очередь.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <summary>Отправляет объект в нетранзакционную очередь, на которую ссылается этот класс <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы отправить сообщение, содержащее `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. При отправке любой объект, отличный от <xref:System.Messaging.Message>, он сериализуется и вставляется в текст сообщения.  
  
 Если эта перегрузка используется для отправки сообщения в транзакционную очередь, сообщение будет отправлено в очередь недоставленных сообщений. Сообщение, быть частью транзакции, которая содержит другие сообщения, используйте перегрузку, которая использует <xref:System.Messaging.MessageQueueTransaction> или <xref:System.Messaging.MessageQueueTransactionType> как параметр.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любой объект, отличный от <xref:System.Messaging.Message>. Если указать, например, метки или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются для любого сообщения, содержащего объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, задать значения свойств для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщение <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода подключается к очереди сообщений и отправляет сообщение в очередь.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 В следующем примере кода отправляет определяемые приложением `Order` класса в очередь, а затем принимается сообщение из этой очереди.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Отправляет объект в транзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы отправить сообщение, содержащее `obj` параметр в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста внутренней транзакции, определенного параметром `transaction` параметр. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. При отправке любой объект, отличный от <xref:System.Messaging.Message>, он сериализуется и вставляется в текст сообщения.  
  
 Если эта перегрузка используется для отправки сообщения в нетранзакционную очередь, сообщения могут быть отправлены в очередь недоставленных сообщений без создания исключения.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любой объект, отличный от <xref:System.Messaging.Message>. Если указать, например, метки или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются для любого сообщения, содержащего объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, задать значения свойств для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщение <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 <xref:System.Messaging.MessageQueueTransaction> Потоковый подразделения знать, поэтому если состояние апартамента — `STA`, транзакции нельзя использовать в нескольких потоках. Visual Basic устанавливает состояние основного потока в `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в `Main` подпрограммы. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Можно применить <xref:System.MTAThreadAttribute> , используя следующий фрагмент.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отправляет в транзакционную очередь строку и затем получает сообщение из этой очереди.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
 - или -  
  
 Приложение Message Queuing указало на неверное использование транзакции.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Отправляет объект в очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы отправить сообщение, содержащее `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста транзакции, определенного `transactionType` параметра. Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для отправки сообщения. Укажите `Single` Если вы хотите отправить сообщение как одна внутренняя транзакция. Можно указать `None` Если вы хотите отправить транзактное сообщение в нетранзакционный поток.  
  
 Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. При отправке любой объект, отличный от <xref:System.Messaging.Message>, он сериализуется и вставляется в текст сообщения.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любой объект, отличный от <xref:System.Messaging.Message>. Если указать, например, метки или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются для любого сообщения, содержащего объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, задать значения свойств для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщение <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <summary>Отправляет объект в нетранзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы отправить сообщение, содержащее `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>. С помощью этой перегрузки можно указать строку метки, которая обозначает сообщение. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message>, структура, объект данных или любой другой управляемый объект. При отправке любой объект, отличный от <xref:System.Messaging.Message>, он сериализуется и вставляется в текст сообщения.  
  
 Метка сообщения отличается от метки очереди сообщений, но оба зависят от приложения и не имеют внутреннего смысла для Message Queuing.  
  
 Если эта перегрузка используется для отправки сообщения в транзакционную очередь, сообщение будет отправлено в очередь недоставленных сообщений. Сообщение, быть частью транзакции, которая содержит другие сообщения, используйте перегрузку, которая использует <xref:System.Messaging.MessageQueueTransaction> или <xref:System.Messaging.MessageQueueTransactionType> как параметр.  
  
 <xref:System.Messaging.MessageQueue.Path%2A> Для данного <xref:System.Messaging.MessageQueue> экземпляр должен быть указан перед отправкой сообщения. Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любой объект, отличный от <xref:System.Messaging.Message>. Если указать, например, метки или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются для любого сообщения, содержащего объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, задать значения свойств для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщение <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Отправляет объект в транзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы отправить сообщение, содержащее `obj` параметр в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста внутренней транзакции, определенного параметром `transaction` параметр. С помощью этой перегрузки можно указать строку метки, которая обозначает сообщение. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message>, структура, объект данных или любой другой управляемый объект. При отправке любой объект, отличный от <xref:System.Messaging.Message>, он сериализуется и вставляется в текст сообщения.  
  
 Метка сообщения отличается от метки очереди сообщений, но оба зависят от приложения и не имеют внутреннего смысла для Message Queuing.  
  
 Если эта перегрузка используется для отправки сообщения в нетранзакционную очередь, сообщения могут быть отправлены в очередь недоставленных сообщений без создания исключения.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любой объект, отличный от <xref:System.Messaging.Message>. Если указать, например, метки или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются для любого сообщения, содержащего объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, задать значения свойств для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщение <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство  
  
 <xref:System.Messaging.MessageQueueTransaction> Потоковый подразделения знать, поэтому если состояние апартамента — `STA`, транзакции нельзя использовать в нескольких потоках. Visual Basic устанавливает состояние основного потока в `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в `Main` подпрограммы. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Можно применить <xref:System.MTAThreadAttribute> , используя следующий фрагмент.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
 - или -  
  
 Приложение Message Queuing указало на неверное использование транзакции.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Отправляет объект в очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы отправить сообщение, содержащее `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста транзакции, определенного `transactionType` параметра. Укажите `Automatic` для `transactionType` параметра, если он уже существует внешний контекст транзакции, присоединенного к потоку, который вы хотите использовать для отправки сообщения. Укажите `Single` Если вы хотите отправить сообщение как одна внутренняя транзакция. Можно указать `None` Если вы хотите отправить транзактное сообщение в нетранзакционный поток.  
  
 Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. При отправке любой объект, отличный от <xref:System.Messaging.Message>, он сериализуется и вставляется в текст сообщения. С помощью этой перегрузки можно указать строку метки, которая обозначает сообщение.  
  
 Метка сообщения отличается от метки очереди сообщений, но оба зависят от приложения и не имеют внутреннего смысла для Message Queuing.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любой объект, отличный от <xref:System.Messaging.Message>. Если указать, например, метки или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются для любого сообщения, содержащего объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, задать значения свойств для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>и сообщение <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Приложение Message Queuing указало на неверное использование транзакции.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет разрешения в текущий набор. Это позволяет контролировать, кто имеет права доступа к свойствам очереди и сообщениям в очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Объект <see cref="T:System.Messaging.AccessControlList" />, содержащий не менее одного элемента управления доступом, в которых указаны доверенные лица и предоставляемые разрешения.</param>
        <summary>Назначает права доступа к очереди на основе содержимого списка управления доступом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для предоставления, запрета или отмены прав с помощью коллекции элементов управления доступом для указания доверенного лица и сведения о разрешениях. Это используется, например, для предоставления разрешений нескольким пользователям одновременно.  
  
 Доверенное лицо, указывается при создании `ace` параметр может иметь отдельного пользователя, компьютера или группы пользователей. Если доверенное лицо — это человек, используйте формат `DOMAIN` \\ `user`. Можно указать «.» для для указания локального компьютера.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ и группы домена, все имеют разрешение на получение свойств очередей и получить разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Отказано в доступе <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потока явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 При построении `dacl` добавить параметр, <xref:System.Messaging.AccessControlEntry> экземпляров для вашего <xref:System.Messaging.AccessControlList> коллекции. При создании каждой записи управления доступом, можно указать универсальный и стандартные права доступа. Права в очередь, могут быть любым сочетанием следующих:  
  
-   Удаление  
  
-   Чтение параметров безопасности  
  
-   Записи безопасности  
  
-   Синхронизация  
  
-   Изменение владельца  
  
-   Чтение  
  
-   Write  
  
-   Выполнение  
  
-   Обязательно  
  
-   Все  
  
-   Нет  
  
 Эти права представляют собой набор битовых флагов, которые можно комбинировать с помощью побитового оператора OR.  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задать свойства очереди  
  
-   Получение разрешений  
  
-   Установка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Объект <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />, который указывает пользователя, тип доступа и тип разрешения.</param>
        <summary>Назначает права доступа к очереди на основе содержимого элемента управления доступом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для предоставления, запрета или отмены прав с помощью записи управления доступом для указания доверенного лица и сведения о разрешениях.  
  
 Доверенное лицо, указывается при создании `ace` параметр может иметь отдельного пользователя, компьютера или группы пользователей. Если доверенное лицо — это человек, используйте формат `DOMAIN` \\ `user`. Можно указать «.» для для указания локального компьютера.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ и группы домена, все имеют разрешение на получение свойств очередей и получить разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Отказано в доступе <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потока явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 Права в очередь, которая задается в `rights` при построении вашей <xref:System.Messaging.MessageQueueAccessControlEntry>, может быть любым сочетанием следующих:  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задать свойства очереди  
  
-   Получение разрешений  
  
-   Установка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 `rights` Задать в конструкторе для параметра `ace` параметр является флагом <xref:System.Messaging.MessageQueueAccessRights> перечисления. Он представляет набор битовых флагов, которые можно комбинировать с помощью побитового оператора OR при построении `rights` параметра.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Отдельный пользователь, группа или компьютер, которые получают дополнительные права на работу с очередью.</param>
        <param name="rights">Объект <see cref="T:System.Messaging.MessageQueueAccessRights" />, который указывает набор прав на работу с очередью, которые назначаются службой очереди сообщений параметру <c>user</c>.</param>
        <summary>Предоставляет компьютеру, группе или пользователю указанные права доступа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для предоставления указанных прав отдельным пользователям. Пользователь может быть любое действительное доверенное лицо, включая отдельных пользователей, групп пользователей или компьютер. Если пользователь — это человек, используйте формат `DOMAIN` \\ `user` для `user` параметра. Можно указать «.» для `user` параметр, чтобы указать локальный компьютер.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ и группы домена, все имеют разрешение на получение свойств очередей и получить разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Отказано в доступе <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потока явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 Права очереди, указанные в `rights` параметр, может быть любым сочетанием следующих:  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задать свойства очереди  
  
-   Получение разрешений  
  
-   Установка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 <xref:System.Messaging.MessageQueueAccessRights> Перечисление представляет набор битовых флагов, которые можно комбинировать с помощью оператора побитового или для создания `rights` параметра.  
  
 Эта перегрузка может предоставлять разрешения только; не удается отменить или запретить их. Необходимо использовать другую перегрузку метода для явного предоставления иного <xref:System.Messaging.AccessControlEntryType> отличный от `Allow`.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="user" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Отдельный пользователь, группа или компьютер, которые получают дополнительные права на работу с очередью.</param>
        <param name="rights">Объект <see cref="T:System.Messaging.MessageQueueAccessRights" />, который указывает набор прав на работу с очередью, которые назначаются службой очереди сообщений параметру <c>user</c>.</param>
        <param name="entryType">Объект <see cref="T:System.Messaging.AccessControlEntryType" />, который указывает, нужно ли предоставить разрешения, отказать в предоставлении разрешений или отозвать разрешения, заданные в параметре <c>rights</c>.</param>
        <summary>Предоставляет компьютеру, группе или пользователю указанные права доступа указанного типа управления доступом (разрешить, отказать, отозвать или задать).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для предоставления, запрета или отмены указанные права для отдельного пользователя. Пользователь может быть любое действительное доверенное лицо, включая отдельных пользователей, групп пользователей или компьютер. Если пользователь — это человек, используйте формат `DOMAIN` \\ `user` для `user` параметра. Можно указать «.» для `user` параметр, чтобы указать локальный компьютер.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ и группы домена, все имеют разрешение на получение свойств очередей и получить разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Отказано в доступе <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потока явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 Права очереди, указанные в `rights` параметр, может быть любым сочетанием следующих:  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задать свойства очереди  
  
-   Получение разрешений  
  
-   Установка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 <xref:System.Messaging.MessageQueueAccessRights> Перечисление представляет набор битовых флагов, которые можно комбинировать с помощью оператора побитового или для создания `rights` параметра.  
  
 Следующая таблица показывает, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, который используется для маршалинга вызовов обработчика событий, возникающих в результате наступления события <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> или события <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, представляющий объект, который выполняет маршалинг вызова обработчика событий, причиной которого стало событие <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> или <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Messaging.MessageQueue.ReceiveCompleted> или <xref:System.Messaging.MessageQueue.PeekCompleted> причиной событий <xref:System.Messaging.MessageQueue.BeginReceive%2A> или <xref:System.Messaging.MessageQueue.BeginPeek%2A> , соответственно, запрос для определенного потока. Как правило <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> задается при его связанный компонент помещается внутри элемента управления или формы, так как эти компоненты привязаны к определенному потоку.  
  
 Как правило синхронизирующий объект маршалирует вызов метода в один поток.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, принимает ли очередь только транзакции.</summary>
        <value>
          Значение <see langword="true" />, если очередь принимает только сообщения, отправляемые как часть транзакции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обмен транзакционными сообщениями относится к объединению нескольких связанных сообщений в одну транзакцию. Отправка сообщений как части транзакции гарантирует, что сообщения доставляются по порядку, только один раз и будут успешно извлечены из очереди назначения.  
  
 Если очередь является транзакционной, он принимает только сообщения, отправляемые как часть транзакции. Однако нетранзакционное сообщение можно передавать и получать из локальной очереди транзакций без явного использования транзакций <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, и <xref:System.Messaging.MessageQueueTransaction.Abort%2A> синтаксиса. Если нетранзакционное сообщение отправляется в транзакционную очередь, этот компонент создаст транзакцию одного сообщения для него, за исключением того, в случае обращение к очереди на удаленном компьютере с помощью непосредственного имени формата. В этом случае если вы не укажете контекста транзакции при отправке сообщения, он не будет создан автоматически и это сообщение будет отправлено в очередь недоставленных сообщений.  
  
 Если нетранзакционное сообщение отправляется в транзакционную очередь, не появится возможность откатить сообщение при возникновении исключения.  
  
 <xref:System.Messaging.MessageQueueTransaction> Потоковый подразделения знать, поэтому если состояние апартамента — `STA`, транзакции нельзя использовать в нескольких потоках. Visual Basic устанавливает состояние основного потока в `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в `Main` подпрограммы. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Можно применить <xref:System.MTAThreadAttribute> , используя следующий фрагмент.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередью сообщений <xref:System.Messaging.MessageQueue.Transactional%2A> свойство.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должны ли полученные сообщения копироваться в очередь журнала.</summary>
        <value>
          Значение <see langword="true" />, если сообщения, полученные из очереди, копируются в очередь журнала; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда приложения Message Queuing создает новую очередь приложения, автоматически создает связанную очередь журнала в том же расположении. Очередь журнала используется для отслеживания сообщений, удаленных из очереди. Задание этого свойства изменяет очереди сообщений. Таким образом, любые другие <xref:System.Messaging.MessageQueue> экземпляры являются повлияло изменение.  
  
 Очередь журнала не отслеживает сообщений, удаленных из очереди, так как время получения истечения, а также отслеживать сообщения, удаленные из очереди с помощью службы каталогов очереди сообщений (банка данных или Active Directory).  
  
 Приложения не могут отправлять сообщения в очереди журнала; они ограничены доступ только для чтения этих очередей. Кроме того очереди сообщений никогда не удаляет сообщения из очередей журнала. Приложения, использующего очереди необходимо снять эти сообщения, получив их или очистка очереди.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередью сообщений <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> свойство.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор, который используется для отправки сообщений в очередь сообщений.</summary>
        <value>Дескриптор собственного объекта очереди, который используется для отправки сообщений в очередь.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> Предоставляет собственный дескриптор Windows для объекта очереди сообщений, который используется для отправки сообщений в очередь. Если изменить путь к очереди, дескриптор закрыт и открыт повторно с новым значением.  
  
 В следующей таблице показаны ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь сообщений недоступна для записи.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>