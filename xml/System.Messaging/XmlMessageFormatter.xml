<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="563e678b40760a20036da2630095cb8b05f461de" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460738" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Сериализует объекты в текст сообщения или десериализует текст сообщения в объекты, используя для этого формат XML, основанный на определении схемы XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.XmlMessageFormatter> Средство форматирования по умолчанию, экземпляр <xref:System.Messaging.MessageQueue> использует для сериализации сообщений, записанных в эту очередь. При создании экземпляра <xref:System.Messaging.MessageQueue>, экземпляр <xref:System.Messaging.XmlMessageFormatter> создается автоматически и связанные с <xref:System.Messaging.MessageQueue>. Можно задать другой форматер, создав его в коде и присвоения его <xref:System.Messaging.MessageQueue.Formatter%2A> свойство вашей <xref:System.Messaging.MessageQueue>.  
  
 По умолчанию очередь <xref:System.Messaging.XmlMessageFormatter> экземпляр можно использовать для записи в очередь, но не может использоваться для чтения из очереди, пока не будет задан либо <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> или <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> свойства форматирования. Либо можно задать одно или оба этих значения в экземпляре по умолчанию модуль форматирования, или можно создать новый экземпляр модуля форматирования и установить эти значения автоматически, передав их в качестве аргументов в соответствующее <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктор.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> вместо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, существование типа проверяется во время компиляции, а не время чтения, что уменьшает вероятность ошибок. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> требуется полное, указав его имя сборки каждой записи. Кроме того при работе с несколькими параллельными версиями номер версии должен также быть добавлен к имени типа цели также.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру схемы, чтобы попытаться найти совпадение при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в теле сообщения должен согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> , метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из них должно быть задано при чтении из очереди, но можно задать и оба. Набор типов является совокупный набор из двух свойств. Решение, какое свойство использовать специфична для вашего приложения. Если тело сообщения содержит тип, схема которой не соответствует типам в массиве для каждого свойства, выдается исключение при чтении сообщения.  
  
 <xref:System.Messaging.XmlMessageFormatter> Является критически важным компонентом слабо связанных обмена сообщениями на основе XML. Утилита XSD.exe, использующая формат XML используется для создания XML-схем, например при использовании программы для сериализации класса, используемого приложением. Этот класс должен иметь конструктор по умолчанию.  
  
 Формат используется повторно в обратном процессе когда программа создает класс на основе схемы распространении для описания своего класса данных. Использование служебной программы и XML-схемы, он создает позволяет избежать перераспределения DLL-файлов, каждый раз при перекомпиляции класса после изменения реализации этого класса. При условии, что схема не изменяется на стороне клиента или сервера, на обеих сторонах другие изменения не влияют на другой.  
  
   
  
## Examples  
 В следующем примере кода включает три части кода: серверный компонент, класс заказов и клиентский код. Можно использовать класс order служебной программой XSD.exe для создания схемы, распознаваемой сервером во входящих сообщениях. Схема является XML-файл, описывающий «форму» класса. Затем эту схему можно использовать на стороне клиента для создания класса order конкретного клиента, использующего ту же схему, что и серверный класс.  
  
 В следующем примере кода представлен серверный компонент, получающий заказы через очередь сообщений. Тело сообщения должно быть объектом заказа, схема которого совпадает с показанным ниже классом Order.cs. Серверный процесс или приложение выполняет десериализацию порядок.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 В следующем примере кода представляет класс order, предоставляющий схему для объектов заказов и десериализуемых приложением на сервере.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Клиентское приложение, взаимодействующее с приложением на сервере необходимо отправлять сообщения на сервер, сериализуя данные в классе локально определенный порядок, в тело сообщения. Этот класс локально определенный порядок должен иметь ту же схему, как класс order, определенные на сервере, в который приложение на сервере будет пытаться десериализовать тело сообщения. Служебная программа XSD.exe позволяет диспетчеру приложения на сервере создавать и распределять схему, которую клиент должен использовать для сериализации сообщений, направляемых на сервер.  
  
 Когда диспетчер клиентского приложения принимает схему для класса order, служебную программу XSD.exe снова используется для создания класса order, относящиеся к клиенту из схемы. Этот класс используется в примере кода ниже сервера класс order клиента (служебная программа XSD.exe вызывает класс, сформированные схемой, имеет имя, совпадающее с именем исходного класса). Этот новый класс заказов используется для сериализации заказа в тело сообщения.  
  
 В следующем примере кода находится на стороне клиента обработки, используемый для сериализации заказа и отправляет данные, связанные с заказом в очередь. Этот код связывает элемент, количество и адрес с элементами схемы, которые были созданы для класса Order.cs служебной программой XSD.exe. Заказ передается в очередь заказов на локальном компьютере.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 После схемы создается на основе класса order на сервере, этот класс можно изменять. Если изменения схемы необходимо повторно распространить схему. После распространения схемы и создания класса на заказ на стороне клиента, этот клиентский класс могут также быть изменены независимо от класса на серверной, при условии, что схема не изменяется. Эти два класса становятся слабо связанными.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" /> без набора типов целевых объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка конструктора используется наиболее часто при записи в очередь, как типы целевого объекта не являются необходимыми при записи.  
  
 Для чтения сообщения из очереди, используя экземпляр <xref:System.Messaging.XmlMessageFormatter> создан с помощью этого конструктора, необходимо задать <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> или <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> таким образом, чтобы модуль форматирования известно, какие типы нужно попытаться выполнить десериализацию.  
  
 При создании нового <xref:System.Messaging.MessageQueue>, значение по умолчанию <xref:System.Messaging.XmlMessageFormatter> , создается экземпляр без набора типов назначения. С помощью модуля форматирования, созданный с помощью этого конструктора, необходимо задать типы целевых объектов для данного экземпляра модуля форматирования, если требуется выполнить чтение из очереди.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Массив типа <see cref="T:System.String" />, задающий набор возможных типов, десериализация которых будет выполняться модулем форматирования из предоставляемого сообщения. Эти значения должны быть полностью определены, например, "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, устанавливая типы целевых объектов, передаваемых как массив (полностью определенных) строковых значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструкторы с параметрами типов целевых объектов чаще всего используются при чтении из очереди. При записи, не требуется указывать типы целевых объектов.  
  
 Эта перегрузка <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктора задает <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> свойство значения массива, переданного через `targetTypeNames` параметра. Установка этого свойства позволяет <xref:System.Messaging.MessageQueue> с помощью этого <xref:System.Messaging.XmlMessageFormatter> экземпляр для чтения сообщений, содержащих объекты заданного типа.  
  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру схемы, чтобы попытаться найти совпадение при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в теле сообщения должен согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> , метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из них должно быть задано при чтении из очереди, но можно задать и оба. Набор типов является совокупный набор из двух свойств. Решение, какую из них использовать вашего приложения. Если тело сообщения содержит тип, схема которой не соответствует типам в массиве для каждого свойства, исключение будет создаваться во время чтения.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="targetTypeNames" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Массив типа <see cref="T:System.Type" />, задающий набор возможных типов, десериализация которых будет выполняться модулем форматирования из предоставляемого сообщения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, устанавливая типы целевых объектов, передаваемых как массив типов объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструкторы с параметрами типов целевых объектов чаще всего используются при чтении из очереди. При записи, не требуется указывать типы целевых объектов.  
  
 Эта перегрузка <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктора задает <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойство значения массива, переданного через `targetTypes` параметра. Установка этого свойства позволяет <xref:System.Messaging.MessageQueue> с помощью этого <xref:System.Messaging.XmlMessageFormatter> экземпляр для чтения сообщений, содержащих объекты заданного типа.  
  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру схемы, чтобы попытаться найти совпадение при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в теле сообщения должен согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> , метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из них должно быть задано при чтении из очереди, но можно задать и оба. Набор типов является совокупный набор из двух свойств. Решение, какую из них использовать вашего приложения. Если тело сообщения содержит тип, схема которой не соответствует типам в массиве для каждого свойства, исключение будет создаваться во время чтения.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> вместо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, существование типа проверяется во время компиляции, а не время чтения, что уменьшает вероятность ошибок. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> требуется полное, указав его имя сборки каждой записи. Кроме того при работе с несколькими параллельными версиями номер версии должен также быть добавлен к имени типа цели также.  
  
 При использовании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, можно добавить каждого объекта (например, `MyClass`) в список, в результате, показано в следующем примере кода C#.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="targetTypes" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Объект <see cref="T:System.Messaging.Message" /> для проверки.</param>
        <summary>Определяет, может ли модуль форматирования десериализовать сообщение.</summary>
        <returns>
          Значение <see langword="true" />, если XML-модуль форматирования может десериализовать сообщение; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> вызывается форматер попытается определить, если содержимое сообщения может выполнить десериализацию. Модуль форматирования может десериализовать сообщение, только если тип в теле сообщения имеет ту же схему, как один из типов в массиве, представленном <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Возвращает `false` в следующих двух случаях:  
  
-   Сообщение не был отформатирован с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Схема тела сообщения не между значениями, перечисленными в любом <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> или <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру какие типы объектов он должен иметь возможность десериализации. Если какая-либо еще отсутствует в списке, не найден в сообщении, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> не установлены.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="message" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, свойства чтения и записи (наборы типов целевых объектов) которого такие же, как и у текущего экземпляра <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
        <returns>Объект со свойствами, идентичными свойствам данного экземпляра <see cref="T:System.Messaging.XmlMessageFormatter" />, но с метаданными, которые не определяют его как экземпляр класса модуля форматирования.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает копию модуля форматирования и инициализирует его свойства на значения <xref:System.Messaging.XmlMessageFormatter> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Десериализуемое сообщение <see cref="T:System.Messaging.Message" /> в XML-формате.</param>
        <summary>Считывает содержимое из данного сообщения и создает объект, содержащий десериализованное сообщение.</summary>
        <returns>Десериализованное сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру схемы, чтобы попытаться найти совпадение при десериализации сообщения. Должен быть задан один из этих свойств, прежде чем можно десериализовать сообщение.  
  
 Экземпляр, сериализованный в теле сообщения должен согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> , метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Типы целевого объекта не обязательно для записи в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> не установлены.  
  
 - или -  
  
 Экземпляр, сериализуемый в тело сообщения, не согласуется ни с одной из схем, представленных типами в свойствах <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> и <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="message" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает набор возможных типов, десериализация которых будет выполняться модулем форматирования из тела предоставляемого сообщения.</summary>
        <value>Массив типа <see cref="T:System.String" />, задающий типы объектов, десериализуемых из тела сообщения при чтении данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру схемы, чтобы попытаться найти совпадение при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в теле сообщения должен согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> , метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из них должно быть задано при чтении из очереди, но можно задать и оба. Набор типов является совокупный набор из двух свойств. Решение, какое свойство использовать специфична для вашего приложения. Если тело сообщения содержит тип, схема которой не соответствует типам в массиве для каждого свойства, выдается исключение при чтении сообщения.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> требуется полное, указав его имя сборки каждой записи. Кроме того при работе с несколькими параллельными версиями номер версии должен также быть добавлен к имени типа цели также.  
  
 Типы целевых объектов только при чтении из очереди. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства не нужно устанавливать при записи в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает набор возможных типов, десериализация которых будет выполняться модулем форматирования из тела предоставляемого сообщения.</summary>
        <value>Массив типа <see cref="T:System.Type" />, задающий типы объектов, десериализуемых из тела сообщения при чтении данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают форматеру схемы, чтобы попытаться найти совпадение при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в теле сообщения должен согласовываться с одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> , метод создает объект типа, который соответствует схеме и считывает тело сообщения в него.  
  
 Только один из них должно быть задано при чтении из очереди, но можно задать и оба. Набор типов является совокупный набор из двух свойств. Решение, какое свойство использовать специфична для вашего приложения. Если тело сообщения содержит тип, схема которой не соответствует типам в массиве для каждого свойства, выдается исключение при чтении сообщения.  
  
 Типы целевых объектов только при чтении из очереди. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> И <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойства не нужно устанавливать при записи в очередь.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> вместо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, существование типа проверяется во время компиляции, а не время чтения, что уменьшает вероятность ошибок.  
  
 При использовании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, можно добавить каждого объекта (например, `MyClass`) в список, как показано в коде C# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее заказ в и из очереди.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Body" /> которого будет содержать сериализованный объект.</param>
        <param name="obj">Объект <see cref="T:System.Object" />, сериализуемый в тело сообщения.</param>
        <summary>Сериализует объект в текст сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типы целевых объектов для записи в очередь, поскольку они должны быть при чтении не обязательно. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Или <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойство используется модулем форматирования только при десериализации сообщения.  
  
 <xref:System.Messaging.XmlMessageFormatter> Использует <xref:System.Xml.Serialization.XmlSerializer> класс, определяющий, что может быть сериализован. Только открытые поля и открытые свойства могут быть сериализованы. Структуры, структуры с массивами и массивы структур являются сериализуемыми, пока они не используется стиль шифрования с протоколом SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="message" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>