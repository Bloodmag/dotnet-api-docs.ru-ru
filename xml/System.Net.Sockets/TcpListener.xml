<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="70b4efe2d402b27e3285b56bb7a50aff7def9e09" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461088" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Прослушивает подключения от TCP-клиентов сети.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> Класс предоставляет простые методы, которые прослушивать и принимать входящие запросы на подключение в блокирующем синхронном режиме. Можно использовать любой <xref:System.Net.Sockets.TcpClient> или <xref:System.Net.Sockets.Socket> соединяться с <xref:System.Net.Sockets.TcpListener>. Создание <xref:System.Net.Sockets.TcpListener> с помощью <xref:System.Net.IPEndPoint>, локальный IP-адрес и номер порта или номер порта. Укажите <xref:System.Net.IPAddress.Any> для локального IP-адреса и значение 0 для номера локального порта, если требуется, чтобы эти значения были присвоены основным поставщиком услуг. Если вы решите сделать это, можно использовать <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> свойство для идентификации связанных сведений после подключения сокета.  
  
 Используйте <xref:System.Net.Sockets.TcpListener.Start%2A> метод, чтобы начать прослушивание входящих запросов на подключение. <xref:System.Net.Sockets.TcpListener.Start%2A> очередь входящих подключений до вызова функции <xref:System.Net.Sockets.TcpListener.Stop%2A> метода или он поставил в очередь <xref:System.Net.Sockets.SocketOptionName.MaxConnections>. Используйте либо <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> или <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> для приема подключения из входной очереди подключений. Эти два метода будет блокировать. Если вы хотите избежать блокировки, можно использовать <xref:System.Net.Sockets.TcpListener.Pending%2A> метод, чтобы определить, если запросы на подключение в очереди.  
  
 Вызовите <xref:System.Net.Sockets.TcpListener.Stop%2A> метод закрытия <xref:System.Net.Sockets.TcpListener>.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.TcpListener.Stop%2A> Метод не закрывает все допустимые подключения. Вы несете ответственность за закрытие их отдельно.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.Sockets.TcpListener>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 В разделе <xref:System.Net.Sockets.TcpClient> пример для клиента.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Чтобы установить исходящее соединение или принять входящий запрос.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use TcpListener (IPAddress address, int port) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Порт, на котором производится ожидание входящих попыток подключений.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpListener" />, который ожидает передачу данных для указанного порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор является устаревшим. Используйте <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType> или <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType> конструкторы.  
  
 Этот конструктор позволяет указать номер порта для прослушивания входящих попыток подключения. С помощью этого конструктора основной поставщик услуг присваивает наиболее подходящий сетевой адрес. Если неважно, какой локальный порт используется, можно указать 0 для номера порта. В этом случае поставщик услуг присвоит доступный эфемерных номер порта. При использовании этого подхода можно выяснить, какой локальный сетевой адрес и номер порта присвоены с помощью <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> свойство.  
  
 Вызовите <xref:System.Net.Sockets.TcpListener.Start%2A> метод, чтобы начать прослушивание входящих попыток подключения.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.Sockets.TcpListener> с помощью нескольких локальных портов.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="port" /> не находится в диапазоне между значениями <see cref="F:System.Net.IPEndPoint.MinPort" /> и <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Объект <see cref="T:System.Net.IPEndPoint" />, представляющий локальную конечную точка, назначенную для связывания со слушателем <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpListener" /> с заданной локальной конечной точкой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор позволяет указать локальный IP-адрес и номер порта, на котором будет прослушивать входящие подключения попыток. Прежде чем использовать этот конструктор, необходимо создать <xref:System.Net.IPEndPoint> с помощью нужный локальный IP-адрес и порт номер. Передать этот <xref:System.Net.IPEndPoint> конструктору как `localEP` параметр.  
  
 Если неважно, какой локальный адрес будет присвоен, можно создать <xref:System.Net.IPEndPoint> с помощью <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> как параметр address и базовой службы Поставщик присвоит наиболее подходящий сетевой адрес. Это поможет упростить приложение, если имеется несколько сетевых интерфейсов. Если неважно, какой локальный порт используется, можно создать <xref:System.Net.IPEndPoint> используется значение 0 для номера порта. В этом случае поставщик услуг присвоит доступный эфемерных номер порта. При использовании этого подхода можно выяснить, какой локальный сетевой адрес и номер порта присвоены с помощью <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> свойство.  
  
 Вызовите <xref:System.Net.Sockets.TcpListener.Start%2A> метод, чтобы начать прослушивание входящих попыток подключения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр <xref:System.Net.Sockets.TcpListener> класса с помощью локальной конечной точки.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="localEP" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr">Объект <see cref="T:System.Net.IPAddress" />, представляющий локальный IP-адрес.</param>
        <param name="port">Порт, на котором производится ожидание входящих попыток подключений.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpListener" />, который выполняет ожидание входящих попыток подключения для заданных локального IP-адреса и номера локального порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор позволяет указать локальный IP-адрес и номер порта, на котором будет прослушивать входящие подключения попыток. Перед вызовом конструктора, необходимо сначала создать <xref:System.Net.IPAddress> с помощью необходимый локальный адрес. Передать этот <xref:System.Net.IPAddress> конструктору как `localaddr` параметр. Если неважно, какой локальный адрес будет присвоен, укажите <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> для `localaddr` параметр и основной поставщик услуг присвоит наиболее подходящий сетевой адрес. Это поможет упростить приложение, если имеется несколько сетевых интерфейсов. Если неважно, какой локальный порт используется, можно указать 0 для номера порта. В этом случае поставщик услуг присвоит доступный номер порта от 1024 до 5000. При использовании этого подхода можно выяснить, какой локальный сетевой адрес и номер порта присвоены с помощью <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> свойство.  
  
 Вызовите <xref:System.Net.Sockets.TcpListener.Start%2A> метод, чтобы начать прослушивание входящих попыток подключения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр <xref:System.Net.Sockets.TcpListener> класса, используя локальный IP-адрес и порт номер.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="localaddr" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="port" /> не находится в диапазоне между значениями <see cref="F:System.Net.IPEndPoint.MinPort" /> и <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принимает ожидающий запрос на подключение.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" />, используемый для приема и передачи данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> — Это блокирующий метод, возвращающий <xref:System.Net.Sockets.Socket> , можно использовать для отправки и получения данных. Если вы хотите избежать блокировки, используйте <xref:System.Net.Sockets.TcpListener.Pending%2A> метод для определения запросов на подключение в очереди входящих подключений.  
  
 <xref:System.Net.Sockets.Socket> Вернул инициализируется при помощи IP адрес и номер порта удаленного узла. Можно использовать любой из <xref:System.Net.Sockets.Socket.Send%2A> и <xref:System.Net.Sockets.Socket.Receive%2A> методов, доступных в <xref:System.Net.Sockets.Socket> класса для взаимодействия с удаленным узлом. По окончании с помощью <xref:System.Net.Sockets.Socket>, необходимо вызвать его <xref:System.Net.Sockets.Socket.Close%2A> метод. Если приложения относительно прост, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метод вместо <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод. <xref:System.Net.Sockets.TcpClient> предоставляет простые методы для отправки и получения данных по сети в блокирующем синхронном режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод используется для возврата <xref:System.Net.Sockets.Socket>. Это <xref:System.Net.Sockets.Socket> используется для связи с вновь подключенным клиентом.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Слушатель не запущен с помощью вызова метода <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принимает запрос ожидающего подключения как асинхронную операцию.</summary>
        <returns>Возвращает <see cref="T:System.Threading.Tasks.Task`1" />.  
  
 Объект задачи, представляющий асинхронную операцию. Свойство <see cref="P:System.Threading.Tasks.Task`1.Result" /> в объекте задачи возвращает <see cref="T:System.Net.Sockets.Socket" />, используемый для отправки и получения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокирована. Возвращенный <xref:System.Threading.Tasks.Task%601> объекта будет выполнена после принятия подключение к сокету.  
  
 <xref:System.Net.Sockets.Socket> Возвращается в <xref:System.Threading.Tasks.Task%601> инициализируется при помощи IP адрес и номер порта удаленного узла. Можно использовать любой из <xref:System.Net.Sockets.Socket.Send%2A> и <xref:System.Net.Sockets.Socket.Receive%2A> методов, доступных в <xref:System.Net.Sockets.Socket> класса для взаимодействия с удаленным узлом. По окончании с помощью <xref:System.Net.Sockets.Socket>, необходимо вызвать его <xref:System.Net.Sockets.Socket.Close%2A> метод. Если приложения относительно прост, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метод вместо <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> метод. <xref:System.Net.Sockets.TcpClient> предоставляет простые методы для отправки и получения данных по сети в блокирующем синхронном режиме.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Слушатель не запущен с помощью вызова метода <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принимает ожидающий запрос на подключение.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.TcpClient" />, используемый для приема и передачи данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> — Это блокирующий метод, возвращающий <xref:System.Net.Sockets.TcpClient> , можно использовать для отправки и получения данных. Используйте <xref:System.Net.Sockets.TcpListener.Pending%2A> метод, чтобы определить, если запросы на подключение доступны в очереди входящих подключений, чтобы избежать блокировки.  
  
 Используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> метод, чтобы получить основной <xref:System.Net.Sockets.NetworkStream> возвращаемого <xref:System.Net.Sockets.TcpClient>. <xref:System.Net.Sockets.NetworkStream> Будет предоставляют методы для отправки и получения с удаленного узла. После завершения использования с <xref:System.Net.Sockets.TcpClient>, необходимо вызвать его <xref:System.Net.Sockets.TcpClient.Close%2A> метод. Если требуется больше гибкости, чем <xref:System.Net.Sockets.TcpClient> предложений, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метод используется для возврата <xref:System.Net.Sockets.TcpClient>. Это <xref:System.Net.Sockets.TcpClient> используется для связи с вновь подключенным клиентом.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Слушатель не запущен с помощью вызова метода <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Для получения кода ошибки можно воспользоваться свойством <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Получив этот код, можно обратиться за подробным описанием ошибки к документации по кодам ошибок API для сокетов Windows версии 2 в библиотеке MSDN.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принимает запрос ожидающего подключения как асинхронную операцию.</summary>
        <returns>Возвращает <see cref="T:System.Threading.Tasks.Task`1" />.  
  
 Объект задачи, представляющий асинхронную операцию. Свойство <see cref="P:System.Threading.Tasks.Task`1.Result" /> в объекте задачи возвращает <see cref="T:System.Net.Sockets.TcpClient" />, используемый для отправки и получения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокирована. Возвращенный <xref:System.Threading.Tasks.Task%601> объекта будет выполнена после принятия соединения по протоколу TCP.  
  
 Используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> метод, чтобы получить основной <xref:System.Net.Sockets.NetworkStream> возвращаемого <xref:System.Net.Sockets.TcpClient> в <xref:System.Threading.Tasks.Task%601>. <xref:System.Net.Sockets.NetworkStream> Будет предоставляют методы для отправки и получения с удаленного узла. После завершения использования с <xref:System.Net.Sockets.TcpClient>, необходимо вызвать его <xref:System.Net.Sockets.TcpClient.Close%2A> метод. Если требуется больше гибкости, чем <xref:System.Net.Sockets.TcpClient> предложений, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> или <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Слушатель не запущен с помощью вызова метода <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Для получения кода ошибки можно воспользоваться свойством <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Получив этот код, можно обратиться за подробным описанием ошибки к документации по кодам ошибок API для сокетов Windows версии 2 в библиотеке MSDN.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли активным объект <see cref="T:System.Net.Sockets.TcpListener" />, выполняющий прослушивание клиентских подключений.</summary>
        <value>
          Значение <see langword="true" />, если прослушивающий объект <see cref="T:System.Net.Sockets.TcpListener" /> активен; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные от <xref:System.Net.Sockets.TcpListener> это свойство можно использовать для определения <xref:System.Net.Sockets.Socket> в настоящее время прослушивание входящих попыток подключения. <xref:System.Net.Sockets.TcpClient.Active%2A> Свойство может использоваться, чтобы избежать избыточных <xref:System.Net.Sockets.TcpListener.Start%2A> попыток.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Логическое значение, указывающее, что надо включить или выключить обход NAT.</param>
        <summary>Включает или отключает обход механизма преобразования сетевых адресов (NAT) для экземпляра <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> Метод используется для включения или отключения прохождения NAT для <xref:System.Net.Sockets.TcpListener> экземпляра. Обход NAT может предоставляться Teredo, 6to4 или туннель ISATAP.  
  
 Когда `allowed` параметр имеет значение false, <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> на связанного сокета был установлен в <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Это явно отключает прохождения NAT для <xref:System.Net.Sockets.TcpListener> экземпляра.  
  
 Когда `allowed` параметр имеет значение true, <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> на связанного сокета был установлен в <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Это может позволить прохождения NAT для <xref:System.Net.Sockets.TcpListener> в зависимости от правил брандмауэра на месте в системе.  
  
 <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> Метод должен быть вызван до вызова метода <xref:System.Net.Sockets.TcpListener.Start%2A> метод, чтобы начать прослушивание входящих запросов на подключение (перед привязкой сокета). Если <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> метод вызывается после <xref:System.Net.Sockets.TcpListener.Start%2A> метод, то <xref:System.InvalidOperationException> будет создано.  
  
 Адрес Teredo — IPv6-адрес с префиксом 2001:: / 32. Адреса Teredo можно возвращенные с помощью обычного разрешения имен DNS или перечислены как IPv6-адрес локального интерфейса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" /> был вызван после метода <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию о данной операции принятия запроса на подключения. Этот объект передается делегату <c>callback</c> по завершении операции.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> операция должна быть завершена, вызвав <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> метод. Как правило, вызывается метод `callback` делегата.  
  
 Этот метод блокируется до завершения операции. Для блокирования до завершения операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойство возвращаемого <xref:System.Net.Sockets.Socket> для идентификации удаленного узла сетевой адрес и номер порта.  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) для подробные Описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> метод для создания и подключения сокета. Вызывает делегат обратного вызова <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> метод для завершения асинхронного запроса.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию о данной операции принятия запроса на подключения. Этот объект передается делегату <c>callback</c> по завершении операции.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.TcpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> операция должна быть завершена, вызвав <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> метод. Как правило, вызывается метод `callback` делегата.  
  
 Этот метод блокируется до завершения операции. Для блокирования до завершения операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) для подробные Описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> метод для создания и подключения сокета. Вызывает делегат обратного вызова <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> метод для завершения асинхронного запроса.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Порт, на котором производится ожидание входящих попыток подключений.</param>
        <summary>Создает Новый экземпляр <see cref="T:System.Net.Sockets.TcpListener" />, который должен прослушивать на определенном порту.</summary>
        <returns>Возвращает <see cref="T:System.Net.Sockets.TcpListener" />.  
  
 Новый экземпляр <see cref="T:System.Net.Sockets.TcpListener" />, который должен прослушивать на определенном порту.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" /> возвращен посредством вызова метода <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" />.  
  
 Объект <see cref="T:System.Net.Sockets.Socket" />, используемый для приема и передачи данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до операции завершения. Для синхронного выполнения этой операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод.  
  
> [!NOTE]
>  Можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойство возвращаемого <xref:System.Net.Sockets.Socket> для идентификации удаленного узла сетевой адрес и номер порта.  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) для подробные Описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> метод для создания и подключения сокета. Вызывает делегат обратного вызова <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> метод для завершения асинхронного запроса.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Основной объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="asyncResult" /> не было создано при вызове метода <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Был ранее вызван метод <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" /> возвращен посредством вызова метода <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.TcpClient" /> для связи с удаленным узлом.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.TcpClient" />.  
  
 Объект <see cref="T:System.Net.Sockets.TcpClient" />, используемый для приема и передачи данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до операции завершения. Для синхронного выполнения этой операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метод.  
  
> [!NOTE]
>  Можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойства базового сокета (<xref:System.Net.Sockets.TcpClient.Client%2A>) для определения удаленного узла сетевой адрес и номер порта.  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) для подробные Описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> метод для создания и подключения сокета. Вызывает делегат обратного вызова <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> метод для завершения асинхронного запроса.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, позволяет ли объект <see cref="T:System.Net.Sockets.TcpListener" /> осуществлять ожидание передачи данных только на одном основном сокете на указанном порту.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.TcpListener" /> разрешает осуществлять ожидание передачи данных только на одном объекте <see cref="T:System.Net.Sockets.TcpListener" /> на указанном порту; в противном случае — значение <see langword="false" />. . По умолчанию используется значение <see langword="true" /> для Windows Server 2003 и Windows XP с пакетом обновления 2 (SP2) и более поздней версии; для всех остальных версий по умолчанию используется значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию несколько прослушивателей может прослушивать определенный порт. Однако только один из прослушивателей выполнять операции на сетевом трафике, отправляемом на порт. Если более одного прослушивателя пытается выполнить привязку к конкретному порту, тем более конкретные IP-адрес обрабатывает сетевого трафика, отправляемого на порт. Можно использовать <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> свойства, чтобы предотвратить прослушивание определенного порта несколько прослушивателей.  
  
 Задать это свойство до вызова метода <xref:System.Net.Sockets.TcpListener.Start%2A>, или вызов <xref:System.Net.Sockets.TcpListener.Stop%2A> метод и задайте для этого свойства.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A> свойства.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Net.Sockets.TcpListener" /> запущен. Вызовите метод <see cref="M:System.Net.Sockets.TcpListener.Stop" />, а затем задайте свойство <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к основному сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Основной объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает основной объект <see cref="T:System.Net.EndPoint" /> для текущего объекта <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <value>Объект <see cref="T:System.Net.EndPoint" />, с которым связан объект <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> свойство для идентификации локальной сетевой интерфейс и номер порта, используемого для прослушивания входящих клиентских запросов на подключение после подключения к сокету. Необходимо сначала привести <xref:System.Net.EndPoint> для <xref:System.Net.IPEndPoint>. Затем можно вызвать <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> свойства, чтобы получить локальный IP-адрес и <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> свойства, чтобы получить имя локального порта.  
  
   
  
## Examples  
 В следующем примере кода отображаются локальный IP-адрес и порт номер, на котором <xref:System.Net.Sockets.TcpListener> прослушивание входящих запросов на подключение.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, имеются ли ожидающие запросы на подключение.</summary>
        <returns>
          Значение <see langword="true" />, если имеются ожидающие подключения; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это неблокирующий метод определяет, имеются все ожидающие запросы на подключение. Поскольку <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> и <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> методов блокировки выполнения до <xref:System.Net.Sockets.TcpListener.Start%2A> метод поставил в очередь входящий запрос на подключение, <xref:System.Net.Sockets.TcpListener.Pending%2A> метод может использоваться для определения доступных подключений перед попыткой принять их.  
  
   
  
## Examples  
 В следующем примере кода в примере выполняется проверка <xref:System.Net.Sockets.TcpListener.Pending%2A> метод. Если запрос на подключение был принят, затем вызов <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метода.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Слушатель не запущен с помощью вызова метода <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает основной сетевой объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Базовый объект <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> Создает <xref:System.Net.Sockets.Socket> для прослушивания входящих клиентских запросов на подключение. Классы, производные от <xref:System.Net.Sockets.TcpListener> это свойство можно использовать для получения этого <xref:System.Net.Sockets.Socket>. Используйте основной <xref:System.Net.Sockets.Socket> возвращенных <xref:System.Net.Sockets.TcpListener.Server%2A> свойство, если требуется доступа, чем, который <xref:System.Net.Sockets.TcpListener> предоставляет.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.TcpListener.Server%2A> Свойство возвращает только <xref:System.Net.Sockets.Socket> используемый для прослушивания входящих клиентских запросов на подключение. Используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод для принятия ожидающего запроса на подключение и для получения <xref:System.Net.Sockets.Socket> для отправки и получения данных. Можно также использовать <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метод для принятия ожидающего запроса на подключение и для получения <xref:System.Net.Sockets.TcpClient> для отправки и получения данных.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.Sockets.TcpListener.Server%2A> свойство. Базовый <xref:System.Net.Sockets.Socket> извлекается и <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> параметр требует времени ожидания после 10 секунд, если данные по-прежнему находится в сетевом буфере после закрытия соединения.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает ожидание входящих запросов на подключение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает ожидание входящих запросов на подключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Start%2A> Метод инициализирует базовый <xref:System.Net.Sockets.Socket>, связывает его с локальной конечной точкой и выполняет прослушивание входящих попыток подключения. Если получен запрос на подключение, <xref:System.Net.Sockets.TcpListener.Start%2A> будет поместить запрос в очередь и продолжит ожидание дополнительные запросы, пока не будет вызван метод <xref:System.Net.Sockets.TcpListener.Stop%2A> метод. Если <xref:System.Net.Sockets.TcpListener> получает запрос на соединение после его в очереди уже имеется максимальное число подключений, он будет вызывать <xref:System.Net.Sockets.SocketException> на стороне клиента.  
  
 Чтобы удалить подключение из входной очереди, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метода или <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод. <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Удалит подключение из очереди и возвращать метод <xref:System.Net.Sockets.TcpClient> , можно использовать для отправки и получения данных. <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Метод будет возвращать <xref:System.Net.Sockets.Socket> , можно использовать для сделайте то же самое. Если приложению требуется только синхронный ввод-вывод, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Для детального контроля поведения используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>. Оба эти метода блокированными, пока запрос на подключение в очереди.  
  
 Используйте <xref:System.Net.Sockets.TcpListener.Stop%2A> метод закрытия <xref:System.Net.Sockets.TcpListener> и прекратить прослушивание. Вы несете ответственность за закрытие каждого из принятых подключений отдельно.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как <xref:System.Net.Sockets.TcpListener.Start%2A> используется для прослушивания входящих попыток клиентских подключений.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Для получения кода ошибки можно воспользоваться свойством <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Получив этот код, можно обратиться за подробным описанием ошибки к документации по кодам ошибок API для сокетов Windows версии 2 в библиотеке MSDN.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Максимальная длина очереди ожидающих подключений.</param>
        <summary>Запускает ожидание входящих запросов на подключение с максимальным числом ожидающих подключений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Start%2A> Метод инициализирует базовый <xref:System.Net.Sockets.Socket>, связывает его с локальной конечной точкой и выполняет прослушивание входящих попыток подключения. Если получен запрос на подключение, <xref:System.Net.Sockets.TcpListener.Start%2A> будет поместить запрос в очередь и продолжит ожидание дополнительные запросы, пока не будет вызван <xref:System.Net.Sockets.TcpListener.Stop%2A> метод. Если <xref:System.Net.Sockets.TcpListener> получает запрос на соединение после его в очереди уже имеется максимальное число подключений, он будет вызывать <xref:System.Net.Sockets.SocketException> на стороне клиента.  
  
 Чтобы удалить подключение из входной очереди, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> метода или <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод. <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Удалит подключение из очереди и возвращать метод <xref:System.Net.Sockets.TcpClient> , можно использовать для отправки и получения данных. <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Метод будет возвращать <xref:System.Net.Sockets.Socket> , можно использовать для сделайте то же самое. Если приложению требуется только синхронный ввод-вывод, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Для детального контроля поведения используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> метод. Оба эти метода блокированными, пока запрос на подключение в очереди.  
  
 Используйте <xref:System.Net.Sockets.TcpListener.Stop%2A> метод закрытия <xref:System.Net.Sockets.TcpListener> и прекратить прослушивание. Вы несете ответственность за закрытие каждого из принятых подключений отдельно.  
  
> [!NOTE]
>  Используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) подробное описание ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как <xref:System.Net.Sockets.TcpListener.Start%2A> используется для прослушивания входящих попыток клиентских подключений.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при получении доступа к сокету.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="backlog" /> меньше нуля или превышает максимальное число разрешенных подключений.</exception>
        <exception cref="T:System.InvalidOperationException">Основной объект <see cref="T:System.Net.Sockets.Socket" /> имеет значение null.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает слушатель.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A> Закрывает прослушиватель. Запросы на подключение, неподдерживаемого в очереди будут потеряны. Вызовет удаленных узлов, Ожидание подключения могут быть приняты <xref:System.Net.Sockets.SocketException>. Вы несете ответственность за закрытие каждого из принятых подключений отдельно.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.Sockets.TcpListener.Stop%2A> метод закрытия базового <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Для получения кода ошибки можно воспользоваться свойством <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />. Получив этот код, можно обратиться за подробным описанием ошибки к документации по кодам ошибок API для сокетов Windows версии 2 в библиотеке MSDN.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.Net.Sockets.TcpListener.Stop" /> Метод закрывает основной <see cref="T:System.Net.Sockets.Socket" />и создает новый <see cref="T:System.Net.Sockets.Socket" /> для <see cref="T:System.Net.Sockets.TcpListener" />. Если значение любого свойства для базового <see cref="T:System.Net.Sockets.Socket" /> до вызова метода <see cref="M:System.Net.Sockets.TcpListener.Stop" /> метод, эти свойства будут не переносятся в новый <see cref="T:System.Net.Sockets.Socket" />.</para>
        </block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>