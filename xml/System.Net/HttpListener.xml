<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="82573ef12ea9f2297019f9e271a52a13621c873d" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33682640" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет простой программно управляемый прослушиватель протокола HTTP. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Net.HttpListener> класса, можно создать простой прослушиватель протокола HTTP, который отвечает на HTTP-запросы. Прослушиватель активен в течение времени существования <xref:System.Net.HttpListener> объекта и выполняется в приложении с его разрешения.
   
 Для использования <xref:System.Net.HttpListener>, создать новый экземпляр класса с помощью <xref:System.Net.HttpListener> конструктор и используйте <xref:System.Net.HttpListener.Prefixes%2A> свойство для доступа к коллекции, содержащий строки, которые указывают, какой универсальный код ресурса (URI) префиксов <xref:System.Net.HttpListener>обработки.
  
 Строка префикса URI состоит из схемы (http или https), узел, дополнительного порта и дополнительный путь. Пример строку завершения префикса — * http://www.contoso.com:8080/customerData/ *. Префиксы должны заканчиваться косой черты («/»). <xref:System.Net.HttpListener> Объекта с префиксом, наиболее точно соответствующий запрашиваемому URL-АДРЕСУ отвечает на запрос. Несколько <xref:System.Net.HttpListener> объектов не удается добавить одинаковый префикс; <xref:System.ComponentModel.Win32Exception> исключение, если <xref:System.Net.HttpListener> добавляет префикс, который уже используется.
  
 Если указан порт, элемент узла может быть заменен с «\*» указывает, что <xref:System.Net.HttpListener> принимает запросы, отправленные в порт, если запрошенный URI не соответствует любому другому префиксу. Например, чтобы получать все запросы, отправляемые на порт 8080, при запрошенный URI не обрабатывается каким-либо <xref:System.Net.HttpListener>, префикс не *http://\*: 8080 /*. Аналогичным образом чтобы указать, что <xref:System.Net.HttpListener> принимает все запросы, отправленные на порт, замените элемент узла символом «+». For example, *https://+:8080*. «\*» И «+» символы могут быть представлены в префиксах, содержащих пути.
  
 Начиная с .NET Core 2.0 или .NET Framework 4.6 в Windows 10, в префиксы URI, которые управляются поддерживаются подстановочные поддомены <xref:System.Net.HttpListener> объекта. Чтобы указать шаблон дочерний домен, используйте "\*" символ как часть имени узла в префикс URI. Например *http://\*.foo.com/*. Это передается в качестве аргумента для <xref:System.Net.HttpListenerPrefixCollection.Add%2A> метод. Это работает, начиная с .NET Core 2.0 или .NET Framework 4.6 в Windows 10; в более ранних версиях это приводит к возникновению ошибки <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Привязки верхнего уровня подстановочный знак (*http://\*: 8080 /* и * http://+:8080 *) следует **не** использоваться. Это может создать уязвимость и поставить ваше приложение под угрозу. Сюда относятся и строгие, и нестрогие подстановочные знаки. Вместо этого используйте имена узлов в явном виде. Привязки с подстановочными знаками на уровне дочерних доменов (например `*.mysub.com`) не создают таких угроз безопасности, если вы полностью контролируете родительский домен (в отличие от варианта `*.com`, создающего уязвимость). Дополнительные сведения см. в документе [rfc7230, раздел 5.4](https://tools.ietf.org/html/rfc7230#section-5.4).
  
 Для приема запросов от клиентов, добавьте префиксы URI коллекции и вызов <xref:System.Net.HttpListener.Start%2A> метод. <xref:System.Net.HttpListener> предоставляет синхронные и асинхронные модели обработки клиентских запросов. Запросы и их связанные ответы осуществляется с помощью <xref:System.Net.HttpListenerContext> объект, возвращаемый <xref:System.Net.HttpListener.GetContext%2A> метода или его асинхронной аналогами <xref:System.Net.HttpListener.BeginGetContext%2A> и <xref:System.Net.HttpListener.EndGetContext%2A> методы.
  
 Синхронная модель подходит в том случае, если приложения должны блокировать во время ожидания для запроса клиента, и если требуется обрабатывать только один запрос единовременно. С помощью Синхронная модель, вызовите <xref:System.Net.HttpListener.GetContext%2A> метод, который ожидает клиента для отправки запроса. Метод возвращает <xref:System.Net.HttpListenerContext> объект для обработки, когда один.
  
 В более сложной асинхронной модели приложение не блокируется во время ожидания для запросов и каждый запрос обрабатывается в своем собственном потоке выполнения. Используйте <xref:System.Net.HttpListener.BeginGetContext%2A> метод, чтобы указать определенные приложением будет вызван метод для каждого входящего запроса. В этом методе, вызывать <xref:System.Net.HttpListener.EndGetContext%2A> метод получения запроса и его обработки ответа.
  
 В любой модели входящих запросов осуществляется с помощью <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> представленного свойством и являются <xref:System.Net.HttpListenerRequest> объектов. Аналогичным образом, ответы осуществляется с помощью <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> представленного свойством и являются <xref:System.Net.HttpListenerResponse> объектов. Эти объекты используют некоторые функциональные возможности с <xref:System.Net.HttpWebRequest> и <xref:System.Net.HttpWebResponse> объектов, но последний объектов не может использоваться в сочетании с <xref:System.Net.HttpListener> так, как они реализуют поведение клиента, а не сервера.
  
 <xref:System.Net.HttpListener> Можно потребовать проверку подлинности клиента. Можно указать определенную схему для проверки подлинности, или можно указать делегат, который определяет схему, которую нужно использовать. Необходимо использовать некоторую форму проверки подлинности для получения сведений об идентификации клиента. Дополнительные сведения см. в разделе <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, и <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> свойства.
  
> [!NOTE]
> Если вы создаете <xref:System.Net.HttpListener> с помощью протокола https, необходимо выбрать сертификат сервера для этого прослушивателя. В противном случае <xref:System.Net.HttpWebRequest> запрос этого <xref:System.Net.HttpListener> , будут завершаться неожиданный запрос закрытия соединения.
  
> [!NOTE]
> Сертификаты сервера и другие параметры прослушивателя можно настроить с помощью сетевой оболочки (netsh.exe). В разделе [сетевой оболочки (Netsh)](/windows-server/networking/technologies/netsh/netsh) для получения дополнительных сведений. Исполняемый файл поставляются с Windows Server 2008 и Windows Vista.
  
> [!NOTE]
> При указании нескольких схем проверки подлинности для <xref:System.Net.HttpListener>, прослушиватель требует клиентов в следующем порядке: `Negotiate`, `NTLM`, `Digest`, а затем `Basic`.
  
   
  
## Examples
 В следующем примере кода показано использование <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед использованием этого экземпляра, возвращаемая этим конструктором, необходимо вызвать его <xref:System.Net.HttpListener.Start%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener> конструктор для создания нового <xref:System.Net.HttpListener> объекта. Полный пример см. в разделе <xref:System.Net.HttpListener> разделе, посвященном классу.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Этот класс не может использоваться в этой операционной системе. Для использования экземпляров этого класса требуется операционная система Windows Server 2003 или Windows XP с пакетом обновления 2.</exception>
        <block subset="none" type="usage">
          <para>Примечание: Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Незамедлительно завершает работу объекта <see cref="T:System.Net.HttpListener" />, отменяя все текущие запросы в очереди.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод освобождает все ресурсы, удерживаемые данным прослушивателем. Все отложенные запросы не удается выполнить.  
  
 После вызова этого метода, вы получите <xref:System.ObjectDisposedException> при попытке использовать этот <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает схему, используемую для аутентификации клиентов.</summary>
        <value>Битовая комбинация значений перечисления <see cref="T:System.Net.AuthenticationSchemes" />, которая указывает, как клиенты должны проходить аутентификацию. Значение по умолчанию — <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener> Использует указанную схему для проверки подлинности всех входящих запросов. <xref:System.Net.HttpListener.GetContext%2A> И <xref:System.Net.HttpListener.EndGetContext%2A> методы возвращают входящего клиентского запроса только в том случае, если <xref:System.Net.HttpListener> успешно проходит проверку подлинности запроса.  
  
 Можно запрашивать удостоверение успешно прошедшего проверку подлинности клиента с помощью <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> свойство.  
  
 Если вы хотите <xref:System.Net.HttpListener> объект для использования в различных механизмов проверки подлинности на основе характеристик запросов, он получает (например, в запросе <xref:System.Net.HttpListenerRequest.Url%2A> или <xref:System.Net.HttpListenerRequest.UserHostName%2A> свойства), необходимо реализовать метод, который выбирает Схема проверки подлинности. Инструкции о том, как это сделать в разделе <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> документации свойства.  
  
> [!NOTE]
>  Чтобы задать это свойство, чтобы включить хэш-кода, NTLM или Negotiate требует <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.AuthenticationSchemes%2A> свойство, чтобы указать схему проверки подлинности.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает делегат, вызываемый для определения протокола, который будет использоваться для аутентификации клиентов.</summary>
        <value>Делегат <see cref="T:System.Net.AuthenticationSchemeSelector" />, который вызывает метод, используемый для выбора протокола аутентификации. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если требуется, чтобы один и тот же протокол проверки подлинности, используемый для всех запросов, обрабатываемых определенным экземпляром <xref:System.Net.HttpListener>, необходимо задать это свойство. Чтобы указать протокол, используемый для всех запросов клиентов, используйте <xref:System.Net.HttpListener.AuthenticationSchemes%2A> свойство.  
  
 Если клиент не указал сведения для проверки подлинности в заголовке, <xref:System.Net.HttpListener> вызывает указанный делегат для каждого не прошедших проверку подлинности входящего запроса определить, какой протокол использовать для проверки подлинности клиента. <xref:System.Net.HttpListener.GetContext%2A> И <xref:System.Net.HttpListener.EndGetContext%2A> входящий запрос только тогда, когда они возвращают <xref:System.Net.HttpListener> успешно прошел проверку подлинности запроса. Если запрос не может пройти проверку подлинности, <xref:System.Net.HttpListener> автоматически отправляет обратно ответ 401. Можно получить удостоверение успешно прошедшего проверку подлинности клиента с помощью <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> свойство.  
  
 Возможность делегирования Выбор протокола проверки подлинности в приложении метод полезно использовать экземпляр <xref:System.Net.HttpListener> для использования различных протоколов проверки подлинности в зависимости от характеристик получит (для запросов Например, запрос <xref:System.Net.HttpListenerRequest.Url%2A> или <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> свойства).  
  
> [!NOTE]
>  Чтобы задать это свойство, чтобы включить хэш-кода, NTLM или Negotiate требует <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 В следующем примере кода задает значение этого свойства.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 В следующем примере кода предоставляет реализацию метод, вызываемый <xref:System.Net.AuthenticationSchemeSelector> делегата.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать при наличии клиентского запроса.</param>
        <param name="state">Пользовательский объект, содержащий сведения об операции. Этот объект передается делегату <c>callback</c> по завершении операции.</param>
        <summary>Начинает асинхронное получение входящего запроса.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, представляющий состояние асинхронной операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.BeginGetContext%2A> Метод начинает асинхронный вызов для получения входящих клиентских запросов (без блокировки). Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A> метода и добавьте по крайней мере один префикс универсальный код ресурса (URI) для прослушивания путем добавления строки URI для <xref:System.Net.HttpListenerPrefixCollection> возвращенных <xref:System.Net.HttpListener.Prefixes%2A> свойство.  
  
 Асинхронная операция необходимо завершить путем вызова <xref:System.Net.HttpListener.EndGetContext%2A> метод. Как правило, вызывается метод `callback` делегата.  
  
 Этот метод блокируется до завершения операции. Чтобы получить входящего запроса и блок до завершения операции, вызовите <xref:System.Net.HttpListener.GetContext%2A> метод.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.BeginGetContext%2A> метод, чтобы указать метод обратного вызова, который будет обрабатывать входящие клиентские запросы.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 В следующем примере кода реализуется метод обратного вызова.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Вызов функции Win32 завершился с ошибкой. Проверьте свойство исключения <see cref="P:System.Net.HttpListenerException.ErrorCode" />, чтобы определить причину исключения.</exception>
        <exception cref="T:System.InvalidOperationException">Этот объект не был запущен или в настоящее время остановлен.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage">
          <para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает работу <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова этого метода, больше не может использовать <xref:System.Net.HttpListener> объекта. Чтобы временно приостановить <xref:System.Net.HttpListener> , используйте <xref:System.Net.HttpListener.Stop%2A> метод.  
  
 Этот метод завершает пребывания <xref:System.Net.HttpListener> объекта без обработки запросов в очереди. Все отложенные запросы не удается выполнить.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает список имен поставщиков услуг (SPN) по умолчанию в соответствии с зарегистрированными префиксами.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" />, содержащий список SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Свойство используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Список имен участников-служб, инициализированный из <xref:System.Net.HttpListener.Prefixes%2A> свойства, если доступ к и очищается, когда добавляются новые префиксы <xref:System.Net.HttpListener.Prefixes%2A> свойство.  
  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Свойство используется в том случае, если приложение не устанавливает <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> свойства на его расширенную политику защиты.  
  
 <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> , Полученные с помощью <xref:System.Net.HttpListener.DefaultServiceNames%2A> свойство строится на основе <xref:System.Net.HttpListener.Prefixes%2A> свойство согласно следующим правилам:  
  
1.  Если имя узла «+», «*», или литералом IPv4 или IPv6 (эквивалентно "\*" но ограничивается в определенном локальном интерфейсе), добавляются следующие SPN:  
  
 `"HTTP/"` а также полное доменное имя компьютера.  
  
1.  Если имя узла содержит не точки (не домены или поддомены), будет предпринята попытка разрешить полное доменное имя, с помощью DNS (то же поведение, используемые <xref:System.Net.HttpWebRequest>). Если полное доменное имя может быть разрешено, добавляются следующие SPN:  
  
 `"HTTP/"` а также имя узла (короткое имя).  
  
 `"HTTP/"` а также полное доменное имя для имени узла.  
  
1.  Если имя узла содержит не точки (не домены или поддомены) и полное доменное имя не может быть разрешено, добавляется следующий SPN:  
  
 `"HTTP/"` а также имя узла.  
  
1.  Если имя узла содержит точки (домены или поддомены), добавляется следующий SPN:  
  
 `"HTTP/"` а также имя узла.  
  
 <xref:System.Net.HttpListener.DefaultServiceNames%2A> Свойство может использоваться приложением для просмотра списка SPN по умолчанию, которые будут использоваться для проверки подлинности, если пользовательский список не предоставляется. Если требуются другие имена участников-служб, приложение можно добавить с помощью одного из <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> методы.  
  
 Не является безопасным при использовании расширенной защиты для принятия решений согласно политике, основанных на запрошенный URL-адрес, поскольку это могут быть перехвачены. Вместо этого приложения следует полагаться на <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> или <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> свойства для принятия таких решений согласно политике.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, который был получен при запуске асинхронной операции.</param>
        <summary>Завершает асинхронную операцию получения входящего клиентского запроса.</summary>
        <returns>Объект <see cref="T:System.Net.HttpListenerContext" />, представляющий клиентский запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.EndGetContext%2A> Вызывается метод, обычно в методе обратного вызова, определяемые приложением, ни делегатом, чтобы получить <xref:System.Net.HttpListenerContext> , содержащий входящего клиентского запроса и его связанного ответа. Этот метод завершает операцию, запущенную ранее вызовом <xref:System.Net.HttpListener.BeginGetContext%2A> метод. Если операция не завершена, этот метод блокируется до завершения удаления.  
  
 Поскольку вызов <xref:System.Net.HttpListener.EndGetContext%2A> метод требует <xref:System.Net.HttpListener> объекта, этот объект обычно передается в метод обратного вызова, используя объект состояния, переданные в <xref:System.Net.HttpListener.BeginGetContext%2A> метод. Этот объект состояния можно получить с помощью <xref:System.IAsyncResult.AsyncState%2A> свойство `asyncResult` объекта.  
  
 Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 В следующем примере кода показана реализация метода обратного вызова, который вызывает <xref:System.Net.HttpListener.EndGetContext%2A> метод.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Значение параметра <paramref name="asyncResult" /> не получено вызовом метода <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> уже был вызван для указанного объекта <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage">
          <para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который используется для расширенной защиты сеанса.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который задает политику для расширенной защиты.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Свойство используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Свойство позволяет настраивать расширенную политику защиты для всего <xref:System.Net.HttpListener> сеанса. <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Свойство позволяет настраивать расширенную политику защиты для каждого отдельного запроса.  
  
 Свойство <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> должно иметь значение `null`. <xref:System.Net.HttpListener> Экземпляр получает маркера привязки канала (CBT) непосредственно из сеанса TLS, если таковой имеется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />, но свойство <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> не имело значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Предпринята попытка задать свойству <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> после вызова метода <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Свойству <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> было присвоено значение <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> на платформе, не поддерживающей расширенную защиту.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает делегат, вызываемый для определения объекта <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который следует использовать для каждого запроса.</summary>
        <value>Объект <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />, который задает политику для расширенной защиты.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Свойство используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Свойство позволяет настраивать расширенную политику защиты для всего <xref:System.Net.HttpListener> сеанса. <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> Свойство позволяет настраивать расширенную политику защиты каждого отдельного запроса.  
  
 Свойство <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> должно иметь значение `null`. <xref:System.Net.HttpListener> Экземпляр получает маркера привязки канала (CBT) непосредственно из сеанса TLS, если таковой имеется.  
  
 Для каждого запроса делегат может выбрать параметры, <xref:System.Net.HttpListener> экземпляр будет использовать для обеспечения расширенной защиты.  
  
 Если делегат возвращает `null` для этого свойства представляет <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> которой <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> свойство <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />, но свойство <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> должно иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Предпринята попытка задать свойству <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка установить свойство <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> после вызова метода <see cref="M:System.Net.HttpListener.Start" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Предпринята попытка задать свойство  <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> на платформе, не поддерживающей расширенную защиту.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ожидает входящий запрос и выполняет возврат при его получении.</summary>
        <returns>Объект <see cref="T:System.Net.HttpListenerContext" />, представляющий клиентский запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A> метода и добавьте по крайней мере один префикс URI для прослушивания путем добавления строки URI для <xref:System.Net.HttpListenerPrefixCollection> возвращенных <xref:System.Net.HttpListener.Prefixes%2A> свойство. Подробное описание префиксов см. в разделе <xref:System.Net.HttpListener> Общие сведения о классе.  
  
 Этот метод блокируется во время ожидания для входящего запроса. Входящие запросы обрабатываются асинхронно (отдельных потоков), чтобы приложение не блокирует используйте <xref:System.Net.HttpListener.BeginGetContext%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов этого метода.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Вызов функции Win32 завершился с ошибкой. Проверьте свойство исключения <see cref="P:System.Net.HttpListenerException.ErrorCode" />, чтобы определить причину исключения.</exception>
        <exception cref="T:System.InvalidOperationException">Этот объект не был запущен или в настоящее время остановлен.  
  
 - или -  
  
 Прослушиватель <see cref="T:System.Net.HttpListener" /> не имеет префиксов URI для ответа.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage">
          <para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ожидает входящий запрос как асинхронную операцию.</summary>
        <returns>Возвращает <see cref="T:System.Threading.Tasks.Task`1" />.  
  
 Объект задачи, представляющий асинхронную операцию. Свойство <see cref="P:System.Threading.Tasks.Task`1.Result" /> объекта задачи возвращает объект <see cref="T:System.Net.HttpListenerContext" />, представляющий запрос клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокирована. Возвращенный <xref:System.Threading.Tasks.Task%601> объекта будет выполнена при получении входящего запроса.  
  
 Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A> метода и добавьте по крайней мере один префикс URI для прослушивания путем добавления строки URI для <xref:System.Net.HttpListenerPrefixCollection> возвращенных <xref:System.Net.HttpListener.Prefixes%2A> свойство. Подробное описание префиксов см. в разделе <xref:System.Net.HttpListener> Общие сведения о классе.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, которое определяет, получает ли приложение исключения, которые возникают при отправке прослушивателем <see cref="T:System.Net.HttpListener" /> ответа клиенту.</summary>
        <value>
          Значение <see langword="true" />, если этот прослушиватель <see cref="T:System.Net.HttpListener" /> не должен возвращать исключения, возникающие при отправке ответа клиенту; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true` Если приложение не требует успешной отправки ответа каждому клиенту.  
  
   
  
## Examples  
 В следующем примере кода показано задание этого свойства.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, был ли запущен прослушиватель <see cref="T:System.Net.HttpListener" />.</summary>
        <value>
          Значение <see langword="true" />, если прослушиватель <see cref="T:System.Net.HttpListener" /> был запущен; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы запустить <xref:System.Net.HttpListener>, вызовите <xref:System.Net.HttpListener.Start%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого свойства для определения состояние прослушивания экземпляра.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, можно ли использовать прослушиватель <see cref="T:System.Net.HttpListener" /> в текущей операционной системе.</summary>
        <value>
          Значение <see langword="true" />, если <see cref="T:System.Net.HttpListener" /> поддерживается; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс доступен только на компьютерах, работающих под управлением ОС Windows XP SP2 или Windows Server 2003.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.IsSupported%2A> свойство для обнаружения ли <xref:System.Net.HttpListener> объект может использоваться с текущей операционной системой.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает префиксы URI, обрабатываемые этим объектом <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Коллекция <see cref="T:System.Net.HttpListenerPrefixCollection" />, содержащая префиксы URI, которые может обрабатывать этот объект <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Префиксы указаны в канонической форме. Подробное описание префиксов см. в разделе <xref:System.Net.HttpListener> Общие сведения о классе.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.Prefixes%2A> свойство для получения и печати префиксы URI-адресов, которые обрабатываются.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает область или раздел ресурса, связанные с этим объектом <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Значение <see cref="T:System.String" />, которое содержит имя области, связанной с этим объектом <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Серверы используют области для разделения защищенных ресурсов; Каждая секция может иметь свою собственную схему и базу данных проверки подлинности. Области используются только для обычной проверки подлинности и дайджест-проверки подлинности. После успешного прохождения клиентом проверки подлинности ее результаты действительны для всех ресурсов в данной области. Подробное описание областей см в документе RFC 2617 по [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Экземпляр <xref:System.Net.HttpListener> имеет только один связанный сферы.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется настройка <xref:System.Net.HttpListener.Realm%2A> свойство.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет этому экземпляру получать входящие запросы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться перед вызовом метода <xref:System.Net.HttpListener.GetContext%2A> или <xref:System.Net.HttpListener.BeginGetContext%2A> метод.  
  
 После запуска <xref:System.Net.HttpListener> объекта, можно использовать <xref:System.Net.HttpListener.Stop%2A> метод для ее остановки.  
  
> [!NOTE]
>  Если этот экземпляр прослушивателя использует https, необходимо установить и выбрать сертификат сервера. В противном случае <xref:System.Net.HttpWebRequest> запрос этого <xref:System.Net.HttpListener> , будут завершаться неожиданный запрос закрытия соединения. Сертификаты сервера и другие параметры прослушивателя можно настроить с помощью HttpCfg.exe. В разделе [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) для получения дополнительных сведений.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.Start%2A> метод для обработки входящих запросов.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Вызов функции Win32 завершился с ошибкой. Проверьте свойство исключения <see cref="P:System.Net.HttpListenerException.ErrorCode" />, чтобы определить причину исключения.</exception>
        <exception cref="T:System.ObjectDisposedException">Данный объект закрыт.</exception>
        <block subset="none" type="usage">
          <para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заставляет этот экземпляр прекратить получать входящие запросы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот экземпляр уже был остановлен, вызов этого метода не оказывает влияния.  
  
 После завершения <xref:System.Net.HttpListener> объекта, можно использовать <xref:System.Net.HttpListener.Start%2A> метод, чтобы перезагрузить компьютер.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Net.HttpListener.Stop%2A> метода для остановки обработки входящих запросов.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
        <block subset="none" type="usage">
          <para>Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, удерживаемые этим объектом <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения должны использовать <xref:System.Net.HttpListener.Close%2A> метод вместо вызова данного метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Диспетчер времени ожидания для этого экземпляра <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Возвращает <see cref="T:System.Net.HttpListenerTimeoutManager" />.  
  
 Диспетчер времени ожидания для этого экземпляра <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Диспетчер времени ожидания определяет ограничения на время ожидания подключения для этого <xref:System.Net.HttpListener> экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, которое определяет, должны ли дополнительные запросы, использующие то же TCP-подключение, проходить аутентификацию при использовании протокола NTLM.</summary>
        <value>
          Значение <see langword="true" />, если сведения об идентификации <see cref="T:System.Security.Principal.IIdentity" /> первого запроса будут использоваться для последующих запросов на том же подключении, в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства `true` и первый запрос по определенному TCP-подключению проходит проверку подлинности с помощью NTLM, последующие запросы через TCP-подключению обрабатываются с использованием проверки подлинности (<xref:System.Security.Principal.IIdentity>) начального запрос.  
  
 Это свойство не имеет значения, если NTLM не является протоколом проверки подлинности. Если указано как протокол проверки подлинности Negotiate, это свойство действует только если для проверки подлинности используется протокол NTLM.  
  
> [!NOTE]
>  При задании этого свойства `true` повышает производительность, поскольку <xref:System.Net.HttpListener> не отправлять дополнительные проверки подлинности NTLM, существует риск для безопасности в запросы, чтобы предоставить сведения для проверки подлинности. Необходимо определить, стоит ли снижать безопасность с целью увеличения производительности.  
  
   
  
## Examples  
 В следующем примере кода показано задание этого свойства.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект закрыт.</exception>
      </Docs>
    </Member>
  </Members>
</Type>