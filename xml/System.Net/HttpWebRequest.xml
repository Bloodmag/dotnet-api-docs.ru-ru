<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c2f9e1a7e4cfd2a9d2a6e45c1c11a90a1be3baad" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34255262" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет связанную с HTTP реализацию класса <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Класс обеспечивает поддержку свойства и методы, определенные в <xref:System.Net.WebRequest> и дополнительных свойств и методов, которые позволяют пользователю взаимодействовать непосредственно с серверами, с помощью протокола HTTP.  
  
 Не используйте <xref:System.Net.HttpWebRequest.%23ctor%2A> конструктор. Используйте <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> метод для инициализации новых <xref:System.Net.HttpWebRequest> объектов. Если схема для универсальный код ресурса (URI) — `http://` или `https://`, <xref:System.Net.WebRequest.Create%2A> возвращает <xref:System.Net.HttpWebRequest> объекта.  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Метод выполняет синхронный запрос к ресурсу, указанному в <xref:System.Net.HttpWebRequest.RequestUri%2A> свойством и возвращает <xref:System.Net.HttpWebResponse> , содержащий объект ответа. Данные ответа могут быть получены с помощью поток, возвращенный <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Если объект ответа или в поток ответа закрыт оставшихся данных будут обнулены. Остальные данные будут утеряны, и будет использовать повторно для последующих запросов сокета при закрытии объекта ответа или потока при следующих условиях: активности или конвейерная передача запроса, небольшой объем данных должен быть получен, или Осталось данных принимается в небольшой задержкой. Если ни одно из условий упомянутых хранения или по истечении срока стока, сокет закрывается. Для поддержания активности или Конвейерные подключения настоятельно рекомендуется, чтобы приложение считывает потоки до конца файла. Это гарантирует, что сокет будет использовать повторно для последующих запросов, что приводит к повышению производительности и меньше ресурсов, используемых.  
  
 Если вы хотите отправлять данные в ресурс <xref:System.Net.HttpWebRequest.GetRequestStream%2A> возвращает <xref:System.IO.Stream> объект, используемый для отправки данных. <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> И <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> методы предоставляют асинхронный доступ к потоку данных отправки.  
  
 Для проверки подлинности клиента с <xref:System.Net.HttpWebRequest>, сертификат клиента должен быть установлен в хранилище сертификатов текущего пользователя.  
  
 <xref:System.Net.HttpWebRequest> Класса вызывает <xref:System.Net.WebException> при возникновении ошибок во время доступа к ресурсу. <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> Свойство содержит <xref:System.Net.WebExceptionStatus> значение, указывающее источник ошибки. Когда <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> — <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> свойство содержит <xref:System.Net.HttpWebResponse> получено из ресурса.  
  
 <xref:System.Net.HttpWebRequest> Предоставляет общие значения для заголовка HTTP посылаемые Интернет-ресурс в виде свойств, устанавливаемых методами или системой; Следующая таблица содержит полный список. Другие заголовки можно задавать <xref:System.Net.HttpWebRequest.Headers%2A> свойства в виде пар «имя значение». Обратите внимание, что серверы и кэш могут изменять и добавлять заголовки во время запроса.  
  
 В следующей таблице перечислены заголовки HTTP, которые задаются либо свойства или методы или системой.  
  
|Header|Задается|  
|------------|------------|  
|Принять|Задается <xref:System.Net.HttpWebRequest.Accept%2A> свойство.|  
|Подключение|Задается <xref:System.Net.HttpWebRequest.Connection%2A> свойства <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство.|  
|Content-Length|Задается <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство.|  
|Тип содержимого|Задается <xref:System.Net.HttpWebRequest.ContentType%2A> свойство.|  
|Ожидается, что|Задается <xref:System.Net.HttpWebRequest.Expect%2A> свойство.|  
|Дата|Задается равным текущей дате.|  
|Ведущее приложение|Задайте равным сведения о текущем узле.|  
|If-Modified-Since|Задается <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство.|  
|Диапазон|Задается <xref:System.Net.HttpWebRequest.AddRange%2A> метод.|  
|Referer|Задается <xref:System.Net.HttpWebRequest.Referer%2A> свойство.|  
|Transfer-Encoding|Задается <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойство ( <xref:System.Net.HttpWebRequest.SendChunked%2A> свойство должно быть `true`).|  
|Агент пользователя|Задается <xref:System.Net.HttpWebRequest.UserAgent%2A> свойство.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> регистрируется автоматически. Необходимо вызвать <xref:System.Net.WebRequest.RegisterPrefix%2A> метода для регистрации <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> перед использованием URIs начиная с версии `http://` или `https://`.  
  
 Локальный компьютер или файл конфигурации приложения могут использовать прокси-сервер по умолчанию. Если <xref:System.Net.HttpWebRequest.Proxy%2A> свойство указано, выберите параметры прокси-сервера из <xref:System.Net.HttpWebRequest.Proxy%2A> переопределения свойств локального компьютера или файл конфигурации приложения и <xref:System.Net.HttpWebRequest> экземпляр будет использовать параметры прокси-сервера. Если в файле конфигурации указан без прокси-сервера и <xref:System.Net.HttpWebRequest.Proxy%2A> не указан, свойство <xref:System.Net.HttpWebRequest> класс использует параметры прокси-сервера, который наследуется от Internet Explorer на локальном компьютере. Если отсутствуют параметры прокси-сервера в Internet Explorer, запрос отправляется непосредственно на сервер.  
  
 <xref:System.Net.HttpWebRequest> Класс анализирует список обхода прокси-сервера с использованием подстановочных знаков, наследуются из Internet Explorer по-разному, чем список пропускаемых анализируется непосредственно с Internet Explorer. Например <xref:System.Net.HttpWebRequest> класса будет выполнять синтаксический анализ список обхода «nt *» из Internet Explorer регулярное выражение «nt. $». Это отличается от поведения собственного обозревателя Internet Explorer. Поэтому URL-адрес "`http://intxxxxx`» будут обходить прокси-сервер с помощью <xref:System.Net.HttpWebRequest> класса, но не будет обходить прокси-сервер, с помощью Internet Explorer.  
  
> [!NOTE]
>  Платформа кэширует сеансы SSL при их создании и пытается повторно использовать кэшированный сеанс для нового запроса, если это возможно. При попытке повторно использовать сеанс SSL, платформа использует первый элемент <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (если есть), или не попытается повторно использовать анонимные сеансы, если <xref:System.Net.HttpWebRequest.ClientCertificates%2A> является пустым.  
  
> [!NOTE]
>  По умолчанию файлы cookie отключены по соображениям безопасности. Если вы хотите использовать файлы cookie, используйте <xref:System.Net.HttpWebRequest.CookieContainer%2A> свойство, чтобы включить файлы cookie.  
  
 .NET Framework 4.6 включает средство безопасности, блокирует небезопасных шифрования и хэширования алгоритмы для подключений. Приложения с помощью TLS/SSL через API-интерфейсы, такие как HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream, т. д. и предназначенных для .NET Framework 4.6 получить более надежные и безопасные поведение по умолчанию.  
  
 Разработчики имеют возможность отказаться от этого поведения для обеспечения взаимодействия с имеющиеся SSL3 услуги или TLS с служб RC4. [В этой статье](https://support.microsoft.com/kb/3069494) объясняется, как изменить код таким образом, чтобы отключить новое поведение.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.HttpWebRequest> для URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Для доступа к запрашиваемому URL-АДРЕСУ или любой URI, на который перенаправляется запрос. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpWebRequest" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpWebRequest" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который содержит сведения, требуемые для сериализации нового объекта <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с новым объектом <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpWebRequest" /> на основе указанных экземпляров классов <see cref="T:System.Runtime.Serialization.SerializationInfo" /> и <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании сериализации приложение должно работать в режиме полного доверия.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Для неограниченного доступа к сетевым ресурсам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет запрос к интернет-ресурсу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A> Метод отменяет запрос к ресурсу. После запроса отмены, вызвав <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, или <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> метода заставляет <xref:System.Net.WebException> с <xref:System.Net.WebException.Status%2A> свойство <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 <xref:System.Net.HttpWebRequest.Abort%2A> Метод выполняется синхронно обратный вызов, указанный для <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> методы Если <xref:System.Net.HttpWebRequest.Abort%2A> метод вызывается во время этих операций необработанных. Это может привести к потенциальной проблемы взаимоблокировки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 В случае асинхронных запросов возлагается клиентского приложения, чтобы реализовать собственный механизм времени ожидания. В следующем примере кода показано, как это сделать.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Accept" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Accept" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы очистить `Accept` задать заголовок HTTP <xref:System.Net.HttpWebRequest.Accept%2A> свойства `null`.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Accept%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет в запрос заголовок диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет запрос заголовок диапазона байтов.  
  
 Если `range` положительное, `range` параметр указывает начальную точку диапазона. Серверу следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Серверу следует начать отправку данных с начала данных сущности HTTP для `range` указан параметр.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка Range в запросе протокола HTTP, который запрашивает у сервера отправку первые 100 байт (от начала до позиции байта 99) будет следующим:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `range` -99 нужно указать параметр.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовком Accept диапазонов. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
   
  
## Examples  
 В следующем примере кода добавляет заголовок диапазона для запроса.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет запрос заголовок диапазона байтов.  
  
 Если `range` положительное, `range` параметр указывает начальную точку диапазона. Серверу следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Серверу следует начать отправку данных с начала данных сущности HTTP для `range` указан параметр.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка Range в запросе протокола HTTP, который запрашивает у сервера отправку первые 100 байт (от начала до позиции байта 99) будет следующим:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `range` -99 нужно указать параметр.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовком Accept диапазонов. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет запрос заголовок диапазона байтов.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка Range в запросе протокола HTTP, что было бы запросы первые 100 байт будет следующая:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `from` указывается как 0 и `to` параметр должен быть указан как 99. Спецификатор диапазона автоматически устанавливается как «байты» с помощью данного метода.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовком Accept диапазонов. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
   
  
## Examples  
 В следующем примере кода добавляет заголовок диапазона для запроса.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> больше <paramref name="to" /> -или- <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет запрос заголовок диапазона байтов.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка Range в запросе протокола HTTP, что было бы запросы первые 100 байт будет следующая:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `from` указывается как 0 и `to` параметр должен быть указан как 99. Спецификатор диапазона автоматически устанавливается как «байты» с помощью данного метода.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовком Accept диапазонов. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> больше <paramref name="to" /> -или- <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок Range для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Если `range` положительное, `range` параметр указывает начальную точку диапазона. Серверу следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Серверу следует начать отправку данных с начала данных сущности HTTP для `range` указан параметр.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметра обычно может быть задан как «байт», поскольку это единственный описатель диапазона, распознаваемый большинством серверов HTTP. Параметр `rangeSpecifier` параметр либо другой строки разрешает поддержку описателей пользовательских диапазонов, отличных от байтов (описатель диапазона байтов, определяется в RFC 2616 IETF).  
  
 Пример заголовка Range в запросе протокола HTTP, что было бы запросы первые 100 байт будет следующая:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` будет задан параметр «байты» и `range` -99 нужно указать параметр.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовок Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок Range для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Если `range` положительное, `range` параметр указывает начальную точку диапазона. Серверу следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Серверу следует начать отправку данных с начала данных сущности HTTP для `range` указан параметр.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметра обычно может быть задан как «байт», поскольку это единственный описатель диапазона, распознаваемый большинством серверов HTTP. Параметр `rangeSpecifier` параметр либо другой строки разрешает поддержку описателей пользовательских диапазонов, отличных от байтов (описатель диапазона байтов, определяется в RFC 2616 IETF).  
  
 Пример заголовка Range в запросе протокола HTTP, что было бы запросы первые 100 байт будет следующая:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` будет задан параметр «байты» и `range` -99 нужно указать параметр.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовок Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметра обычно может быть задан как «байт», поскольку это единственный описатель диапазона, распознаваемый большинством серверов HTTP. Параметр `rangeSpecifier` параметр либо другой строки разрешает поддержку описателей пользовательских диапазонов, отличных от байтов (описатель диапазона байтов, определяется в RFC 2616 IETF).  
  
 Пример заголовка Range в запросе протокола HTTP, что было бы запросы первые 100 байт будет следующая:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` будет задан параметр «байты», `from` параметра будет равно 0 и `to` 99 нужно указать параметр.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовок Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Строка, указанная в заголовке Accept-Ranges является спецификатор диапазона, по указывается в `rangeSpecifier` для этого метода.  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> больше <paramref name="to" /> -или- <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Поскольку все сущности HTTP представляются в HTTP-сообщений в виде последовательности байтов, понятие диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок Range в запросе позволяет клиенту запрашивать, что его нужно получить только часть указанному диапазону байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметра обычно может быть задан как «байт», поскольку это единственный описатель диапазона, распознаваемый большинством серверов HTTP. Параметр `rangeSpecifier` параметр либо другой строки разрешает поддержку описателей пользовательских диапазонов, отличных от байтов (описатель диапазона байтов, определяется в RFC 2616 IETF).  
  
 Пример заголовка Range в запросе протокола HTTP, что было бы запросы первые 100 байт будет следующая:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` будет задан параметр «байты», `from` параметра будет равно 0 и `to` 99 нужно указать параметр.  
  
 HTTP-сервера указывает на поддержку заголовки диапазона с заголовок Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Строка, указанная в заголовке Accept-Ranges является спецификатор диапазона, по указывается в `rangeSpecifier` для этого метода.  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки Range. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, однако распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанные с запросом всей анализируются и становятся доступными посредством свойства <xref:System.Net.HttpWebResponse> класса. В ответе возвращаются заголовки, связанные с каждым диапазоном.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="rangeSpecifier" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> больше <paramref name="to" /> -или- <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает код URI интернет-ресурса, который фактически отвечает на запрос.</summary>
        <value>Класс <see cref="T:System.Uri" />, идентифицирующий интернет-ресурс, который отвечает на запрос. По умолчанию это URI, используемый методом <see cref="M:System.Net.WebRequest.Create(System.String)" /> для инициализации запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A> Свойству URI после выполнения любых перенаправлений, которые происходят во время запроса.  
  
 URI исходного запроса сохраняется в <xref:System.Net.HttpWebRequest.RequestUri%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода в примере выполняется проверка на наличие <xref:System.Net.HttpWebRequest> объекта `req` был перенаправлен в другое место для выполнения запроса и задает значение `hasChanged` переменной `true` Если запрос был перенаправлен; в противном случае `hasChanged`равно `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, должен ли запрос следовать ответам переадресации.</summary>
        <value>Значение <see langword="true" />, если запрос должен автоматически следовать ответам переадресации, получаемым от интернет-ресурса; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задать <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> для `true` Если запросом, автоматически заголовков HTTP перенаправление в новое расположение ресурса. Максимальное число выполняемых перенаправления задается <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> свойство.  
  
 Если <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> равно `false`, все ответы с кодом состояния HTTP от 300 до 399 возвращается приложению.  
  
 Заголовок авторизации очищается при автоматическом перенаправление и <xref:System.Net.HttpWebRequest> автоматически пытается повторно пройти проверку подлинности в перенаправленном расположении. На практике это означает, что приложение невозможно перевести сведения нестандартной проверки подлинности в заголовок Authorization, если существует возможность столкнуться с перенаправлением. Вместо этого приложения необходимо реализовать и зарегистрировать пользовательский модуль проверки подлинности. <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> И связанного класса используются для реализации пользовательского модуля проверки подлинности. <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> Метод регистрирует пользовательский модуль проверки подлинности.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> свойство, чтобы разрешить запрос следовать ответам переадресации.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будет ли выполняться буферизация данных, полученных от интернет-ресурса.</summary>
        <value>Значение <see langword="true" /> устанавливается для включения буферизации данных, получаемых от интернет-ресурса; значение <see langword="false" /> — для выключения буферизации. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будет ли выполняться буферизация данных, отправляемых в интернет-ресурс.</summary>
        <value>Значение <see langword="true" /> устанавливается для включения буферизации данных, посылаемых в интернет-ресурс; значение <see langword="false" /> — для выключения буферизации. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> — `true`, обеспечения готовности повторно в случае перенаправления или проверки подлинности запросов в буфере данных.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> свойство для отключения буферизации данных.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Установка <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> для <see langword="true" /> может привести к снижению производительности при загрузке больших наборов данных, поскольку буфер данных может использовать всю доступную память.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип используемой распаковки.</summary>
        <value>Объект <see cref="T:System.Net.DecompressionMethods" /> объект, указывающий тип используемой распаковки.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Текущее состояние объекта не позволяет задать это свойство.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект состояния для данного запроса.</param>
        <summary>Начинает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
        <returns>Класс <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Метод начинает выполнение асинхронного запроса для потока, используемого для отправки данных <xref:System.Net.HttpWebRequest>. Метод асинхронного обратного вызова использует <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> метод для возврата существующего потока.  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Метода требуется выполнение некоторых задач синхронной установки завершения этот метод становится асинхронной (разрешение DNS, обнаружения прокси-сервера и подключения сокета TCP, например). В результате этот метод вызывать не следует в потоке пользовательского интерфейса (UI), так как он может занять значительное время (до нескольких минут в зависимости от параметров сети) для завершения задачи начальной настройки синхронной до исключения для возникает ошибка или метод выполнен успешно.  
  
 Дополнительные сведения о пуле потоков см. в разделе [пул управляемых потоков](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод для выполнения асинхронного запроса экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Значение свойства <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD.  -или- <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Поток используется предыдущим вызовом в <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> -или- Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> установлено значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.  -или- В пуле потоков заканчиваются потоки.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако запросы, которые записывают данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского средства проверки кэша, которое неправильно реализовано.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.</exception>
        <exception cref="T:System.ObjectDisposedException">В приложении .NET Compact Framework поток запроса с нулевой длиной содержимого не был правильно получен и закрыт. Дополнительные сведения об обработке запросов с нулевой длиной содержимого см. в разделе [Сетевое программирование в .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" /></param>
        <param name="state">Объект состояния для данного запроса.</param>
        <summary>Начинает асинхронный запрос интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос ответа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Метод начинает выполнение асинхронного запроса для ответ от Интернет-ресурса. Метод асинхронного обратного вызова использует <xref:System.Net.HttpWebRequest.EndGetResponse%2A> метод для возврата существующего <xref:System.Net.WebResponse>.  
  
 Объект <xref:System.Net.ProtocolViolationException> создается исключение в некоторых случаях, если для свойства не задано <xref:System.Net.HttpWebRequest> класса, конфликтуют. Это исключение возникает, если приложение задает <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство и <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true`, а затем отправляет запрос HTTP GET. Это исключение возникает, если приложение пытается отправить фрагментированный на сервере, который поддерживает только протокол HTTP 1.0, где это не поддерживается. Это исключение возникает, если приложение пытается отправить данные без параметра <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство или <xref:System.Net.HttpWebRequest.SendChunked%2A> — `false` при отключенной буферизации и для проверки активности подключения ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`)`.`  
  
 Если <xref:System.Net.WebException> — исключение, используйте <xref:System.Net.WebException.Response%2A> и <xref:System.Net.WebException.Status%2A> свойства исключения для определения ответа от сервера.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Метода требуется выполнение некоторых задач синхронной установки завершения этот метод становится асинхронной (разрешение DNS, обнаружения прокси-сервера и подключения сокета TCP, например). В результате этот метод вызывать не следует в потоке пользовательского интерфейса (UI), так как он может занять значительное время (до нескольких минут в зависимости от параметров сети) для завершения задачи начальной настройки синхронной до исключения для возникает ошибка или метод выполнен успешно.  
  
 Дополнительные сведения о пуле потоков см. в разделе [ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод для приготовления асинхронный запрос Интернет-ресурса.  
  
> [!NOTE]
>  В случае асинхронных запросов возлагается клиентского приложения, чтобы реализовать собственный механизм времени ожидания. В следующем примере кода показано, как это сделать.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток уже используется предыдущим вызовом в <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> -или- Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> установлено значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.  -или- В пуле потоков заканчиваются потоки.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Значение <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD, кроме того или <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, или <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="true" />.  -или- <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, и какое-либо одно из значений <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.  -или- Запрос <see cref="T:System.Net.HttpWebRequest" /> имеет тело сущности, но метод <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> вызывается без вызова метода <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  -или- Значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, но приложение не записывает все обещанные данные.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает коллекцию сертификатов безопасности, связанных с данным запросом.</summary>
        <value>Коллекция <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />, содержащая сертификаты безопасности, связанные этим с запросом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение можно добавить сертификат в коллекцию, но могут отсутствовать права доступа к нему. Чтобы использовать сертификат, содержащийся в коллекции, приложение должно иметь те же права доступа, как сущность, выдавшего сертификат.  
  
> [!NOTE]
>  Платформа кэширует сеансы SSL при их создании и пытается повторно использовать кэшированный сеанс для нового запроса, если это возможно. При попытке повторно использовать сеанс SSL, платформа использует первый элемент <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (если есть), или не попытается повторно использовать анонимные сеансы, если <xref:System.Net.HttpWebRequest.ClientCertificates%2A> является пустым.  
  
> [!NOTE]
>  По соображениям производительности не следует добавлять клиентский сертификат для <xref:System.Net.HttpWebRequest> Если вы не знаете сервер запросит его.  
>   
>  Пример кода, иллюстрирующий перечисление сертификатов в хранилище сертификатов клиента, в разделе <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Для операции задания указано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Connection" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Connection" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отправляет запрос <xref:System.Net.HttpWebRequest.Connection%2A> свойство Интернет-ресурс как `Connection` заголовка HTTP. Если значение <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`, значение «Keep-alive» добавляется в конец `Connection` заголовок.  
  
 Чтобы очистить `Connection` задать заголовок HTTP <xref:System.Net.HttpWebRequest.Connection%2A> свойства `null`.  
  
 Изменение <xref:System.Net.HttpWebRequest.Connection%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.Connection%2A> свойство, чтобы задать значение заголовка HTTP-соединение.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение заголовка <see cref="P:System.Net.HttpWebRequest.Connection" /> устанавливается равным Keep-alive или Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя группы подключения для запроса.</summary>
        <value>Имя группы подключения для данного запроса. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> Позволяет связывать запрос с группой подключения. Это полезно в том случае, когда приложение выполняет запросы к одному серверу для разных пользователей, например веб-сайт, который возвращает данные клиента с сервера базы данных.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пользовательские данные для создания группы подключения, при условии, что переменные `username`, `password`, и `domain` устанавливаются приложением до вызова этого кода.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Каждая группа подключения создает дополнительные соединения для сервера. Это может привести к превышению количество соединений, заданные <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> свойства для этого сервера.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает HTTP-заголовок <see langword="Content-length" />.</summary>
        <value>Количество байтов данных, отправляемых в интернет-ресурс. Значение по умолчанию, равное –1, показывает, что свойство не установлено и отсутствуют данные запроса, предназначенные для отправки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A> Свойство содержит значение для отправки в виде `Content-length` заголовка HTTP с запросом.  
  
 Значение, отличное от -1 в <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство указывает, что запрос отправляет данные, и что только методы, которые передают данные могут задаваться в <xref:System.Net.HttpWebRequest.Method%2A> свойство.  
  
 После <xref:System.Net.HttpWebRequest.ContentLength%2A> свойству присвоено значение, это количество байтов должно записываться в поток запроса, который возвращается путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода или обоих <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> и <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> методы.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство длине строки.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новое значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Content-type" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Content-type" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A> Свойство содержит тип мультимедиа запроса. Значения, присвоенные <xref:System.Net.HttpWebRequest.ContentType%2A> свойство заменяют любое имеющееся содержимое при отправке запроса `Content-type` заголовка HTTP.  
  
 Чтобы очистить `Content-type` задать заголовок HTTP <xref:System.Net.HttpWebRequest.ContentType%2A> свойства `null`.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection> . Если <xref:System.Net.WebHeaderCollection> не установлен, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.ContentType%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод делегата, вызываемый при получении от интернет-ресурса HTTP-ответа 100-continue.</summary>
        <value>Делегат, реализующий метод обратного вызова, который выполняется при возвращении от интернет-ресурса ответа HTTP Continue. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Свойство задает метод обратного вызова вызывается, когда клиент получает 100-продолжением ответа.  
  
 Когда <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> имеет значение, клиент вызывает делегат каждый раз, когда протокола ответа типа <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) принимаются. Это полезно, если требуется, чтобы клиент выведены данные, полученные от Интернет-ресурса.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает время ожидания в миллисекундах до получения ответа 100-Continue с сервера.</summary>
        <value>Время ожидания в миллисекундах до получения ответа 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если 100-продолжить ответ получен до истечения времени ожидания, можно отправить тело сущности.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает файлы cookie, связанные с запросом.</summary>
        <value>Контейнер <see cref="T:System.Net.CookieContainer" />, в котором содержатся файлы cookie, связанные с этим запросом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> Свойство предоставляет экземпляр <xref:System.Net.CookieContainer> класс, который содержит файлы cookie, связанные с данным запросом.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> является `null` по умолчанию. Необходимо назначить <xref:System.Net.CookieContainer> объект для свойства значение файлы cookie, возвращаемые в <xref:System.Net.HttpWebResponse.Cookies%2A> свойство <xref:System.Net.HttpWebResponse> возвращенных <xref:System.Net.HttpWebRequest.GetResponse%2A> метод.  
  
> [!NOTE]
>  По умолчанию файлы cookie отключены по соображениям безопасности. Если вы хотите использовать файлы cookie, используйте <xref:System.Net.HttpWebRequest.CookieContainer%2A> свойство, чтобы включить файлы cookie.  
  
   
  
## Examples  
 В следующем примере кода отправляет запрос на URL-адрес и отображаются файлы cookie, возвращаемые в ответе.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о проверке подлинности для этого запроса.</summary>
        <value>Класс <see cref="T:System.Net.ICredentials" />, содержащий учетные данные для проверки подлинности, связанные с запросом. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A> Свойство содержит сведения о проверке подлинности для идентификации автора запроса. <xref:System.Net.HttpWebRequest.Credentials%2A> Свойство может быть либо <xref:System.Net.NetworkCredential>, в какие пользователем, пароль и домен сведения, содержащиеся в <xref:System.Net.NetworkCredential> объект используется для проверки подлинности запроса, или он может быть <xref:System.Net.CredentialCache>в этом случае универсальный код ресурса Идентификатор запроса (URI) используется для определения пользователя, пароль и сведения о домене для проверки подлинности запроса.  
  
 В большинстве сценариев клиента, следует использовать <xref:System.Net.CredentialCache.DefaultCredentials%2A> свойство, содержащее учетные данные текущего пользователя. Чтобы сделать это, задайте <xref:System.Net.WebClient.UseDefaultCredentials%2A> свойства `true` вместо задания этого свойства.  
  
 Если <xref:System.Net.HttpWebRequest> класс используется в приложении среднего уровня, например учетных данных в приложениях ASP.NET <xref:System.Net.CredentialCache.DefaultCredentials%2A> свойство принадлежит учетной записи, страница ASP (учетных данных на стороне сервера). Как правило этому свойству будет присвоено учетные данные клиента, от лица которого выполняется запрос.  
  
> [!NOTE]
>  Схема проверки подлинности NTLM не может использоваться для олицетворения другого пользователя. Kerberos должен быть специально настроен для поддержки олицетворения.  
  
 Чтобы ограничить HttpWebRequest один или несколько методов проверки подлинности, использовать <xref:System.Net.CredentialCache> класса и привяжите свои учетные данные для одного или нескольких схем проверки подлинности  
  
 Поддерживаемых схем проверки подлинности включают дайджест, Negotiate, Kerberos, NTLM и Basic.  
  
 По соображениям безопасности при автоматически после перенаправления, хранить учетные данные, которые вы хотите включить в перенаправления в <xref:System.Net.CredentialCache> и присвоить этому свойству. Это свойство будет автоматически присвоено `null` после перенаправления, если она содержит либо, кроме <xref:System.Net.CredentialCache>. Значение этого свойства автоматически присваивается значение `null` при этих условиях предотвращает учетные данные, отправляемые любой непреднамеренное назначение.
  
## Examples  
 В следующем примере кода задает учетные данные для запроса.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение заголовка HTTP <see langword="Date" /> для использования в HTTP-запросе.</summary>
        <value>Значение заголовка Date в HTTP-запросе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если заголовок даты `null`, то возвращаемое значение будет присвоено <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Date%2A> Свойство — это стандарт <xref:System.DateTime?displayProperty=nameWithType> объекта и может содержать <xref:System.DateTimeKind?displayProperty=nameWithType> поле <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, или <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Любые виды времени можно задать при использовании <xref:System.Net.HttpWebRequest.Date%2A> свойство. Если <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> задать или извлечь, <xref:System.Net.HttpWebRequest.Date%2A> свойство считается <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (местное время).  
  
 Классы в <xref:System.Net> пространства имен всегда записывают его <xref:System.Net.HttpWebRequest.Date%2A> свойство по сети во время передачи в стандартную форму, используя формат среднего времени по Гринвичу (Utc).  
  
 Если <xref:System.Net.HttpWebRequest.Date%2A> свойству <xref:System.DateTime.MinValue?displayProperty=nameWithType>, то `Date` HTTP-заголовок удаляется из <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
 Если <xref:System.Net.HttpWebRequest.Date%2A> свойство <xref:System.DateTime.MinValue?displayProperty=nameWithType>, это означает, что `Date` заголовок HTTP не включен в <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
 Если <xref:System.Net.HttpWebRequest.Date%2A> задано и попытка отправки <xref:System.Net.HttpWebRequest> без тела то <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> , будут созданы методом <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, и <xref:System.Net.HttpWebRequest.EndGetResponse%2A> методы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает политику кэширования для этого запроса.</summary>
        <value>Свойство <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />, которое указывает политику кэширования, действующую для этого запроса, если неприменима любая другая политика.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задание этого свойства регистрирует указанной политики для схем HTTP и HTTPS. Эта политика используется для этого запроса, если:  
  
 Имеется не <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> свойство, указанное для данного запроса.  
  
 \- или -  
  
 Конфигурации компьютера и приложения, файлы определяют политику кэширования, которая применяется к универсальный код ресурса (URI) используется для создания данного запроса.  
  
 Политика кэширования, определяет ли запрошенный ресурс может браться из кэша вместо отправки запроса к главному компьютеру ресурсов.  
  
 Копии ресурса добавляется в кэш, только если получен и чтения в конец потока в поток ответа для ресурса. Поэтому другой запрос для того же ресурса может использовать кэшированную копию, в зависимости от уровня политики кэша для этого запроса.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Для неограниченного доступа к сетевым ресурсам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает наибольшую длину по умолчанию для ответа HTTP об ошибке.</summary>
        <value>Наибольшая длина по умолчанию для ответа HTTP об ошибке.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше нуля и не равно –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение по умолчанию для свойства <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />.</summary>
        <value>Длина в килобайтах (1024 байта) или максимум по умолчанию для получаемых заголовков ответов. В файле конфигурации по умолчанию это значение устанавливается равным 64 килобайтам.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина заголовка ответа получил строку состояния ответа, а также все дополнительные управляющие символы, получаемые в протоколе HTTP. Значение-1 означает отсутствие ограничений на заголовках ответ получен; значение 0 означает, что все запросы будут отвергнуты.  
  
 Это значение также может быть изменено в файле конфигурации. Влияние этого свойства можно переопределить, задав <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> свойства экземпляра <xref:System.Net.HttpWebRequest> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше нуля и не равно -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос потока.</param>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Метод завершает выполнение асинхронного запроса для потока, который был запущен <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод. После <xref:System.IO.Stream> возвратил объект, можно отправлять данные с <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
> [!NOTE]
>  Необходимо задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойства перед записью данных в поток.  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить подключение для повторного использования. Не удалось закрыть поток предписывает приложению работать без подключения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> метод для завершения асинхронного запроса экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Запрос не завершил работу, и нет ни одного доступного потока.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  -или- При обработке этого запроса возникла ошибка.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос потока.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных, и выводит объект <see cref="T:System.Net.TransportContext" />, связанный с потоком.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Метод завершает выполнение асинхронного запроса для потока, который был запущен <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод и выходы <xref:System.Net.TransportContext> связанный с потоком. После <xref:System.IO.Stream> возвратил объект, можно отправлять данные с <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
 Некоторые приложения, использующие встроенную проверку подлинности Windows с расширенной защитой может потребоваться иметь возможность направлять запрос на транспортном уровне, используемые <xref:System.Net.HttpWebRequest> для получения маркера привязки канала (CBT) из базового канала TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод предоставляет доступ к этим сведениям для HTTP-методов, имеющих текст запроса (`POST` и `PUT` запросов). Требуется, только если приложение реализует собственную проверку подлинности и требуется доступ к CBT.  
  
> [!NOTE]
>  Если приложению требуется задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство, то это необходимо сделать до получения потока и запись в нее данных.  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить подключение для повторного использования. Не удалось закрыть поток предписывает приложению работать без подключения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">Запрос не завершен, и поток недоступен.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  -или- При обработке этого запроса возникла ошибка.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос ответа.</param>
        <summary>Завершает асинхронный запрос интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.Net.WebResponse" />, содержащий ответ от интернет-ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Завершения асинхронный запрос Интернет-ресурса, который был запущен с помощью вызова метода <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод.  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.Net.HttpWebResponse.Close%2A> метод, чтобы закрыть поток и освободить соединение. Невыполнение этого требования может привести к нехватке подключений вашего приложения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.EndGetResponse%2A> для завершения асинхронный запрос Интернет-ресурса.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод уже вызывался с помощью <paramref name="asyncResult." /> -или- Свойство <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше 0, но данные не были записаны в поток запроса.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  -или- При обработке этого запроса возникла ошибка.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Expect" />.</summary>
        <value>Содержимое HTTP-заголовка <see langword="Expect" />. Значение по умолчанию — <see langword="null" />.  
  
 <block subset="none" type="note"><para> Значение этого свойства хранится в <see cref="T:System.Net.WebHeaderCollection" />. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> устанавливается равным строке, содержащей "100-continue" в качестве подстроки.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="streamingContext">Контекст <see cref="T:System.Runtime.Serialization.StreamingContext" />, определяющий целевой объект сериализации.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, необходимыми для сериализации целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты, включенные в <xref:System.Runtime.Serialization.SerializationInfo> , автоматически отслеживаются и сериализации модулем форматирования.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод возвращает поток, используемый для отправки данных <xref:System.Net.HttpWebRequest>. После <xref:System.IO.Stream> возвратил объект, можно отправлять данные с <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
 Если приложению требуется задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойства, то это необходимо сделать перед возвращением в поток.  
  
 Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить подключение для повторного использования. Не удалось закрыть поток предписывает приложению работать без подключения.  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.GetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метод для возврата экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Значение свойства <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD.  -или- <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> вызывается несколько раз.  -или- Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако запросы, которые записывают данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского средства проверки кэша, которое неправильно реализовано.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  -или- Истекло время ожидания для запроса.  -или- При обработке этого запроса возникла ошибка.</exception>
        <exception cref="T:System.ObjectDisposedException">В приложении .NET Compact Framework поток запроса с нулевой длиной содержимого не был правильно получен и закрыт. Дополнительные сведения об обработке запросов с нулевой длиной содержимого см. в разделе [Сетевое программирование в .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Net.TransportContext" /> для <see cref="T:System.IO.Stream" />.</param>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса, и выводит объект <see cref="T:System.Net.TransportContext" />, связанный с потоком.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод возвращает поток, используемый для отправки данных <xref:System.Net.HttpWebRequest> и выводит <xref:System.Net.TransportContext> связанный с потоком. После <xref:System.IO.Stream> возвратил объект, можно отправлять данные с <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
 Некоторые приложения, использующие встроенную проверку подлинности Windows с расширенной защитой может потребоваться иметь возможность направлять запрос на транспортном уровне, используемые <xref:System.Net.HttpWebRequest> для получения маркера привязки канала (CBT) из базового канала TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод предоставляет доступ к этим сведениям для HTTP-методов, имеющих текст запроса (`POST` и `PUT` запросов). Требуется, только если приложение реализует собственную проверку подлинности и требуется доступ к CBT.  
  
 Если приложению требуется задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойства, то это необходимо сделать перед возвращением в поток.  
  
 Необходимо вызвать метод <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить подключение для повторного использования. Не удалось закрыть поток предписывает приложению работать без подключения.  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.GetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Методу <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> не удалось получить <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> вызывается несколько раз.  -или- Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако запросы, которые записывают данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского средства проверки кэша, которое неправильно реализовано.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Значение свойства <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD.  -или- <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  -или- Истекло время ожидания для запроса.  -или- При обработке этого запроса возникла ошибка.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ответ от интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.Net.WebResponse" />, содержащий ответ от интернет-ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Возвращает метод <xref:System.Net.WebResponse> , содержащий ответ от Интернет-ресурса. Фактический экземпляр возвращается <xref:System.Net.HttpWebResponse>и может быть приведен к этому классу для НТТР-доступа к свойствам.  
  
 Объект <xref:System.Net.ProtocolViolationException> создается исключение в некоторых случаях, если для свойства не задано <xref:System.Net.HttpWebRequest> класса, конфликтуют. Это исключение возникает, если приложение задает <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство и <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true`, а затем отправляет запрос HTTP GET. Это исключение возникает, если приложение пытается отправить фрагментированный на сервере, который поддерживает только протокол HTTP 1.0, где это не поддерживается. Это исключение возникает, если приложение пытается отправить данные без параметра <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство или <xref:System.Net.HttpWebRequest.SendChunked%2A> — `false` при отключенной буферизации и для проверки активности подключения ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`)`.`  
  
> [!CAUTION]
>  Необходимо вызвать метод <xref:System.Net.HttpWebResponse.Close%2A> метод, чтобы закрыть поток и освободить соединение. Невыполнение этого требования может привести к нехватке подключений вашего приложения.  
  
 При использовании метода POST, необходимо получить поток запроса, запись данных для публикации и закройте поток. Этот метод блокирует ожидание публикуемого содержимого; Если не определено время ожидания и не предоставлено содержимое, вызывающий поток блокируется на неопределенное время.  
  
> [!NOTE]
>  Несколько вызовов <xref:System.Net.HttpWebRequest.GetResponse%2A> возвратить объект ответа; запрос не выполняется повторно.  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.GetResponse%2A> для получения ответа.  
  
> [!NOTE]
>  Если <xref:System.Net.WebException> — исключение, используйте <xref:System.Net.WebException.Response%2A> и <xref:System.Net.WebException.Status%2A> свойства исключения для определения ответа от сервера.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  По умолчанию файлы cookie отключены по соображениям безопасности. Если вы хотите использовать файлы cookie, используйте <xref:System.Net.HttpWebRequest.CookieContainer%2A> свойство, чтобы включить файлы cookie.  
  
   
  
## Examples  
 В следующем примере кода получает ответ на запрос.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток уже занят предыдущим вызовом <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  -или- Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> задано значение, а <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Значение <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD, и либо <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше или равно нулю, либо <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="true" />.  -или- <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> равно <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> равно <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> равно –1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />, а <see cref="P:System.Net.HttpWebRequest.Method" /> равно POST или PUT.  -или- Запрос <see cref="T:System.Net.HttpWebRequest" /> имеет тело сущности, но метод <see cref="M:System.Net.HttpWebRequest.GetResponse" /> вызывается без вызова метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  -или- Значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, но приложение не записывает все обещанные данные.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша. Однако этот запрос содержит данные, которые будут отправлены на сервер. Запросы, отправляющие данные, не должны использовать кэш. Это исключение может возникнуть при использовании настраиваемого проверяющего элемента управления кэша, который неправильно реализован.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  -или- Истекло время ожидания для запроса.  -или- При обработке этого запроса возникла ошибка.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, был ли получен ответ от интернет-ресурса.</summary>
        <value>Значение <see langword="true" />, если ответ получен, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода в примере выполняется проверка <xref:System.Net.HttpWebRequest.HaveResponse%2A> свойства, чтобы определить, если был получен ответ от Интернет-ресурса.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает коллекцию пар "имя-значение", из которых создаются заголовки HTTP.</summary>
        <value>Коллекция <see cref="T:System.Net.WebHeaderCollection" />, содержащая пары "имя-значение", из которых состоят заголовки HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A> Коллекция содержит заголовки протокола, связанного с запросом. В следующей таблице перечислены заголовки HTTP, которые не хранятся в <xref:System.Net.HttpWebRequest.Headers%2A> коллекции, а все установленные системой или заданные свойства и методы.  
  
|Header|Задается|  
|------------|------------|  
|Принять|Задается <xref:System.Net.HttpWebRequest.Accept%2A> свойство.|  
|Подключение|Задается <xref:System.Net.HttpWebRequest.Connection%2A> свойство и <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойства.|  
|Content-Length|Задается <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство.|  
|Тип содержимого|Задается <xref:System.Net.HttpWebRequest.ContentType%2A> свойство.|  
|Ожидается, что|Задается <xref:System.Net.HttpWebRequest.Expect%2A> свойство.|  
|Дата|Задается <xref:System.Net.HttpWebRequest.Date%2A> свойство.|  
|Ведущее приложение|Задается <xref:System.Net.HttpWebRequest.Host%2A> свойство.|  
|If-Modified-Since|Задается <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство.|  
|Диапазон|Задается <xref:System.Net.HttpWebRequest.AddRange%2A> метод.|  
|Referer|Задается <xref:System.Net.HttpWebRequest.Referer%2A> свойство.|  
|Transfer-Encoding|Задается <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойство ( <xref:System.Net.HttpWebRequest.SendChunked%2A> свойство должно иметь значение true).|  
|Агент пользователя|Задается <xref:System.Net.HttpWebRequest.UserAgent%2A> свойство.|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A> Вызывает исключение <xref:System.ArgumentException> при попытке задать одно из этих защищенных заголовков.  
  
 Изменение <xref:System.Net.HttpWebRequest.Headers%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
 Не следует предполагать, что значения заголовка не изменится, так как веб-серверы и кэши могут изменять и добавлять заголовки для веб-запроса.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.Headers%2A> свойство для печати пары имя/значение заголовка HTTP на консоль.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение заголовка Host для использования в HTTP-запросе независимо от URI запроса.</summary>
        <value>Значение заголовка Host в HTTP-запросе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A> Свойства можно установить для узлов значение заголовка для использования в HTTP-запросе независимо от URI запроса. <xref:System.Net.HttpWebRequest.Host%2A> Свойство может состоять из имени узла и номера порта необязательно. Заголовок Host без сведения о порте подразумевает порт по умолчанию для запроса службы (порт 80 для URL-адрес HTTP, например).  
  
 Формат для указания узла и порта должны соответствовать правилам в разделе 14.23 RFC2616, опубликованном IETF. Пример ответственность за соблюдение этих требований, задающее порт 8080 будет иметь следующее значение для <xref:System.Net.HttpWebRequest.Host%2A> свойства:  
  
 `www.contoso.com:8080`  
  
 С помощью <xref:System.Net.HttpWebRequest.Host%2A> свойство, чтобы явно указать пользовательское значение заголовка узла также влияет на области кэширования, файлы cookie и проверки подлинности. Если приложение предоставляет учетные данные для определенного префикса URI, приложениям необходимо убедитесь в использовании URI, содержащего значение заголовка узла не целевого сервера в URI. Ключ, используемый при кэшировании ресурсов, использует значение заголовка Host вместо URI запроса. Файлы Cookie хранятся в <xref:System.Net.CookieContainer> и логически сгруппированные доменное имя сервера. Если приложение указывает заголовок узла, то это значение будет использоваться как домен.  
  
 Если <xref:System.Net.HttpWebRequest.Host%2A> свойство не задано, то значение заголовка Host для использования в HTTP-запрос основан на URI запроса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заголовку узла не может быть присвоено значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Заголовку узла не может задано недопустимое значение.</exception>
        <exception cref="T:System.InvalidOperationException">Заголовок узла нельзя задать после запуска <see cref="T:System.Net.HttpWebRequest" /> для отправки.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="If-Modified-Since" />.</summary>
        <value>Объект <see cref="T:System.DateTime" />, в котором размещено содержимое HTTP-заголовка <see langword="If-Modified-Since" />. Значением по умолчанию являются текущие дата и время.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Свойство — это стандарт <xref:System.DateTime?displayProperty=nameWithType> объекта и может содержать <xref:System.DateTimeKind?displayProperty=nameWithType> поле <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, или <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Любые виды времени можно задать при использовании <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство. Если <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> задать или извлечь, <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство считается <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (местное время).  
  
 Классы в <xref:System.Net> пространства имен всегда записывают его <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство по сети во время передачи в стандартную форму, используя формат среднего времени по Гринвичу (Utc).  
  
 Если <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойству <xref:System.DateTime.MinValue?displayProperty=nameWithType>, то `If-Modified-Since` HTTP-заголовок удаляется из <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
 Если <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство <xref:System.DateTime.MinValue?displayProperty=nameWithType>, это означает, что `If-Modified-Since` заголовок HTTP не включен в <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода в примере выполняется проверка <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, необходимо ли устанавливать постоянное подключение к интернет-ресурсу.</summary>
        <value>Значение <see langword="true" />, если запрос к интернет-ресурсу должен содержать HTTP-заголовок <see langword="Connection" /> со значением Keep-alive; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true` для отправки `Connection` заголовок HTTP со значением Keep-alive. Приложение использует <xref:System.Net.HttpWebRequest.KeepAlive%2A> , чтобы указать, что предпочтительны постоянные подключения. Когда <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`, приложение создает постоянные подключения к серверам, которые поддерживают их.  
  
> [!NOTE]
>  При использовании HTTP/1.1, Keep-Alive включен по умолчанию. Установка <xref:System.Net.HttpWebRequest.KeepAlive%2A> для `false` может привести к отправке `Connection: Close` заголовок на сервер.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойства `false` во избежание создания постоянного подключения с Интернет-ресурса.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество переадресаций, выполняемых запросом.</summary>
        <value>Максимальное количество ответов переадресации, указаниям которых следует запрос. Значение по умолчанию — 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Устанавливает максимальное количество переадресаций, выполняемых запросом, если значение свойства <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> свойство `true`.  
  
   
  
## Examples  
 В следующем примере кода задает значение этого свойства.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Задано значение 0 или меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальную допустимую длину заголовков ответов.</summary>
        <value>Длина заголовков ответов, выраженная в килобайтах (1024 байта).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина заголовка ответа включает строку состояния ответа, а также все дополнительные управляющие символы, получаемые в протоколе HTTP. Значение-1 означает отсутствие ограничений на заголовке ответа; значение 0 означает, что все запросы будут отвергнуты.  
  
 Если <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> свойство не задано явно, по умолчанию используется значение <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> свойства.  
  
 Если длина получен заголовок ответа превышает значение <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> свойства <xref:System.Net.HttpWebRequest.EndGetResponse%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> методы создают исключение <xref:System.Net.WebException> с <xref:System.Net.WebException.Status%2A> свойство <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 В следующем примере кода задает значение этого свойства.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство установлено уже после отправки запроса.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше нуля и не равно –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает формат носителя запроса.</summary>
        <value>Формат носителя запроса. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Net.HttpWebRequest.MediaType%2A> свойства влияет на <xref:System.Net.HttpWebResponse.CharacterSet%2A> свойство. При задании <xref:System.Net.HttpWebRequest.MediaType%2A> в запросе, соответствующий тип носителя выбирается из списка наборов знаков, возвращаемых в ответе `Content-type` заголовка HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод для запроса.</summary>
        <value>Метод запроса, используемый для связи с интернет-ресурсом. Значение по умолчанию — GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A> Свойству можно присвоить значение любой из команд протокол HTTP 1.1: GET, HEAD, POST, PUT, удалять, ТРАССИРОВКИ и параметры.  
  
 Если <xref:System.Net.HttpWebRequest.ContentLength%2A> свойству присвоено значение, отличное от -1, <xref:System.Net.HttpWebRequest.Method%2A> свойство необходимо задать свойству протокола, используемого для загрузки данных.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Method%2A> значение POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Метод не указан.  -или- Строка метода содержит недопустимые символы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выполняется ли конвейерная передача запроса в интернет-ресурс.</summary>
        <value>Значение <see langword="true" />, если должна выполняться конвейерная передача запроса, в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение использует <xref:System.Net.HttpWebRequest.Pipelined%2A> свойство, указывающее предпочтение Конвейерные подключения. Когда <xref:System.Net.HttpWebRequest.Pipelined%2A> — `true`, приложение создает Конвейерные подключения к серверам, которые поддерживают их.  
  
 Конвейерные подключения только если <xref:System.Net.HttpWebRequest.KeepAlive%2A> также имеет `true`.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Net.HttpWebRequest.Pipelined%2A> свойства на консоль.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли отправлять заголовок авторизации вместе с запросом.</summary>
        <value>
          <see langword="true" /> отправлять заголовок авторизации HTTP с запросами, после выполнения аутентификации; в противном случае <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После запроса клиента к определенному <xref:System.Uri> проверка подлинности прошла успешно, если <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> — `true` и учетные данные указаны, заголовок Authorization будут отправляться с каждым запросом на любой <xref:System.Uri> , соответствующей конкретной <xref:System.Uri>до последнего косой черты. Таким образом, если запрос клиента успешно прошел проверку подлинности с определенным <xref:System.Uri> , содержит следующее:  
  
 `http://www.contoso.com/firstpath/`  
  
 Заголовок авторизации для предварительной проверки подлинности, отправляется в каждом запросе к любому из следующих <xref:System.Uri> экземпляров:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Тем не менее, заголовок авторизации не отправляется вместе с запросами к любому из следующих <xref:System.Uri> экземпляров:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Если запрос клиента с определенным <xref:System.Uri> — проверка подлинности не успешно, запрос использует стандартные процедуры проверки подлинности.  
  
 За исключением первого запроса <xref:System.Net.WebRequest.PreAuthenticate%2A> свойство указывает, следует ли отправлять сведения о проверке подлинности с последующими запросами к <xref:System.Uri> , соответствующей конкретной <xref:System.Uri> вплоть до последнего косая черта без ожидание запроса сервером.  
  
 Следующее диалоговое окно между клиентом и сервером показано влияние этого свойства. Диалоговое окно предполагается, что является обычной проверки подлинности используется.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> — `false`:  
  
 Клиента: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Клиент: GET с заголовками авторизации  
  
 Сервер: 200 ОК  
  
 Клиента: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Клиент: GET с заголовками авторизации  
  
 Сервер: 200 ОК  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> — `true`:  
  
 Клиента: SomeUrl GET  
  
 Server: Basic 401 WWW-Authenticate  
  
 Клиент: GET с заголовками авторизации  
  
 Сервер: 200 ОК  
  
 Клиент: SomeUrl с заголовки Authorization получить  
  
 Если схема проверки подлинности не поддерживает предварительную проверку подлинности, значение этого свойства учитывается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает версию HTTP-протокола, используемую для запроса.</summary>
        <value>Версия HTTP-протокола, используемая для запроса. Значение по умолчанию: <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Класс поддерживает только версии 1.0 и 1.1 HTTP. Задание <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> до другой версии приводит к возникновению исключения.  
  
> [!NOTE]
>  Чтобы установить версию HTTP текущего запроса, используйте <xref:System.Net.HttpVersion.Version10> и <xref:System.Net.HttpVersion.Version11> поля <xref:System.Net.HttpVersion> класса.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для версии HTTP задано значение, отличное от 1.0 или 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о прокси-сервере для запроса.</summary>
        <value>Объект <see cref="T:System.Net.IWebProxy" />, используемый в качестве прокси-сервера для этого запроса. Значение по умолчанию устанавливается путем вызова свойства <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A> Свойство, обозначающее <xref:System.Net.WebProxy> объект, который используется для обработки запросов к Интернет-ресурсам. Чтобы указать, что должна использоваться без прокси-сервера, задайте <xref:System.Net.HttpWebRequest.Proxy%2A> свойства экземпляра прокси-сервера, возвращенный <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> метод.  
  
 Локальный компьютер или файл конфигурации приложения могут использовать прокси-сервер по умолчанию. Если <xref:System.Net.HttpWebRequest.Proxy%2A> свойство указано, выберите параметры прокси-сервера из <xref:System.Net.HttpWebRequest.Proxy%2A> переопределения свойств локального компьютера или файл конфигурации приложения и <xref:System.Net.HttpWebRequest> экземпляр будет использовать параметры прокси-сервера. Если в файле конфигурации указан без прокси-сервера и <xref:System.Net.HttpWebRequest.Proxy%2A> не указан, свойство <xref:System.Net.HttpWebRequest> класс использует параметры прокси-сервера, который наследуется от Internet Explorer на локальном компьютере. Если отсутствуют параметры прокси-сервера в Internet Explorer, запрос отправляется непосредственно на сервер.  
  
 <xref:System.Net.HttpWebRequest> Класс анализирует список обхода прокси-сервера с использованием подстановочных знаков наследуется от Internet Explorer же как список пропускаемых анализируется непосредственно с Internet Explorer. Например <xref:System.Net.HttpWebRequest> класса будет выполнять синтаксический анализ список обхода «nt *» из Internet Explorer регулярное выражение «nt.\*». Таким образом URL-адрес "`http://nt.com`» будут обходить прокси-сервер с помощью <xref:System.Net.HttpWebRequest> класса и с помощью Internet Explorer.  
  
 <xref:System.Net.HttpWebRequest> Класс поддерживает обхода локальный прокси-сервер. Класс считает целевой локальной, если выполняется любое из следующих условий:  
  
-   Назначение содержит плоское имя (нет точек в URL-адрес).  
  
-   Назначение содержит адрес замыкания на себя (<xref:System.Net.IPAddress.Loopback> или <xref:System.Net.IPAddress.IPv6Loopback>) или назначение содержит <xref:System.Net.IPAddress> локального компьютера.  
  
-   Суффикс домена назначения совпадает с суффиксом домена локального компьютера (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Изменение <xref:System.Net.HttpWebRequest.Proxy%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>. Сведения об элементе прокси-сервера в разделе [ \&lt; defaultProxy\&gt; Элемент (параметры сети)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Net.HttpWebRequest.Proxy%2A> метод, чтобы получить сведения о прокси для запроса.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметру <see cref="P:System.Net.HttpWebRequest.Proxy" /> задается значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Запрос начат посредством вызова метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект не имеет разрешения на запрошенную операцию.</exception>
        <permission cref="T:System.Net.WebPermission">Чтобы получить или задать <see cref="P:System.Net.HttpWebRequest.Proxy" /> свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает время ожидания в миллисекундах при записи в поток или при чтении из него.</summary>
        <value>Количество миллисекунд до истечения срока действия записи или чтения. По умолчанию установлено значение 300 000 миллисекунд (5 минут).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Свойство используется при записи в поток, возвращенный <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода или чтение из потока, возвращенного <xref:System.Net.HttpWebResponse.GetResponseStream%2A> метод.  
  
 В частности <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> свойство определяет время ожидания для <xref:System.IO.Stream.Read%2A> метод, который используется для чтения поток, возвращенный <xref:System.Net.HttpWebResponse.GetResponseStream%2A> метод, а также для <xref:System.IO.Stream.Write%2A> метод, который используется для записи в поток, возвращенный <xref:System.Net.HttpWebRequest.GetRequestStream%2A>метод.  
  
 Чтобы указать время ожидания для завершения запроса, используйте <xref:System.Net.HttpWebRequest.Timeout%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано задание свойства <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос уже был отправлен.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное значение для операции присвоения меньше или равно нулю и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Referer" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Referer" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> свойство `true`, <xref:System.Net.HttpWebRequest.Referer%2A> устанавливается автоматически, когда запрос перенаправляется на другой сайт.  
  
 Чтобы очистить `Referer` задать заголовок HTTP <xref:System.Net.HttpWebRequest.Referer%2A> свойства `null`.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Referer%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходный код URI запроса.</summary>
        <value>Объект <see cref="T:System.Uri" />, который содержит код URI интернет-ресурса, переданный в метод <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri> Объект, переданный в <xref:System.Net.HttpWebRequest> вызовом <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Переадресации не изменяет заголовок <xref:System.Net.HttpWebRequest.RequestUri%2A> свойство. Для получения реального URI Ресурса, ответившего на запрос проверьте <xref:System.Net.HttpWebRequest.Address%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода в примере выполняется проверка на наличие <xref:System.Net.HttpWebRequest> объекта `req` был перенаправлен в другое место для выполнения запроса и задает значение `hasChanged` переменной `true` Если перенаправляются; в противном случае — запрос `hasChanged` равно `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будут ли отправляться данные в интернет-ресурс в виде сегментов.</summary>
        <value>Значение <see langword="true" />, если требуется посылать данные в интернет-ресурс сегментами; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Net.HttpWebRequest.SendChunked%2A> — `true`, запрос отправляет данные в Интернет-ресурс сегментами. Интернет-ресурс должен поддерживать получение данных по частям.  
  
 Изменение <xref:System.Net.HttpWebRequest.SendChunked%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает исключение <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true` , чтобы данные можно отправить в сегментах Интернет-ресурс.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает функцию обратного вызова для проверки сертификата сервера.</summary>
        <value>Функция обратного вызова для проверки сертификата сервера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение по умолчанию — что функция обратного вызова не задано и <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> свойство `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает точку обслуживания, используемую для запроса.</summary>
        <value>Значение <see cref="T:System.Net.ServicePoint" />, представляющее сетевое подключение к интернет-ресурсу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> Свойств могут отличаться от <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> Если перенаправляется запрос.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, поддерживает ли запрос <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> Если запрос поддерживает <see cref="T:System.Net.CookieContainer" />; в противном случае <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="streamingContext">Контекст <see cref="T:System.Runtime.Serialization.StreamingContext" />, определяющий целевой объект сериализации.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, необходимыми для сериализации целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты, включенные в <xref:System.Runtime.Serialization.SerializationInfo> , автоматически отслеживаются и сериализации модулем форматирования.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение ожидания в миллисекундах для методов <see cref="M:System.Net.HttpWebRequest.GetResponse" /> и <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>Количество миллисекунд, ожидаемых до остановки запроса. По умолчанию установлено значение 100 000 миллисекунд (100 секунд).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> число миллисекунд, последующие синхронный запрос сделан с <xref:System.Net.HttpWebRequest.GetResponse%2A> метод ожидает ответа и <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метод ожидает поток. <xref:System.Net.HttpWebRequest.Timeout%2A> Применяется для всего запроса и ответа, не по отдельности к <xref:System.Net.HttpWebRequest.GetRequestStream%2A> и <xref:System.Net.HttpWebRequest.GetResponse%2A> вызовы методов. Если ресурс не возвращается до истечения времени ожидания, запрос создает исключение <xref:System.Net.WebException> с <xref:System.Net.WebException.Status%2A> свойство <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Свойство должно быть установлено перед <xref:System.Net.HttpWebRequest.GetRequestStream%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> вызывается метод. Изменение <xref:System.Net.HttpWebRequest.Timeout%2A> свойства после вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> метод не оказывает влияния  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Свойство не оказывает влияния на асинхронные запросы, созданные с помощью <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> или <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод.  
  
> [!CAUTION]
>  В случае асинхронных запросов клиентское приложение реализует собственный механизм времени ожидания. В примере в <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод.  
  
 Чтобы указать время ожидания чтения или записи операции истечением времени ожидания, используйте <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> свойство.  
  
 Запрос доменных имен (DNS) может занять до 15 секунд до возврата или истечения времени ожидания. Если запрос содержит имя узла, требуется разрешение и установить <xref:System.Net.FileWebRequest.Timeout%2A> значение меньше 15 секунд, может потребоваться 15 секунд или больше перед <xref:System.Net.WebException> вызывается, чтобы указать время ожидания запроса.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Timeout%2A> свойство <xref:System.Net.HttpWebRequest> объекта.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное значение меньше нуля и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Transfer-encoding" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Transfer-encoding" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед тем как установить <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойства, необходимо сначала установить <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true`. Очистка <xref:System.Net.HttpWebRequest.TransferEncoding%2A> присвоив ему значение `null` не влияет на значение <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Значения, присвоенные <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойство заменяют любое имеющееся содержимое.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается, когда значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается равным значению "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли разрешено совместное использование высокоскоростного подключения с проверкой подлинности NTLM.</summary>
        <value>Значение <see langword="true" />, если необходимо сохранить открытым подключение, прошедшее проверку подлинности, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение по умолчанию для этого свойства — `false`, которое вызывает текущее подключение закрывается после завершения запроса. Приложение должно пройти через последовательность проверки подлинности каждый раз, он выдает новый запрос.  
  
 Если это свойство имеет значение `true`, соединение, используемое для извлечения ответа остается открытой после проверки подлинности. В этом случае другие запросы, у которых данное свойство установлено равным `true` могут использовать подключение без повторной аутентификации. Другими словами, если подключение прошел проверку подлинности для пользователя A, пользователь Б может повторно соединение. запрос пользователя Б выполняется на основе учетных данных пользователя, а.  
  
> [!CAUTION]
>  Поскольку приложение может использовать подключение без прохождения проверки подлинности, необходимо убедиться, что это не административные уязвимости в системе при задании этого свойства `true`. Если приложение отправляет запросы для нескольких пользователей (олицетворяет несколько учетных записей пользователей) и полагается на проверку подлинности для защиты ресурсов, это свойство не задано `true` при использовании групп соединений, как описано ниже.  
  
 Вы можете включить этот механизм, если ваш возникают проблемы производительности и приложение выполняется на веб-сервере со встроенной проверкой подлинности Windows.  
  
 Включение этого параметра открывает риск для безопасности системы. Если задать <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> свойства `true` не забудьте предпринять следующие меры:  
  
-   Используйте <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> свойство, чтобы управлять соединениями для разных пользователей. Это исключает возможность использования подключения приложениями без проверки подлинности. Например пользователь А должен иметь уникальное соединение имя группы, которое отличается от пользователя б. Это обеспечивает уровень изоляции для каждой учетной записи пользователя.  
  
-   Запустите приложение в защищенной среде, чтобы избежать несанкционированного использования подключения.  
  
 Если вы можете управлять внутреннего сервера, в качестве альтернативы может потребоваться отключить сохраняемую проверку подлинности. Благодаря этому увеличивается производительность в меньшей степени, но он является более безопасным. Дополнительные сведения, выполните поиск AuthPersistence в библиотеке MSDN по [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Если оба <xref:System.Net.WebRequest.PreAuthenticate%2A> и <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> присваиваются `true`, каждый запрос отправляется через подключение небезопасный пул, но имеет заголовок авторизации.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Неограниченное разрешение Web требуется задать это свойство.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение <see cref="T:System.Boolean" />, которое управляет отправкой учетных данных по умолчанию вместе с запросами.</summary>
        <value>Значение <see langword="true" />, если используются учетные данные по умолчанию; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true` при запросов, выполненных этим <xref:System.Net.HttpWebRequest> объекта по запросу сервера, проверка подлинности должна выполняться с использованием учетных данных пользователя, выполнившего вход. Для клиентских приложений это приемлемо в большинстве сценариев. Для приложений среднего уровня, таких как приложения ASP.NET, вместо того чтобы использовать это свойство обычно устанавливается <xref:System.Net.HttpWebRequest.Credentials%2A> свойства учетные данные клиента, от лица которого выполняется запрос.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка задать для этого свойства значение после отправки запроса.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="User-agent" />.</summary>
        <value>Значение HTTP-заголовка <see langword="User-agent" />. Значение по умолчанию — <see langword="null" />.  
  
 <block subset="none" type="note"><para> Значение этого свойства хранится в <see cref="T:System.Net.WebHeaderCollection" />. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.UserAgent%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>