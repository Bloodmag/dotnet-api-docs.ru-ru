<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="45aed4a95edff1e825b957b2993f72dc022d64ea" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39754212" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="38e1f-101">Представляет комплексное число.</span>
      <span class="sxs-lookup">
        <span data-stu-id="38e1f-101">Represents a complex number.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-102">Комплексного числа — это число, которое состоит из вещественную и мнимую части.</span><span class="sxs-lookup"><span data-stu-id="38e1f-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="38e1f-103">Z комплексного числа, обычно записываются в виде z = x + yi, где *x* и *y* являются вещественных чисел и *я* — это единица мнимого со свойством *i* <sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="38e1f-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="38e1f-104">Действительная часть комплексного числа, представленного *x*, а мнимая часть комплексного числа представлен *y*.</span><span class="sxs-lookup"><span data-stu-id="38e1f-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="38e1f-105"><xref:System.Numerics.Complex> Тип использует декартовой системе координат (реальные, мнимые) при создании экземпляров и управлении комплексными числами.</span><span class="sxs-lookup"><span data-stu-id="38e1f-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="38e1f-106">Комплексного числа могут быть представлены в качестве точки в двумерной системе координат, которая называется на комплексной плоскости.</span><span class="sxs-lookup"><span data-stu-id="38e1f-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="38e1f-107">Действительная часть комплексного числа расположено на оси x (горизонтальной оси) и мнимой части находится на оси y (вертикальной оси).</span><span class="sxs-lookup"><span data-stu-id="38e1f-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="38e1f-108">Все точки на комплексной плоскости также может быть выражен на основе его абсолютное значение, используя полярных координат., в Полярные координаты, точку характеризуется два числа:</span><span class="sxs-lookup"><span data-stu-id="38e1f-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="38e1f-109">Его величина, которая является расстоянием точки от начала координат (то есть, 0,0 или точку пересечения оси x и y пересекаются).</span><span class="sxs-lookup"><span data-stu-id="38e1f-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="38e1f-110">Его этап, на котором — это угол между реальной оси и линии, рисуемой от начала координат в точку.</span><span class="sxs-lookup"><span data-stu-id="38e1f-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="38e1f-111">Создание экземпляра комплексного числа</span><span class="sxs-lookup"><span data-stu-id="38e1f-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="38e1f-112">Можно назначить значение для комплексного числа в одном из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="38e1f-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="38e1f-113">Передавая два <xref:System.Double> значения в его конструктор.</span><span class="sxs-lookup"><span data-stu-id="38e1f-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="38e1f-114">Первое значение представляет вещественную часть комплексного числа, а второе значение мнимую часть.</span><span class="sxs-lookup"><span data-stu-id="38e1f-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="38e1f-115">Эти значения представляют положение комплексного числа в двумерной системе координат.</span><span class="sxs-lookup"><span data-stu-id="38e1f-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="38e1f-116">Путем вызова статического (`Shared` в Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> метод для создания комплексного числа из его полярных координат.</span><span class="sxs-lookup"><span data-stu-id="38e1f-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="38e1f-117">Назначив <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, или <xref:System.Double> значение <xref:System.Numerics.Complex> объекта.</span><span class="sxs-lookup"><span data-stu-id="38e1f-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="38e1f-118">Значение становится вещественной части комплексного числа и мнимую часть равен 0.</span><span class="sxs-lookup"><span data-stu-id="38e1f-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="38e1f-119">Приведение (в C#) или преобразования (в Visual Basic) <xref:System.Decimal> или <xref:System.Numerics.BigInteger> значение <xref:System.Numerics.Complex> объекта.</span><span class="sxs-lookup"><span data-stu-id="38e1f-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="38e1f-120">Значение становится вещественной части комплексного числа и мнимую часть равен 0.</span><span class="sxs-lookup"><span data-stu-id="38e1f-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="38e1f-121">Назначив комплексное число, которое возвращается методом или оператор <xref:System.Numerics.Complex> объекта.</span><span class="sxs-lookup"><span data-stu-id="38e1f-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="38e1f-122">Например <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> — это статический метод, который возвращает комплексное число, которое складывается из двух комплексных чисел и <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> оператора складывает два комплексных числа и возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="38e1f-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="38e1f-123">В следующем примере показано, каждый из этих пяти способов присваивание значения комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="38e1f-124">Операции с комплексными числами</span><span class="sxs-lookup"><span data-stu-id="38e1f-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="38e1f-125"><xref:System.Numerics.Complex> Структуры в .NET Framework включает в себя элементы, которые обеспечивают следующие функциональные возможности:</span><span class="sxs-lookup"><span data-stu-id="38e1f-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="38e1f-126">Методы для сравнения двух комплексных чисел, чтобы определить, равны ли они.</span><span class="sxs-lookup"><span data-stu-id="38e1f-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="38e1f-127">Операторы для выполнения арифметических операций над комплексными числами.</span><span class="sxs-lookup"><span data-stu-id="38e1f-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="38e1f-128"><xref:System.Numerics.Complex> операторы позволяют выполнять сложение, вычитание, умножение, деление и Унарное отрицание с комплексными числами.</span><span class="sxs-lookup"><span data-stu-id="38e1f-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="38e1f-129">Методы для выполнения других числовых операций с комплексными числами.</span><span class="sxs-lookup"><span data-stu-id="38e1f-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="38e1f-130">В дополнение к четыре основные арифметические операции можно вызвать комплексного числа в указанную степень, найти квадратный корень из комплексного числа и получать абсолютное значение комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="38e1f-131">Методы для выполнения тригонометрических операций с комплексными числами.</span><span class="sxs-lookup"><span data-stu-id="38e1f-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="38e1f-132">Например можно вычислить тангенс угла представленный комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="38e1f-133">Обратите внимание, что, поскольку <xref:System.Numerics.Complex.Real%2A> и <xref:System.Numerics.Complex.Imaginary%2A> свойства доступны только для чтения, нельзя изменить значение существующего <xref:System.Numerics.Complex> объекта.</span><span class="sxs-lookup"><span data-stu-id="38e1f-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="38e1f-134">Все методы, которые выполняют операции на <xref:System.Numerics.Complex> номер, если их возвращаемое значение имеет тип <xref:System.Numerics.Complex>, возвращают новую <xref:System.Numerics.Complex> номер.</span><span class="sxs-lookup"><span data-stu-id="38e1f-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="38e1f-135">Точность и комплексных чисел</span><span class="sxs-lookup"><span data-stu-id="38e1f-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="38e1f-136">И действительная и мнимая части комплексного числа представлены два значения с плавающей запятой двойной точности.</span><span class="sxs-lookup"><span data-stu-id="38e1f-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="38e1f-137">Это означает, что <xref:System.Numerics.Complex> значений, как значения с плавающей запятой двойной точности, может происходить потеря точности в результате числовых операций.</span><span class="sxs-lookup"><span data-stu-id="38e1f-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="38e1f-138">Это означает, что strict сравнения на равенство двух <xref:System.Numerics.Complex> значений может произойти ошибка, даже если разница между двумя значениями из-за потери точности.</span><span class="sxs-lookup"><span data-stu-id="38e1f-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="38e1f-139">Дополнительные сведения см. в разделе <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="38e1f-140">Например выполнение возведения в степень на логарифм числа должен возвращать исходный номер.</span><span class="sxs-lookup"><span data-stu-id="38e1f-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="38e1f-141">Однако в некоторых случаях потеря точности значений с плавающей запятой может привести к небольшие различия между двумя значениями, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="38e1f-142">Точно так же, в следующем примере, который вычисляет квадратный корень из <xref:System.Numerics.Complex> number, создает немного другие результаты для 32-разрядных и IA64 версий платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="38e1f-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="38e1f-143">Комплексные числа, бесконечности и NaN</span><span class="sxs-lookup"><span data-stu-id="38e1f-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="38e1f-144">И действительная и мнимая части комплексного числа, представляются <xref:System.Double> значения.</span><span class="sxs-lookup"><span data-stu-id="38e1f-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="38e1f-145">В дополнение к от <xref:System.Double.MinValue?displayProperty=nameWithType> для <xref:System.Double.MaxValue?displayProperty=nameWithType>, реальных или мнимая часть комплексного числа может иметь значение <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, или <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38e1f-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, и <xref:System.Double.NaN?displayProperty=nameWithType> все распространяются в любой арифметические и тригонометрические операции.</span><span class="sxs-lookup"><span data-stu-id="38e1f-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="38e1f-147">В следующем примере, деление <xref:System.Numerics.Complex.Zero> выдает комплексное число, Вещественная и мнимая части которого являются <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38e1f-148">В результате выполнение умножения с этим значением также создает комплексное число, Вещественная и мнимая части которого являются <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38e1f-149">Аналогичным образом, выполнение умножения, вызывающих переполнение диапазон <xref:System.Double> типа создает комплексное число, Вещественная часть <xref:System.Double.NaN?displayProperty=nameWithType> и мнимая часть <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38e1f-150">Впоследствии выполнение операции деления с помощью комплексного числа возвращает комплексное число, Вещественная часть <xref:System.Double.NaN?displayProperty=nameWithType> и мнимая часть <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="38e1f-151">Математические операции с комплексными числами, которые являются недопустимыми или который выйдет за пределы <xref:System.Double> тип данных не вызывают исключение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="38e1f-152">Вместо этого они возвращают <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, или <xref:System.Double.NaN?displayProperty=nameWithType> при следующих условиях:</span><span class="sxs-lookup"><span data-stu-id="38e1f-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="38e1f-153">Деления положительного числа, ноль возвращает <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="38e1f-154">Любая операция, которая вызывает переполнение верхнюю границу <xref:System.Double> возвращает тип данных <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="38e1f-155">Деления отрицательного числа, ноль возвращает <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="38e1f-156">Любая операция, которая вызывает переполнение нижняя граница <xref:System.Double> возвращает тип данных <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="38e1f-157">Разделение нулю на ноль возвращает <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="38e1f-158">Любая операция, которая выполняется для операндов, значения которого являются <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, или <xref:System.Double.NaN?displayProperty=nameWithType> возвращает <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, или <xref:System.Double.NaN?displayProperty=nameWithType>в зависимости от конкретной операции.</span><span class="sxs-lookup"><span data-stu-id="38e1f-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="38e1f-159">Обратите внимание на то, что это относится к любой промежуточных вычислений, выполняемых с помощью метода.</span><span class="sxs-lookup"><span data-stu-id="38e1f-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="38e1f-160">Например, умножение `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` формулу (ac - bd) + (ad + bc) я.</span><span class="sxs-lookup"><span data-stu-id="38e1f-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="38e1f-161">Вычисление действительных компонентов, полученный в результате умножения вычисляет выражение 9e308 * 2.5 - 9e308 * 3.5.</span><span class="sxs-lookup"><span data-stu-id="38e1f-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="38e1f-162">Возвращает каждый промежуточный умножения в этом выражении <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>и попытки для вычитания <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> из <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> возвращает <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="38e1f-163">Форматирование комплексного числа</span><span class="sxs-lookup"><span data-stu-id="38e1f-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="38e1f-164">По умолчанию строковое представление комплексного числа принимает форму `(` *реальных* `,` *мнимой*`)`, где *реальных* и *мнимой* являются строковыми представлениями <xref:System.Double> значений, образующих вещественными и мнимыми комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="38e1f-165">Некоторые перегруженные версии <xref:System.Numerics.Complex.ToString%2A> метод позволяет настраивать строковыми представлениями этих <xref:System.Double> значения с учетом правил форматирования конкретного языка и региональных параметров или для отображения в определенном формате, заданном по стандартного или настраиваемого числового Строка формата.</span><span class="sxs-lookup"><span data-stu-id="38e1f-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="38e1f-166">(Дополнительные сведения см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="38e1f-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="38e1f-167">Один из наиболее распространенных способов задания строкового представления комплексного числа принимает форму a + bi, где — комплексное число, вещественная, а b — мнимая часть комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="38e1f-168">В электротехнике наиболее часто выражается комплексного числа + bj.</span><span class="sxs-lookup"><span data-stu-id="38e1f-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="38e1f-169">В любом из этих двух видах может возвращать строковое представление комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="38e1f-170">Для этого определение поставщика пользовательского формата, реализовав <xref:System.ICustomFormatter> и <xref:System.IFormatProvider> интерфейсы, а затем вызовите <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="38e1f-171">В следующем примере определяется `ComplexFormatter` класс, который представляет комплексное число в виде строки в формате "+" бизнес-аналитики или + bj.</span><span class="sxs-lookup"><span data-stu-id="38e1f-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="38e1f-172">Следующий пример затем использует этот пользовательский модуль форматирования для отображения строкового представления комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">
          <span data-ttu-id="38e1f-173">Действительная часть комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-173">The real part of the complex number.</span>
          </span>
        </param>
        <param name="imaginary">
          <span data-ttu-id="38e1f-174">Мнимая часть комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-174">The imaginary part of the complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-175">Инициализирует новый экземпляр структуры <see cref="T:System.Numerics.Complex" /> с использованием заданных значений действительного и мнимого чисел.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-176">`real` Или `imaginary` аргументов может уменьшиться точность, если они являются типами данных, которые требуется явное приведение к <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-177">Следующий пример создает два комплексных числа, а затем использует их в операции сложения, вычитания, умножения и деления.</span><span class="sxs-lookup"><span data-stu-id="38e1f-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-178">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-178">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-179">Возвращает абсолютное значение (или величину) комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-179">Gets the absolute value (or magnitude) of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-180">Абсолютное значение параметра <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-180">The absolute value of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-181">Абсолютное значение комплексного числа эквивалентно его <xref:System.Numerics.Complex.Magnitude%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="38e1f-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="38e1f-182">Абсолютное значение вещественного числа + bi вычисляется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="38e1f-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="38e1f-183">Если b = 0, результат равен 0.</span><span class="sxs-lookup"><span data-stu-id="38e1f-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="38e1f-184">Если > b, результатом является \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="38e1f-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="38e1f-185">Если b >, результатом является b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 +<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="38e1f-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="38e1f-186">Если вычисление абсолютного значения приводит к переполнению, метод возвращает либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38e1f-187">Если параметр <xref:System.Numerics.Complex.Real%2A> или <xref:System.Numerics.Complex.Imaginary%2A> свойство <xref:System.Double.NaN?displayProperty=nameWithType> и другие свойства не является ни <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> , ни <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, метод возвращает <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-188">В следующем примере Вычисляет абсолютное значение комплексного числа и демонстрирует, что эквивалентно значению <xref:System.Numerics.Complex.Magnitude%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="38e1f-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-189">Комплексное число, представляющее косинус.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-189">A complex number that represents a cosine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-190">Возвращает угол, представляющий собой арккосинус указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-190">Returns the angle that is the arc cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-191">Угол (в радианах), представляющий собой арккосинус параметра <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-192"><xref:System.Numerics.Complex.Acos%2A> Метод для комплексных чисел соответствует <xref:System.Math.Acos%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-193"><xref:System.Numerics.Complex.Acos%2A> Метод использует следующую формулу:</span><span class="sxs-lookup"><span data-stu-id="38e1f-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="38e1f-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="38e1f-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="38e1f-195">В следующем примере показано <xref:System.Numerics.Complex.Acos%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="38e1f-196">Он показывает, передавая значение, возвращенное <xref:System.Numerics.Complex.Acos%2A> метод <xref:System.Numerics.Complex.Cos%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-197">Первое комплексное число для сложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-197">The first complex number to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-198">Второе комплексное число для сложения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-198">The second complex number to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-199">Складывает два комплексных числа и возвращает результат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-199">Adds two complex numbers and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-200">Сумма <paramref name="left" /> и <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-201">Добавление сложных number "," a + bi, и второе комплексное число, c + di, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-202">(a + c) + (b + d) я.</span><span class="sxs-lookup"><span data-stu-id="38e1f-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="38e1f-203">Если метод результаты вызова переполнение в любом реальном или мнимая компонента, компонент значение либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-204">Можно использовать языки, которые не поддерживают пользовательские операторы <xref:System.Numerics.Complex.Add%2A> метод для выполнения сложения с комплексными числами.</span><span class="sxs-lookup"><span data-stu-id="38e1f-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-205">В следующем примере показано сложение комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-206">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-206">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-207">Возвращает угол, представляющий собой арксинус указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-207">Returns the angle that is the arc sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-208">Угол, представляющий собой арксинус параметра <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-208">The angle which is the arc sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-209"><xref:System.Numerics.Complex.Asin%2A> Метод для комплексных чисел соответствует <xref:System.Math.Asin%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-210"><xref:System.Numerics.Complex.Asin%2A> Метод использует следующую формулу:</span><span class="sxs-lookup"><span data-stu-id="38e1f-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="38e1f-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* значение + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -значение \* значение))</span><span class="sxs-lookup"><span data-stu-id="38e1f-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="38e1f-212">В следующем примере показано <xref:System.Numerics.Complex.Asin%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="38e1f-213">Он показывает, передавая значение, возвращенное <xref:System.Numerics.Complex.Asin%2A> метод <xref:System.Numerics.Complex.Sin%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-214">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-214">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-215">Возвращает угол, представляющий собой арктангенс указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-215">Returns the angle that is the arc tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-216">Угол, представляющий собой арктангенс параметра <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-216">The angle that is the arc tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-217"><xref:System.Numerics.Complex.Atan%2A> Метод для комплексных чисел соответствует <xref:System.Math.Atan%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-218"><xref:System.Numerics.Complex.Atan%2A> Метод использует следующую формулу:</span><span class="sxs-lookup"><span data-stu-id="38e1f-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="38e1f-219"><xref:System.Numerics.Complex.ImaginaryOne> / Создание комплексного (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* значение)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* значение)</span><span class="sxs-lookup"><span data-stu-id="38e1f-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="38e1f-220">В следующем примере показано <xref:System.Numerics.Complex.Atan%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="38e1f-221">Он показывает, передавая значение, возвращенное <xref:System.Numerics.Complex.Atan%2A> метод <xref:System.Numerics.Complex.Tan%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-222">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-222">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-223">Вычисляет сопряженное число комплексного числа и возвращает результат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-223">Computes the conjugate of a complex number and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-224">Сопряженное число для <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-224">The conjugate of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-225">Сопряженное число комплексного числа инвертирует знак мнимую; то есть применяется Унарное отрицание мнимую.</span><span class="sxs-lookup"><span data-stu-id="38e1f-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="38e1f-226">Если + bi — это комплексное число, его сопряженной величины является элемента - bi.</span><span class="sxs-lookup"><span data-stu-id="38e1f-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-227">В следующем примере отображается сопряженное число для двух комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-228">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-228">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-229">Возвращает косинус указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-229">Returns the cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-230">Косинус <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-230">The cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-231"><xref:System.Numerics.Complex.Cos%2A> Метод для комплексных чисел соответствует <xref:System.Math.Cos%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-232"><xref:System.Numerics.Complex.Cos%2A> Метод использует следующую формулу для вычисления косинус комплексного числа a + bi:</span><span class="sxs-lookup"><span data-stu-id="38e1f-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="38e1f-233">(<xref:System.Math.Cos%2A>() * <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>() * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="38e1f-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-234">В следующем примере показано <xref:System.Numerics.Complex.Acos%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="38e1f-235">Он показывает, передавая значение, возвращенное <xref:System.Numerics.Complex.Acos%2A> метод <xref:System.Numerics.Complex.Cos%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-236">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-236">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-237">Возвращает гиперболический косинус указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-237">Returns the hyperbolic cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-238">Гиперболический косинус <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-238">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-239"><xref:System.Numerics.Complex.Cosh%2A> Метод для комплексных чисел соответствует <xref:System.Math.Cosh%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-240"><xref:System.Numerics.Complex.Cosh%2A> Метод использует следующую формулу для вычисления гиперболический косинус комплексного числа a + bi:</span><span class="sxs-lookup"><span data-stu-id="38e1f-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="38e1f-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="38e1f-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">
          <span data-ttu-id="38e1f-242">Комплексное число-числитель.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-242">The complex number to be divided.</span>
          </span>
        </param>
        <param name="divisor">
          <span data-ttu-id="38e1f-243">Комплексное число-знаменатель.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-243">The complex number to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-244">Делит одно комплексное число на другое и возвращает результат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-244">Divides one complex number by another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-245">Частное от деления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-245">The quotient of the division.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-246">Деление комплексного числа + bi, второе комплексное число, число, c + di, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-247">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) я</span><span class="sxs-lookup"><span data-stu-id="38e1f-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="38e1f-248">Если результатом вычисления частного переполнение в реальном или мнимая компонента, значение этого компонента является либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-249"><xref:System.Numerics.Complex.Divide%2A> Метод может использоваться в языках, которые не поддерживают пользовательские операторы.</span><span class="sxs-lookup"><span data-stu-id="38e1f-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="38e1f-250">Его поведение идентично поведению деления, используя оператор деления.</span><span class="sxs-lookup"><span data-stu-id="38e1f-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-251">Следующий пример делит каждый элемент массива комплексных чисел комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-252">Возвращает значение, указывающее, равны ли два комплексных числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-252">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-253">Комплексное число для сравнения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-253">The complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-254">Возвращает значение, указывающее, равны ли текущий экземпляр и указанное комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-255">Значение <see langword="true" />, если значения комплексного числа и <paramref name="value" /> совпадают; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-255">
              <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-256"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Предоставляет метод <xref:System.IEquatable%601> внедрению <xref:System.Numerics.Complex> структуры.</span><span class="sxs-lookup"><span data-stu-id="38e1f-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="38e1f-257">Он выполняет немного лучше, чем <xref:System.Numerics.Complex.Equals%28System.Object%29> метод так как он имеет для преобразования его параметра для комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="38e1f-258">Два комплексных числа равны, если равны их вещественные части и мнимые части равны.</span><span class="sxs-lookup"><span data-stu-id="38e1f-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="38e1f-259"><xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Метод является эквивалентом следующего выражения:</span><span class="sxs-lookup"><span data-stu-id="38e1f-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="38e1f-260">
            <para>Используйте <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> метод с осторожностью, поскольку два значения, которые внешне эквивалентны могут считаться неравными из-за различий в точности своих вещественной и мнимой компонентов. В следующем примере сообщается, <c>(3.33333, 0.142857)</c> и <c>(10/3, 1/7)</c> не равны.  [! code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! код vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)] один из рекомендуемых приемов — определить разницу между допустимого поля Эти два значения (такие как. 01% одного из значений вещественными и мнимыми) вместо сравнения значений на равенство. Если абсолютное значение разницы между двумя значениями меньше или равна предельному, разница может не из-за различия в точности и, таким образом, значения равны. В следующем примере этот метод используется для сравнения двух сложных значений, которые в предыдущем примере кода были не эквивалентны. Он находит два комплексных числа равны.  [! code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! код vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-260">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.  [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal. The following example uses this technique to compare the two complex values that the previous code example found to be unequal. It finds the two complex numbers to be equal.  [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="38e1f-261">Объект для сравнения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-261">The object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-262">Возвращает значение, определяющее, равны ли текущий экземпляр и указанный объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-262">Returns a value that indicates whether the current instance and a specified object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-263">Значение <see langword="true" />, если параметр <paramref name="obj" /> является объектом <see cref="T:System.Numerics.Complex" /> или типом, поддерживающим неявное преобразование в объект <see cref="T:System.Numerics.Complex" />, а его значение равняется текущему объекту <see cref="T:System.Numerics.Complex" />; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-263">
              <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-264">Два комплексных числа равны, если равны их вещественные части и мнимые части равны.</span><span class="sxs-lookup"><span data-stu-id="38e1f-264">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="38e1f-265"><xref:System.Numerics.Complex.Equals%28System.Object%29> Метод является эквивалентом следующего выражения:</span><span class="sxs-lookup"><span data-stu-id="38e1f-265">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="38e1f-266">Если `obj` параметр не <xref:System.Numerics.Complex> объект, но он является типом данных, для которого определен неявное преобразование, <xref:System.Numerics.Complex.Equals%28System.Object%29> метод преобразует `obj` для <xref:System.Numerics.Complex> объекта, действительная часть которого равно значению `obj`и мнимая часть равна нулю, перед проведением сравнения.</span><span class="sxs-lookup"><span data-stu-id="38e1f-266">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="38e1f-267">Следующий пример иллюстрирует поиск комплексного числа, а значение с плавающей запятой двойной точности, равны.</span><span class="sxs-lookup"><span data-stu-id="38e1f-267">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="38e1f-268">
            <para>Используйте <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> метод с осторожностью, поскольку два значения, которые внешне эквивалентны могут считаться неравными из-за различий в точности своих вещественной и мнимой компонентов. Проблема может быть осложнена, если <paramref name="obj" /> должны быть преобразованы в <see cref="T:System.Double" /> перед выполнением сравнения. В следующем примере сравнивается комплексное число, вещественная отображается должно быть равно <see cref="T:System.Single" /> значения <see cref="T:System.Single" /> значение. Как показывает вывод, сравнение на предмет равенства возвращает <see langword="False" />.  [! code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! код vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)] один из рекомендуемых приемов — определить различие между ними допустимого поля значения (например. 01% одного из значений вещественными и мнимыми) вместо сравнения значений на равенство. Если абсолютное значение разницы между двумя значениями меньше или равна предельному, разница может не из-за различия в точности, и, таким образом, значения равны. В следующем примере этот метод используется для сравнения двух значений, которые в предыдущем примере кода были не эквивалентны. Теперь она находит их равными.  [! code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! код vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-268">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison. The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value. As the output shows, the comparison for equality returns <see langword="False" />.  [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare the two values that the previous code example found to be unequal. It now finds them to be equal.  [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-269">Комплексное число, определяющее степень.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-269">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-270">Возвращает число <see langword="e" />, возведенное в степень, определяемую комплексным числом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-270">Returns <see langword="e" /> raised to the power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-271">Число <see langword="e" />, возведенное в степень <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-271">The number <see langword="e" /> raised to the power <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-272">Используйте <xref:System.Numerics.Complex.Pow%2A> метод для вычисления степеней с другими основаниями.</span><span class="sxs-lookup"><span data-stu-id="38e1f-272">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="38e1f-273"><xref:System.Numerics.Complex.Exp%2A> Метод для комплексных чисел соответствует <xref:System.Math.Exp%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-273">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="38e1f-274"><xref:System.Numerics.Complex.Exp%2A> обратна <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-274"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-275">В следующем примере показано <xref:System.Numerics.Complex.Exp%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-275">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="38e1f-276">Он показывает, что, с помощью некоторых лимит для отсутствия точность <xref:System.Double> тип данных, передав значение, возвращенное <xref:System.Numerics.Complex.Log%2A> метод <xref:System.Numerics.Complex.Exp%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-276">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">
          <span data-ttu-id="38e1f-277">Модуль, т. е. расстояние от начала координат (точки пересечения осей X и Y) до числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-277">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span>
          </span>
        </param>
        <param name="phase">
          <span data-ttu-id="38e1f-278">Фаза, т. е. угол от прямой до горизонтальной оси в радианах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-278">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-279">Создает комплексное число из полярных координат точки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-279">Creates a complex number from a point's polar coordinates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-280">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-280">A complex number.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-281"><xref:System.Numerics.Complex.FromPolarCoordinates%2A> Метод создает комплексное число, на основе его полярных координат.</span><span class="sxs-lookup"><span data-stu-id="38e1f-281">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="38e1f-282">Так как существует несколько представлений точки на комплексной плоскости, возвращаемое значение <xref:System.Numerics.Complex.FromPolarCoordinates%2A> нормализуется метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-282">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="38e1f-283">Абсолютное значение нормализуется положительное число, а фазы нормализуется со значением в диапазоне от -<xref:System.Math.PI> для <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-283">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="38e1f-284">В результате значения <xref:System.Numerics.Complex.Phase%2A> и <xref:System.Numerics.Complex.Magnitude%2A> свойства сложное число не может быть равно исходные значения `magnitude` и `phase` параметров.</span><span class="sxs-lookup"><span data-stu-id="38e1f-284">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="38e1f-285">Для преобразования значения из градусов в радианы для `phase` параметра, умножьте его по  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="38e1f-285">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-286">В следующем примере используется <xref:System.Numerics.Complex.FromPolarCoordinates%2A> метод для создания экземпляра в комплексное число на основе его полярных координат, а затем отображает значение его <xref:System.Numerics.Complex.Magnitude%2A> и <xref:System.Numerics.Complex.Phase%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="38e1f-286">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-287">Возвращает хэш-код для текущего объекта <see cref="T:System.Numerics.Complex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-287">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-288">Хэш-код в виде 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-288">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-289">Получает мнимую часть текущего объекта <see cref="T:System.Numerics.Complex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-289">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="38e1f-290">Мнимая часть комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-290">The imaginary component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-291">Учитывая комплексного числа a + bi, <xref:System.Numerics.Complex.Imaginary%2A> свойство возвращает значение b.</span><span class="sxs-lookup"><span data-stu-id="38e1f-291">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-292">В следующем примере создается массив <xref:System.Numerics.Complex> объектов и отображает компоненты вещественной и мнимой каждого в форме "+" бизнес-аналитики.</span><span class="sxs-lookup"><span data-stu-id="38e1f-292">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-293">Возвращает новый экземпляр объекта <see cref="T:System.Numerics.Complex" /> со значением действительного числа, равным нулю, и значением мнимого числа, равным единице.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-293">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="38e1f-294">В следующем примере создается <xref:System.Numerics.Complex> значение с помощью <xref:System.Numerics.Complex.ImaginaryOne> свойство.</span><span class="sxs-lookup"><span data-stu-id="38e1f-294">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="38e1f-295">Затем сравнивает это значение на другое значение, экземпляр которого создается путем вызова <xref:System.Numerics.Complex> конструктор с вещественной части, равным нулю и мнимой частью равно единице.</span><span class="sxs-lookup"><span data-stu-id="38e1f-295">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="38e1f-296">Как видно из примера, два значения равны.</span><span class="sxs-lookup"><span data-stu-id="38e1f-296">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-297">Возвращает логарифм комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-297">Returns the logarithm of a complex number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-298">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-298">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-299">Возвращает натуральный логарифм (по основанию <see langword="e" />) указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-299">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-300">Натуральный логарифм (по основанию <see langword="e" />) значения <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-300">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-301"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> Метод для комплексных чисел соответствует <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-301">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-302">В следующем примере показано <xref:System.Numerics.Complex.Log%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-302">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="38e1f-303">Он показывает, что, с помощью некоторых лимит для отсутствия точность <xref:System.Double> тип данных, передав значение, возвращенное <xref:System.Numerics.Complex.Log%2A> метод <xref:System.Numerics.Complex.Exp%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-303">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-304">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-304">A complex number.</span>
          </span>
        </param>
        <param name="baseValue">
          <span data-ttu-id="38e1f-305">Основание логарифма.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-305">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-306">Возвращает логарифм по заданному основанию указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-306">Returns the logarithm of a specified complex number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-307">Логарифм <paramref name="value" /> по основанию <paramref name="baseValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-307">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-308"><xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> Метод для комплексных чисел соответствует <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-308">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-309">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-309">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-310">Возвращает логарифм по основанию 10 указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-310">Returns the base-10 logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-311">Логарифм <paramref name="value" /> по основанию 10.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-311">The base-10 logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-312"><xref:System.Numerics.Complex.Log10%2A> Метод для комплексных чисел соответствует <xref:System.Math.Log10%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-312">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-313">Возвращает модуль (или абсолютное значение) комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-313">Gets the magnitude (or absolute value) of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="38e1f-314">Модуль текущего экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-314">The magnitude of the current instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-315"><xref:System.Numerics.Complex.Magnitude%2A> Свойство является аналогом абсолютное значение комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-315">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="38e1f-316">Оно задает расстояние от начала координат (точки пересечения оси x и y в декартовой системе координат) двухмерный точка, представленная комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-316">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="38e1f-317">Абсолютное значение вычисляется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="38e1f-317">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="38e1f-318">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span><span class="sxs-lookup"><span data-stu-id="38e1f-318">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="38e1f-319">Если вычисление абсолютного значения приводит к переполнению, это свойство возвращает либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-319">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-320"><xref:System.Numerics.Complex.Magnitude%2A> И <xref:System.Numerics.Complex.Phase%2A> свойства определяют положение точки, который представляет комплексное число в полярных координат.</span><span class="sxs-lookup"><span data-stu-id="38e1f-320">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="38e1f-321">Можно создать экземпляр комплексного числа, на основе его полярных координат вместо декартовой системе координат, вызвав <xref:System.Numerics.Complex.FromPolarCoordinates%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-321">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-322">В следующем примере Вычисляет абсолютное значение комплексного числа и демонстрирует, что эквивалентно значению <xref:System.Numerics.Complex.Magnitude%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="38e1f-322">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-323">Первое комплексное число для перемножения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-323">The first complex number to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-324">Второе комплексное число для перемножения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-324">The second complex number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-325">Возвращает произведение двух комплексных чисел.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-325">Returns the product of two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-326">Произведение параметров <paramref name="left" /> и <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-326">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-327">Умножение сложных number "," a + bi, и второе комплексное число, c + di, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-327">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-328">(ac - bd) + (ad + bc) я</span><span class="sxs-lookup"><span data-stu-id="38e1f-328">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="38e1f-329">Если операция умножения приводит к переполнению в реальном или мнимая компонента, значение этого компонента является либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-329">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-330"><xref:System.Numerics.Complex.Multiply%2A> Метод реализуется для языков, которые не поддерживают пользовательские операторы.</span><span class="sxs-lookup"><span data-stu-id="38e1f-330">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="38e1f-331">Его поведение идентично поведению умножения, используя оператор умножения.</span><span class="sxs-lookup"><span data-stu-id="38e1f-331">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-332">Следующий пример кратные в комплексное число на каждый элемент массива комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-332">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-333">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-333">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-334">Возвращает аддитивную инверсию указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-334">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-335">Результат умножения частей <see cref="P:System.Numerics.Complex.Real" /> и <see cref="P:System.Numerics.Complex.Imaginary" /> параметра <paramref name="value" /> на -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-335">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-336">Аддитивная Инверсия комплексного числа — это комплексное число, которое дает значение <xref:System.Numerics.Complex> при его добавлении исходного комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-336">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="38e1f-337">Этот метод возвращает комплексное число, в котором компоненты вещественной и мнимой исходного комплексного числа умножаются на -1.</span><span class="sxs-lookup"><span data-stu-id="38e1f-337">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="38e1f-338"><xref:System.Numerics.Complex.Negate%2A> Метод реализуется для языков, которые не поддерживают пользовательские операторы.</span><span class="sxs-lookup"><span data-stu-id="38e1f-338">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="38e1f-339">Его поведение идентично поведению отрицания, с помощью оператора унарного отрицания <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-339">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-340">Следующий пример получает аддитивную инверсию каждого элемента в массиве комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-340">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-341">Возвращает новый экземпляр объекта <see cref="T:System.Numerics.Complex" /> со значением действительного числа, равным единице, и значением мнимого числа, равным нулю.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-341">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="38e1f-342">В следующем примере создается <xref:System.Numerics.Complex> значение с помощью <xref:System.Numerics.Complex.One> свойство.</span><span class="sxs-lookup"><span data-stu-id="38e1f-342">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="38e1f-343">Затем сравнивает это значение на другое значение, экземпляр которого создается путем вызова <xref:System.Numerics.Complex> конструктор с вещественной части, равным одному и мнимой частью равно нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-343">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="38e1f-344">Как видно из примера, два значения равны.</span><span class="sxs-lookup"><span data-stu-id="38e1f-344">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-345">Первое из складываемых значений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-345">The first value to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-346">Второе из складываемых значений.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-346">The second value to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-347">Складывает два комплексных числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-347">Adds two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-348">Сумма <paramref name="left" /> и <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-348">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-349"><xref:System.Numerics.Complex.op_Addition%2A> Метод определяет операцию сложения для комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-349">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="38e1f-350">В результате следующий код:</span><span class="sxs-lookup"><span data-stu-id="38e1f-350">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="38e1f-351">Добавление сложных number "," a + bi, и второе комплексное число, c + di, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-351">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-352">(a + c) + (b + d) я</span><span class="sxs-lookup"><span data-stu-id="38e1f-352">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="38e1f-353">Если метод результаты вызова переполнение в любом реальном или мнимая компонента, значение этого компонента является либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-353">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-354">Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.Complex.Add%2A> метод вместо этого.</span><span class="sxs-lookup"><span data-stu-id="38e1f-354">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="38e1f-355">Имеет эквивалентный метод для этого оператора <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="38e1f-355">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="38e1f-356">В следующем примере показано сложение комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-356">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-357">Значение, которое необходимо разделить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-357">The value to be divided.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-358">Значение, на которое необходимо разделить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-358">The value to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-359">Делит одно указанное комплексное число на другое.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-359">Divides a specified complex number by another specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-360">Результат деления <paramref name="left" /> на <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-360">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-361"><xref:System.Numerics.Complex.op_Division%2A> Метод определяет операцию деления для комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-361">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="38e1f-362">В результате следующий код:</span><span class="sxs-lookup"><span data-stu-id="38e1f-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="38e1f-363">Деления сложных number "," a + bi, и второе комплексное число, c + di, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-363">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-364">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) я</span><span class="sxs-lookup"><span data-stu-id="38e1f-364">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="38e1f-365">Если результатом деления переполнение в реальном или мнимая компонента, значение этого компонента, равен <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-365">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-366">Языки, которые не поддерживают пользовательские операторы и перегрузка операторов можно вызвать <xref:System.Numerics.Complex.Divide%2A> метод вместо этого.</span><span class="sxs-lookup"><span data-stu-id="38e1f-366">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="38e1f-367">Имеет эквивалентный метод для этого оператора <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="38e1f-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-368">Первое комплексное число для сравнения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-368">The first complex number to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-369">Второе комплексное число для сравнения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-369">The second complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-370">Возвращает значение, указывающее, равны ли два комплексных числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-370">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-371">Значение <see langword="true" />, если параметры <paramref name="left" /> и <paramref name="right" /> имеют одинаковые значения; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-371">
              <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-372"><xref:System.Numerics.Complex.op_Equality%2A> Метод определяет операцию от оператора равенства для <xref:System.Numerics.Complex> значения.</span><span class="sxs-lookup"><span data-stu-id="38e1f-372">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="38e1f-373">В результате следующий код:</span><span class="sxs-lookup"><span data-stu-id="38e1f-373">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="38e1f-374">Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> метод вместо этого.</span><span class="sxs-lookup"><span data-stu-id="38e1f-374">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="38e1f-375">Два комплексных числа равны, если равны их вещественные части и мнимые части равны.</span><span class="sxs-lookup"><span data-stu-id="38e1f-375">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="38e1f-376"><xref:System.Numerics.Complex.op_Equality%2A> Метод является эквивалентом следующего выражения:</span><span class="sxs-lookup"><span data-stu-id="38e1f-376">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="38e1f-377">Обратите внимание на то, что из-за различий в точности два комплексных числа, которые внешне эквивалентны могут считаться неравными.</span><span class="sxs-lookup"><span data-stu-id="38e1f-377">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="38e1f-378">Дополнительные сведения и возможное решение, см. в разделе <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-378">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="38e1f-379">Имеет эквивалентный метод для этого оператора <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="38e1f-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-380">Определяет явное преобразование между объектом типа <see cref="T:System.Numerics.Complex" /> и другим типом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-380">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-381">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-381">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-382">Определяет явное преобразование значения <see cref="T:System.Decimal" /> в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-382">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-383">Комплексное число, вещественная часть которого равна параметру <paramref name="value" />, а мнимая часть равна нулю.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-383">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-384">Операторы явного преобразования определяют типы, которые могут быть преобразованы <xref:System.Numerics.Complex> объекта.</span><span class="sxs-lookup"><span data-stu-id="38e1f-384">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="38e1f-385">Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных.</span><span class="sxs-lookup"><span data-stu-id="38e1f-385">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="38e1f-386">Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (например, `CType` в Visual Basic) используется.</span><span class="sxs-lookup"><span data-stu-id="38e1f-386">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="38e1f-387">В противном случае они отображают ошибку компилятора.</span><span class="sxs-lookup"><span data-stu-id="38e1f-387">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="38e1f-388">Преобразование <xref:System.Decimal> значение вещественной части комплексного числа может привести к потере точности, так как <xref:System.Double>, который является типом комплексного числа <xref:System.Numerics.Complex.Real%2A> , имеет меньше значимых цифр, чем <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-388">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="38e1f-389">В следующем примере показано явное преобразование объекта <xref:System.Decimal> значения <xref:System.Numerics.Complex> значения.</span><span class="sxs-lookup"><span data-stu-id="38e1f-389">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-390">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-390">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-391">Определяет явное преобразование значения <see cref="T:System.Numerics.BigInteger" /> в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-391">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-392">Комплексное число, вещественная часть которого равна параметру <paramref name="value" />, а мнимая часть равна нулю.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-392">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-393">Операторы явного преобразования определяют типы, которые могут быть преобразованы <xref:System.Numerics.Complex> объекта.</span><span class="sxs-lookup"><span data-stu-id="38e1f-393">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="38e1f-394">Языковые компиляторы не выполняют это преобразование автоматически, так как он может привести к потере данных.</span><span class="sxs-lookup"><span data-stu-id="38e1f-394">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="38e1f-395">Вместо этого они выполняют преобразование только в том случае, если оператор приведения (в C#) или функции преобразования (например, `CType` в Visual Basic) используется.</span><span class="sxs-lookup"><span data-stu-id="38e1f-395">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="38e1f-396">В противном случае они отображают ошибку компилятора.</span><span class="sxs-lookup"><span data-stu-id="38e1f-396">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="38e1f-397">Преобразование <xref:System.Numerics.BigInteger> значение вещественной части комплексного числа может привести к потере точности, так как <xref:System.Double>, который является типом комплексного числа <xref:System.Numerics.Complex.Real%2A> , имеет меньше значимых цифр, чем <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-397">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="38e1f-398">Если преобразование завершается неудачно из-за <xref:System.Numerics.BigInteger> значение находится за пределами диапазона <xref:System.Double> тип, не вызывает операцию <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-398">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="38e1f-399">Вместо этого Если `value` — меньше, чем <xref:System.Double.MinValue>, результат — это комплексное число, имеющее <xref:System.Numerics.Complex.Real%2A> свойство-значение, равное <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-399">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="38e1f-400">Если `value` больше, чем <xref:System.Double.MaxValue>, результат — это комплексное число, имеющее <xref:System.Numerics.Complex.Real%2A> свойство-значение, равное <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-400">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="38e1f-401">В следующем примере показано явное преобразование объекта <xref:System.Numerics.BigInteger> значения <xref:System.Numerics.Complex> значения.</span><span class="sxs-lookup"><span data-stu-id="38e1f-401">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-402">Определяет неявное преобразование объекта типа <see cref="T:System.Numerics.Complex" /> в другой тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-402">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-403">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-403">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-404">Определяет неявное преобразование байта без знака в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-404">Defines an implicit conversion of an unsigned byte to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-405">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-405">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-406">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-406">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-407">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-407">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-408">Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.Byte> комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-408">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-409">Обратите внимание, что результат преобразования — это комплексное число, Вещественная часть равен <xref:System.Byte> значение и мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-409">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-410">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-410">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-411">Определяет неявное преобразование числа с плавающей запятой двойной точности в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-411">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-412">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-412">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-413">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-413">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-414">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-414">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-415">Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.Double> комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-415">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-416">Обратите внимание, что результат преобразования — это комплексное число, Вещественная часть равен <xref:System.Double> значение и мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-416">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-417">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-417">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-418">Определяет неявное преобразование 16-битового целого числа со знаком в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-418">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-419">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-419">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-420">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-420">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-421">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-421">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-422">Эта перегрузка позволяет компилятору обрабатывать преобразования из 16-разрядное целое число со знаком в комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-422">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-423">Обратите внимание на то, что результатом преобразования является комплексное число, Вещественная часть равен 16-битового знакового целого числа, а мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-423">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-424">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-424">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-425">Определяет неявное преобразование 32-битового целого числа со знаком в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-425">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-426">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-426">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-427">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-427">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-428">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-428">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-429">Эта перегрузка позволяет компилятору обрабатывать преобразования из 32-битового знакового целого числа в комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-429">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-430">Обратите внимание на то, что результатом преобразования является комплексное число, Вещественная часть равен 32-битового знакового целого числа, а мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-430">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-431">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-431">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-432">Определяет неявное преобразование 64-битового целого числа со знаком в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-432">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-433">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-433">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-434">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-434">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-435">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-435">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-436">Эта перегрузка позволяет компилятору обрабатывать преобразования из 64-битового знакового целого числа в комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-436">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-437">Обратите внимание на то, что результатом преобразования является комплексное число, Вещественная часть равен 64-битового знакового целого числа, а мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-437">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-438">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-438">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-439">Определяет неявное преобразование байта со знаком в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-439">Defines an implicit conversion of a signed byte to a complex number.</span>
          </span>
          <span data-ttu-id="38e1f-440">Этот интерфейс API CLS-несовместим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-440">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-441">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-441">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-442">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-442">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-443">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-443">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-444">Эта перегрузка позволяет компилятору обрабатывать преобразования байт со знаком в комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-444">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-445">Обратите внимание на то, что результатом преобразования является комплексное число, Вещественная часть равен байт со знаком, а мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-445">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-446">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-446">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-447">Определяет неявное преобразование числа с плавающей запятой одиночной точности в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-447">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-448">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-448">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-449">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-449">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-450">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-450">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-451">Эта перегрузка позволяет компилятору обрабатывать преобразования из <xref:System.Single> комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-451">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-452">Обратите внимание, что результат преобразования — это комплексное число, Вещественная часть равен <xref:System.Single> значение и мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-452">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-453">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-453">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-454">Определяет неявное преобразование 16-битного целого числа без знака в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-454">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="38e1f-455">Этот интерфейс API CLS-несовместим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-455">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-456">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-456">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-457">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-457">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-458">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-458">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-459">Эта перегрузка позволяет компилятору обрабатывать преобразования из 16-разрядное целое число без знака в комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-459">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-460">Обратите внимание на то, что результатом преобразования является комплексное число, Вещественная часть равен 16-разрядное целое число без знака, а мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-460">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-461">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-461">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-462">Определяет неявное преобразование 32-битного целого числа без знака в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-462">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="38e1f-463">Этот интерфейс API CLS-несовместим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-463">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-464">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-464">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-465">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-465">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-466">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-466">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-467">Эта перегрузка позволяет компилятору обрабатывать преобразования из 32-разрядное целое число без знака в комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-467">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-468">Обратите внимание на то, что результатом преобразования является комплексное число, Вещественная часть равен 32-разрядное целое число без знака, а мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-468">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-469">Значение, преобразуемое в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-469">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-470">Определяет неявное преобразование 64-битного целого числа без знака в комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-470">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="38e1f-471">Этот интерфейс API CLS-несовместим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-471">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-472">Объект, содержащий значение параметра <paramref name="value" /> как действительную часть и ноль как мнимую часть.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-472">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-473">Перегрузки <xref:System.Numerics.Complex.op_Implicit%2A> оператор определения типов, из которых компилятор будет автоматически преобразован <xref:System.Numerics.Complex> объекта без оператора явного приведения (в C#) или вызов функции преобразования (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="38e1f-473">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="38e1f-474">Они являются расширяющими преобразованиями, которые не привести к потере данных и не вызывают <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-474">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="38e1f-475">Эта перегрузка позволяет компилятору обрабатывать преобразования из 64-разрядное целое число без знака в комплексное число, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="38e1f-475">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="38e1f-476">Обратите внимание на то, что результатом преобразования является комплексное число, Вещественная часть равен 64-разрядное целое число без знака, а мнимая часть равна нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-476">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-477">Первое сравниваемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-477">The first value to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-478">Второе сравниваемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-478">The second value to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-479">Возвращает значение, указывающее, равны ли два комплексных числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-479">Returns a value that indicates whether two complex numbers are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-480">Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-480">
              <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-481"><xref:System.Numerics.Complex.op_Equality%2A> Метод определяет операцию, оператор неравенства для комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-481">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="38e1f-482">В результате следующий код:</span><span class="sxs-lookup"><span data-stu-id="38e1f-482">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="38e1f-483">Языки, которые не поддерживают пользовательские операторы можно проверить на предмет их неравенства, вызвав <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> метод и изменение его значения.</span><span class="sxs-lookup"><span data-stu-id="38e1f-483">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="38e1f-484">Обратите внимание на то, что из-за различий в точности два комплексных числа, которые внешне эквивалентны могут считаться неравными.</span><span class="sxs-lookup"><span data-stu-id="38e1f-484">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="38e1f-485">Одно возможное решение — реализовать метод сравнения, который возвращает `true` только в том случае, если разница между двумя вещественной и мнимой частей комплексных чисел превышает определенный порог (такие как. 01% значения действительной или мнимой компонента одно из комплексных чисел).</span><span class="sxs-lookup"><span data-stu-id="38e1f-485">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="38e1f-486">Дополнительные сведения см. в описании метода <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-486">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-487">Первое значение для перемножения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-487">The first value to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-488">Второе значение для перемножения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-488">The second value to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-489">Перемножает два заданных комплексных числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-489">Multiplies two specified complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-490">Произведение <paramref name="left" /> на <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-490">The product of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-491"><xref:System.Numerics.Complex.op_Multiply%2A> Метод определяет операцию, оператор умножения для комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-491">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="38e1f-492">В результате следующий код:</span><span class="sxs-lookup"><span data-stu-id="38e1f-492">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="38e1f-493">Умножение сложных number "," a + bi, и второе комплексное число, c + di, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-493">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-494">(ac - bd) + (ad + bc) я</span><span class="sxs-lookup"><span data-stu-id="38e1f-494">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="38e1f-495">Если операция умножения приводит к переполнению в реальном или мнимая компонента, значение этого компонента является либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-495">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-496">Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.Complex.Multiply%2A> метод вместо этого.</span><span class="sxs-lookup"><span data-stu-id="38e1f-496">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="38e1f-497">Имеет эквивалентный метод для этого оператора <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="38e1f-497">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-498">Значение, из которого следует вычитать (уменьшаемое).</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-498">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-499">Значение для вычитания (вычитаемое).</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-499">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-500">Вычитает комплексное число из другого комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-500">Subtracts a complex number from another complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-501">Результат вычитания <paramref name="right" /> из <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-501">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-502"><xref:System.Numerics.Complex.op_Subtraction%2A> Метод определяет операцию, оператор вычитания для комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-502">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="38e1f-503">В результате следующий код:</span><span class="sxs-lookup"><span data-stu-id="38e1f-503">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="38e1f-504">Если метод результаты вызова переполнение в любом реальном или мнимая компонента, значение этого компонента является либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-504">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-505">Вычитание комплексного числа, c + di, из другого комплексного числа + bi, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-505">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-506">(— c) + (b - d) я</span><span class="sxs-lookup"><span data-stu-id="38e1f-506">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="38e1f-507">Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.Complex.Subtract%2A> метод вместо этого.</span><span class="sxs-lookup"><span data-stu-id="38e1f-507">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="38e1f-508">Имеет эквивалентный метод для этого оператора <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="38e1f-508">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-509">Инвертируемое значение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-509">The value to negate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-510">Возвращает аддитивную инверсию указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-510">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-511">Результат умножения частей <see cref="P:System.Numerics.Complex.Real" /> и <see cref="P:System.Numerics.Complex.Imaginary" /> параметра <paramref name="value" /> на -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-511">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-512"><xref:System.Numerics.Complex.op_UnaryNegation%2A> Метод определяет операцию, оператор унарного отрицания (аддитивную инверсию) для комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-512">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="38e1f-513">В результате следующий код:</span><span class="sxs-lookup"><span data-stu-id="38e1f-513">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="38e1f-514">Сложное число дает значение <xref:System.Numerics.Complex> 0 (ноль), добавленное в исходном комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-514">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="38e1f-515">Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.Numerics.Complex.Negate%2A> метод вместо этого.</span><span class="sxs-lookup"><span data-stu-id="38e1f-515">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="38e1f-516">Имеет эквивалентный метод для этого оператора <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="38e1f-516">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-517">Возвращает фазу комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-517">Gets the phase of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="38e1f-518">Фаза комплексного числа в радианах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-518">The phase of a complex number, in radians.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-519">Для комплексного числа + бизнес-аналитики, стадия вычисляется как <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b).</span><span class="sxs-lookup"><span data-stu-id="38e1f-519">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="38e1f-520">Вы можете определить комплексного числа в декартовой системе координат на комплексной плоскости или его полярных координат.</span><span class="sxs-lookup"><span data-stu-id="38e1f-520">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="38e1f-521">Фаза (аргумент) комплексного числа — это угол на реальной оси, линии, рисуемой из точку начала координат (точки пересечения оси x и y) до точки, представленный комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-521">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="38e1f-522">Величина (представленный <xref:System.Numerics.Complex.Magnitude%2A> свойство) является расстоянием от точку начала координат в точку, представленного комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-522">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="38e1f-523">Можно создать экземпляр комплексного числа, на основе его полярных координат вместо декартовой системе координат, вызвав <xref:System.Numerics.Complex.FromPolarCoordinates%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-523">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="38e1f-524">Чтобы преобразовать на этапе из радиан в градусы, умножьте его на 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-524">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-525">В следующем примере используется <xref:System.Numerics.Complex.FromPolarCoordinates%2A> метод для создания экземпляра в комплексное число на основе его полярных координат, а затем отображает значение его <xref:System.Numerics.Complex.Magnitude%2A> и <xref:System.Numerics.Complex.Phase%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="38e1f-525">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-526">Возвращает указанное комплексное число, возведенное в заданную степень.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-526">Returns a specified complex number raised to a specified power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-527">Комплексное число для возведения в степень.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-527">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="38e1f-528">Число двойной точности с плавающей запятой, задающее степень.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-528">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-529">Возвращает заданное комплексное число, возведенное в степень, заданную числом с плавающей запятой двойной точности.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-529">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-530">Комплексное число <paramref name="value" />, возведенное в степень <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-530">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-531">Если значением параметра `value` является <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, метод возвращает <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-531">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38e1f-532">Для других значений Если `power` равен 0, метод возвращает <xref:System.Numerics.Complex.One?displayProperty=nameWithType>и если `power` имеет значение 1, он возвращает `value`.</span><span class="sxs-lookup"><span data-stu-id="38e1f-532">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="38e1f-533">Этот метод соответствует <xref:System.Math.Pow%2A?displayProperty=nameWithType> метод для числовых типов-примитивов.</span><span class="sxs-lookup"><span data-stu-id="38e1f-533">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-534">В следующем примере показано возведение в степень, с помощью комплексного числа и показателя степени в диапазоне значений от -1 до 10.</span><span class="sxs-lookup"><span data-stu-id="38e1f-534">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-535">Комплексное число для возведения в степень.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-535">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="38e1f-536">Комплексное число, определяющее степень.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-536">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-537">Возвращает заданное комплексное число, возведенное в степень, заданную комплексным числом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-537">Returns a specified complex number raised to a power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-538">Комплексное число <paramref name="value" />, возведенное в степень <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-538">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-539">Получает вещественную часть текущего объекта <see cref="T:System.Numerics.Complex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-539">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="38e1f-540">Действительная часть комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-540">The real component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-541">Учитывая комплексного числа a + bi, <xref:System.Numerics.Complex.Real%2A> свойство возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-541">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-542">В следующем примере создается массив <xref:System.Numerics.Complex> объектов и отображает компоненты вещественной и мнимой каждого в форме "+" бизнес-аналитики.</span><span class="sxs-lookup"><span data-stu-id="38e1f-542">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-543">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-543">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-544">Возвращает обратную величину комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-544">Returns the multiplicative inverse of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-545">Обратная величина значения <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-545">The reciprocal of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-546">Обратная величина значения, то есть обратную величину, число *x* — это число *y* где *x* умноженное *y* дает результат 1.</span><span class="sxs-lookup"><span data-stu-id="38e1f-546">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="38e1f-547">Обратная величина комплексного числа — это комплексное число, которое создает <xref:System.Numerics.Complex.One?displayProperty=nameWithType> при два числа перемножаются.</span><span class="sxs-lookup"><span data-stu-id="38e1f-547">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="38e1f-548">Если a + bi представлен в комплексное число, его обратную представляется с помощью выражения / (<sup>2</sup>+ b<sup>2</sup>) + -b / (<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="38e1f-548">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="38e1f-549">Если значение равно <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, метод возвращает <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-549">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="38e1f-550">В противном случае возвращается результат выражения <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="38e1f-550">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-551">В следующем примере используется <xref:System.Numerics.Complex.Reciprocal%2A> метод для вычисления значений взаимные несколько комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-551">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="38e1f-552">Он также демонстрирует, что результатом умножения его обратная величина комплексного числа <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-552">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-553">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-553">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-554">Возвращает синус указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-554">Returns the sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-555">Синус <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-555">The sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-556"><xref:System.Numerics.Complex.Sin%2A> Метод для комплексных чисел соответствует <xref:System.Math.Sin%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-556">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-557"><xref:System.Numerics.Complex.Sin%2A> Метод использует следующую формулу для вычисления синус комплексного числа a + bi:</span><span class="sxs-lookup"><span data-stu-id="38e1f-557">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="38e1f-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="38e1f-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-559">В следующем примере показано <xref:System.Numerics.Complex.Sin%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-559">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="38e1f-560">Он показывает, передавая значение, возвращенное <xref:System.Numerics.Complex.Asin%2A> метод <xref:System.Numerics.Complex.Sin%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-560">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-561">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-561">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-562">Возвращает гиперболический синус указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-562">Returns the hyperbolic sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-563">Гиперболический синус <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-563">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-564"><xref:System.Numerics.Complex.Sinh%2A> Метод для комплексных чисел соответствует <xref:System.Math.Sinh%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-564">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-565"><xref:System.Numerics.Complex.Sinh%2A> Метод использует следующую формулу для вычисления гиперболический синус комплексного числа a + bi:</span><span class="sxs-lookup"><span data-stu-id="38e1f-565">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="38e1f-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="38e1f-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-567">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-567">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-568">Возвращает квадратный корень из указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-568">Returns the square root of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-569">Квадратный корень числа <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-569">The square root of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-570">Квадратный корень из комплексного числа `value` вычисляется по следующей формуле:</span><span class="sxs-lookup"><span data-stu-id="38e1f-570">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="38e1f-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> / 2.0)</span><span class="sxs-lookup"><span data-stu-id="38e1f-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="38e1f-572"><xref:System.Numerics.Complex.Sqrt%2A> Метод для комплексных чисел соответствует <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-572">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="38e1f-573">Значение, из которого следует вычитать (уменьшаемое).</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-573">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="38e1f-574">Значение для вычитания (вычитаемое).</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-574">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-575">Вычитает одно комплексное число из другого и возвращает результат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-575">Subtracts one complex number from another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-576">Результат вычитания <paramref name="right" /> из <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-576">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-577">Вычитание комплексного числа, c + di, из другого комплексного числа + bi, имеет следующий вид:</span><span class="sxs-lookup"><span data-stu-id="38e1f-577">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="38e1f-578">(— c) + (b - d) я</span><span class="sxs-lookup"><span data-stu-id="38e1f-578">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="38e1f-579">Если метод результаты вызова переполнение в любом реальном или мнимая компонента, значение этого компонента является либо <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> или <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-579">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="38e1f-580">Можно использовать языки, которые не поддерживают пользовательские операторы <xref:System.Numerics.Complex.Subtract%2A> метод для выполнения вычитания с помощью комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-580">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-581">Следующий пример вычитает каждый комплексного числа в виде массива, из комплексного числа.</span><span class="sxs-lookup"><span data-stu-id="38e1f-581">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-582">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-582">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-583">Возвращает тангенс указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-583">Returns the tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-584">Тангенс <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-584">The tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-585"><xref:System.Numerics.Complex.Tan%2A> Метод для комплексных чисел соответствует <xref:System.Math.Tan%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-585">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-586"><xref:System.Numerics.Complex.Tan%2A> Метод использует следующую формулу для вычисления тангенс комплексного числа `value`:</span><span class="sxs-lookup"><span data-stu-id="38e1f-586">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="38e1f-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="38e1f-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-588">В следующем примере показано <xref:System.Numerics.Complex.Tan%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="38e1f-588">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="38e1f-589">Он показывает, передавая значение, возвращенное <xref:System.Numerics.Complex.Atan%2A> метод <xref:System.Numerics.Complex.Tan%2A> метод возвращается исходное <xref:System.Numerics.Complex> значение.</span><span class="sxs-lookup"><span data-stu-id="38e1f-589">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="38e1f-590">Комплексное число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-590">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-591">Возвращает гиперболический тангенс указанного комплексного числа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-591">Returns the hyperbolic tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-592">Гиперболический тангенс <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-592">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-593"><xref:System.Numerics.Complex.Tanh%2A> Метод для комплексных чисел соответствует <xref:System.Math.Tanh%2A?displayProperty=nameWithType> метод для вещественных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-593">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="38e1f-594"><xref:System.Numerics.Complex.Tanh%2A> Метод использует следующую формулу для вычисления гиперболический тангенс комплексного числа `value`:</span><span class="sxs-lookup"><span data-stu-id="38e1f-594">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="38e1f-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="38e1f-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-596">Преобразует значение комплексного числа в эквивалентное строковое представление.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-596">Converts the value of a complex number to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-597">Преобразует значение текущего комплексного числа в эквивалентное строковое представление в прямоугольной системе координат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-597">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-598">Строковое представление текущего экземпляра в прямоугольной системе координат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-598">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-599">Строковое представление по умолчанию комплексного числа отображает число в декартовой системе координат в форме `(` ** `,` *b*`)`, где ** является вещественной части комплексного числа, и *b* является мнимую часть.</span><span class="sxs-lookup"><span data-stu-id="38e1f-599">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="38e1f-600">Оба ** и *b* форматируются с помощью спецификатора общего формата («G») и соглашений для текущего языка и региональных параметров системы.</span><span class="sxs-lookup"><span data-stu-id="38e1f-600">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-601">Следующий пример отображает строковое представление нескольких комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-601">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="38e1f-602">В выходных данных используется соглашения о форматировании английский — США («en US») языка и региональных параметров, который, в данном случае является текущий язык и региональные параметры.</span><span class="sxs-lookup"><span data-stu-id="38e1f-602">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="38e1f-603">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-603">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-604">Преобразует значение текущего комплексного числа в эквивалентное строковое представление в прямоугольной системе координат, используя указанные сведения об особенностях форматирования, связанных с языком и региональными параметрами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-604">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-605">Строковое представление текущего экземпляра в прямоугольной системе координат, заданное <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-605">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-606">Строковое представление комплексного числа, возвращаемого этим методом отображает число в декартовой системе координат в форме `(` ** `,` *b*`)`, где ** является вещественной части комплексного числа, и *b* является мнимую часть.</span><span class="sxs-lookup"><span data-stu-id="38e1f-606">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="38e1f-607">Оба ** и *b* форматируются с помощью спецификатора общего формата («G») и соглашений для языка и региональных параметров, определяемых `provider`.</span><span class="sxs-lookup"><span data-stu-id="38e1f-607">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="38e1f-608">`provider` Параметр <xref:System.IFormatProvider> реализации.</span><span class="sxs-lookup"><span data-stu-id="38e1f-608">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="38e1f-609">Его <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, который предоставляет зависящие от культуры сведения о формате реального и мнимого чисел в возвращаемую строку.</span><span class="sxs-lookup"><span data-stu-id="38e1f-609">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="38e1f-610">Если `provider` — `null`, возвращаемая строка форматируется с использованием <xref:System.Globalization.NumberFormatInfo> объект текущего языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="38e1f-610">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="38e1f-611">`provider` Параметр может принимать одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="38e1f-611">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="38e1f-612">Объект <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, который предоставляет сведения о форматировании</span><span class="sxs-lookup"><span data-stu-id="38e1f-612">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="38e1f-613"><xref:System.Globalization.NumberFormatInfo> Объект, предоставляющий сведения о форматировании.</span><span class="sxs-lookup"><span data-stu-id="38e1f-613">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="38e1f-614">Пользовательский объект, реализующий <xref:System.IFormatProvider> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="38e1f-614">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="38e1f-615">Его <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.</span><span class="sxs-lookup"><span data-stu-id="38e1f-615">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-616">Следующий пример отображает строковое представление нескольких комплексных чисел.</span><span class="sxs-lookup"><span data-stu-id="38e1f-616">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="38e1f-617">В результате используются соглашения о форматировании английский — США («en US») и французского языка, Франция («fr-FR») языков и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="38e1f-617">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="38e1f-618">Стандартная или пользовательская строка числового формата.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-618">A standard or custom numeric format string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-619">Преобразует значение текущего комплексного числа в эквивалентное строковое представление в прямоугольной системе координат, используя указанный формат для действительной и мнимой частей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-619">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-620">Строковое представление текущего экземпляра в прямоугольной системе координат.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-620">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-621">Строковое представление комплексного числа, возвращаемого этим методом отображает число в декартовой системе координат в форме `(` ** `,` *b*`)`, где ** является вещественной части комплексного числа, и *b* является мнимую часть.</span><span class="sxs-lookup"><span data-stu-id="38e1f-621">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="38e1f-622">Оба ** и *b* форматируются с помощью строки формата, заданной `format`.</span><span class="sxs-lookup"><span data-stu-id="38e1f-622">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="38e1f-623">`format` Параметр может быть любой допустимый стандартный описатель числового формата, или любое сочетание описателей настраиваемого числового формата.</span><span class="sxs-lookup"><span data-stu-id="38e1f-623">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="38e1f-624">Если `format` равен <xref:System.String.Empty?displayProperty=nameWithType> или `null`, и действительная и мнимая части комплексного числа форматируются с помощью спецификатора общего формата («G»).</span><span class="sxs-lookup"><span data-stu-id="38e1f-624">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="38e1f-625">Если `format` задано любое другое значение, вызывает метод <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-625">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="38e1f-626">.NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="38e1f-626">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="38e1f-627">Дополнительные сведения о строки числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="38e1f-627">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="38e1f-628">Дополнительные сведения о форматировании в .NET Framework, см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="38e1f-628">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="38e1f-629">Формат возвращаемой строки определяется <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="38e1f-629">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="38e1f-630">В зависимости от `format` параметр, этот объект определяет символы, такие как знак минус, разделитель групп и символ десятичной запятой в выходной строке.</span><span class="sxs-lookup"><span data-stu-id="38e1f-630">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="38e1f-631">Чтобы предоставить сведения о форматировании для языков и региональных параметров, отличных от текущего языка и региональных параметров, вызовите <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> перегрузки.</span><span class="sxs-lookup"><span data-stu-id="38e1f-631">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-632">В следующем примере инициализирует комплексного числа и он отображается с помощью нескольких стандартных строк форматирования.</span><span class="sxs-lookup"><span data-stu-id="38e1f-632">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="38e1f-633">
            <paramref name="format" /> не является допустимым форматом строки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-633">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="38e1f-634">Стандартная или пользовательская строка числового формата.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-634">A standard or custom numeric format string.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="38e1f-635">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-635">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="38e1f-636">Преобразует значение текущего комплексного числа в эквивалентное строковое представление в прямоугольной системе координат, используя для действительной и мнимой частей указанный формат и сведения об особенностях форматирования, связанных с языком и региональными параметрами.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="38e1f-637">Строковое представление текущего экземпляра в прямоугольной системе координат, заданное <paramref name="format" /> и <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-637">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-638">Строковое представление комплексного числа, возвращаемого этим методом отображает число в декартовой системе координат в форме `(` ** `,` *b*`)`, где ** является вещественной части комплексного числа, и *b* является мнимую часть.</span><span class="sxs-lookup"><span data-stu-id="38e1f-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="38e1f-639">Оба ** и *b* форматируются с помощью строки формата, заданной `format`.</span><span class="sxs-lookup"><span data-stu-id="38e1f-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="38e1f-640">`format` Параметр может быть любой допустимый стандартный описатель числового формата, или любое сочетание описателей настраиваемого числового формата.</span><span class="sxs-lookup"><span data-stu-id="38e1f-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="38e1f-641">Если `format` равен <xref:System.String.Empty?displayProperty=nameWithType> или `null`, и действительная и мнимая части комплексного числа форматируются с помощью спецификатора общего формата («G»).</span><span class="sxs-lookup"><span data-stu-id="38e1f-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="38e1f-642">Если `format` задано любое другое значение, вызывает метод <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="38e1f-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="38e1f-643">.NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="38e1f-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="38e1f-644">Дополнительные сведения о строки числовых форматов см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="38e1f-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="38e1f-645">Дополнительные сведения о форматировании в .NET Framework, см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="38e1f-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="38e1f-646">`provider` Параметр <xref:System.IFormatProvider> реализации.</span><span class="sxs-lookup"><span data-stu-id="38e1f-646">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="38e1f-647">Его <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, который предоставляет зависящие от культуры сведения о формате реального и мнимого чисел в возвращаемую строку.</span><span class="sxs-lookup"><span data-stu-id="38e1f-647">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="38e1f-648">В зависимости от `format` параметр, этот объект определяет символы, такие как знак минус, разделитель групп и символ десятичной запятой в выходной строке.</span><span class="sxs-lookup"><span data-stu-id="38e1f-648">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="38e1f-649">Если `provider` — `null`, возвращаемая строка форматируется с использованием <xref:System.Globalization.NumberFormatInfo> объект текущего языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="38e1f-649">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="38e1f-650">`provider` Параметр может принимать одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="38e1f-650">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="38e1f-651">Объект <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, который предоставляет сведения о форматировании</span><span class="sxs-lookup"><span data-stu-id="38e1f-651">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="38e1f-652"><xref:System.Globalization.NumberFormatInfo> Объект, предоставляющий сведения о форматировании.</span><span class="sxs-lookup"><span data-stu-id="38e1f-652">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="38e1f-653">Пользовательский объект, реализующий <xref:System.IFormatProvider> интерфейс.</span><span class="sxs-lookup"><span data-stu-id="38e1f-653">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="38e1f-654">Его <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.</span><span class="sxs-lookup"><span data-stu-id="38e1f-654">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-655">В следующем примере создается массив комплексных чисел и отображает каждый с помощью нескольких стандартных строк форматирования также <xref:System.Globalization.CultureInfo> объекты, представляющие английский — США («en US») и французский — Франция («fr-FR») языков и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="38e1f-655">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="38e1f-656">
            <paramref name="format" /> не является допустимым форматом строки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-656">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="38e1f-657">Возвращает новый экземпляр объекта <see cref="T:System.Numerics.Complex" /> со значениями действительного и мнимого чисел, равными нулю.</span>
          <span class="sxs-lookup">
            <span data-stu-id="38e1f-657">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="38e1f-658"><xref:System.Numerics.Complex.Zero> Свойство наиболее часто используется для сравнения <xref:System.Numerics.Complex> значение до нуля.</span><span class="sxs-lookup"><span data-stu-id="38e1f-658">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="38e1f-659">В следующем примере создается <xref:System.Numerics.Complex> значение с помощью <xref:System.Numerics.Complex.Zero> свойство.</span><span class="sxs-lookup"><span data-stu-id="38e1f-659">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="38e1f-660">Затем сравнивает это значение на другое значение, экземпляр которого создается путем вызова <xref:System.Numerics.Complex> конструктор с вещественной части, равным нулю и мнимой частью равно нулю.</span><span class="sxs-lookup"><span data-stu-id="38e1f-660">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="38e1f-661">Как видно из примера, два значения равны.</span><span class="sxs-lookup"><span data-stu-id="38e1f-661">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>