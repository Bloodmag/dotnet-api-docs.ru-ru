<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DynamicMethod.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5862a235668e7e4b96457329cbd2f33598707245d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">862a235668e7e4b96457329cbd2f33598707245d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Defines and represents a dynamic method that can be compiled, executed, and discarded.</source>
          <target state="translated">Определяет и представляет динамический метод, который можно скомпилировать, выполнить и удалить.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Discarded methods are available for garbage collection.</source>
          <target state="translated">Удаленные методы доступны для сборки мусора.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class to generate and execute a method at run time, without having to generate a dynamic assembly and a dynamic type to contain the method.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класс для создания и выполнения метода во время выполнения, без необходимости создания динамическую сборку и динамический тип, который будет содержать метод.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The executable code created by the just-in-time (JIT) compiler is reclaimed when the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> object is reclaimed.</source>
          <target state="translated">Исполняемый код, созданный компилятором just-in-time (JIT) будет удален при <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> объект будет освобожден.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Dynamic methods are the most efficient way to generate and execute small amounts of code.</source>
          <target state="translated">Динамические методы являются наиболее эффективный способ создания и выполнения кода небольшого объема.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method can be anonymously hosted, or it can belogically associated with a module or with a type.</source>
          <target state="translated">Анонимно размещенных динамических методов, или он может belogically, связанный с модулем или типом.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is anonymously hosted, it is located in a system-provided assembly, and therefore is isolated from other code.</source>
          <target state="translated">Если динамический метод размещен анонимно, находится в сборке, предоставляемых системой и поэтому изолирован от другого кода.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>By default, it does not have access to any non-public data.</source>
          <target state="translated">По умолчанию он имеет доступ ко всем данным, не являющиеся открытыми.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An anonymously hosted dynamic method can have restricted ability to skip the JIT compiler's visibility checks, if it has been granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Анонимно размещенный динамический метод может быть ограничен возможность пропускать проверки видимости JIT-компилятора, если оно было предоставлено <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The trust level of the assembly whose non-public members are accessed by the dynamic method must be equal to, or a subset of, the trust level of the call stack that emitted the dynamic method.</source>
          <target state="translated">Уровень доверия сборки, не являющиеся открытыми члены, осуществляется динамического метода необходимо, равным или подмножество, уровень доверия стека вызовов, создавшего динамического метода.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>For more information about anonymously hosted dynamic methods, see <bpt id="p1">[</bpt>Walkthrough: Emitting Code in Partial Trust Scenarios<ept id="p1">](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о анонимно размещенные динамические методы см. в разделе <bpt id="p1">[</bpt>Пошаговое руководство: порождение кода в сценариях частичного доверия<ept id="p1">](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is associated with a module that you specify, the dynamic method is effectively global to that module.</source>
          <target state="translated">Если динамический метод связан с модулем, который указывается, динамический метод является фактически глобальными для данного модуля.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>It can access all types in the module and all <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of the types.</source>
          <target state="translated">Он может получить доступ к все типы в модуль и все <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> в Visual Basic) члены типов.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can associate a dynamic method with any module, regardless of whether you created the module, provided that a demand for <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag can be satisfied by the call stack that includes your code.</source>
          <target state="translated">Можно связать динамический метод с любого модуля, независимо от того создания модуля, при условии, что спрос на <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> флаг можно удовлетворить стек вызовов, включающее код.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag is included in the grant, the dynamic method can skip the JIT compiler's visibility checks and access the private data of all types declared in the module or in any other module in any assembly.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> флаг включен в прав, можно пропускать проверки видимости JIT-компилятора и доступ к конфиденциальным данным всех типов, объявленных в модуле или в любой другой модуль в любой сборке динамического метода.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>When you specify the module with which a dynamic method is associated, that module must not be in the system-provided assembly that is used for anonymous hosting.</source>
          <target state="translated">При указании модуля, с которым связан динамический метод, что этот модуль должен отсутствовать в системную сборку, которая используется для анонимного размещения.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If the dynamic method is associated with a type that you specify, it has access to all members of the type, regardless of access level.</source>
          <target state="translated">Если динамический метод связан с указанного типа, он получает доступ ко всем членам типа, независимо от уровня доступа.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>In addition, JIT visibility checks can be skipped.</source>
          <target state="translated">Кроме того можно пропускать проверки видимости JIT-компилятора.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This gives the dynamic method access to the private data of other types declared in the same module or in any other module in any assembly.</source>
          <target state="translated">Это дает динамическому методу получать доступ к конфиденциальным данным других типов, объявленных в том же модуле или в любой другой модуль в любой сборке.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can associate a dynamic method with any type, but your code must be granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with both the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flags.</source>
          <target state="translated">Динамический метод можно связать с любым типом, но необходимо предоставить код <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с обоими <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> и <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> флаги.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following table shows which types and members are accessible to an anonymously hosted dynamic method, with and without JIT visibility checks, depending on whether <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag is granted.</source>
          <target state="translated">В следующей таблице приведены типы и члены доступны анонимно размещенный динамический метод, с и без проверки видимости JIT-компилятора, в зависимости от того, следует ли <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> предоставляется флаг.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></source>
          <target state="translated">Без <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>With <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></source>
          <target state="translated">С <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without skipping JIT visibility checks</source>
          <target state="translated">Без пропуска проверки видимости JIT-компилятора</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Открытые элементы открытых типов в любой сборке.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Открытые элементы открытых типов в любой сборке.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Skipping JIT visibility checks, with restrictions</source>
          <target state="translated">JIT-компилятора пропуска проверки видимости, с ограничениями</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Открытые элементы открытых типов в любой сборке.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types, only in assemblies whose trust levels are equal to or less than the trust level of the assembly that emitted the dynamic method.</source>
          <target state="translated">Все члены всех типов, только в сборках, уровни доверия которых равно или меньше, чем уровень доверия сборки, выпущенной динамического метода.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Prior to the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, emitting code required <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">До появления <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, выпуска кода требовалось <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This permission is included by default in the FullTrust and LocalIntranet named permission sets, but not in the Internet permission set.</source>
          <target state="translated">Это разрешение включено по умолчанию в FullTrust и LocalIntranet, именованные наборы разрешений, но отсутствует в наборе разрешений Интернета.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Therefore, in earlier versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> a library can be used with Internet permissions only if it has the <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attribute and also executes an <ph id="ph3">&lt;xref:System.Security.PermissionSet.Assert%2A&gt;</ph> for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>.</source>
          <target state="translated">Таким образом, в более ранних версиях <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> библиотека может использоваться с интернет-разрешениями только в том случае, если он имеет <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> атрибута, а также выполняет <ph id="ph3">&lt;xref:System.Security.PermissionSet.Assert%2A&gt;</ph> для <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Such libraries require careful security review because coding errors could result in security holes.</source>
          <target state="translated">Такие библиотеки требуют тщательной проверки безопасности, так как ошибки в коде могут стать причиной уязвимости.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph> allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</source>
          <target state="translated">Платформа <ph id="ph1">[!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]</ph> позволяет создавать код в сценариях частичного доверия без предъявления каких-либо требований к безопасности, так как создание кода по сути не является привилегированной операцией.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>That is, the generated code has no more permissions than the assembly that emits it.</source>
          <target state="translated">То есть созданный код имеет не больше разрешений, чем породившая его сборка.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This allows libraries that emit code to be security transparent and removes the need to assert <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>, which simplifies the task of writing a secure library.</source>
          <target state="translated">Это позволяет библиотекам, порождающим код, сохранять прозрачность для системы безопасности, что устраняет необходимость в утверждении перечисления <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph> и упрощает задачу написания безопасной библиотеки.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>To use this feature, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Чтобы использовать эту функцию, приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздней версии.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following table shows which types and members are accessible to a dynamic method that is associated with a module or with a type in a module.</source>
          <target state="translated">В следующей таблице приведены типы и члены доступны для динамического метода, связанного с модулем или с типом в модуле.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Associated with module</source>
          <target state="translated">Связанный с модулем</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Associated with type</source>
          <target state="translated">Связанный с типом</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Without skipping JIT visibility checks</source>
          <target state="translated">Без пропуска проверки видимости JIT-компилятора</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public and internal members of public, internal, and private types in the module.</source>
          <target state="translated">Открытые и внутренние элементы открытых, внутренних и закрытых типов в модуле.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Открытые элементы открытых типов в любой сборке.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of the associated type.</source>
          <target state="translated">Все члены связанного типа.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public and internal members of all the other types in the module.</source>
          <target state="translated">Открытые и внутренние элементы всех других типов в модуле.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Public members of public types in any assembly.</source>
          <target state="translated">Открытые элементы открытых типов в любой сборке.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Skipping JIT visibility checks</source>
          <target state="translated">Пропуск проверки видимости JIT-компилятора</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types in any assembly.</source>
          <target state="translated">Все члены всех типов в любой сборке.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>All members of all types in any assembly.</source>
          <target state="translated">Все члены всех типов в любой сборке.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a module has the permissions of that module.</source>
          <target state="translated">Динамический метод, который связан с модулем, имеет разрешения модуля.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a type has the permissions of the module containing that type.</source>
          <target state="translated">Динамический метод, который связан с типом, имеет разрешения модуля, содержащего типа.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Dynamic methods and their parameters do not have to be named, but you can specify names to assist in debugging.</source>
          <target state="translated">Динамические методы и их параметры не обязательно присваивать имя, но можно указать имена, чтобы упростить отладку.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Custom attributes are not supported on dynamic methods or their parameters.</source>
          <target state="translated">Пользовательские атрибуты не поддерживаются для динамических методов или их параметров.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Although dynamic methods are <ph id="ph1">`static`</ph> methods (<ph id="ph2">`Shared`</ph> methods in Visual Basic), the relaxed rules for delegate binding introduced in the <ph id="ph3">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> allow a dynamic method to be bound to an object, so that it acts like an instance method when called using that delegate instance.</source>
          <target state="translated">Несмотря на то, что динамические методы являются <ph id="ph1">`static`</ph> методы (<ph id="ph2">`Shared`</ph> методы в Visual Basic), настроить правила для привязки делегата, представленных в <ph id="ph3">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph> Разрешить динамический метод может быть привязано к объекту, чтобы они работали как метод экземпляра при вызван с использованием этого экземпляра делегата.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An example that demonstrates this is provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload.</source>
          <target state="translated">Пример, демонстрирующий это предоставляется для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, dynamic methods do not support symbol information, that is, local variable names and line-number mapping.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, динамические методы не поддерживают сведения символа, то есть, имена локальных переменных и сопоставления номеров строк.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>This limitation might be removed in a future version.</source>
          <target state="translated">Это ограничение может быть удален в будущей версии.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>You can use <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> during development to simplify debugging the generated Microsoft intermediate language (MSIL), and then switch to dynamic methods during final deployment, because the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> calls are the same in both cases.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> во время разработки, чтобы упростить процесс отладки созданный промежуточный язык Майкрософт (MSIL), а затем переключиться в динамические методы во время окончательного развертывания, так как <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> , вызываются в обоих случаях совпадают.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Verification</source>
          <target state="translated">Проверка</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following list summarizes the conditions under which dynamic methods can contain unverifiable code.</source>
          <target state="translated">В следующем списке перечислены условия, при которых динамические методы могут содержать непроверяемый код.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>(For example, a dynamic method is unverifiable if its <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.)</source>
          <target state="translated">(Например, динамический метод не может быть проверен при его <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> свойству <ph id="ph2">`false`</ph>.)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>A dynamic method that is associated with a security-critical assembly is also security-critical, and can skip verification.</source>
          <target state="translated">Динамический метод, который связан с точки зрения безопасности сборки также является критическим с точки зрения безопасности и проверку можно пропустить.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>For example, an assembly without security attributes that is run as a desktop application is treated as security-critical by the runtime.</source>
          <target state="translated">Например сборки без атрибутов безопасности, который выполняется как классическое приложение рассматривает как критические для безопасности среды выполнения.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you associate a dynamic method with the assembly, the dynamic method can contain unverifiable code.</source>
          <target state="translated">Если динамический метод связан со сборкой, динамический метод может содержать непроверяемый код.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If a dynamic method that contains unverifiable code is associated with an assembly that has level 1 transparency, the just-in-time (JIT) compiler injects a security demand.</source>
          <target state="translated">Если динамический метод, который содержит непроверяемый код связан с сборку, которая имеет прозрачность уровня 1, компилятор just-in-time (JIT) внедряет требование безопасности.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The demand succeeds only if the dynamic method is executed by fully trusted code.</source>
          <target state="translated">Требование завершается успешно только в том случае, если динамический метод выполняется полностью доверенным кодом.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>See <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>прозрачный с точки зрения безопасности код, уровень 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If a dynamic method that contains unverifiable code is associated with an assembly that has level 2 transparency (such as mscorlib.dll), it throws an exception (injected by the JIT compiler) instead of making a security demand.</source>
          <target state="translated">Если динамический метод, который содержит непроверяемый код связан с сборку, которая имеет прозрачность уровня 2 (например mscorlib.dll), создается исключение (поступающее JIT-компилятором) вместо создания требования безопасности.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>See <bpt id="p1">[</bpt>Security-Transparent Code, Level 2<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>прозрачный с точки зрения безопасности код, уровень 2<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>An anonymously hosted dynamic method that contains unverifiable code always throws an exception.</source>
          <target state="translated">Анонимно размещенный динамический метод, который содержит непроверяемый код всегда создает исключение.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>It can never skip verification, even if it is created and executed by fully trusted code.</source>
          <target state="translated">Он никогда не может пропускать проверку, даже в том случае, если он создается и выполняется полностью доверенным кодом.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The exception that is thrown for unverifiable code varies depending on the way the dynamic method is invoked.</source>
          <target state="translated">Исключение, которое выдается в случае непроверяемый код зависит от способа вызова динамического метода.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you invoke a dynamic method by using a delegate returned from the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method, a <ph id="ph2">&lt;xref:System.Security.VerificationException&gt;</ph> is thrown.</source>
          <target state="translated">Если вызвать динамический метод с помощью делегата, возвращенные <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> метода <ph id="ph2">&lt;xref:System.Security.VerificationException&gt;</ph> создается исключение.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>If you invoke the dynamic method by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, a <ph id="ph2">&lt;xref:System.Reflection.TargetInvocationException&gt;</ph> is thrown with an inner <ph id="ph3">&lt;xref:System.Security.VerificationException&gt;</ph>.</source>
          <target state="translated">Если динамический метод вызывается с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метода <ph id="ph2">&lt;xref:System.Reflection.TargetInvocationException&gt;</ph> создается внутренний <ph id="ph3">&lt;xref:System.Security.VerificationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">В следующем примере кода создается динамический метод, который принимает два параметра.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">В этом примере выпускается основной текст простой функции, который выводит первый параметр в консоль, а в примере используется второй параметр в качестве возвращаемого значения метода.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">В примере завершает метод путем создания делегата, вызывает делегат с различными параметрами и наконец вызывает динамический метод с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Creates a dynamic method.</source>
          <target state="translated">Создает динамический метод.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Initializes an anonymously hosted dynamic method, specifying the method name, return type, and parameter types.</source>
          <target state="translated">Инициализирует анонимно размещенный динамический метод, указывая имя метода, возвращаемый тип и типы параметров.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</source>
          <target state="translated">Динамический метод, который создан этим конструктором связан с анонимной сборкой, а не существующий тип или модуль.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</source>
          <target state="translated">Анонимная сборка существует только для предоставления изолированной среды для динамических методов, то есть, чтобы изолировать их из другого кода.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</source>
          <target state="translated">Эта среда делает безопасным для динамического метода, чтобы выпуск и выполнение кода с частичным доверием.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor specifies that just-in-time (JIT) visibility checks will be enforced for the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Этот конструктор указывает, что видимость just-in-time (JIT) проверяет, будет действовать для промежуточного языка Майкрософт (MSIL) динамического метода.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>That is, the code in the dynamic method has access to public methods of public classes.</source>
          <target state="translated">То есть код в динамическом методе имеет доступ для открытых методов открытых классов.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Exceptions are thrown if the method tries to access types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">Исключения возникают в том случае, если метод пытается обращаться к типам и членам, которые имеют <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, или <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>To create a dynamic method that has restricted ability to skip JIT visibility checks, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Чтобы создать динамический метод, который имеет ограниченные возможности пропуска проверки видимости JIT-компилятора, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</source>
          <target state="translated">При создании анонимно размещенный динамический метод входит в стеке вызовов порождающей сборки.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>When the method is invoked, the permissions of the emitting assembly are used instead of the permissions of the actual caller.</source>
          <target state="translated">При вызове метода разрешения порождающей сборки используются вместо фактического вызывающего объекта разрешений.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</source>
          <target state="translated">Таким образом динамический метод не может выполняться на более высокий уровень привилегий, чем, выпустившей его сборки, даже если он был передан и выполнен в сборке, которая имеет более высокий уровень доверия.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor specifies the method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and the calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот конструктор задает атрибуты метода <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>и соглашение о вызовах <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>This constructor was introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Этот конструктор впервые появился в <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздней версии.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> — это тип, для которого <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method, with this restriction: the trust level of the assemblies that contain those types and members must be equal to or less than the trust level of the call stack that emits the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> — пропускает проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода, с таким ограничением: уровень доверия сборок, содержащих эти типы и члены, должен быть равен уровню доверия стека вызовов, создающего динамический метод, или меньше его. В противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Initializes an anonymously hosted dynamic method, specifying the method name, return type, parameter types, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Инициализирует анонимно размещенный динамический метод, указывая имя метода, возвращаемый тип, типы параметров и необходимость пропуска проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The dynamic method that is created by this constructor is associated with an anonymous assembly instead of an existing type or module.</source>
          <target state="translated">Динамический метод, который создан этим конструктором связан с анонимной сборкой, а не существующий тип или модуль.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The anonymous assembly exists only to provide a sandbox environment for dynamic methods, that is, to isolate them from other code.</source>
          <target state="translated">Анонимная сборка существует только для предоставления изолированной среды для динамических методов, то есть, чтобы изолировать их из другого кода.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This environment makes it safe for the dynamic method to be emitted and executed by partially trusted code.</source>
          <target state="translated">Эта среда делает безопасным для динамического метода, чтобы выпуск и выполнение кода с частичным доверием.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Anonymously hosted dynamic methods do not have automatic access to any types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">Анонимно размещенные динамические методы имеют автоматический доступ к устаревшие типы и члены, которые являются <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, или <ph id="ph3">`internal`</ph> (<ph id="ph4">`Friend`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This is different from dynamic methods that are associated with an existing type or module, which have access to hidden members in their associated scope.</source>
          <target state="translated">Это отличается от динамических методов, связанных с существующим типом или модулем, которые имеют доступ к скрытым элементам в соответствующей области.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`restrictedSkipVisibility`</ph> if your dynamic method has to access types or members that are <ph id="ph3">`private`</ph>, <ph id="ph4">`protected`</ph>, or <ph id="ph5">`internal`</ph>.</source>
          <target state="translated">Укажите <ph id="ph1">`true`</ph> для <ph id="ph2">`restrictedSkipVisibility`</ph> Если динамический метод имеет доступ к типы или члены, которые являются <ph id="ph3">`private`</ph>, <ph id="ph4">`protected`</ph>, или <ph id="ph5">`internal`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This gives the dynamic method restricted access to these members.</source>
          <target state="translated">Это дает динамическому методу ограниченный доступ к этим членам.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>That is, the members can be accessed only if the following conditions are met:</source>
          <target state="translated">То есть члены доступны только в том случае, если выполняются следующие условия:</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The target members belong to an assembly that has a level of trust equal to or lower than the call stack that emits the dynamic method.</source>
          <target state="translated">Целевые элементы принадлежат к сборке, уровень доверия выше, чем стека вызовов, создающего динамический метод.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The call stack that emits the dynamic method is granted <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Стек вызовов, создающего динамический метод предоставляется <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This is always true when the code is executed with full trust.</source>
          <target state="translated">Это всегда значение true, если код выполняется с полным доверием.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>For partially trusted code, it is true only if the host explicitly grants the permission.</source>
          <target state="translated">Частично доверенным кодом он имеет значение true только в том случае, если узел явным образом предоставляет разрешение.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If the permission has not been granted, a security exception is thrown when <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> is called or when the dynamic method is invoked, not when this constructor is called.</source>
          <target state="translated">Если не предоставлено разрешение, возникает исключение безопасности при <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> вызывается или при вызове динамического метода, не когда этот конструктор вызывается.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>No special permissions are required to emit the dynamic method.</source>
          <target state="translated">Специальные разрешения не требуются для создания динамического метода.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>For example, a dynamic method that is created with <ph id="ph1">`restrictedSkipVisibility`</ph> set to <ph id="ph2">`true`</ph> can access a private member of any assembly on the call stack if the call stack has been granted restricted member access.</source>
          <target state="translated">Например, динамический метод, который создается с <ph id="ph1">`restrictedSkipVisibility`</ph> значение <ph id="ph2">`true`</ph> можно доступ к закрытому элементу любой сборки в стеке вызовов, если стек вызовов имеет ограниченный доступ к элементу.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If the dynamic method is created with partially trusted code on the call stack, it cannot access a private member of a type in a <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> assembly, because such assemblies are fully trusted.</source>
          <target state="translated">Если динамический метод создается с частично доверенным кодом в стеке вызовов, ему не удается открыть закрытый член типа в <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> сборки, поскольку такие сборки являются полностью доверенными.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>If <ph id="ph1">`restrictedSkipVisibility`</ph> is <ph id="ph2">`false`</ph>, JIT visibility checks are enforced.</source>
          <target state="translated">Если <ph id="ph1">`restrictedSkipVisibility`</ph> — <ph id="ph2">`false`</ph>, применяются проверки видимости JIT.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>The code in the dynamic method has access to public methods of public classes, and exceptions are thrown if it tries to access types or members that are <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, or <ph id="ph3">`internal`</ph>.</source>
          <target state="translated">Код в динамический метод имеет доступ к открытых методов открытых классов, и исключения возникают в том случае, если он пытается обращаться к типам и членам, которые имеют <ph id="ph1">`private`</ph>, <ph id="ph2">`protected`</ph>, или <ph id="ph3">`internal`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>When an anonymously hosted dynamic method is constructed, the call stack of the emitting assembly is included.</source>
          <target state="translated">При создании анонимно размещенный динамический метод входит в стеке вызовов порождающей сборки.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>When the method is invoked, the permissions of the emitting call stack are used instead of the permissions of the actual caller.</source>
          <target state="translated">При вызове метода разрешения порождающего стека вызовов используются вместо фактического вызывающего объекта разрешений.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>Thus, the dynamic method cannot execute at a higher level of privilege than that of the assembly that emitted it, even if it is passed to and executed by an assembly that has a higher trust level.</source>
          <target state="translated">Таким образом динамический метод не может выполняться на более высокий уровень привилегий, чем, выпустившей его сборки, даже если он был передан и выполнен в сборке, которая имеет более высокий уровень доверия.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This constructor specifies the method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and the calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот конструктор задает атрибуты метода <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>и соглашение о вызовах <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>This constructor was introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Этот конструктор впервые появился в <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздней версии.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> — это тип, для которого <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> representing the module with which the dynamic method is to be logically associated.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>, представляющий модуль, с которым должен быть логически связан динамический метод.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, and module.</source>
          <target state="translated">Создает динамический метод, который является глобальным по отношению к модулю, используя имя метода, возвращаемый тип, типы параметров и модуль.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, and does not skip just-in-time (JIT) visibility checks.</source>
          <target state="translated">Этот конструктор задает атрибуты метода <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, соглашение о вызовах <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>и не пропускает проверки видимости just-in-time (JIT).</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the types contained in module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">Созданный с помощью этого конструктора динамический метод имеет доступ к открытым и <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> в Visual Basic) члены всех типов, содержащихся в модуле <ph id="ph3">`m`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Для обеспечения обратной совместимости это конструктору требуется <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> флаг, если выполняются следующие условия, как true: <ph id="ph3">`m`</ph> — это модуль, отличный от вызывающего и потребности в <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> флаг не удалось.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Если потребность в <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> завершается успешно, операция разрешена.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">В следующем примере кода создается динамический метод, который принимает два параметра.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">В этом примере выпускается основной текст простой функции, который выводит первый параметр в консоль, а в примере используется второй параметр в качестве возвращаемого значения метода.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method.</source>
          <target state="translated">В примере завершает метод путем создания делегата, вызывает делегат с различными параметрами и наконец вызывает динамический метод с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> — это модуль, предоставляющий анонимное размещение для динамических методов.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="m" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> — это тип, для которого <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">Чтобы связать динамический метод с модулем, отличным от вызывающего.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, с которым логически связан динамический метод.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">Динамический метод имеет доступ ко всем членам типа.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Creates a dynamic method, specifying the method name, return type, parameter types, and the type with which the dynamic method is logically associated.</source>
          <target state="translated">Создает динамический метод, указывая имя метода, возвращаемый тип, типы параметров и тип, с которым логически связан динамический метод.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the other types in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">Созданный с помощью этого конструктора динамический метод имеет доступ ко всем членам типа <ph id="ph1">`owner`</ph>и общедоступный и <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> в Visual Basic) члены других типов в модуль, содержащий <ph id="ph4">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>, and does not skip just-in-time (JIT) visibility checks.</source>
          <target state="translated">Этот конструктор задает атрибуты метода <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, соглашение о вызовах <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>и не пропускает проверки видимости just-in-time (JIT).</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Для обеспечения обратной совместимости это конструктору требуется <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> флаг, если выполняются следующие условия, как true: <ph id="ph3">`owner`</ph> находится в модуле, отличном от вызывающего и потребности в <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> Сбой флаг.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Если потребность в <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> завершается успешно, операция разрешена.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The following code example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that is logically associated with a type.</source>
          <target state="translated">В следующем примере кода создается <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> , логически связан с типом.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This association gives it access to the private members of that type.</source>
          <target state="translated">Это связь дает доступ к закрытым членам этого типа.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The code example defines a class named <ph id="ph1">`Example`</ph> with a private field, a class named <ph id="ph2">`DerivedFromxample`</ph> that derives from the first class, a delegate type named <ph id="ph3">`UseLikeStatic`</ph> that returns <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and has parameters of type <ph id="ph5">`Example`</ph> and <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, and a delegate type named <ph id="ph7">`UseLikeInstance`</ph> that returns <ph id="ph8">&lt;xref:System.Int32&gt;</ph> and has one parameter of type <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">В примере кода определяется класс с именем <ph id="ph1">`Example`</ph> с закрытое поле с именем класса <ph id="ph2">`DerivedFromxample`</ph> , производный от первого класса, тип делегата с именем <ph id="ph3">`UseLikeStatic`</ph> , возвращающий <ph id="ph4">&lt;xref:System.Int32&gt;</ph> параметров типа <ph id="ph5">`Example`</ph> и <ph id="ph6">&lt;xref:System.Int32&gt;</ph>и тип делегата с именем <ph id="ph7">`UseLikeInstance`</ph> , возвращающий <ph id="ph8">&lt;xref:System.Int32&gt;</ph> и имеет один параметр типа <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The example code then creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that changes the private field of an instance of <ph id="ph2">`Example`</ph> and returns the previous value.</source>
          <target state="translated">Затем в примере кода создается <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> , изменяющий закрытое поле экземпляра <ph id="ph2">`Example`</ph> и возвращает предыдущее значение.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>In general, changing the internal fields of classes is not good object-oriented coding practice.</source>
          <target state="translated">Как правило изменение внутренних полей классов не объектно ориентированном программировании рекомендаций.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The example code creates an instance of <ph id="ph1">`Example`</ph> and then creates two delegates.</source>
          <target state="translated">Этот пример кода создает экземпляр <ph id="ph1">`Example`</ph> , а затем создает два делегата.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The first is of type <ph id="ph1">`UseLikeStatic`</ph>, which has the same parameters as the dynamic method.</source>
          <target state="translated">Первый — типа <ph id="ph1">`UseLikeStatic`</ph>, который имеет те же параметры динамического метода.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The second is of type <ph id="ph1">`UseLikeInstance`</ph>, which lacks the first parameter (of type <ph id="ph2">`Example`</ph>).</source>
          <target state="translated">Второй — типа <ph id="ph1">`UseLikeInstance`</ph>, у которого нет первый параметр (типа <ph id="ph2">`Example`</ph>).</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This delegate is created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload; the second parameter of that method overload is an instance of <ph id="ph2">`Example`</ph>, in this case the instance just created, which is bound to the newly created delegate.</source>
          <target state="translated">Этот делегат создается с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> перегрузка метода; второй параметр этой перегрузки метода является экземпляром класса <ph id="ph2">`Example`</ph>в данном случае экземпляр только что создали, который привязан к вновь созданного делегата.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Whenever that delegate is invoked, the dynamic method acts on the bound instance of <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">При каждом вызове делегата динамический метод начинает работать привязанный экземпляр <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>This is an example of the relaxed rules for delegate binding introduced in the <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, along with new overloads of the <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Это пример Мягкие правила для привязки делегата, представленных в <ph id="ph1">[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</ph>, а также новые перегрузки <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения см. в описании класса <ph id="ph1">&lt;xref:System.Delegate&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The <ph id="ph1">`UseLikeStatic`</ph> delegate is invoked, passing in the instance of <ph id="ph2">`Example`</ph> that is bound to the <ph id="ph3">`UseLikeInstance`</ph> delegate.</source>
          <target state="translated"><ph id="ph1">`UseLikeStatic`</ph> Вызове делегата, передавая экземпляр <ph id="ph2">`Example`</ph> , привязанный к <ph id="ph3">`UseLikeInstance`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Then the <ph id="ph1">`UseLikeInstance`</ph> delegate is invoked, so that both delegates act on the same instance of <ph id="ph2">`Example`</ph>.</source>
          <target state="translated">Затем <ph id="ph1">`UseLikeInstance`</ph> вызове делегата, чтобы оба Представители действуют на том же экземпляре <ph id="ph2">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>The changes in the values of the internal field are displayed after each call.</source>
          <target state="translated">Изменения в значениях внутреннего поля отображаются после каждого вызова.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Finally, a <ph id="ph1">`UseLikeInstance`</ph> delegate is bound to an instance of <ph id="ph2">`DerivedFromxample`</ph>, and the delegate calls are repeated.</source>
          <target state="translated">Наконец <ph id="ph1">`UseLikeInstance`</ph> делегат привязан к экземпляру <ph id="ph2">`DerivedFromxample`</ph>, и вызывает делегат повторяются.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> является интерфейсом, массивом, открытым универсальным типом или параметром универсального типа или метода.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="owner" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or is a type for which <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или является типом, для которого <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">Чтобы связать динамический метод с типом в модуле, отличном от вызывающего.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> representing the module with which the dynamic method is to be logically associated.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>, представляющий модуль, с которым должен быть логически связан динамический метод.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для пропуска проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Создает динамический метод, который является глобальным для модуля, указывая имя метода, возвращаемый тип, типы параметров, модуль и необходимость пропуска проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот конструктор задает атрибуты метода <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>и соглашение о вызовах <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the types in contained module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">Созданный с помощью этого конструктора динамический метод имеет доступ к открытым и <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> в Visual Basic) члены всех типов, содержащихся в модуле <ph id="ph3">`m`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">Пропуск JIT проверки видимости компилятора позволяет динамическому методу получать доступ к закрытым и защищенным членам всех других типов.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Это полезно, например, при написании кода для сериализации объектов.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Для обеспечения обратной совместимости это конструктору требуется <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> флаг, если выполняются следующие условия, как true: <ph id="ph3">`m`</ph> — это модуль, отличный от вызывающего и потребности в <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> флаг не удалось.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Если потребность в <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> завершается успешно, операция разрешена.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> — это модуль, предоставляющий анонимное размещение для динамических методов.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="m" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> — это тип, для которого <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">Чтобы связать динамический метод с модулем, отличным от вызывающего.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, с которым логически связан динамический метод.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">Динамический метод имеет доступ ко всем членам типа.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для пропуска проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Creates a dynamic method, specifying the method name, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Создает динамический метод, указывая имя метода, возвращаемый тип, типы параметров, тип, с которым логически связан динамический метод, и необходимость пропуска проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the other types in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">Созданный с помощью этого конструктора динамический метод имеет доступ ко всем членам типа <ph id="ph1">`owner`</ph>и общедоступный и <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> в Visual Basic) члены других типов в модуль, содержащий <ph id="ph4">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">Пропуск JIT проверки видимости компилятора позволяет динамическому методу получать доступ к закрытым и защищенным членам всех других типов.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Это полезно, например, при написании кода для сериализации объектов.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This constructor specifies method attributes <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>, and calling convention <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот конструктор задает атрибуты метода <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph>и соглашение о вызовах <ph id="ph3">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Для обеспечения обратной совместимости это конструктору требуется <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> флаг, если выполняются следующие условия, как true: <ph id="ph3">`owner`</ph> находится в модуле, отличном от вызывающего и потребности в <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> Сбой флаг.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Если потребность в <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> завершается успешно, операция разрешена.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> является интерфейсом, массивом, открытым универсальным типом или параметром универсального типа или метода.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="owner" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or is a type for which <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или является типом, для которого <ph id="ph3">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">Чтобы связать динамический метод с типом в модуле, отличном от вызывающего.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values that specifies the attributes of the dynamic method.</source>
          <target state="translated">Битовая комбинация значений <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph>, определяющая атрибуты динамического метода.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The only combination allowed is <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Разрешена только комбинация <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> и <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The calling convention for the dynamic method.</source>
          <target state="translated">Соглашение о вызовах для динамического метода.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Must be <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated">Должно иметь значение <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для пропуска проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Creates a dynamic method that is global to a module, specifying the method name, attributes, calling convention, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Создает динамический метод, который является глобальным для модуля, указывая имя метода, атрибуты, соглашение о вызовах, возвращаемый тип, типы параметров, модуль и необходимость пропуска проверки видимости JIT для типов и членов, к которым получает доступ промежуточный язык Майкрософт (MSIL) динамического метода.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>The dynamic method created with this constructor has access to public and <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> in Visual Basic) members of all the public and internal types contained in module <ph id="ph3">`m`</ph>.</source>
          <target state="translated">Созданный с помощью этого конструктора динамический метод имеет доступ к открытым и <ph id="ph1">`internal`</ph> (<ph id="ph2">`Friend`</ph> в Visual Basic) члены всех открытых и внутренних типов, содержащихся в модуле <ph id="ph3">`m`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types in the module and in all other assemblies as well.</source>
          <target state="translated">Пропуск JIT проверки видимости компилятора позволяет динамическому методу получать доступ к закрытым и защищенным членам других типов в модуль и все другие сборки.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Это полезно, например, при написании кода для сериализации объектов.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`m`</ph> is a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Для обеспечения обратной совместимости это конструктору требуется <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> флаг, если выполняются следующие условия, как true: <ph id="ph3">`m`</ph> — это модуль, отличный от вызывающего и потребности в <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> флаг не удалось.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Если потребность в <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> завершается успешно, операция разрешена.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is a module that provides anonymous hosting for dynamic methods.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> — это модуль, предоставляющий анонимное размещение для динамических методов.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="m" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="m" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> is a combination of flags other than <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> представляет собой сочетание флагов, отличных от <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> и <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> не является <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> — это тип, для которого <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>to associate the dynamic method with a module other than the calling module.</source>
          <target state="translated">Чтобы связать динамический метод с модулем, отличным от вызывающего.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The name of the dynamic method.</source>
          <target state="translated">Имя динамического метода.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This can be a zero-length string, but it cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это может быть строка нулевой длины, но не <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values that specifies the attributes of the dynamic method.</source>
          <target state="translated">Битовая комбинация значений <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph>, определяющая атрибуты динамического метода.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The only combination allowed is <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Разрешена только комбинация <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> и <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The calling convention for the dynamic method.</source>
          <target state="translated">Соглашение о вызовах для динамического метода.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Must be <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated">Должно иметь значение <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that specifies the return type of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который указывает возвращаемый тип динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects specifying the types of the parameters of the dynamic method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method has no parameters.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, указывающих типы параметров динамического метода, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with which the dynamic method is logically associated.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, с которым логически связан динамический метод.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method has access to all members of the type.</source>
          <target state="translated">Динамический метод имеет доступ ко всем членам типа.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для пропуска проверки видимости JIT для типов и членов, к которым получает доступ MSIL динамического метода; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Creates a dynamic method, specifying the method name, attributes, calling convention, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.</source>
          <target state="translated">Создает динамический метод, указывая имя метода, атрибуты, соглашение о вызовах, возвращаемый тип, типы параметров, тип, с которым логически связан динамический метод, и необходимость пропуска проверки видимости JIT для типов и членов, к которым получает доступ промежуточный язык Майкрософт (MSIL) динамического метода.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method is global to the module that contains the type <ph id="ph1">`owner`</ph>.</source>
          <target state="translated">Динамический метод является глобальным для модуля, содержащего тип <ph id="ph1">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>It has access to all members of the type <ph id="ph1">`owner`</ph>.</source>
          <target state="translated">Он имеет доступ ко всем членам типа <ph id="ph1">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>The dynamic method created with this constructor has access to all members of the type <ph id="ph1">`owner`</ph>, and to public and <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic) members of all the types contained in the module that contains <ph id="ph4">`owner`</ph>.</source>
          <target state="translated">Созданный с помощью этого конструктора динамический метод имеет доступ ко всем членам типа <ph id="ph1">`owner`</ph>и общедоступный и <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> в Visual Basic) члены всех типов, содержащихся в модуле, который содержит <ph id="ph4">`owner`</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Skipping the JIT compiler's visibility checks allows the dynamic method to access private and protected members of all other types as well.</source>
          <target state="translated">Пропуск JIT проверки видимости компилятора позволяет динамическому методу получать доступ к закрытым и защищенным членам всех других типов.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>This is useful, for example, when writing code to serialize objects.</source>
          <target state="translated">Это полезно, например, при написании кода для сериализации объектов.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>For backward compatibility, this constructor demands <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag if the following conditions are both true: <ph id="ph3">`owner`</ph> is in a module other than the calling module, and the demand for <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag has failed.</source>
          <target state="translated">Для обеспечения обратной совместимости это конструктору требуется <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> с <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> флаг, если выполняются следующие условия, как true: <ph id="ph3">`owner`</ph> находится в модуле, отличном от вызывающего и потребности в <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph5">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> Сбой флаг.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>If the demand for <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> succeeds, the operation is allowed.</source>
          <target state="translated">Если потребность в <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> завершается успешно, операция разрешена.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>An element of <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is an interface, an array, an open generic type, or a type parameter of a generic type or method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> является интерфейсом, массивом, открытым универсальным типом или параметром универсального типа или метода.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="owner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="owner" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> is a combination of flags other than <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> and <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> представляет собой сочетание флагов, отличных от <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Public" /&gt;</ph> и <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callingConvention" /&gt;</ph> не является <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.Standard" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> is a type for which <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="returnType" /&gt;</ph> — это тип, для которого <ph id="ph2">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>to associate the dynamic method with a type in a module other than the calling module.</source>
          <target state="translated">Чтобы связать динамический метод с типом в модуле, отличном от вызывающего.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>Gets the attributes specified when the dynamic method was created.</source>
          <target state="translated">Возвращает атрибуты, указанные при создании динамического метода.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values representing the attributes for the method.</source>
          <target state="translated">Побитовое сочетание значений <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph>, представляющее атрибуты для метода.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>Currently, the method attributes for a dynamic method are always <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static&gt;</ph>.</source>
          <target state="translated">В настоящее время, всегда являются атрибутами метода для динамического метода <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Static&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>The following code example displays the method attributes of a dynamic method.</source>
          <target state="translated">В следующем примере кода отображаются атрибуты метода динамического метода.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Attributes">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>Gets the calling convention specified when the dynamic method was created.</source>
          <target state="translated">Получает соглашение о вызовах, указанное при создании динамического метода.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> values that indicates the calling convention of the method.</source>
          <target state="translated">Одно из значений <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph>, указывающее соглашение о вызовах метода.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>Currently, the calling convention for a dynamic method is always <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard&gt;</ph>.</source>
          <target state="translated">В настоящее время всегда равно соглашение о вызовах для динамического метода <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>The following code example displays the calling convention of a dynamic method.</source>
          <target state="translated">В следующем примере кода отображаются соглашение о вызовах для динамического метода.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.CallingConvention">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it.</source>
          <target state="translated">Завершает динамический метод и создает делегата, который может использоваться для его выполнения.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>A delegate type whose signature matches that of the dynamic method.</source>
          <target state="translated">Тип делегата, подпись которого совпадает с подписью динамического метода.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it.</source>
          <target state="translated">Завершает динамический метод и создает делегата, который может использоваться для его выполнения.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>A delegate of the specified type, which can be used to execute the dynamic method.</source>
          <target state="translated">Делегат указанного типа, который может использоваться для выполнения динамического метода.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> метода или <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод завершает динамический метод.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">Любые дополнительные попытки изменить динамический метод, такие как изменение определений параметров или выпуска дополнительные промежуточного языка Майкрософт (MSIL), учитывается; исключение не возникает.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>To create a method body for a dynamic method when you have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> object.</source>
          <target state="translated">Для создания тела метода для динамического метода, когда у вас есть генератор MSIL, вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>If you do not have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> object that can be used to generate the method body.</source>
          <target state="translated">Если у вас генератор MSIL, вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> объект, который может использоваться для создания тела метода.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">В следующем примере кода создается динамический метод, который принимает два параметра.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">В этом примере выпускается основной текст простой функции, который выводит первый параметр в консоль, а в примере используется второй параметр в качестве возвращаемого значения метода.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">В примере завершает метод путем создания делегата, вызывает делегат с различными параметрами и наконец вызывает динамический метод с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source>The dynamic method has no method body.</source>
          <target state="translated">У динамического метода отсутствует тело метода.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)">
          <source><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> has the wrong number of parameters or the wrong parameter types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> имеет неверное число параметров или неправильные типы параметров.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>A delegate type whose signature matches that of the dynamic method, minus the first parameter.</source>
          <target state="translated">Тип делегата, подпись которого совпадает с подписью динамического метода минус первый параметр.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>An object the delegate is bound to.</source>
          <target state="translated">Объект, к которому привязан делегат.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Must be of the same type as the first parameter of the dynamic method.</source>
          <target state="translated">Должен быть того же типа, что и первый параметр динамического метода.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Completes the dynamic method and creates a delegate that can be used to execute it, specifying the delegate type and an object the delegate is bound to.</source>
          <target state="translated">Завершает динамический метод и создает делегат, который может использоваться для его выполнения, указывая тип делегата и объект, к которому привязан делегат.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>A delegate of the specified type, which can be used to execute the dynamic method with the specified target object.</source>
          <target state="translated">Делегат указанного типа, который может использоваться для выполнения динамического метода с указанным целевым объектом.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This method overload creates a delegate bound to a particular object.</source>
          <target state="translated">Эта перегрузка метода создает делегат, привязанный к определенному объекту.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Such a delegate is said to be closed over its first argument.</source>
          <target state="translated">Такой делегат считается закрытым в отношении своего первого аргумента.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Although the method is static, it acts as if it were an instance method; the instance is <ph id="ph1">`target`</ph>.</source>
          <target state="translated">Несмотря на то, что метод является статическим, он действует, как если бы это был метод экземпляра; экземпляр является <ph id="ph1">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This method overload requires <ph id="ph1">`target`</ph> to be of the same type as the first parameter of the dynamic method, or to be assignable to that type (for example, a derived class).</source>
          <target state="translated">Эта перегрузка метода требуется <ph id="ph1">`target`</ph> быть того же типа как первый параметр динамического метода, или был назначен этому типу (например, производном классе).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The signature of <ph id="ph1">`delegateType`</ph> has all the parameters of the dynamic method except the first.</source>
          <target state="translated">Подпись <ph id="ph1">`delegateType`</ph> содержит все параметры динамического метода, кроме первого.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>For example, if the dynamic method has the parameters <ph id="ph1">&lt;xref:System.String&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.Byte&gt;</ph>, then <ph id="ph4">`delegateType`</ph> has the parameters <ph id="ph5">&lt;xref:System.Int32&gt;</ph> and <ph id="ph6">&lt;xref:System.Byte&gt;</ph>; <ph id="ph7">`target`</ph> is of type <ph id="ph8">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Например, если динамический метод имеет параметры <ph id="ph1">&lt;xref:System.String&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, и <ph id="ph3">&lt;xref:System.Byte&gt;</ph>, затем <ph id="ph4">`delegateType`</ph> параметров <ph id="ph5">&lt;xref:System.Int32&gt;</ph> и <ph id="ph6">&lt;xref:System.Byte&gt;</ph>; <ph id="ph7">`target`</ph> относится к типу <ph id="ph8">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> метода или <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод завершает динамический метод.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">Любые дополнительные попытки изменить динамический метод, такие как изменение определений параметров или выпуска дополнительные промежуточного языка Майкрософт (MSIL), учитывается; исключение не возникает.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>To create a method body for a dynamic method when you have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> object.</source>
          <target state="translated">Для создания тела метода для динамического метода, когда у вас есть генератор MSIL, вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>If you do not have your own MSIL generator, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> method to obtain an <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> object that can be used to generate the method body.</source>
          <target state="translated">Если у вас генератор MSIL, вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> объект, который может использоваться для создания тела метода.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The following code example creates delegate that binds a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> to an instance of a type, so that the method acts on the same instance each time it is invoked.</source>
          <target state="translated">В следующем примере кода создается делегат, который привязывает <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> к экземпляру типа, чтобы метод действует на том же экземпляре при каждом вызове.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The code example defines a class named <ph id="ph1">`Example`</ph> with a private field, a class named <ph id="ph2">`DerivedFromxample`</ph> that derives from the first class, a delegate type named <ph id="ph3">`UseLikeStatic`</ph> that returns <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and has parameters of type <ph id="ph5">`Example`</ph> and <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, and a delegate type named <ph id="ph7">`UseLikeInstance`</ph> that returns <ph id="ph8">&lt;xref:System.Int32&gt;</ph> and has one parameter of type <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">В примере кода определяется класс с именем <ph id="ph1">`Example`</ph> с закрытое поле с именем класса <ph id="ph2">`DerivedFromxample`</ph> , производный от первого класса, тип делегата с именем <ph id="ph3">`UseLikeStatic`</ph> , возвращающий <ph id="ph4">&lt;xref:System.Int32&gt;</ph> параметров типа <ph id="ph5">`Example`</ph> и <ph id="ph6">&lt;xref:System.Int32&gt;</ph>и тип делегата с именем <ph id="ph7">`UseLikeInstance`</ph> , возвращающий <ph id="ph8">&lt;xref:System.Int32&gt;</ph> и имеет один параметр типа <ph id="ph9">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The example code then creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> that changes the private field of an instance of <ph id="ph2">`Example`</ph> and returns the previous value.</source>
          <target state="translated">Затем в примере кода создается <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> , изменяющий закрытое поле экземпляра <ph id="ph2">`Example`</ph> и возвращает предыдущее значение.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>In general, changing the internal fields of classes is not good object-oriented coding practice.</source>
          <target state="translated">Как правило изменение внутренних полей классов не объектно ориентированном программировании рекомендаций.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The example code creates an instance of <ph id="ph1">`Example`</ph> and then creates two delegates.</source>
          <target state="translated">Этот пример кода создает экземпляр <ph id="ph1">`Example`</ph> , а затем создает два делегата.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The first is of type <ph id="ph1">`UseLikeStatic`</ph>, which has the same parameters as the dynamic method.</source>
          <target state="translated">Первый — типа <ph id="ph1">`UseLikeStatic`</ph>, который имеет те же параметры динамического метода.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The second is of type <ph id="ph1">`UseLikeInstance`</ph>, which lacks the first parameter (of type <ph id="ph2">`Example`</ph>).</source>
          <target state="translated">Второй — типа <ph id="ph1">`UseLikeInstance`</ph>, у которого нет первый параметр (типа <ph id="ph2">`Example`</ph>).</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This delegate is created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> method overload; the second parameter of that method overload is an instance of <ph id="ph2">`Example`</ph>, in this case the instance just created, which is bound to the newly created delegate.</source>
          <target state="translated">Этот делегат создается с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> перегрузка метода; второй параметр этой перегрузки метода является экземпляром класса <ph id="ph2">`Example`</ph>в данном случае экземпляр только что создали, который привязан к вновь созданного делегата.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Whenever that delegate is invoked, the dynamic method acts on the bound instance of <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">При каждом вызове делегата динамический метод начинает работать привязанный экземпляр <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>This is an example of the relaxed rules for delegate binding introduced in the <ph id="ph1">[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]</ph>, along with new overloads of the <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Это пример Мягкие правила для привязки делегата, представленных в <ph id="ph1">[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]</ph>, а также новые перегрузки <ph id="ph2">&lt;xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения см. в описании класса <ph id="ph1">&lt;xref:System.Delegate&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The <ph id="ph1">`UseLikeStatic`</ph> delegate is invoked, passing in the instance of <ph id="ph2">`Example`</ph> that is bound to the <ph id="ph3">`UseLikeInstance`</ph> delegate.</source>
          <target state="translated"><ph id="ph1">`UseLikeStatic`</ph> Вызове делегата, передавая экземпляр <ph id="ph2">`Example`</ph> , привязанный к <ph id="ph3">`UseLikeInstance`</ph> делегата.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Then the <ph id="ph1">`UseLikeInstance`</ph> delegate is invoked, so that both delegates act on the same instance of <ph id="ph2">`Example`</ph>.</source>
          <target state="translated">Затем <ph id="ph1">`UseLikeInstance`</ph> вызове делегата, чтобы оба Представители действуют на том же экземпляре <ph id="ph2">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The changes in the values of the internal field are displayed after each call.</source>
          <target state="translated">Изменения в значениях внутреннего поля отображаются после каждого вызова.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>Finally, a <ph id="ph1">`UseLikeInstance`</ph> delegate is bound to an instance of <ph id="ph2">`DerivedFromxample`</ph>, and the delegate calls are repeated.</source>
          <target state="translated">Наконец <ph id="ph1">`UseLikeInstance`</ph> делегат привязан к экземпляру <ph id="ph2">`DerivedFromxample`</ph>, и вызывает делегат повторяются.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>The dynamic method has no method body.</source>
          <target state="translated">У динамического метода отсутствует тело метода.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not the same type as the first parameter of the dynamic method, and is not assignable to that type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> не относится к тому же типу, что и первый параметр динамического метода, и не может быть назначен этому типу.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)">
          <source><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> has the wrong number of parameters or the wrong parameter types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delegateType" /&gt;</ph> имеет неверное число параметров или неправильные типы параметров.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Gets the type that declares the method, which is always <ph id="ph1">&lt;see langword="null" /&gt;</ph> for dynamic methods.</source>
          <target state="translated">Возвращает тип, который объявляет метод, всегда являющийся <ph id="ph1">&lt;see langword="null" /&gt;</ph> для динамических методов. </target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Всегда <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">Это свойство всегда возвращает <ph id="ph1">`null`</ph> для динамических методов.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>Even when a dynamic method is logically associated with a type, it is not declared by the type.</source>
          <target state="translated">Даже в том случае, если динамический метод логически связан с типом, не объявлен в типе.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>The following code example displays the declaring type of a dynamic method.</source>
          <target state="translated">В следующем примере кода объявляющий тип динамического метода.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.DeclaringType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">Позиция параметра в списке параметров.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter.</source>
          <target state="translated">Параметры индексируются, начиная с номера 1 для первого параметра.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterAttributes" /&gt;</ph> values that specifies the attributes of the parameter.</source>
          <target state="translated">Битовая комбинация значений <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterAttributes" /&gt;</ph>, определяющая атрибуты параметра.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">Имя параметра.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be a zero-length string.</source>
          <target state="translated">Имя может быть строкой нулевой длины.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Defines a parameter of the dynamic method.</source>
          <target state="translated">Определяет параметр динамического метода.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Always returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Всегда возвращает значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If <ph id="ph1">`position`</ph> is 0, the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method refers to the return value.</source>
          <target state="translated">Если <ph id="ph1">`position`</ph> равно 0, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> метод относится к возвращаемому значению.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Setting parameter information has no effect on the return value.</source>
          <target state="translated">Установка сведений о параметре не оказывает влияния на возвращаемое значение.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If the dynamic method has already been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, the <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method has no effect.</source>
          <target state="translated">Если динамический метод уже была завершена, путем вызова <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метода <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> метод не оказывает влияния.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>No exception is thrown.</source>
          <target state="translated">Исключение не возникает.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The following code example shows how to define parameter information for a dynamic method.</source>
          <target state="translated">В следующем примере кода показано, как определить сведения о параметрах для динамического метода.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The method has no parameters.</source>
          <target state="translated">Метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is less than 0.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="position" /&gt;</ph> меньше 0.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is greater than the number of the method's parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> превышает число параметров метода.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>Returns the base implementation for the method.</source>
          <target state="translated">Возвращает базовую реализацию метода.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>The base implementation of the method.</source>
          <target state="translated">Базовая реализация метода.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition">
          <source>This method always returns the current <ph id="ph1">`DynamicMethod`</ph> object.</source>
          <target state="translated">Этот метод всегда возвращает текущий <ph id="ph1">`DynamicMethod`</ph> объекта.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Returns the custom attributes applied to the method.</source>
          <target state="translated">Возвращает настраиваемые атрибуты, примененные к методу.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для поиска цепочки наследования метода с целью поиска пользовательских атрибутов; <ph id="ph2">&lt;see langword="false" /&gt;</ph> для проверки только текущего метода.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for the method.</source>
          <target state="translated">Возвращает все настраиваемые атрибуты, определенные для метода.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>An array of objects representing all the custom attributes of the method.</source>
          <target state="translated">Массив объектов, представляющих все настраиваемые атрибуты метода.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect, because the method is not declared in a type.</source>
          <target state="translated">Для динамических методов, указав <ph id="ph1">`true`</ph> для <ph id="ph2">`inherit`</ph> не делает ничего, так как метод не объявлен в типе.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">Пользовательские атрибуты не поддерживаются для динамических методов.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)">
          <source>The only attribute returned is <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; you can get the method implementation flags more easily using the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">Возвращается только атрибут <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; можно получить метод флаги реализации проще с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of custom attribute to return.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий тип возвращаемого пользовательского атрибута.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для поиска цепочки наследования метода с целью поиска пользовательских атрибутов; <ph id="ph2">&lt;see langword="false" /&gt;</ph> для проверки только текущего метода.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes of the specified type that have been applied to the method.</source>
          <target state="translated">Возвращает настраиваемые атрибуты заданного типа, которые были применены к методу.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of objects representing the attributes of the method that are of type <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> or derive from type <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">Массив объектов, представляющий атрибуты метода, которые или являются типом <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>, или производными из типа <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect, because the method is not declared in a type.</source>
          <target state="translated">Для динамических методов, указав <ph id="ph1">`true`</ph> для <ph id="ph2">`inherit`</ph> не делает ничего, так как метод не объявлен в типе.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">Пользовательские атрибуты не поддерживаются для динамических методов.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The only attribute returned is <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; you can get the method implementation flags more easily using the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">Возвращается только атрибут <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute&gt;</ph>; можно получить метод флаги реализации проще с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> object that can be used to generate a method body from metadata tokens, scopes, and Microsoft intermediate language (MSIL) streams.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph>, который может быть использован для создания основного текста метода из токенов метаданных, областей и потоков MSIL.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph> object that can be used to generate a method body from metadata tokens, scopes, and MSIL streams.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicILInfo" /&gt;</ph>, который может быть использован для создания основного текста метода из токенов метаданных, областей и потоков MSIL.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> class is provided to support unmanaged code generation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicILInfo&gt;</ph> Класс предназначен для поддержки создания неуправляемого кода.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>to execute unmanaged code.</source>
          <target state="translated">на выполнение неуправляемого кода.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.DynamicMethod">
          <source>Returns an MSIL generator that can be used to emit a body for the dynamic method.</source>
          <target state="translated">Возвращает генератор MSIL, который может использоваться для создания тела динамического метода.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>Returns a Microsoft intermediate language (MSIL) generator for the method with a default MSIL stream size of 64 bytes.</source>
          <target state="translated">Возвращает генератор MSIL для этого метода с размером потока MSIL, по умолчанию равным 64 байтам.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object for the method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> для метода.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>After a dynamic method has been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, any further attempt to add MSIL is ignored.</source>
          <target state="translated">После завершения динамический метод, вызвав <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод, любые дополнительные попытки добавления MSIL учитывается.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>No exception is thrown.</source>
          <target state="translated">Исключение не возникает.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</source>
          <target state="translated">Существуют ограничения на непроверяемый код в динамических методов, даже в некоторых сценариях полного доверия.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</source>
          <target state="translated">См. подраздел "Проверка" в разделе примечаний для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The following code example creates a dynamic method that takes two parameters.</source>
          <target state="translated">В следующем примере кода создается динамический метод, который принимает два параметра.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The example emits a simple function body that prints the first parameter to the console, and the example uses the second parameter as the return value of the method.</source>
          <target state="translated">В этом примере выпускается основной текст простой функции, который выводит первый параметр в консоль, а в примере используется второй параметр в качестве возвращаемого значения метода.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator">
          <source>The example completes the method by creating a delegate, invokes the delegate with different parameters, and finally invokes the dynamic method using the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">В примере завершает метод путем создания делегата, вызывает делегат с различными параметрами и наконец вызывает динамический метод с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">Размер потока MSIL (в байтах).</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>Returns a Microsoft intermediate language (MSIL) generator for the method with the specified MSIL stream size.</source>
          <target state="translated">Возвращает генератор промежуточного языка Майкрософт (MSIL) для этого метода с указанным размером потока MSIL.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> object for the method, with the specified MSIL stream size.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> для метода с указанным размером потока MSIL.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>After a dynamic method has been completed, by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method, any further attempt to add MSIL is ignored.</source>
          <target state="translated">После завершения динамический метод, вызвав <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод, любые дополнительные попытки добавления MSIL учитывается.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Исключение не возникает.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>There are restrictions on unverifiable code in dynamic methods, even in some full-trust scenarios.</source>
          <target state="translated">Существуют ограничения на непроверяемый код в динамических методов, даже в некоторых сценариях полного доверия.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</source>
          <target state="translated">См. подраздел "Проверка" в разделе примечаний для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>The following code example demonstrates this method overload.</source>
          <target state="translated">В следующем примере кода демонстрируется перегрузка метода.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Возвращает флаги реализации для метода.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> values representing the implementation flags for the method.</source>
          <target state="translated">Битовая комбинация значений <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, представляющих флаги реализации этого метода.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags">
          <source>Currently, method implementation attributes for dynamic methods are always <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.IL&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.NoInlining&gt;</ph>.</source>
          <target state="translated">В настоящее время атрибутов реализации метода для динамических методов, всегда <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.IL&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.NoInlining&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>Returns the parameters of the dynamic method.</source>
          <target state="translated">Возвращает параметры динамического метода.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> objects that represent the parameters of the dynamic method.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph>, которые представляют параметры динамического метода.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> objects returned by this method are for information only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> Объекты, возвращаемые этим методом, только в информационных целях.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> method to set or change the characteristics of the parameters.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A&gt;</ph> метод, чтобы задать или изменить характеристики параметров.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>The following code example displays the parameters of a dynamic method.</source>
          <target state="translated">В следующем примере кода отображаются параметры динамического метода.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.GetParameters">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>Gets or sets a value indicating whether the local variables in the method are zero-initialized.</source>
          <target state="translated">Возвращает или задает значение, указывающее, инициализированы ли локальные переменные в методе нулевым значением.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the local variables in the method are zero-initialized; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если локальные переменные в методе инициализированы нулевым значением; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>If this property is set to <ph id="ph1">`true`</ph>, the emitted Microsoft intermediate language (MSIL) includes initialization of local variables.</source>
          <target state="translated">Если это свойство имеет значение <ph id="ph1">`true`</ph>, порожденный промежуточный язык Майкрософт (MSIL) включает инициализацию локальных переменных.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>If it is set to <ph id="ph1">`false`</ph>, local variables are not initialized and the generated code is unverifiable.</source>
          <target state="translated">Если задано значение <ph id="ph1">`false`</ph>, локальные переменные не инициализируются и созданный код не может быть проверен.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> property of a dynamic method.</source>
          <target state="translated">В следующем примере кода отображается <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A&gt;</ph> свойства динамического метода.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.InitLocals">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This parameter is ignored for dynamic methods, because they are static.</source>
          <target state="translated">Эти параметры игнорируются для динамических методов, поскольку они являются статическими.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Задайте имя <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values.</source>
          <target state="translated">Побитовое сочетание значений <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>, который допускает связывание, приведение типов аргументов, вызов элементов и извлечение объектов <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> путем отражения.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если указан <bpt id="p1">&lt;c&gt;</bpt>модуль привязки<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется модуль привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For more details, see <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">Список аргументов.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</source>
          <target state="translated">Это массив аргументов с тем же числом, порядком и типом, что и параметры вызываемого метода.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this parameter should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если параметров нет, значением этого параметра должно быть <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Экземпляр объекта <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>, используемого для управления приведением типов.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Если значение этого объекта — <ph id="ph1">&lt;see langword="null" /&gt;</ph>, для текущего потока используется <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, this information is needed to correctly convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, because 1000 is represented differently by different cultures.</source>
          <target state="translated">Например, эти сведения необходимы для правильного преобразования строки <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, которая представляет 1000, в значение <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>, так как 1000 в различных языках и региональных параметрах представляется по-разному.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the dynamic method using the specified parameters, under the constraints of the specified binder, with the specified culture information.</source>
          <target state="translated">Вызывает динамический метод, используя указанные параметры и учитывая ограничения заданного модуля привязки и указанные сведения о языке и региональных параметрах.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> containing the return value of the invoked method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, содержащий возвращенное значение вызванного метода.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>In addition to the listed exceptions, the calling code should be prepared to catch any exceptions thrown by the dynamic method.</source>
          <target state="translated">Помимо перечисленных исключений вызывающий код следует подготовить к перехватывать исключения, вызываемые динамического метода.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Executing a dynamic method with a delegate created by the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method is more efficient than executing it with the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">Выполнение динамического метода с делегатом, созданные <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> метод является более эффективным, чем его с выполнением <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> method completes the dynamic method.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Invoke%2A&gt;</ph> метода или <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A&gt;</ph> метод завершает динамический метод.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any further attempt to alter the dynamic method, such as modifying parameter definitions or emitting more Microsoft intermediate language (MSIL), is ignored; no exception is thrown.</source>
          <target state="translated">Любые дополнительные попытки изменить динамический метод, такие как изменение определений параметров или выпуска дополнительные промежуточного языка Майкрософт (MSIL), учитывается; исключение не возникает.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>All dynamic methods are static, so the <ph id="ph1">`obj`</ph> parameter is always ignored.</source>
          <target state="translated">Все динамические методы являются статическими, поэтому <ph id="ph1">`obj`</ph> всегда игнорируется.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To treat a dynamic method as if it were an instance method, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> overload that takes an object instance.</source>
          <target state="translated">Чтобы рассматривать динамический метод, как если бы это был метод экземпляра, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29&gt;</ph> перегрузку, принимающую экземпляр объекта.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the dynamic method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если динамический метод не имеет параметров, значение <ph id="ph1">`parameters`</ph> должно быть <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters of the dynamic method.</source>
          <target state="translated">В противном случае число, тип и порядок элементов в массиве параметров должны быть идентичны количество, тип и порядок параметров динамического метода.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method overload is called by the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29&gt;</ph> method overload inherited from the <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> class, so the preceding remarks apply to both overloads.</source>
          <target state="translated">Эта перегрузка метода вызывается <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29&gt;</ph> унаследован перегрузке метода <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> класса, поэтому выше примечания относятся к обе перегрузки.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method does not demand permissions directly, but invoking the dynamic method can result in security demands, depending on the method.</source>
          <target state="translated">Этот метод не требует разрешений напрямую, однако вызов динамического метода может привести к требований к безопасности, в зависимости от метода.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, no demands are made for anonymously hosted dynamic methods that are created with the <ph id="ph1">`restrictedSkipVisibility`</ph> parameter set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Например, нет требования предъявляются анонимно размещенные динамические методы, созданных с помощью <ph id="ph1">`restrictedSkipVisibility`</ph> равным <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if you create a method with <ph id="ph1">`restrictedSkipVisibility`</ph> set to <ph id="ph2">`true`</ph> so it can access a hidden member of a target assembly, the method will cause a demand for the permissions of the target assembly plus <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">С другой стороны, при создании метода с <ph id="ph1">`restrictedSkipVisibility`</ph> значение <ph id="ph2">`true`</ph> , он имеет доступ к скрытым членом целевой сборки, метод приведет к запросу для разрешения целевой сборки плюс <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph4">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Prior to the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method required <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> flag.</source>
          <target state="translated">До появления <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот метод требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following code example invokes a dynamic method with exact binding, using the US-English culture.</source>
          <target state="translated">В следующем примере кода вызывается динамический метод с точной привязкой, английский (США) язык и региональные параметры.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.VarArgs" /&gt;</ph> calling convention is not supported.</source>
          <target state="translated">Соглашение о вызове <ph id="ph1">&lt;see cref="F:System.Reflection.CallingConventions.VarArgs" /&gt;</ph> не поддерживается.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not match the number of parameters in the dynamic method.</source>
          <target state="translated">Количество элементов в <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> не соответствует количеству параметров в динамическом методе.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of one or more elements of <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not match the type of the corresponding parameter of the dynamic method.</source>
          <target state="translated">Тип <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> одного или нескольких элементов не сопоставляется с типом соответствующего параметра динамического метода.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method is associated with a module, is not anonymously hosted, and was constructed with <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>, but the dynamic method accesses members that are not <ph id="ph3">&lt;see langword="public" /&gt;</ph> or <ph id="ph4">&lt;see langword="internal" /&gt;</ph> (<ph id="ph5">&lt;see langword="Friend" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Динамический метод связан с модулем, не размещен анонимно и был сконструирован с параметром <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph>, равным <ph id="ph2">&lt;see langword="false" /&gt;</ph>, однако динамический метод получает доступ к элементам, которые не являются <ph id="ph3">&lt;see langword="public" /&gt;</ph> или <ph id="ph4">&lt;see langword="internal" /&gt;</ph> (<ph id="ph5">&lt;see langword="Friend" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method is anonymously hosted and was constructed with <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph> set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>, but it accesses members that are not <ph id="ph3">&lt;see langword="public" /&gt;</ph>.</source>
          <target state="translated">Динамический метод размещен анонимно и был сконструирован с параметром <ph id="ph1">&lt;paramref name="skipVisibility" /&gt;</ph>, равным <ph id="ph2">&lt;see langword="false" /&gt;</ph>, однако он получает доступ к элементам, которые не являются <ph id="ph3">&lt;see langword="public" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The dynamic method contains unverifiable code.</source>
          <target state="translated">Динамический метод содержит непроверяемый код.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated">См. подраздел "Проверка" в разделе примечаний для <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of custom attribute to search for.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий искомый тип атрибута.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to search the method's inheritance chain to find the custom attributes; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to check only the current method.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для поиска цепочки наследования метода с целью поиска пользовательских атрибутов; <ph id="ph2">&lt;see langword="false" /&gt;</ph> для проверки только текущего метода.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Indicates whether the specified custom attribute type is defined.</source>
          <target state="translated">Указывает, определен ли заданный тип настраиваемых атрибутов.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если указанный пользовательский атрибут определен; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>For dynamic methods, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`inherit`</ph> has no effect.</source>
          <target state="translated">Для динамических методов, указав <ph id="ph1">`true`</ph> для <ph id="ph2">`inherit`</ph> не делает ничего.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Dynamic methods have no inheritance chain.</source>
          <target state="translated">Динамические методы не имеют цепочки наследования.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)">
          <source>Custom attributes are not currently supported on dynamic methods.</source>
          <target state="translated">Пользовательские атрибуты не поддерживаются для динамических методов.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Gets a value that indicates whether the current dynamic method is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий динамический метод критическим с точки зрения безопасности или надежным с точки зрения безопасности и, следовательно, может ли он выполнять важные операции.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current dynamic method is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий динамический метод является критически важным для безопасности или защищенным критически важным для безопасности; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является прозрачным.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности динамический метод, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Надежным с точки зрения</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">Прозрачность динамического метода зависит от модуля, связанного с ним.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">Если динамический метод связан с типом вместо модуля, его прозрачность зависит от модуля, содержащего тип.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">Динамические методы не имеют заметки безопасности, поэтому им назначаются прозрачность по умолчанию для соответствующего модуля.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">Анонимно размещенные динамические методы всегда являются прозрачными, поскольку системные модуля, содержащего их является прозрачным.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">В следующей таблице описывается прозрачность динамического метода, который связан с надежной сборкой (то есть сборки строгим именем, установленной в глобальном кэше сборок).</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Assembly annotation</source>
          <target state="translated">Заметка сборки</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Level 1 transparency</source>
          <target state="translated">Прозрачность уровня 1</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Level 2 transparency</source>
          <target state="translated">Прозрачность уровня 2</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Fully transparent</source>
          <target state="translated">Полностью прозрачный</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Fully critical</source>
          <target state="translated">Полностью критический</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Mixed transparency</source>
          <target state="translated">Смешанная прозрачность</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Security-agnostic</source>
          <target state="translated">Зависит от безопасности</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">Критический в плане безопасности</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">Например если динамический метод связан с типом, который находится в библиотеке mscorlib.dll, имеющей уровень 2 смешанной прозрачности, динамический метод является прозрачным и нельзя выполнить критический код.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">Сведения об уровнях прозрачности см. в разделе <bpt id="p1">[</bpt>прозрачный с точки зрения безопасности код, уровень 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> и <bpt id="p2">[</bpt>прозрачный с точки зрения безопасности код, уровень 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">Сопоставление динамического метода с модулем в сборке доверенного уровня 1, которая не зависит от безопасности, например System.dll, не разрешает повышение уровня доверия.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">Если набор прав код, который вызывает динамический метод не включает набор прав System.dll (то есть полное доверие), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> создается при вызове динамического метода.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">Прозрачность динамического метода, который связан с частично доверенная сборка зависит от того, как сборка загружается.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">Сборка и все ее типы и члены, включая динамические методы, считается прозрачным.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности только в том случае, если частичным доверием сборка загружена с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">В этом случае среда выполнения назначает динамическому методу прозрачность по умолчанию для методов, согласно примечаниям сборки.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об отражении выпуска и прозрачности см <bpt id="p1">[</bpt>вопросы безопасности в порождение отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">В этом динамическом методе отсутствует тело метода.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current dynamic method is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Возвращает значение, которое указывает, является ли текущий динамический метод надежным с точки зрения безопасности на текущем уровне доверия и, следовательно, может ли он выполнять критически важные операции и предоставлять доступ прозрачному коду.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dynamic method is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий динамический метод является защищенным критически важным для безопасности на текущем уровне доверия; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является критически важным для безопасности или прозрачным.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности динамический метод, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Надежным с точки зрения</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">Прозрачность динамического метода зависит от модуля, связанного с ним.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">Если динамический метод связан с типом вместо модуля, его прозрачность зависит от модуля, содержащего тип.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">Динамические методы не имеют заметки безопасности, поэтому им назначаются прозрачность по умолчанию для соответствующего модуля.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">Анонимно размещенные динамические методы всегда являются прозрачными, поскольку системные модуля, содержащего их является прозрачным.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">В следующей таблице описывается прозрачность динамического метода, который связан с надежной сборкой (то есть сборки строгим именем, установленной в глобальном кэше сборок).</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Assembly annotation</source>
          <target state="translated">Заметка сборки</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Level 1 transparency</source>
          <target state="translated">Прозрачность уровня 1</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Level 2 transparency</source>
          <target state="translated">Прозрачность уровня 2</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Fully transparent</source>
          <target state="translated">Полностью прозрачный</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Fully critical</source>
          <target state="translated">Полностью критический</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Mixed transparency</source>
          <target state="translated">Смешанная прозрачность</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Security-agnostic</source>
          <target state="translated">Зависит от безопасности</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">Критический в плане безопасности</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">Например если динамический метод связан с типом, который находится в библиотеке mscorlib.dll, имеющей уровень 2 смешанной прозрачности, динамический метод является прозрачным и нельзя выполнить критический код.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">Сведения об уровнях прозрачности см. в разделе <bpt id="p1">[</bpt>прозрачный с точки зрения безопасности код, уровень 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> и <bpt id="p2">[</bpt>прозрачный с точки зрения безопасности код, уровень 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">Сопоставление динамического метода с модулем в сборке доверенного уровня 1, которая не зависит от безопасности, например System.dll, не разрешает повышение уровня доверия.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">Если набор прав код, который вызывает динамический метод не включает набор прав System.dll (то есть полное доверие), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> создается при вызове динамического метода.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">Прозрачность динамического метода, который связан с частично доверенная сборка зависит от того, как сборка загружается.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">Сборка и все ее типы и члены, включая динамические методы, считается прозрачным.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности только в том случае, если частичным доверием сборка загружена с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">В этом случае среда выполнения назначает динамическому методу прозрачность по умолчанию для методов, согласно примечаниям сборки.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об отражении выпуска и прозрачности см <bpt id="p1">[</bpt>вопросы безопасности в порождение отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">В этом динамическом методе отсутствует тело метода.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current dynamic method is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий динамический метод прозрачным на текущем уровне доверия и, следовательно, не может выполнять критические операции.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dynamic method is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий динамический метод является прозрачным на текущем уровне доверия; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the dynamic method as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности динамический метод, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Safe critical</source>
          <target state="translated">Надежным с точки зрения</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method depends on the module it is associated with.</source>
          <target state="translated">Прозрачность динамического метода зависит от модуля, связанного с ним.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the dynamic method is associated with a type rather than a module, its transparency depends on the module that contains the type.</source>
          <target state="translated">Если динамический метод связан с типом вместо модуля, его прозрачность зависит от модуля, содержащего тип.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Dynamic methods do not have security annotations, so they are assigned the default transparency for the associated module.</source>
          <target state="translated">Динамические методы не имеют заметки безопасности, поэтому им назначаются прозрачность по умолчанию для соответствующего модуля.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Anonymously hosted dynamic methods are always transparent, because the system-provided module that contains them is transparent.</source>
          <target state="translated">Анонимно размещенные динамические методы всегда являются прозрачными, поскольку системные модуля, содержащего их является прозрачным.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method that is associated with a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is described in the following table.</source>
          <target state="translated">В следующей таблице описывается прозрачность динамического метода, который связан с надежной сборкой (то есть сборки строгим именем, установленной в глобальном кэше сборок).</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Assembly annotation</source>
          <target state="translated">Заметка сборки</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Level 1 transparency</source>
          <target state="translated">Прозрачность уровня 1</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Level 2 transparency</source>
          <target state="translated">Прозрачность уровня 2</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Fully transparent</source>
          <target state="translated">Полностью прозрачный</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Fully critical</source>
          <target state="translated">Полностью критический</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Mixed transparency</source>
          <target state="translated">Смешанная прозрачность</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Security-agnostic</source>
          <target state="translated">Зависит от безопасности</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">Критический в плане безопасности</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For example, if you associate a dynamic method with a type that is in mscorlib.dll, which has level 2 mixed transparency, the dynamic method is transparent and cannot execute critical code.</source>
          <target state="translated">Например если динамический метод связан с типом, который находится в библиотеке mscorlib.dll, имеющей уровень 2 смешанной прозрачности, динамический метод является прозрачным и нельзя выполнить критический код.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For information about transparency levels, see <bpt id="p1">[</bpt>Security-Transparent Code, Level 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> and <bpt id="p2">[</bpt>Security-Transparent Code, Level 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</source>
          <target state="translated">Сведения об уровнях прозрачности см. в разделе <bpt id="p1">[</bpt>прозрачный с точки зрения безопасности код, уровень 1<ept id="p1">](~/docs/framework/misc/security-transparent-code-level-1.md)</ept> и <bpt id="p2">[</bpt>прозрачный с точки зрения безопасности код, уровень 2<ept id="p2">](~/docs/framework/misc/security-transparent-code-level-2.md)</ept>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>Associating a dynamic method with a module in a trusted level 1 assembly that is security-agnostic, such as System.dll, does not permit elevation of trust.</source>
          <target state="translated">Сопоставление динамического метода с модулем в сборке доверенного уровня 1, которая не зависит от безопасности, например System.dll, не разрешает повышение уровня доверия.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the grant set of the code that calls the dynamic method does not include the grant set of System.dll (that is, full trust), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the dynamic method is called.</source>
          <target state="translated">Если набор прав код, который вызывает динамический метод не включает набор прав System.dll (то есть полное доверие), <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> создается при вызове динамического метода.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The transparency of a dynamic method that is associated with a partially trusted assembly depends on how the assembly is loaded.</source>
          <target state="translated">Прозрачность динамического метода, который связан с частично доверенная сборка зависит от того, как сборка загружается.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>If the assembly is loaded with partial trust (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The assembly and all its types and members, including dynamic methods, are treated as transparent.</source>
          <target state="translated">Сборка и все ее типы и члены, включая динамические методы, считается прозрачным.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The runtime pays attention to security annotations only if the partial-trust assembly is loaded with full trust (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности только в том случае, если частичным доверием сборка загружена с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>In that case, the runtime assigns the dynamic method the default transparency for methods according to the assembly's annotations.</source>
          <target state="translated">В этом случае среда выполнения назначает динамическому методу прозрачность по умолчанию для методов, согласно примечаниям сборки.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об отражении выпуска и прозрачности см <bpt id="p1">[</bpt>вопросы безопасности в порождение отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent">
          <source>The dynamic method doesn't have a method body.</source>
          <target state="translated">В этом динамическом методе отсутствует тело метода.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not supported for dynamic methods.</source>
          <target state="translated">Не поддерживается для динамических методов.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not supported for dynamic methods.</source>
          <target state="translated">Не поддерживается для динамических методов.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.MethodHandle">
          <source>Not allowed for dynamic methods.</source>
          <target state="translated">Не разрешено для динамических методов.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>Gets the module with which the dynamic method is logically associated.</source>
          <target state="translated">Возвращает модуль, с которым логически связан динамический метод.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> with which the current dynamic method is associated.</source>
          <target state="translated">Модуль <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>, с которым логически связан текущий динамический метод.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>If a module was specified when the dynamic method was created, this property returns that module.</source>
          <target state="translated">Если модуль был указан при создании динамического метода, это свойство возвращает данного модуля.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>If a type was specified as the owner when the dynamic method was created, this property returns the module which contains that type.</source>
          <target state="translated">Если тип был указан в качестве владельца при создании динамического метода, это свойство возвращает модуль, содержащий указанный тип.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Module%2A&gt;</ph> property of a dynamic method.</source>
          <target state="translated">В следующем примере кода отображается <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.Module%2A&gt;</ph> свойства динамического метода.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Module">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>Gets the name of the dynamic method.</source>
          <target state="translated">Получает имя динамического метода.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>The simple name of the method.</source>
          <target state="translated">Простое имя метода.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>It is not necessary to name dynamic methods.</source>
          <target state="translated">Необязательно для имен динамических методов.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>The following code example displays the name of a dynamic method.</source>
          <target state="translated">В следующем примере кода имя динамического метода.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.Name">
          <source>This code example is part of a larger example provided for  the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>Gets the class that was used in reflection to obtain the method.</source>
          <target state="translated">Возвращает класс, который использовался в отражении для получения метода.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Всегда <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">Это свойство всегда возвращает <ph id="ph1">`null`</ph> для динамических методов.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>The following code example displays the reflected type of a dynamic method.</source>
          <target state="translated">В следующем примере кода отраженный тип динамического метода.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReflectedType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>Gets the return parameter of the dynamic method.</source>
          <target state="translated">Возвращает выходной параметр динамического метода.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Всегда <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnParameter">
          <source>This property always returns <ph id="ph1">`null`</ph> for dynamic methods.</source>
          <target state="translated">Это свойство всегда возвращает <ph id="ph1">`null`</ph> для динамических методов.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>Gets the type of return value for the dynamic method.</source>
          <target state="translated">Получает тип возвращаемого значения для динамического метода.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of the return value of the current method; <ph id="ph2">&lt;see cref="T:System.Void" /&gt;</ph> if the method has no return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий тип возвращаемого значения текущего метода; значение <ph id="ph2">&lt;see cref="T:System.Void" /&gt;</ph>, если метод не имеет возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>If <ph id="ph1">`null`</ph> was specified for the return type when the dynamic method was created, this property returns <ph id="ph2">&lt;xref:System.Void?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`null`</ph> был указан для возвращаемого типа, при создании динамического метода, это свойство возвращает <ph id="ph2">&lt;xref:System.Void?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>The following code example displays the return type of a dynamic method.</source>
          <target state="translated">В следующем примере кода отображает тип возвращаемого значения динамического метода.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnType">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>Gets the custom attributes of the return type for the dynamic method.</source>
          <target state="translated">Получает настраиваемые атрибуты типа возвращаемого значения для динамического метода.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.ICustomAttributeProvider" /&gt;</ph> representing the custom attributes of the return type for the dynamic method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.ICustomAttributeProvider" /&gt;</ph>, представляющий пользовательские атрибуты возвращаемого типа для динамического метода.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>Custom attributes are not supported on the return type of a dynamic method, so the array of custom attributes returned by the <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A&gt;</ph> method is always empty.</source>
          <target state="translated">Пользовательские атрибуты не поддерживаются на тип возвращаемого значения динамического метода, поэтому массив настраиваемых атрибутов, возвращаемый <ph id="ph1">&lt;xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A&gt;</ph> метод была всегда пуста.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>The following code example shows how to display the custom attributes of the return type of a dynamic method.</source>
          <target state="translated">В следующем примере кода показано, как отобразить настраиваемые атрибуты возвращаемого типа динамического метода.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>Returns the signature of the method, represented as a string.</source>
          <target state="translated">Возвращает сигнатуру метода, представленную в виде строки.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>A string representing the method signature.</source>
          <target state="translated">Строка, представляющая сигнатуру метода.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>The signature includes only types and the method name, if any.</source>
          <target state="translated">Сигнатура содержит только типы и имя метода, если таковые имеются.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>Parameter names are not included.</source>
          <target state="translated">Имена параметров не включаются.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.ToString%2A&gt;</ph> method of a dynamic method.</source>
          <target state="translated">В следующем примере кода отображается <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod.ToString%2A&gt;</ph> метод динамического метода.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.DynamicMethod.ToString">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> class.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph> класса.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>