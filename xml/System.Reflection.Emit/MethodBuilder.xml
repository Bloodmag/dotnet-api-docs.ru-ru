<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBuilder.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c93c1a358d5c177a5835b41cbeaeae252a6af730.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c93c1a358d5c177a5835b41cbeaeae252a6af730</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Defines and represents a method (or constructor) on a dynamic class.</source>
          <target state="translated">Определяет и представляет метод (или конструктор) для динамического класса.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> Класс используется для полного описания метода на промежуточном языке MSIL, включая имя, атрибуты, подпись и метод тело.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>It is used in conjunction with the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class to create classes at runtime.</source>
          <target state="translated">Он используется в сочетании с <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> класс для создания классов во время выполнения.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods and methods as type members</source>
          <target state="translated">Глобальные методы и методы, как члены типов</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can use reflection emit to define global methods and to define methods as type members.</source>
          <target state="translated">Отражение можно использовать для определения глобальных методов и определения методов как членов типа.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The APIs that define methods return <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> objects.</source>
          <target state="translated">API-интерфейсы, которые определяют методы возвращают <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods</source>
          <target state="translated">Глобальные методы</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> object.</source>
          <target state="translated">Глобальный метод определяется с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType&gt;</ph> метод, возвращающий <bpt id="p1">**</bpt>MethodBuilder<ept id="p1">**</ept> объекта.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Global methods must be static.</source>
          <target state="translated">Глобальные методы должны быть статическими.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>If a dynamic module contains global methods, the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.</source>
          <target state="translated">Если динамический модуль содержит глобальные методы <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType&gt;</ph> метод должен вызываться перед сохранением динамического модуля или содержащей его динамической сборки, потому что общеязыковая среда выполнения откладывает модификацию динамического модуля до все глобальные функции определено.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A global native method is defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Глобальный собственный метод определяется с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Platform invoke (PInvoke) methods must not be declared abstract or virtual.</source>
          <target state="translated">Неуправляемого кода (PInvoke) методы не должны быть объявлены абстрактный или виртуальный.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The runtime sets the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> attribute for a platform invoke method.</source>
          <target state="translated">Задает время выполнения <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType&gt;</ph> атрибут для платформы вызова метода.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods as members of types</source>
          <target state="translated">Методы, как члены типов</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>A method is defined as a type member by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object.</source>
          <target state="translated">Метод определяется как член типа с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> метод, возвращающий <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> method is used to set the name and parameter attributes of a parameter, or of the return value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A&gt;</ph> Метод используется для задания атрибутов имени и параметров, параметра или возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method represents a parameter or the return value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> Представляет объект, возвращаемый этим методом, параметра или возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> Объект может использоваться для установки маршалинга, для установки постоянного значения и для применения пользовательских атрибутов.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Attributes</source>
          <target state="translated">Атрибуты</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Members of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration define the precise character of a dynamic method:</source>
          <target state="translated">Члены <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> перечисления определить точный знак динамического метода:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Static methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Статические методы определяются с помощью <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Final methods (methods that cannot be overridden) are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Конечные методы (методы, которые не могут быть переопределены) задаются с помощью <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Virtual methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Виртуальные методы определяются с помощью <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Abstract methods are specified using the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Абстрактные методы определяются с помощью <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Several attributes determine method visibility.</source>
          <target state="translated">Несколько атрибутов определяют видимость метода.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> enumeration.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Methods that implement overloaded operators must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Необходимо задать методы, которые реализуют перегруженные операторы <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Finalizers must set the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Методы завершения должны задать <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Known Issues</source>
          <target state="translated">Известные проблемы</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class are not fully implemented in <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">Несмотря на то что <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> является производным от <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, некоторые из абстрактных методов, определенных в <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> класс еще не полностью реализованы в <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>These <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> methods throw the <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Эти <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> методы создают исключение <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>For example the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> method is not fully implemented.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType&gt;</ph> метод не реализован полностью.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>You can reflect on these methods by retrieving the enclosing type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">С помощью этих методов можно отразить путем получения внешнего типа с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Custom modifiers are supported starting with the .NET Framework version 2.0.</source>
          <target state="translated">Начиная с .NET Framework версии 2.0 поддерживаются пользовательские модификаторы.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>They are not supported in earlier versions.</source>
          <target state="translated">Они не поддерживаются в более ранних версиях.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> class to create a method within a dynamic type.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> класс для создания метода внутри динамического типа.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken (Demand, Assert, and so on).</source>
          <target state="translated">Выполняемое действие для безопасности (Demand, Assert и т. д.).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">Набор разрешений, к которому применяется действие.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this method.</source>
          <target state="translated">Добавляет декларативную безопасность в этот метод.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> can be called several times, with each call specifying a security action (such as <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, and <ph id="ph4">`Deny`</ph>) and a set of permissions that the action applies to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> может вызываться несколько раз, при каждом вызове действие по обеспечению безопасности (такие как <ph id="ph2">`Demand`</ph>, <ph id="ph3">`Assert`</ph>, и <ph id="ph4">`Deny`</ph>) и набор разрешений, к которым применяется действие.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> method are stored in the old XML metadata format.</source>
          <target state="translated">В .NET Framework версий 1.0, 1.1 и 2.0 декларативные атрибуты безопасности применяется к методу с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A&gt;</ph> метод хранятся в старом формате метаданных XML.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>See Emitting Declarative Security Attributes.</source>
          <target state="translated">В разделе выпуск декларативных атрибутов безопасности.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The code sample below illustrates the contextual use of <ph id="ph1">`AddDeclarativeSecurity`</ph> to require the caller of a method to have unrestricted permissions.</source>
          <target state="translated">Следующий пример кода иллюстрирует использование <ph id="ph1">`AddDeclarativeSecurity`</ph> в вызывающий объект метода разрешения не ограничен.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated">Недопустимый параметр <ph id="ph1">&lt;paramref name="action" /&gt;</ph> (недопустимы значения <ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> и <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>.</source>
          <target state="translated">Набор разрешений <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> содержит действие, добавленное ранее с помощью <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the attributes for this method.</source>
          <target state="translated">Извлекает атрибуты для данного метода.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Attributes">
          <source>Retrieves the <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> for this method.</source>
          <target state="translated">Извлекает <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> для данного метода.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Returns the calling convention of the method.</source>
          <target state="translated">Возвращает соглашение о вызовах метода.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.CallingConvention">
          <source>The calling convention of the method.</source>
          <target state="translated">Соглашение о вызовах метода.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported for this type.</source>
          <target state="translated">Не поддерживается для этого типа.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>Not supported.</source>
          <target state="translated">Не поддерживается.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> always represents a generic method definition, and thus cannot be invoked.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> всегда представляет определение универсального метода и таким образом, не могут быть вызваны.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделах <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Сведения об универсальных типах см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>An array containing valid MSIL instructions.</source>
          <target state="translated">Массив, содержащий допустимые инструкции MSIL.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>If this parameter is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the method's body is cleared.</source>
          <target state="translated">Если этот параметр равен <ph id="ph1">&lt;see langword="null" /&gt;</ph>, тело метода очищается.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of valid bytes in the MSIL array.</source>
          <target state="translated">Число допустимых байтов в массиве MSIL.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This value is ignored if MSIL is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это значение игнорируется, если MSIL — <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">Создает тело метода с использованием предоставленного массива байтов инструкций промежуточного языка Майкрософт (MSIL).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method creates the method's body from <ph id="ph1">`il`</ph>, an array containing MSIL instructions as opcodes.</source>
          <target state="translated">Этот метод создает тело метода из <ph id="ph1">`il`</ph>, массив, содержащий инструкции MSIL в виде кодов операций.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The number of bytes of valid MSIL is given by count.</source>
          <target state="translated">Получает число байтов, предоставляющих инструкции по количеству.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This is currently not fully supported.</source>
          <target state="translated">В настоящее время не поддерживается полностью.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The user cannot supply the location of token fix ups and exception handlers.</source>
          <target state="translated">Пользователь не может передать местоположение привязок маркеров и обработчиков исключений.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>In the example provided below, a simple method that adds two integers is generated via opcode using <ph id="ph1">`CreateMethodBody`</ph>.</source>
          <target state="translated">В приведенном ниже примере создается простой метод, который добавляет два целых числа, через код операции с помощью <ph id="ph1">`CreateMethodBody`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> is not within the range of indexes of the supplied MSIL instruction array and <ph id="ph2">&lt;paramref name="il" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="count" /&gt;</ph> выходит за пределы диапазона индексов предоставленного массива инструкций MSIL, и <ph id="ph2">&lt;paramref name="il" /&gt;</ph> не равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>This method was called previously on this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> with an <ph id="ph2">&lt;paramref name="il" /&gt;</ph> argument that was not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Этот метод был вызван ранее применительно к этому <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> с аргументом <ph id="ph2">&lt;paramref name="il" /&gt;</ph>, не равным <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Returns the type that declares this method.</source>
          <target state="translated">Возвращает тип, объявляющий этот метод.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The type that declares this method.</source>
          <target state="translated">Тип, объявляющий этот метод.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.DeclaringType">
          <source>The following code illustrates the use of the <ph id="ph1">`Type`</ph> property.</source>
          <target state="translated">Следующий код иллюстрирует использование <ph id="ph1">`Type`</ph> свойство.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of strings that represent the names of the generic type parameters.</source>
          <target state="translated">Массив строк, представляющих имена параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define their constraints.</source>
          <target state="translated">Задает количество параметров универсального типа для текущего метода, указывает их имена и возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>, которые можно использовать для определения их ограничений.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters of the generic method.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>, представляющих параметры типа универсального метода.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method makes the current method generic.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метода делает текущий метод универсальным.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>There is no way to undo this change.</source>
          <target state="translated">Нет возможности отменить это изменение.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method a second time causes an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Вызов этого метода во второй раз вызывает <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The type parameters of the generic method can be retrieved later by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">Параметры типа универсального метода можно получить с помощью более поздней версии <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>By convention, a type parameter name is a single uppercase letter.</source>
          <target state="translated">По соглашению именем параметра типа является одну прописную букву.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделах <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Сведения об универсальных типах см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a dynamic type, <ph id="ph1">`DemoType`</ph>, which contains the dynamic generic method <ph id="ph2">`DemoMethod`</ph>.</source>
          <target state="translated">В следующем примере кода создается динамический тип <ph id="ph1">`DemoType`</ph>, который содержит динамический универсальный метод <ph id="ph2">`DemoMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.</source>
          <target state="translated">Этот метод имеет два параметра универсального типа, один из которых используется в качестве параметра, а другой — как тип возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">При выполнении этого кода динамическая сборка сохраняется как DemoGenericMethod1.dll и может быть проанализирована с помощью <bpt id="p1">[</bpt>Ildasm.exe (дизассемблера IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>This code example generates a simple method body that merely returns a null reference.</source>
          <target state="translated">Данный пример кода приводит к возникновению ошибки текст простой метод, который всего лишь возвращает пустую ссылку.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>For a code example with a more fully developed method body that creates and uses generic types, see <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Пример кода с более полностью разработанный метод текстом, который создает и использует универсальных типов см. в разделе <bpt id="p1">[</bpt>как: определение универсального метода с помощью порождаемого отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this method.</source>
          <target state="translated">Для этого метода уже были определены параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The method has been completed already.</source>
          <target state="translated">Метод уже завершен.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>The <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> method has been called for the current method.</source>
          <target state="translated">Метод <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /&gt;</ph> был вызван для текущего метода.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="names" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="names" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> является пустым массивом.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The position of the parameter in the parameter list.</source>
          <target state="translated">Позиция параметра в списке параметров.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</source>
          <target state="translated">Параметры индексируются, начиная с номера 1 для первого параметра; число 0 представляет возвращаемое значение метода.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The parameter attributes of the parameter.</source>
          <target state="translated">Атрибуты параметра.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name of the parameter.</source>
          <target state="translated">Имя параметра.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The name can be the null string.</source>
          <target state="translated">Имя может быть пустой строкой.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method.</source>
          <target state="translated">Задает атрибуты параметров и имя параметра этого метода или возвращаемого значения данного метода.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a ParameterBuilder that can be used to apply custom attributes.</source>
          <target state="translated">Возвращает ParameterBuilder, который можно использовать для применения настраиваемых атрибутов.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph> object that represents a parameter of this method or the return value of this method.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see langword="ParameterBuilder" /&gt;</ph>, представляющий параметр этого метода или возвращаемое значение этого метода.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ParameterBuilder&gt;</ph> Объект, возвращаемый этим методом может использоваться для задания значения по умолчанию для параметра или для применения пользовательских атрибутов.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>Parameter numbering begins with 1, so <ph id="ph1">`position`</ph> is 1 for the first parameter.</source>
          <target state="translated">Параметр нумерация начинается с 1, поэтому <ph id="ph1">`position`</ph> -1 для первого параметра.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>If <ph id="ph1">`position`</ph> is zero, this method affects the return value.</source>
          <target state="translated">Если <ph id="ph1">`position`</ph> равен нулю, этот метод влияет на возвращаемое значение.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>In the .NET Framework versions 1.0 and 1.1, an exception is thrown if <ph id="ph1">`position`</ph> is zero, so this method cannot be used to modify attributes of the return value in those versions.</source>
          <target state="translated">В .NET Framework версий 1.0 и 1.1, если исключение <ph id="ph1">`position`</ph> равен нулю, поэтому этот метод не может использоваться для изменения атрибутов возвращаемого значения в этих версиях.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The method has no parameters.</source>
          <target state="translated">Метод не имеет параметров.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="position" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> is greater than the number of the method's parameters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> превышает число параметров метода.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>The object to compare with this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance.</source>
          <target state="translated">Объект, сравниваемый с этим экземпляром <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Determines whether the given object is equal to this instance.</source>
          <target state="translated">Определяет, равен ли данный объект этому экземпляру.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is an instance of <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph> and is equal to this object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> является экземпляром <ph id="ph3">&lt;see langword="MethodBuilder" /&gt;</ph> и равен этому объекту; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)">
          <source>Equality is determined by having the same name, attributes, and signature.</source>
          <target state="translated">Равенство определяется с именем, атрибутами и подписи.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>Return the base implementation for a method.</source>
          <target state="translated">Возвращает базовую реализацию метода.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>The base implementation of this method.</source>
          <target state="translated">Базовая реализация этого метода.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition">
          <source>This always returns the current <ph id="ph1">`MethodBuilder`</ph> object.</source>
          <target state="translated">Эта функция всегда возвращает текущий <ph id="ph1">`MethodBuilder`</ph> объекта.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns the custom attributes defined for this method.</source>
          <target state="translated">Возвращает настраиваемые атрибуты, определенные для этого метода.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения настраиваемых атрибутов.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this method.</source>
          <target state="translated">Возвращает все настраиваемые атрибуты, определенные для данного метода.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this method.</source>
          <target state="translated">Возвращает массив объектов, представляющих все настраиваемые атрибуты этого метода.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">В настоящее время этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Извлеките метод с помощью <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> и вызовите <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> в возвращенном методе <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">Тип настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения настраиваемых атрибутов.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns the custom attributes identified by the given type.</source>
          <target state="translated">Возвращает настраиваемые атрибуты, определяемые заданным типом.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns an array of objects representing the attributes of this method that are of type <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов, предоставляющих атрибуты типа <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> данного метода.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">В настоящее время этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Извлеките метод с помощью <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> и вызовите <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> в возвращенном методе <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that represent the type parameters of the method, if it is generic.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>, которые представляют параметры типа для метода, если он является универсальным.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects representing the type parameters, if the method is generic, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the method is not generic.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>, представляющих параметры типа, если метод является универсальным, или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>The type parameters of a generic method also are returned by the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method that is used to define them.</source>
          <target state="translated">Параметры типа универсального метода также возвращаются с <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод, используемый для их определения.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделах <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Сведения об универсальных типах см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>Returns this method.</source>
          <target state="translated">Возвращает этот метод.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current instance of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">Текущий экземпляр <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> cannot be used to emit a constructed generic method directly.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> не может использоваться для выдачи непосредственно к сконструированному универсальному методу.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The emitted method is a generic method definition.</source>
          <target state="translated">Выпущенный метод — это определение универсального метода.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделах <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>For information on generic types, see <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Сведения об универсальных типах см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>The current method is not generic.</source>
          <target state="translated">Текущий метод не является универсальным.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> возвращает значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>Gets the hash code for this method.</source>
          <target state="translated">Возвращает хэш-код для этого метода.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetHashCode">
          <source>The hash code for this method.</source>
          <target state="translated">Хэш-код для этого метода.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> данного метода.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> для этого метода с потоком промежуточного языка Майкрософт (MSIL), имеющим размер по умолчанию (64 байта).</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> для этого метода.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">Следующий пример кода демонстрирует использование <ph id="ph1">`GetILGenerator`</ph> метод создания и выдачи динамической сборки, которая вычисляет скалярное произведение двух векторов в трехмерном пространстве.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">Метод не должен иметь тело из-за своих флагов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> или <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, например, потому что имеет флаг <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">Метод является универсальным методом, но не определением универсального метода.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, однако свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The size of the MSIL stream, in bytes.</source>
          <target state="translated">Размер потока MSIL (в байтах).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> for this method with the specified Microsoft intermediate language (MSIL) stream size.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> для этого метода с указанным размером потока MSIL.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>Returns an <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> object for this method.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see langword="ILGenerator" /&gt;</ph> для этого метода.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The code sample below demonstrates the contextual usage of the <ph id="ph1">`GetILGenerator`</ph> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</source>
          <target state="translated">Следующий пример кода демонстрирует использование <ph id="ph1">`GetILGenerator`</ph> метод создания и выдачи динамической сборки, которая вычисляет скалярное произведение двух векторов в трехмерном пространстве.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method should not have a body because of its <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags, for example because it has the <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph> flag.</source>
          <target state="translated">Метод не должен иметь тело из-за своих флагов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> или <ph id="ph2">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>, например, потому что имеет флаг <ph id="ph3">&lt;see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>The method is a generic method, but not a generic method definition.</source>
          <target state="translated">Метод является универсальным методом, но не определением универсального метода.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, однако свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Возвращает флаги реализации для метода.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags">
          <source>Returns the implementation flags for the method.</source>
          <target state="translated">Возвращает флаги реализации для метода.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">Возвращает ссылку на модуль, содержащий этот метод.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>Returns a reference to the module that contains this method.</source>
          <target state="translated">Возвращает ссылку на модуль, содержащий этот метод.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetModule">
          <source>The sample code below illustrates the usage of the <ph id="ph1">`GetModule`</ph> method to retrieve information about a dynamically-generated module.</source>
          <target state="translated">Следующий пример кода иллюстрирует использование <ph id="ph1">`GetModule`</ph> метод для извлечения сведений о динамически создаваемом модуле.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Returns the parameters of this method.</source>
          <target state="translated">Возвращает параметры данного метода.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>An array of <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> objects that represent the parameters of the method.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph>, которые представляют параметры метода.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>The code sample below illustrates the use of <ph id="ph1">`GetParameters`</ph> to discover information on the parameters passed to a dynamically-generated method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`GetParameters`</ph> для получения сведений о параметрах, передаваемых в метод динамически создаются.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>This method is not currently supported.</source>
          <target state="translated">В настоящее время этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetParameters">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Извлеките метод с помощью <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> и вызовите <ph id="ph2">&lt;see langword="GetParameters" /&gt;</ph> в возвращенном методе <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> that represents the token for this method.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph>, представляющий маркер данного метода.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.GetToken">
          <source>Returns the <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> of this method.</source>
          <target state="translated">Возвращает токен <ph id="ph1">&lt;see langword="MethodToken" /&gt;</ph> данного метода.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized.</source>
          <target state="translated">Возвращает или задает логическое значение, указывающее, инициализируются ли локальные переменные в этом методе нулевым значением.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>The default value of this property is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">По умолчанию этому свойству присваивается значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the local variables in this method should be zero initialized; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если локальные переменные в этом методе должны быть инициализированы нулевым значением. В противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If this property is set to <ph id="ph1">`true`</ph>, the emitted MSIL includes initialization of local variables.</source>
          <target state="translated">Если это свойство имеет значение <ph id="ph1">`true`</ph>, выпущенный язык MSIL включает инициализацию локальных переменных.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>If it is set to <ph id="ph1">`false`</ph>, local variables are not initialized and the generated code is unverifiable.</source>
          <target state="translated">Если задано значение <ph id="ph1">`false`</ph>, локальные переменные не инициализируются и созданный код не может быть проверен.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.InitLocals">
          <source>(Get or set.)</source>
          <target state="translated">(Получить или установить.)</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified method.</source>
          <target state="translated">Объект, для которого нужно вызвать указанный метод.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, this parameter is ignored.</source>
          <target state="translated">Если метод является статическим, этот параметр игнорируется.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Этот параметр должен представлять собой битовый флаг объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и т. д.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection.</source>
          <target state="translated">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов членов, а также поиск объектов MemberInfo с помощью отражения.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если связыватель имеет значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется связыватель по умолчанию.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For more details, see <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list.</source>
          <target state="translated">Список аргументов.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</source>
          <target state="translated">Это массив аргументов с тем же числом, порядком и типом, что и параметры вызываемого метода.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">При отсутствии параметров — <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Экземпляр объекта <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>, используемого для управления приведением типов.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is null, the <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Если его значением является null, для текущего потока используется <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(Note that this is necessary to, for example, convert a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Обратите внимание, что необходимо, к примеру, преобразовывать объект <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, представляющий 1000, в значение <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>, поскольку в разных языках и региональных параметрах 1000 представляется по-разному).</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</source>
          <target state="translated">Динамически вызывает метод, отраженный этим экземпляром для данного объекта, передавая указанные параметры и учитывая ограничения данного модуля привязки.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Returns an object containing the return value of the invoked method.</source>
          <target state="translated">Возвращает объект, содержащий возвращаемое значение вызываемого элемента.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">Если метод является статическим, <ph id="ph1">`obj`</ph> параметр учитывается.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Для методов, не являющиеся статическими <ph id="ph1">`obj`</ph> должен быть экземпляром класса, который наследует или объявляет метод, а также должен быть того же типа, что и этот класс.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если метод не имеет параметров, значение <ph id="ph1">`parameters`</ph> должно быть <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">В противном случае число, тип и порядок элементов в массиве параметров должны быть идентичны количество, тип и порядок параметров метода, отраженный этим экземпляром.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully-trusted code.</source>
          <target state="translated">Ограничения доступа игнорируются для полностью доверенного кода.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</source>
          <target state="translated">То есть закрытые конструкторы, методы, поля и свойства доступны и вызывается всегда, когда код с помощью отражения.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is not currently supported.</source>
          <target state="translated">В настоящее время этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Извлеките метод с помощью <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> и вызовите <ph id="ph2">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> в возвращенном методе <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The custom attribute type.</source>
          <target state="translated">Тип настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the custom attributes.</source>
          <target state="translated">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения настраиваемых атрибутов.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Checks if the specified custom attribute type is defined.</source>
          <target state="translated">Проверяет, определен ли заданный тип настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified custom attribute type is defined; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если указанный пользовательский атрибут определен; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported.</source>
          <target state="translated">В настоящее время этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Извлеките метод с помощью <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> и вызовите <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> в возвращенном методе <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>Gets a value indicating whether the method is a generic method.</source>
          <target state="translated">Получает значение, которое указывает, является ли метод универсальным.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is generic; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если метод является универсальным; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>A method is generic if it has type parameters.</source>
          <target state="translated">Метод является универсальным, если он имеет параметры типа.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>You can make a method generic by calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to add type parameters.</source>
          <target state="translated">Можно сделать метод универсального путем вызова <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод, чтобы добавить параметры типа.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This change cannot be reversed.</source>
          <target state="translated">Это изменение нельзя отменить.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">В следующем примере отображается состояние метода.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method.</source>
          <target state="translated">Получает значение, указывающее, представляет ли текущий объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> определение универсального метода.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> представляет определение универсального метода; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> может использоваться только для создания определений универсальных методов; он не может использоваться для создания напрямую к сконструированному универсальному методу.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>However, a subclass of <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> might represent a constructed generic method.</source>
          <target state="translated">Тем не менее подкласс <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> может представлять сконструированного универсального метода.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>The following code example displays the status of a method.</source>
          <target state="translated">В следующем примере отображается состояние метода.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Во всех случаях вызывает исключение <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Во всех случаях вызывает исключение <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Чтобы определить, является ли метод в динамической сборке является критическим с точки зрения безопасности, завершить тип путем вызова <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, вызовите <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> метод завершенного типа, и get <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> в результате <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>In all cases.</source>
          <target state="translated">Во всех случаях.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Это свойство не поддерживается в динамических сборках.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Во всех случаях вызывает исключение <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Во всех случаях вызывает исключение <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Чтобы определить, является ли метод в динамической сборке защищенным критически важным для безопасности, выполните тип путем вызова <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, вызовите <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> метод завершенного типа, и get <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> в результате <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>In all cases.</source>
          <target state="translated">Во всех случаях.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Это свойство не поддерживается в динамических сборках.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Во всех случаях вызывает исключение <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>Throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> in all cases.</source>
          <target state="translated">Во всех случаях вызывает исключение <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method on the completed type, and get the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> property on the resulting <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Чтобы определить, является ли метод в динамической сборке прозрачный для системы безопасности, выполните тип путем вызова <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>, вызовите <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> метод завершенного типа, и get <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> в результате <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>In all cases.</source>
          <target state="translated">Во всех случаях.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent">
          <source>This property is not supported in dynamic assemblies.</source>
          <target state="translated">Это свойство не поддерживается в динамических сборках.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments for the generic method.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, которые представляют аргументы типа для универсального метода.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">Возвращает универсальный метод, построенный на основе определения текущего универсального метода с использованием указанных аргументов универсального типа.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</source>
          <target state="translated">Сведения <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющие универсальный метод, построенный на основе определения текущего универсального метода с использованием указанных аргументов универсального типа.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, before the enclosing type has been completed.</source>
          <target state="translated">При выпуске динамического кода может понадобиться выпустить вызов в метод, построенный на основе определения универсального метода, представленного <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, до завершения данного включающего типа.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for such a constructed method, and use the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the emitted call.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> метод для создания <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> для таких сконструированный метод и используйте <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> в порожденный вызова.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.</source>
          <target state="translated">В следующем примере кода создается сконструированный метод из неполного определения универсального метода в неполный тип.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example creates a transient assembly and module with a single type, adds a method <ph id="ph1">`M`</ph>, and makes the method generic by adding a type parameter T using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">В примере создается временная сборка и модуль с одним типом, добавляет метод <ph id="ph1">`M`</ph>и делает универсальный метод, добавив параметр T типа с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The type parameter is used as the type of the method's parameter, and also as its return type.</source>
          <target state="translated">Параметр типа используется в качестве типа параметра метода и как ее возвращаемый тип.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The generic method definition is not given a body, and the enclosing type is not completed.</source>
          <target state="translated">Определение универсального метода не имеет тела, и включающий тип не будет завершена.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method is then used to make the constructed method <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> Метод затем использовать для внесения сконструированный метод <ph id="ph2">`M&lt;String&gt;`</ph> (<ph id="ph3">`M(Of String)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>The example code has no output, because the subclass of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> method does not allow reflection over its parameters.</source>
          <target state="translated">В примере кода не имеет выхода, так как подкласс <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> возвращенных <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> метод не поддерживает отражение через его параметры.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>For another code example that uses <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, see <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>.</source>
          <target state="translated">Другой пример кода, использующего <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph>, в разделе <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> is also used extensively when emitting code that uses generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A&gt;</ph> также широко используется при создании кода, использующего универсальные типы.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])">
          <source>See <bpt id="p1">[</bpt>How to: Define a Generic Method with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>как: определение универсального метода с отражением порождение<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieves the internal handle for the method.</source>
          <target state="translated">Извлекает внутренний маркер метода.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">Используйте этот маркер для доступа к основному дескриптору метаданных.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>The internal handle for the method.</source>
          <target state="translated">Внутренний маркер метода.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Use this handle to access the underlying metadata handle.</source>
          <target state="translated">Используйте этот дескриптор для доступа к дескриптору базовых метаданных.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>This method is not currently supported.</source>
          <target state="translated">В настоящее время этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.MethodHandle">
          <source>Retrieve the method using <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> and call <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</source>
          <target state="translated">Извлеките метод с помощью <ph id="ph1">&lt;see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /&gt;</ph> и вызовите <ph id="ph2">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph> в возвращенном методе <ph id="ph3">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>Gets the module in which the current method is being defined.</source>
          <target state="translated">Возвращает модуль, в котором определяется текущий метод.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph> in which the member represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is being defined.</source>
          <target state="translated">Модуль <ph id="ph1">&lt;see cref="T:System.Reflection.Module" /&gt;</ph>, в котором определяется элемент, представленный текущим <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Это свойство предоставляется для удобства.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>It is equivalent to using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> property to get the type in which the method is being declared, and then calling the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property of the resulting <ph id="ph3">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Это эквивалентно использованию <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A&gt;</ph> свойство для получения типа, в котором объявлен метод, а затем вызов метода <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> результирующего <ph id="ph3">&lt;xref:System.Type&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Module">
          <source>This property is also equivalent to calling <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>.</source>
          <target state="translated">Это свойство также эквивалентно вызову <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetModule%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves the name of this method.</source>
          <target state="translated">Извлекает имя данного метода.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Name">
          <source>Retrieves a string containing the simple name of this method.</source>
          <target state="translated">Извлекает строку, содержащую простое имя этого метода.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Retrieves the class that was used in reflection to obtain this object.</source>
          <target state="translated">Возвращает класс, который использовался в отражении для получения этого объекта.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReflectedType">
          <source>The type used to obtain this method.</source>
          <target state="translated">Тип, используемый для получения этого метода.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph>, который содержит сведения о типе возвращаемого значения этого метода, например, имеет ли возвращаемый тип пользовательские модификаторы.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph>, содержащий сведения о типе возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">Конструкторы компилятора могут использовать <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> объект, возвращаемый этим свойством, для обнаружения ли пользовательские модификаторы, такие как <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, были применены к возвращаемому типу.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnParameter">
          <source>The declaring type has not been created.</source>
          <target state="translated">Объявляющий тип не создан.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Gets the return type of the method represented by this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">Возвращает метод, представленный этим <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>The return type of the method.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Начиная с .NET Framework 2.0 и .NET Compact Framework 2.0, этот член наследуется от базового класса <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnType">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Returns the custom attributes of the method's return type.</source>
          <target state="translated">Возвращает настраиваемые атрибуты типа возвращаемого значения метода.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>The custom attributes of the method's return type.</source>
          <target state="translated">Настраиваемые атрибуты типа возвращаемого значения метода.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>This method always returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Этот метод всегда возвращает значение <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes">
          <source>Get the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> after the containing <ph id="ph2">&lt;xref:System.Type&gt;</ph> has been created and invoked <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> on the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> после содержащий <ph id="ph2">&lt;xref:System.Type&gt;</ph> создаются и вызываются <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> на <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.MethodBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">Задает пользовательский атрибут.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to describe the custom attribute.</source>
          <target state="translated">Экземпляр вспомогательного класса для описания настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Sets a custom attribute using a custom attribute builder.</source>
          <target state="translated">Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> Метод может взаимодействовать с <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метод, если два метода используются в сочетании.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">В разделе «Примечания» <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метод подробные сведения.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Конструктор настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">Большой двоичный объект байтов, представляющий атрибуты.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For details on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Дополнительные сведения о форматировании <ph id="ph1">`binaryAttribute`</ph>, см. в документации Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method can interact with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method when the two methods are used in combination.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> Метод может взаимодействовать с <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метод, если два метода используются в сочетании.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method for details.</source>
          <target state="translated">В разделе «Примечания» <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метод подробные сведения.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="con" /&gt;</ph> или <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The implementation flags to set.</source>
          <target state="translated">Флаги реализации для установки.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Sets the implementation flags for this method.</source>
          <target state="translated">Задает флаги реализации для этого метода.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you use the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method in combination with the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method, be aware of potential interactions.</source>
          <target state="translated">При использовании <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метод в сочетании с <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> метод, имейте в виду потенциальные взаимодействий.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For example, using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method to add the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> attribute also sets the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Например, с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> метод, чтобы добавить <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph> набора атрибутов также <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>If you subsequently call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method, the <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> flag is overwritten.</source>
          <target state="translated">Если впоследствии вызвать <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метода <ph id="ph2">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig&gt;</ph> флаг перезаписывается.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>There are two ways to avoid this:</source>
          <target state="translated">Чтобы этого избежать двумя способами.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method before you call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метод перед вызовом метода <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> method always respects existing method implementation flags.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A&gt;</ph> Метод всегда учитывает существующие флаги реализации метода.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>When you set implementation flags, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> method.</source>
          <target state="translated">При установке флаги реализации, вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A&gt;</ph> метод получения флаги существующей, используйте побитовый для добавления флага, а затем вызвать <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The code sample below illustrates the contextual use of the <ph id="ph1">`SetImplementationFlags`</ph> method to describe the implementation of MSIL in a method body.</source>
          <target state="translated">Следующий пример кода иллюстрирует использование <ph id="ph1">`SetImplementationFlags`</ph> метода для описания реализации языка MSIL в теле метода.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Marshaling information for the return type of this method.</source>
          <target state="translated">Сведения о маршалинге для типа возвращаемого значения этого метода.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>Sets marshaling information for the return type of this method.</source>
          <target state="translated">Задает сведения о маршалинге для типа возвращаемого значения этого метода.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetMarshal`</ph> method to marshal the results of a method call as a different type.</source>
          <target state="translated">Следующий пример кода иллюстрирует использование <ph id="ph1">`SetMarshal`</ph> метода для маршалинга результатов вызова метода с другим типом.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array that contains valid MSIL instructions.</source>
          <target state="translated">Массив, содержащий допустимые инструкции MSIL.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The maximum stack evaluation depth.</source>
          <target state="translated">Максимальная глубина оценки стека.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>An array of bytes that contain the serialized local variable structure.</source>
          <target state="translated">Массив байтов, содержащий сериализованную структуру локальной переменной.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no local variables.</source>
          <target state="translated">Укажите значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если у метода отсутствуют локальные переменные.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection that contains the exception handlers for the method.</source>
          <target state="translated">Коллекция, содержащая обработчики исключений для метода.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no exception handlers.</source>
          <target state="translated">Укажите значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если у метода отсутствуют обработчики исключений.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>A collection of values that represent offsets in <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, each of which specifies the beginning of a token that may be modified.</source>
          <target state="translated">Коллекция значений, представляющих смещения в <bpt id="p1">&lt;c&gt;</bpt>il<ept id="p1">&lt;/c&gt;</ept>, каждое из которых задает начало токена, который может быть изменен.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the method has no tokens that have to be modified.</source>
          <target state="translated">Укажите значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если у метода отсутствуют токены, которые требуется изменить.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</source>
          <target state="translated">Создает тело метода с использованием указанного массива байтов инструкций промежуточного языка Майкрософт (MSIL).</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="il" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="il" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStack" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> specifies an offset outside of <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</source>
          <target state="translated">Один из <ph id="ph1">&lt;paramref name="exceptionHandlers" /&gt;</ph> указывает смещение за пределами <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>One of <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> specifies an offset that is outside the <ph id="ph2">&lt;paramref name="il" /&gt;</ph> array.</source>
          <target state="translated">Один из <ph id="ph1">&lt;paramref name="tokenFixups" /&gt;</ph> задает смещение за пределами массива <ph id="ph2">&lt;paramref name="il" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>The containing type was previously created using the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью метода <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})">
          <source>This method was called previously on this <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">Этот метод был вызван ранее в данном объекте <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the parameter types.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих типы параметров.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Sets the number and types of parameters for a method.</source>
          <target state="translated">Задает количество и типы параметров для метода.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">Если количество и типы параметров известны при определен метод, их можно задать с помощью любой перегрузки <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> метод, который принимает массив типов параметров.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">Однако универсальный метод может иметь параметры, типы которых указаны для одного или нескольких свои собственные параметры универсального типа, которые могут быть определены только после определения метода.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">Используйте этот метод для указания типов параметров в этом случае.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">Если тип возвращаемого значения содержит необязательный или обязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, используйте <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>Calling this method replaces any parameter types that were set using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вызов этого метода заменяет любой из типов параметров, заданные с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод, чтобы сделать универсальный метод.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> Метод используется для предоставления одного параметра метода, тип которого будет указан первым параметром универсального типа.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> Метод используется для предоставления метода, возвращаемый тип, указанный в качестве второго параметра универсального типа.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">Текущий метод является универсальным, но определение метода универсальным не является.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, однако свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the return type of the method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Sets the return type of the method.</source>
          <target state="translated">Задает возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method.</source>
          <target state="translated">Используйте этот метод, чтобы задать тип возвращаемого значения типа универсального метода, если тип возвращаемого значения определяется одним из параметров универсального типа для метода.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>If the return type has optional or required custom modifiers, such as <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> method overload.</source>
          <target state="translated">Если тип возвращаемого значения содержит необязательный или обязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IsConst&gt;</ph>, используйте <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>Calling this method replaces a return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вызов этого метода заменяет тип возвращаемого значения с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method to make a method generic.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод, чтобы сделать универсальный метод.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> Метод используется для предоставления одного параметра метода, тип которого будет указан первым параметром универсального типа.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> method is used to give the method a return type, specified by the second generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> Метод используется для предоставления метода, возвращаемый тип, указанный в качестве второго параметра универсального типа.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">Текущий метод является универсальным, но определение метода универсальным не является.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, однако свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа метода.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа метода.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Типы параметров метода.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива типов.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</source>
          <target state="translated">Задает сигнатуру метода, включая возвращаемый тип, типы параметров, а также обязательные и необязательные настраиваемые модификаторы для возвращаемого типа и типов параметров.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method that accepts an array of parameter types.</source>
          <target state="translated">Если тип возвращаемого значения и числа и типов параметров известны при определен метод, их можно установить с помощью любой перегрузки <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> метод, который принимает массив типов параметров.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</source>
          <target state="translated">Однако универсальный метод может иметь параметры, типы которых указаны для одного или нескольких свои собственные параметры универсального типа, которые могут быть определены только после определения метода.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this method to set the parameter types in that case.</source>
          <target state="translated">Используйте этот метод для указания типов параметров в этом случае.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If neither the return type nor the parameter types have optional or required custom modifiers, such as <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, you can use the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> methods.</source>
          <target state="translated">Если тип возвращаемого значения ни типы параметров не содержит обязательный или необязательный пользовательские модификаторы, такие как <ph id="ph1">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, можно использовать <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Calling this method replaces the parameters and return type established using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вызов этого метода заменяет параметры и тип возвращаемого значения с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter <ph id="ph1">`T`</ph>.</source>
          <target state="translated">В следующем примере кода содержит исходный код для универсального класса с именем Sample, который имеет параметр типа <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method <ph id="ph3">`GM`</ph> with its own type parameter, <ph id="ph4">`U`</ph>.</source>
          <target state="translated">Класс имеет поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, а также универсальный метод <ph id="ph3">`GM`</ph> со своим параметром типа <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of Sample, substituting its own type parameter <ph id="ph2">`U`</ph> for the type parameter of Sample, and stores its input parameter in <ph id="ph3">`Field`</ph>.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> создает экземпляр Sample, заменяя собственный параметр типа <ph id="ph2">`U`</ph> для параметра типа Sample и сохраняет входной параметр в <ph id="ph3">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Этот исходный код скомпилирован, но не используется. Вы можете просмотреть ее с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>и сравнивают его код, созданный классом <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method in emitting generic code.</source>
          <target state="translated">Код в классе <ph id="ph1">`Example`</ph> демонстрирует использование <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> метода в выпуске универсального кода.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph> Метод класса <ph id="ph2">`Example`</ph> создает динамическую сборку, содержащую класс с именем <ph id="ph3">`Sample`</ph>и использует <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы сделать ее универсальной, добавив параметр типа с именем <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Конструктор по умолчанию и поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, добавляются к классу <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A method <ph id="ph1">`GM`</ph> is added, and turned into a generic method using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> добавляется и преобразуются в универсальный метод с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Параметр типа <ph id="ph1">`GM`</ph> называется <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Once the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added, using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> method.</source>
          <target state="translated">Если задан параметр типа, сигнатуры <ph id="ph1">`GM`</ph> добавляется со <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>There is no return type, and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>, which sets the type of the only parameter of the method; this is set to the method's type parameter, <ph id="ph3">`U`</ph>.</source>
          <target state="translated">Отсутствует возвращаемый тип и требуемые или пользовательские модификаторы, поэтому все параметры этого метода имеют <ph id="ph1">`null`</ph> за исключением <ph id="ph2">`parameterTypes`</ph>, который задает тип единственным параметром метода; это значение параметра типа метода, <ph id="ph3">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Тело метода создает экземпляр сконструированного типа <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> в Visual Basic), назначает параметр метода для <ph id="ph3">`Field`</ph>, а затем выводит значение <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A dummy type is defined, to hold the entry point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Пустой тип определяется для хранения метод точки входа <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">В теле <ph id="ph1">`Main`</ph>, статический <ph id="ph2">`GM`</ph> сконструированный универсальный тип вызывается метод <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> в Visual Basic), с типом <ph id="ph5">&lt;xref:System.String&gt;</ph> замещен <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType&gt;</ph> Метод используется для создания <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> для статического <ph id="ph3">`GM`</ph> метод сконструированного универсального типа <ph id="ph4">`Sample&lt;U&gt;`</ph>и <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> метод затем используется для создания <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , можно создать в вызове метода.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">При запуске примера кода, она сохраняет порожденную сборку как TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Можно запустить TypeBuilderGetFieldExample.exe и использовании <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для сравнения порожденного кода с кодом <ph id="ph1">`Sample`</ph> класс, который компилируется в примере сам.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The current method is generic, but is not a generic method definition.</source>
          <target state="translated">Текущий метод является универсальным, но определение метода универсальным не является.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, однако свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the symbolic custom attribute.</source>
          <target state="translated">Имя символьного настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The byte blob that represents the value of the symbolic custom attribute.</source>
          <target state="translated">Большой двоичный объект байтов, представляющий значение символьного настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Set a symbolic custom attribute using a blob.</source>
          <target state="translated">Задает символьный настраиваемый атрибут с помощью большого двоичного объекта.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</source>
          <target state="translated">В отличие от пользовательского атрибута метаданных настраиваемый атрибут связан с помощью модуля записи символов.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The code sample below illustrates the contextual usage of the <ph id="ph1">`SetSymCustomAttribute`</ph> method to set the byte values for the name and key of a custom attribute attached to a method.</source>
          <target state="translated">Следующий пример кода иллюстрирует использование <ph id="ph1">`SetSymCustomAttribute`</ph> метод для установки байтовых значений имени и ключа пользовательского атрибута, присоединенного к методу.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The containing type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The module that contains this method is not a debug module.</source>
          <target state="translated">Модуль, содержащий этот метод, не является модулем отладки.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>For the current method, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего метода свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Retrieves the signature of the method.</source>
          <target state="translated">Извлекает сигнатуру метода.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.MethodBuilder.Signature">
          <source>A String containing the signature of the method reflected by this <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">Строка, содержащая подпись метода, отражаемого данным экземпляром <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Переданный массив имен, которые необходимо сопоставить.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Количество сопоставляемых имен.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Контекст языкового стандарта для интерпретации имен.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Возвращаемые сведения о типе.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Идентификатор языкового стандарта для сведений о типе.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Получает указатель на объект с запрошенными сведениями о типе.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Идентифицирует член.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Флаги, описывающие контекст вызова.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Указатель, по которому будет сохранен результат.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Указатель на структуру, содержащую сведения об исключении.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Индекс первого аргумента, вызвавшего ошибку.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Предоставляет доступ к открытым свойствам и методам объекта.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::Invoke`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns this <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> instance as a string.</source>
          <target state="translated">Возвращает этот экземпляр <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> в виде строки.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.MethodBuilder.ToString">
          <source>Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</source>
          <target state="translated">Возвращает строку, содержащую имя, атрибуты, сигнатуру метода, исключения и локальную сигнатуру данного метода, за которой следует текущий поток MSIL.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>