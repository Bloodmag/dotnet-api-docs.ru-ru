<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a136bc8fb48fe619f1be21928afbfcd9094d7463" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30474588" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Содержит поля, предоставляющие инструкции языка MSIL для выпуска элементами класса <see cref="T:System.Reflection.Emit.ILGenerator" /> (например, <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подробное описание с кодами операций члена см. в документации Common Language Infrastructure (CLI), особенно «Раздел III набору инструкций CIL» и «Раздел II: определение метаданных и семантика». Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
   
  
## Examples  
 Ниже приведен пример создания динамического метода с использованием <xref:System.Reflection.Emit.ILGenerator> для порождения `OpCodes` в <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|58|add|Добавляет два числовых значения и возвращает новое числовое значение.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется `value2`.  
  
4.  Результат помещается в стек.  
  
 Не обнаружено переполнение для целочисленных операций (для управления переполнением правильную, в разделе <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Целое число со знаком сложения заключает в оболочку, а не насыщение. Например, при условии, что 8-битовых целых чисел где `value1` равно 255 и `value2` имеет значение 1, будет получен результат 0, а не 256.  
  
 С плавающей запятой переполнения возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата. Если нет записи для сочетания определенного типа (например, `int32` и `float`; `int32` и `int64`), он является недопустимым Microsoft промежуточного языка MSIL и создает ошибку.  
  
|Операнд|Значение1 типа|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `add` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целых числа, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D6|Add.ovf|Складывает два значения целого числа со знаком и выполняет проверку переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется `value2` проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не представлен в тип результата.  
  
 Можно выполнить эту операцию для целых чисел со знаком. Для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата. Если нет записи для сочетания определенного типа (например, `int32` и `float`; `int32` и `int64`), он имеет недопустимую инструкцию промежуточного языка Майкрософт (MSIL) и создает ошибку.  
  
|Операнд|Значение1 типа|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `add.ovf` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D7|Add.ovf.un|Добавляет два целочисленных значений без знака и выполняет проверку переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется `value2` проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не представлен в тип результата.  
  
 Можно выполнить эту операцию для целых чисел со знаком. Для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата. Если нет записи для сочетания определенного типа (например, `int32` и `float`; `int32` и `int64`), он имеет недопустимую инструкцию промежуточного языка Майкрософт (MSIL) и создает ошибку.  
  
|Операнд|Значение1 типа|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `add.ovf.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое И двух значений и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Инструкция|Описание:|  
|------------|-----------------|-----------------|  
|5F|и|Вычисляет побитовое и двух целочисленных значений.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value1` и `value2` извлекаются из стека; вычисляется побитовое и двух значений.  
  
4.  Результат помещается в стек.  
  
 `and` Инструкция вычисляет побитовое и двух верхних значений в стеке и оставляет результат в стеке.  
  
 `And` представляет собой операцию целыми числами.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `and` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает неуправляемый указатель на список аргументов текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Возвращает дескриптор списка аргументов для текущего метода.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `arglist` Инструкция возвращает непрозрачный дескриптор (неуправляемый указатель типа `native int`), представляющий список аргументов текущего метода. Этот дескриптор допустим только в течение времени существования текущего метода. Тем не менее, можно передает этот дескриптор для других методов, пока текущий метод в потоке управления. Может выполняться только `arglist` инструкции в пределах метод, который принимает переменное число аргументов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `arglist` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|Выполняет переход к цели инструкции по смещению `target` Если два значения равны.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` равен `value2`, выполняется операция перехода.  
  
 `beq` Инструкция передает управление указанной конечной инструкции, если `value1` равен `value2`. Действует так же, как при выполнении `ceq` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков (подобная передача строго ограничивается и необходимо использовать <xref:System.Reflection.Emit.OpCodes.Leave> инструкции вместо).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `beq` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|Выполняет переход к цели инструкции по смещению `target` Если объекты равны, краткая форма|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` равен `value2`, выполняется операция перехода.  
  
 `beq.s` Инструкция передает управление указанной конечной инструкции, если `value1` равен `value2`. Действует так же, как при выполнении `ceq` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков (подобная передача строго ограничивается и необходимо использовать <xref:System.Reflection.Emit.OpCodes.Leave> инструкции вместо).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `beq.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно значению второго.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`. Действует аналогично выполнению `clt.un` инструкции, за которым следует `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно ему, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`. Действует аналогично выполнению `clt.un` инструкции, за которым следует `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно ему (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge.un` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `clt` инструкции, за которым следует `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge.un` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно ему (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше или равно `value2`, выполняется операция перехода.  
  
 `bge.un.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `clt` инструкции, за которым следует `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bge.un.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`. Действует аналогично выполнению `cgt` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`. Действует аналогично выполнению `cgt` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt.un` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `cgt.un` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt.un` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` больше, чем `value2`, выполняется операция перехода.  
  
 `bgt.un.s` Инструкция передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `cgt.un` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bgt.un.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго значения или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|3E `<int32>`|отключить `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно значению второго.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Действует аналогично выполнению `cgt` инструкции (`cgt.un` для значений с плавающей запятой) следуют `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно ему, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble.s` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Действует аналогично выполнению `cgt` инструкции (`cgt.un` для значений с плавающей запятой) инструкции, за которым следует`brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно ему (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble.un` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `cgt.un` инструкции (`cgt` для значений с плавающей запятой) следуют `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble.un` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно ему (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` меньше или равно `value2`, выполняется операция перехода.  
  
 `ble.un.s` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `cgt.un` инструкции (`cgt` для значений с плавающей запятой) следуют `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ble.un.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|3F < `int32` >|BLT `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго значения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt` Инструкция передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Действует аналогично выполнению `clt` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|32 < `int8` >|BLT.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше, чем значение второго краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt.s` Инструкция передает управление указанной конечной инструкции, если `value1` — меньше, чем `value2`. Действует аналогично выполнению `clt` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|44 < `int32` >|BLT.un `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt.un` Инструкция передает управление указанной конечной инструкции, если `value1` — меньше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `clt.un` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt.un` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|37 < `int8` >|BLT.un.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго (для значений без знака), краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` — меньше, чем `value2`, выполняется операция перехода.  
  
 `blt.un` Инструкция передает управление указанной конечной инструкции, если `value1` — меньше, чем `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `clt.un` инструкции, за которым следует `brtrue` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `blt.un.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|Ветвь в целевой объект инструкции с указанным смещением в случае двух целочисленных значений, не равно (значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` не равен `value2`, выполняется операция перехода.  
  
 `bne.un` Инструкция передает управление указанной конечной инструкции, если `value1` не равен `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `ceq` инструкции, за которым следует `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bne.un` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма) в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Ветвь в целевой объект инструкции с указанным смещением в случае двух целочисленных значений, не равно (значений без знака), краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; если `value1` не равен `value2`, выполняется операция перехода.  
  
 `bne.un` Инструкция передает управление указанной конечной инструкции, если `value1` не равен `value2`, по сравнению с помощью целого числа без знака или неупорядоченных типа float. Действует аналогично выполнению `ceq` инструкции, за которым следует `brfalse` выполняет переход к соответствующей конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `bne.un.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения в ссылку на объект (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|8C < `T` >|Поле `valTypeToken`|Преобразование типа значения (типа, указанного в `valTypeToken`) для ссылки на объект, значение true.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Тип значения помещается в стек.  
  
2.  Тип значения извлекается из стека; `box` выполняется операция.  
  
3.  Ссылки на объект в результирующий тип «процессор» значение помещается в стек.  
  
 Тип значения имеет два представления в Common Language Infrastructure (CLI):  
  
-   «Первичная» форма, используемый при внедрении типа значения в другом объекте или в стеке.  
  
-   Форма «процессор», где данные в тип значения упаковываются в объект и существуют как независимая сущность.  
  
 `box` Инструкция преобразует тип значения «первичного» (распакованный) в ссылку на объект (тип `O`). Это достигается путем создания нового объекта и копирования данных из типа значения во вновь выделенный объект. `valTypeToken` токен метаданных, указывающий тип значения в стеке.  
  
 <xref:System.OutOfMemoryException> возникает, если памяти недостаточно для удовлетворения запроса.  
  
 <xref:System.TypeLoadException> возникает, если класс не найден. Обычно это обнаруживается промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `box` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Выполняет переход к конечной инструкции с указанным смещением.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `br` Инструкция выполняет безусловную передачу управления конечной инструкции. Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `br` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|Выполняет переход к конечной инструкции с указанным смещением, краткая форма.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `br.s` Инструкция выполняет безусловную передачу управления конечной инструкции. Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `br.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сообщает инфраструктуре CLI, что необходимо оповестить отладчик о достижении точки останова.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|01|break|оповещение отладчик о достижении точки останова.|  
  
 По этой операции выполняются не стек вычислений.  
  
 `break` Инструкция предназначена для поддержки отладки. Она сообщает инфраструктуре CLI, необходимо оповестить отладчик о достижении точки останова. Он имеет не влияет на состояние интерпретатора.  
  
 `break` Инструкция имеет наименьший возможный размер Включение исправлений с помощью точки останова с минимальным воздействием на окружающий код.  
  
 `break` Инструкция может осуществляться отладчиком, не выполняют никаких действий или выдать исключение безопасности. Точное поведение определяется реализацией.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `break` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка (<see langword="Nothing" /> в Visual Basic) или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Выполняет переход к конечной инструкции с указанным смещением, если `false`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек предыдущей операцией.  
  
2.  `value` извлекаются из стека; Если `value` — `false`, переход на `target`.  
  
 `brfalse` Инструкции (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (типа `int32`, `int64`, ссылку на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равно нулю (`false`). Если `value` не равно нулю (`true`) продолжает выполнение следующей инструкции.  
  
 Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brfalse` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если `false`, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек предыдущей операцией.  
  
2.  `value` извлекаются из стека; Если `value` — `false`, переход на `target`.  
  
 `brfalse.s` Инструкции (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (типа `int32`, `int64`, ссылку на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равно нулю (`false`). Если `value` не равно нулю (`true`) продолжает выполнение следующей инструкции.  
  
 Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brfalse.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значение <paramref name="value" /> равно <see langword="true" />, либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|Выполняет переход к конечной инструкции с указанным смещением, если ненулевое значение (`true`).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек предыдущей операцией.  
  
2.  `value` извлекаются из стека; Если `value` — `true`, переход на `target`.  
  
 `brtrue` Инструкция передает управление указанной конечной инструкции, если `value` (тип `native int`) имеет ненулевое значение (`true`). Если `value` равно нулю (`false`) продолжает выполнение следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`) затем `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на пустой объект; см. раздел <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brtrue` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если значение <paramref name="value" /> равно <see langword="true" /> либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|Выполняет переход к конечной инструкции с указанным смещением, если ненулевое значение (`true`), краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек предыдущей операцией.  
  
2.  `value` извлекаются из стека; Если `value` — `true`, переход на `target`.  
  
 `brtrue.s` Инструкция передает управление указанной конечной инструкции, если `value` (тип `native int`) имеет ненулевое значение (`true`). Если `value` равно нулю (`false`) продолжает выполнение следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`) затем `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на пустой объект; см. раздел <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов. Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `brtrue.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, на который ссылается переданный дескриптор метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|28 < `T` >|Вызов `methodDesc`|Вызовите метод, описанный `methodDesc`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Аргументы метода `arg1` через `argN` помещается в стек.  
  
2.  Аргументы метода `arg1` через `argN` извлекаются из стека; выполняется вызов метода с этими аргументами и управление передается методу, на который ссылается дескриптор метода. По завершении возвращаемое значение создается с помощью метода вызываемого объекта и отправлен в вызывающий код.  
  
3.  Возвращаемое значение помещается в стек.  
  
 `call` Инструкция вызывает метод, передаваемый с инструкцией дескриптор метода. Дескриптор метода представляет собой лексему метаданных, который указывает метод для вызова и количество, тип и порядок аргументов, которые были помещены в стек должен быть передан этому методу, а также соглашение о вызовах для использования. `call` Инструкция может непосредственно предшествовать `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) префиксная инструкция для указания освобождение состояния текущего метода перед передачей управления. Если вызов передает управление методу, более высокий уровень доверия, чем у исходного метода, кадр стека не освобождается. Вместо этого выполнение продолжается так, словно `tail` не был указан. Токен метаданных содержит сведения, позволяющие определить, является ли вызов статического метода, метод экземпляра, виртуальный метод или глобальной функции. Во всех этих случаях адрес назначения определяется исключительно на основании дескриптора метода (Сравните это с <xref:System.Reflection.Emit.OpCodes.Callvirt> инструкции для вызова виртуальных методов, где адрес назначения также зависит от типа среды выполнения экземпляра ссылка в стек перед <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент вычисляется, а поместить в стек, затем второй аргумент, затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания. Существует три важных особых случаях:  
  
 1. Вызовы к экземпляру (или виртуальных) метода необходимо поместить ссылку на экземпляр перед любыми видимыми аргументов. Ссылка на экземпляр не должен быть пустой ссылкой. Подпись, передавая с метаданными не содержит запись в списке параметров для `this` указателю; вместо этого используется бит, определяющий, требует ли метод передачи `this` указателя.  
  
 2. Он допустим для вызова виртуального метода с помощью `call` (а не `callvirt`); это означает, что метод является будет обработан с помощью класса, заданного методом, а не как динамически из вызываемого объекта.  
  
 3. Обратите внимание, что делегат `Invoke` метод может вызываться с помощью `call` или `callvirt` инструкции.  
  
 <xref:System.Security.SecurityException> может быть вызвано, если система безопасности не позволяет вызывающей процедуре получить доступ к вызываемому методу. Проверка безопасности может возникнуть при преобразовании в машинный код, а не во время выполнения инструкции промежуточного языка Майкрософт (MSIL).  
  
> [!NOTE]
>  При вызове методов класса System.Object в типах значений, рассмотрите возможность использования `constrained` префикс `callvirt` инструкции вместо выдача `call` инструкции. Это устраняет необходимость выпуска другой инструкции промежуточного языка в зависимости от того, является ли тип значения переопределяет метод, как избежать потенциальных проблем управления версиями. Рассмотрите возможность использования `constrained` префикс при вызове методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью `MethodImpl`. Эти проблемы описаны более подробно в <xref:System.Reflection.Emit.OpCodes.Constrained> код операции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `call` код операции:  
  
-   ILGenerator.Emit (код операции, MethodInfo)  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Метод предоставляется для `varargs` вызовов. Используйте <xref:System.Reflection.Emit.ILGenerator.Emit%2A> метод обычные вызовы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, заданный в стеке вычислений (как указатель на точку входа), с аргументами, описанными в соглашении о вызовах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|29 < `T` >|Calli `callSiteDescr`|Вызывает метод по указателю с аргументами, описанными в соглашении о вызовах.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Аргументы метода `arg1` через `argN` помещается в стек.  
  
2.  Указатель на точку входа метода помещается в стек.  
  
3.  Аргументы метода `arg1` через `argN` и указатель на точку входа метода извлекаются из стека; выполняется вызов метода. По завершении возвращаемое значение создается с помощью метода вызываемого объекта и отправлен в вызывающий код.  
  
4.  Возвращаемое значение помещается в стек.  
  
 `calli` Инструкция вызывает указатель на точку входа метода с аргументами `arg1` через `argN`. Типы этих аргументов описаны определенным соглашением о вызовах (`callSiteDesc`). `calli` Инструкция может непосредственно предшествовать `tail` префикс (<xref:System.Reflection.Emit.OpCodes.Tailcall>) для указания освобождение состояния текущего метода перед передачей управления. Если вызов передает управление методу более высокий уровень доверия, чем у исходного метода кадр стека не удаляется. Вместо этого выполнение продолжается так, как если бы `tail` не был указан.  
  
 Указатель на точку входа метода предполагается определенный указатель на машинный код (конечного компьютера), допустимым образом вызван с аргументами, описанными в соглашении о вызовах (лексема метаданных для отдельной подписи). Такой указатель можно создать с помощью <xref:System.Reflection.Emit.OpCodes.Ldftn> или <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> инструкции, и переданный из машинного кода.  
  
 Соглашение о вызовах не проверяется динамически, поэтому код, использующий `calli` инструкций не работает правильно, если конечный метод не использует соглашение о вызовах.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент вычисляется, а поместить в стек, затем второй аргумент, затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания. Последовательности кода программисту для экземпляра или виртуального метода необходимо поместить ссылку на экземпляр (он не должен быть пустой ссылкой) перед любыми видимыми аргументов.  
  
 <xref:System.Security.SecurityException> может быть вызвано, если система безопасности не позволяет вызывающей процедуре получить доступ к вызываемому методу. Проверка безопасности происходит на этапе преобразования инструкций промежуточного языка Майкрософт (MSIL) в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> методы можно использовать для выполнения `calli` инструкции в стеке. Обратите внимание, что `calli` должен вызываться через ниже методов, а не с помощью <xref:System.Reflection.Emit.ILGenerator.Emit%2A> класса для помещения инструкции непосредственно в стеке.  
  
-   ILGenerator.EmitCalli (код операции, CallingConventions, тип, Type [], Type[]) для вызовов с помощью управляемых соглашение о вызовах.  
  
-   ILGenerator.EmitCalli (Opcode Type[]) CallingConvention, тип, для вызовов с помощью неуправляемых соглашение о вызовах.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод объекта с поздней привязкой и помещает возвращаемое значение в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Вызывает определенный метод, связанный с `obj`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Аргументы метода `arg1` через `argN` помещается в стек.  
  
3.  Аргументы метода `arg1` через `argN` и ссылка на объект `obj` извлекаются из стека; выполняется вызов метода с этими аргументами и управление передается методу в `obj` ссылается метод токен метаданных. По завершении возвращаемое значение создается с помощью метода вызываемого объекта и отправлен в вызывающий код.  
  
4.  Возвращаемое значение помещается в стек.  
  
 `callvirt` Инструкция вызывает метод позднего связывания объекта. То есть метод зависит от типа времени выполнения `obj` вместо класса во время компиляции, видимого в указателе метода. `Callvirt` можно использовать для вызова виртуальных методов и методов экземпляра. `callvirt` Инструкция может непосредственно предшествовать `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) префикс для указания отжатии текущий кадр стека перед передачей управления. Если вызов передает управление методу более высокий уровень доверия, чем у исходного метода кадр стека не удаляется.  
  
 Токен метаданных метода предоставляет имя, класс и сигнатуру метода для вызова. Класс, связанный с `obj` — это класс, экземпляр которого он является. Если класс определяет нестатический метод, который соответствует указанное имя и подпись, этот метод вызывается. В противном случае все классы в цепочке базовый класс этого класса проверяются по порядку. Считается ошибкой, если метод не найден.  
  
 `Callvirt` Извлекает объект и соответствующие аргументы из стека вычислений перед вызовом метода. Если метод имеет возвращаемое значение, он помещается в стек по завершении метода. На стороне вызываемой `obj` параметра доступно в качестве аргумента 0, `arg1` как аргумент 1 и т. д.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент вычисляется, а поместить в стек, затем второй аргумент, затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания. Ссылка на экземпляр `obj` (всегда требуется для `callvirt`) должна быть стек перед всеми видимыми аргументов. Подпись (передается в токен метаданных) не должны содержать запись в списке параметров для этого указателя.  
  
 Обратите внимание, что виртуальный метод может также вызываться с использованием <xref:System.Reflection.Emit.OpCodes.Call> инструкции.  
  
 <xref:System.MissingMethodException> возникает, если нестатический метод с указанным именем и подписью не удалось найти в классе, связанном с `obj` или любого из его базовых классов. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.  
  
 <xref:System.NullReferenceException> возникает, если obj имеет значение null.  
  
 <xref:System.Security.SecurityException> возникает, если система безопасности не позволяет вызывающей процедуре получить доступ к вызываемому методу. Проверка безопасности обычно происходит, когда CIL-ФАЙЛ преобразуется в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов класса System.Object в типах значений, рассмотрите возможность использования `constrained` префикс `callvirt` инструкции. Это устраняет необходимость выпуска другой инструкции промежуточного языка в зависимости от того, является ли тип значения переопределяет метод, как избежать потенциальных проблем управления версиями. Рассмотрите возможность использования `constrained` префикс при вызове методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью `MethodImpl`. Эти проблемы описаны более подробно в <xref:System.Reflection.Emit.OpCodes.Constrained> код операции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `callvirt` код операции:  
  
-   ILGenerator.Emit (код операции, MethodInfo)  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предпринимает попытку привести объект, передаваемый по ссылке, к указанному классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Приводит объект новый объект типа `class`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека; Указанный объект приводится как указанный `class`.  
  
3.  В случае успеха новая ссылка на объект помещается в стек.  
  
 `castclass` Инструкция пытается выполнить преобразование ссылки на объект (тип `O`) на вершине стека к указанному классу. Новый класс, указанный с помощью лексемы метаданных, указывающий нужный класс. Если класс объекта на вершине стека не реализует новый класс (новый класс — интерфейс), а не производным классом от нового класса то <xref:System.InvalidCastException> возникает исключение. Если ссылка на объект является пустой ссылкой, `castclass` завершается успешно и возвращает новый объект как пустую ссылку.  
  
 <xref:System.InvalidCastException> возникает, если obj не может быть приведен к классу.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `castclass` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если они равны, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Помещает в стек 1, если `value1` равняется `value2`; в противном случае помещает в стек 0.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` сравнивается с `value2`.  
  
4.  Если `value1` равен `value2`, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `ceq` Сравнивает инструкция `value1` и `value2`. Если `value1` равен `value2`, нажмите 1 (типа `int32`) помещается в стек. В противном случае — 0 (типа `int32`) помещается в стек.  
  
 Числа с плавающей запятой `ceq` возвращает 0, если числа неупорядочены (одно или оба значения имеют тип NaN). Бесконечные значения равны на самих себя.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ceq` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Помещает в стек 1, если `value1` больше, чем `value2`; в противном случае помещает в стек 0.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt` проверяет `value1` больше, чем `value2`.  
  
4.  Если `value1` больше, чем `value2`, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `cgt` Сравнивает инструкция `value1` и `value2`. Если `value1` строго больше `value2`, то `int32` помещается значение 1 в стек. В противном случае `int32` значение 0 помещается в стек.  
  
-   Для чисел с плавающей запятой `cgt` возвращает 0, если числа неупорядочены (то есть, если один или оба аргумента имеют значение NaN).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cgt` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 03|или cgt.un|Помещает в стек 1, если `value1` больше, чем `value2`; в противном случае помещает в стек 0 (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt.un` проверяет `value1` больше, чем `value2`.  
  
4.  Если `value1` больше, чем `value2`, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `int32` В стеке помещается значение 1, если выполняется одно из следующих `true` :  
  
 Для чисел с плавающей запятой `value1` не упорядочен по отношению к `value2`.  
  
 Для целых значений `value1` строго больше `value2` при сравнении чисел без знака.  
  
 В противном случае `int32` значение 0 помещается в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cgt.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает исключение <see cref="T:System.ArithmeticException" />, если значение не является конечным числом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|C3|Ckfinite|исключение <xref:System.ArithmeticException> , если значение не является конечным числом.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек...  
  
2.  `value` извлекается из стека и `ckfinite` инструкций, выполняемых в ней.  
  
3.  `value` помещается обратно в стек, если исключение не возникает.  
  
 `ckfinite instruction` Вызывает <xref:System.ArithmeticException> Если `value` (число с плавающей запятой) имеет значение «не число» значением (NaN) или `+-` значение бесконечности. `Ckfinite` оставляет значение в стеке, если исключение не возникает. Выполнение не определено, если `value` не является числом с плавающей запятой.  
  
 <xref:System.ArithmeticException> возникает, если `value` не имеет значение «normal».  
  
 Обратите внимание, что специальное исключение или производный класс <xref:System.ArithmeticException> может оказаться более удобным, передачи неверного значения обработчику исключений.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ckfinite` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение меньше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 04|Средство регистрации звонков|Помещает в стек 1, если `value1` — меньше, чем `value2`; в противном случае помещает в стек 0.|  
  
 Изменения состояния стека в последовательном порядке, является: `value1` помещается в стек.  
  
1.  `value2` помещается в стек.  
  
2.  `value2` и `value1` извлекаются из стека; `clt` проверяет `value1` — меньше, чем `value2`.  
  
3.  Если `value1` — меньше, чем `value2`, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `clt` Сравнивает инструкция `value1` и `value2`. Если `value1` является строго меньше `value2`, то `int32` помещается значение 1 в стек. В противном случае `int32` значение 0 помещается в стек.  
  
-   Для чисел с плавающей запятой `clt` возвращает 0, если числа неупорядочены (то есть, если один или оба аргумента имеют значение NaN).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `clt` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения <paramref name="value1" /> и <paramref name="value2" />. Если значение <paramref name="value1" /> меньше значения <paramref name="value2" />, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 05|CLT.un|Помещает в стек 1, если `value1` — меньше, чем `value2`; в противном случае помещает в стек 0 (для значений без знака).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `clt.un` проверяет `value1` — меньше, чем `value2`.  
  
4.  Если `value1` — меньше, чем `value2`, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `clt.un` Сравнивает инструкция `value1` и `value2`. `int32` В стеке помещается значение 1, если выполняется хотя бы одно из следующих действий:  
  
-   `value1` является строго меньше `value2` (как для `clt`).  
  
-   Для чисел с плавающей запятой `value1` не упорядочен по отношению к `value2`.  
  
-   Для целых значений `value1` является строго меньше `value2` при сравнении чисел без знака.  
  
 В противном случае `int32` значение 0 помещается в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `clt.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ограничивает тип, для которого был вызван виртуальный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|ограничение. `thisType`|Вызов виртуального метода в типе ограничена до типа `T`.|  
  
 `constrained` Префикса разрешается только в `callvirt` инструкции.  
  
 Состояние стека MSIL на этом этапе может выглядеть следующим образом:  
  
1.  Управляемый указатель, `ptr`, помещенный в стек. Тип `ptr` должен быть управляемым указателем (`&`) для `thisType`. Обратите внимание, что это отличается от применения без префикса `callvirt` инструкции, которая ожидает ссылку из `thisType`.  
  
2.  Аргументы метода `arg1` через `argN` помещаются в стек, как и в случае без префикса `callvirt` инструкции.  
  
 `constrained` Префикс позволяет `callvirt` инструкциям, чтобы быть независимы в единую, каким образом следует ли `thisType` является типом значения или ссылочным типом.  
  
 Когда `callvirt` `method` предваряться инструкция `constrained` `thisType`, инструкция выполняется следующим образом:  
  
-   Если `thisType` является ссылочным типом (в отличие от типа значения), затем `ptr` разыменован и передается как указатель «this» для `callvirt` из `method`.  
  
-   Если `thisType` является типом значения и `thisType` реализует `method` затем `ptr` передается без изменений как указатель «this» для `call` `method` инструкции для реализации `method` по `thisType`.  
  
-   Если `thisType` является типом значения и `thisType` не реализует `method` затем `ptr` разыменован, упаковывается и передается как указатель «this» для `callvirt` `method` инструкции.  
  
 Этот последний случай может произойти, только если `method` была определена в <xref:System.Object>, <xref:System.ValueType>, или <xref:System.Enum> и не переопределяется `thisType`. В этом случае упаковка приводит копию исходного объекта должна быть выполнена. Тем не менее поскольку ни один из методов <xref:System.Object>, <xref:System.ValueType>, и <xref:System.Enum> изменения состояния объекта, не удается обнаружить этот факт.  
  
 `constrained` Префикс поддерживает генераторы промежуточного языка, которые создают универсальный код. Обычно `callvirt` инструкция не является допустимой для типов значений. Вместо этого она необходима, компиляторы IL эффективно выполняют 'this' преобразования, описанные выше, во время компиляции, в зависимости от типа `ptr` и вызываемого метода. Тем не менее, если `ptr` является универсальным типом, неизвестным во время компиляции невозможно сделать это преобразование во время компиляции.  
  
 `constrained` Opcode позволяет компиляторам промежуточного языка вызов виртуальной функции в единую, каким образом независимо от ли `ptr` является типом значения или ссылочным типом. Несмотря на то, что он предназначен для случая где `thisType` является переменной универсального типа `constrained` префикс также работает для неуниверсальных типов и может уменьшить сложность создания виртуальных вызовов на языках, в которых скрывается различие между типами значений и ссылочные типы.  
  
 С помощью `constrained` префикс также избегает потенциальных проблем управления версиями с типами значений. Если `constrained` префикс не используется, в зависимости от того, является ли тип значения переопределяет метод System.Object извлекаются разные IL. Например, если тип значения `V` переопределяет метод Object.ToString() `call` `V.ToString()` создается инструкция; Если нет, `box` инструкции и `callvirt` `Object.ToString()` выдаются инструкции. Проблема может возникнуть в первом примере, если переопределение позже будет удалено, а в последнем случае, если переопределение будет добавлено.  
  
 `constrained` Префикс может также быть использован для вызова методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью `MethodImpl`. Если `constrained` префикс не используется, компилятор вынужден выбирать, какие значения методы типа, чтобы подключить во время компиляции. С помощью `constrained` префикс позволяет MSIL для привязки к методу, который реализует метод интерфейса во время выполнения, а не во время компиляции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `constrained` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D3|conv.i|Преобразовать `native int`и помещает `native int` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|67|conv.i1|Преобразовать `int8`и помещает `int32` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i1` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|68|conv.I2|Преобразовать `int16`и помещает `int32` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i2` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|69|conv.i4|Преобразовать `int32`и помещает `int32` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i4` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|6A|conv.I8|Преобразовать `int64`и помещает `int64` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.i8` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Преобразовать `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Преобразует значение без знака `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Преобразовать `int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i1` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Преобразует значение без знака `int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i1.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i1.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.I2|Преобразовать `int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i2` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|83|conv.ovf.I2.un|Преобразует значение без знака `int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i2.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i2.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Преобразовать `int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i4` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Преобразует значение без знака `int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i4.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i4.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.I8|Преобразовать `int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i8` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|85|conv.ovf.I8.un|Преобразует значение без знака `int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.i8.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.i8.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Преобразовать `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Преобразует значение в без знака `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.uvf.u.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.U1|Преобразовать `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u1` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|86|conv.ovf.U1.un|Преобразует значение без знака `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u1.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u1.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|Преобразовать `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u2` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Преобразует значение без знака `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u2.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u2.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.U4|Преобразовать `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u4` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Преобразует значение без знака `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u4.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u4.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Преобразовать `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u8` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Преобразует значение без знака `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция. Если происходит переполнение, создается исключение.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.ovf.u8.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.  
  
 Преобразование чисел с плавающей запятой в целые усечь число к нулю. Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.ovf.i` или `conv.ovf.u` используются, в этом случае результат также имеет `native int`).  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.ovf.u8.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразование целочисленного значения без знака на вершине стека вычислений в <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Преобразовать целое число без знака для чисел с плавающей запятой, помещает `F` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.r.un` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целочисленный `result` возвращается не указан. `conv.r.un` Операция принимает целое число из стека, интерпретирует его как число без знака и заменяет числом с плавающей запятой, чтобы представить целое число: либо `float32`, если это достаточно широкой, чтобы представить целое число без потери точности или else `float64`.  
  
 Нет когда-либо исключения при использовании данного поля.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.r.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|6B|conv.R4|Преобразовать `float32`и помещает `F` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.r4` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|6C|conv.R8|Преобразовать `float64`и помещает `F` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.r8` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned native int" />, а затем расширяет его до <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|E0|conv.u|Преобразовать `unsigned native int`и помещает `native int` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D2|conv.U1|Преобразовать `int8`и помещает `int32` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u1` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D1|conv.u2|Преобразовать `int16`и помещает `int32` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u2` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int32" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|6D|conv.U4|Преобразовать `unsigned int32`и помещает `int32` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u4` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int64" />, а затем расширяет его до <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|6E|conv.u8|Преобразовать `int64`и помещает `int64` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, а преобразование выполняется операция.  
  
3.  Если преобразование прошло успешно, результирующее значение помещается в стек.  
  
 `conv.u8` Преобразует код операции `value` на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека. Целочисленные значения размером менее 4 байтов расширяются до `int32` когда они были загружены в стек вычислений (если не `conv.i` или `conv.u` используется, в этом случае результат также имеет `native int`). Значения с плавающей запятой, преобразуются в `F` типа.  
  
 Преобразование чисел с плавающей запятой в целые усекает число к нулю. При преобразовании из `float64` для `float32`, точность может быть потеряно. Если `value` слишком велик для размещения в `float32 (F)`, плюс бесконечность (если `value` является положительным) или минус бесконечность (если `value` является отрицательным) возвращается. Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка. Если результат меньше `int32`, значение выполняется с расширением знака для заполнения области.  
  
 Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 Нет когда-либо исключения при использовании данного поля. В разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `conv.u8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует заданное число байт из исходного адреса в конечный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Копирует данные из одного блока памяти в другое.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Конечный адрес помещается в стек.  
  
2.  Исходный адрес помещается в стек.  
  
3.  Число байтов для копирования помещается в стек.  
  
4.  Число байтов, адрес источника и целевой адрес извлекаются из стека; указанное число байтов копируются из исходного адреса на указанный адрес назначения.  
  
 `cpblk` Инструкция копирует число (типа `unsigned int32`) байтов из исходного адреса (типа `*`, `native int`, или `&`) по адресу назначения (типа `*`, `native int`, или `&`). Поведение `cpblk` не указан при перекрытии исходного и конечного областей.  
  
 `cpblk` предполагается, что исходный и конечный адреса выровнены по размеру машины. `cpblk` Инструкция может непосредственно предшествовать `unaligned.<prefix>` инструкции, чтобы указать, что исходный или конечный адрес не выровнен.  
  
 Работу `cpblk` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> может быть создано исключение при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cpblk` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует тип значения по адресу объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />) и помещает его по адресу конечного объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Копирует тип значения из исходного объекта в целевой объект.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на конечный объект помещается в стек.  
  
2.  Ссылка на исходный объект помещается в стек.  
  
3.  Обе ссылки на объекты извлекаются из стека; Тип значения по адресу объекта источника копируется на адрес целевого объекта.  
  
 Поведение `cpobj` не определено, если исходный и целевой объект ссылки не являются указателями на экземпляры класса, представленного маркером класс `classTok` ( `typeref` или `typedef`), или если `classTok` не представляет Тип значения.  
  
 <xref:System.NullReferenceException> может быть создано исключение при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `cpobj` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает результат в стек вычислений как число с плавающей запятой (с типом <see langword="F" />) или как частное (с типом <see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|5B|div|Делит одно значение возвращает частное или результат с плавающей запятой.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` div value2 удовлетворяет следующим условиям:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, и:  
  
 знак (`result`) = +, если знак (`value1`) = знак (`value2`), или-, если знак (`value1`) ~ = знак (`value2`)  
  
 `div` Инструкция вычисляет результат и помещает его в стеке.  
  
 Целочисленное деление усекает к нулю.  
  
 Деление конечного числа на ноль создает правильно подписанного бесконечное значение.  
  
 Деление ноля на ноль или бесконечности на бесконечность возвращает значение NaN (не числовое). Деление любого числа на бесконечность сформирует нулевое значение.  
  
 Целочисленные операции создают исключение <xref:System.ArithmeticException> Если результат невозможно представить в типе результата. Это может произойти, если `value1` — это максимальное значение отрицательное, и `value2` — -1.  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException> Если `value2` равно нулю.  
  
 Обратите внимание, что для платформ на основе Intel <xref:System.OverflowException> возникает при вычислении (minint div -1). Операции с плавающей запятой не генерируют исключений (они возвращают значения NaN или бесконечность).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `div` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно целочисленное значение без знака на другое и помещает результат (<see langword="int32" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|5C|div.un|Делит одно значение без знака, возврат частного.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 `div.un` Инструкция вычисляет `value1` деленная `value2`, без целых чисел без знака и помещает `result` в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `div.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует текущее верхнее значение в стеке вычислений и помещает копию в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|25|Dup|Дублирует значению на вершине стека.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека для дублирования.  
  
3.  `value` помещается обратно в стек.  
  
4.  Повторяющееся значение помещается в стек.  
  
 `dup` Инструкция дублирует верхний элемент стека и оставляет два одинаковых значения на вершине стека.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `dup` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="filter" /> исключения обратно в обработчик исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 11|Команда endfilter|Конец предложения filter обработки исключений SEH.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекаются из стека; `endfilter` выполняется и управление передается обработчику исключений.  
  
 `Value` (который должен быть типа `int32` и является одним из определенного набора значений) возвращается из предложения filter. Он должен быть одним из:  
  
-   `exception_continue_search` (`value` = 0) для продолжения поиска для обработчика исключений  
  
-   `exception_execute_handler` (`value` = 1) — начать второй этап обработки исключений, в котором блоки finally выполняются до обработчик, связанный с данным предложением filter находится. После обнаружения обработчик выполняется.  
  
 Другие целочисленные значения сформирует результаты не определены.  
  
 Точка входа фильтра, как показано в таблице исключений метода, должны быть первой инструкции в блоке кода filter. `endfilter` Инструкция должна быть последней инструкции в блоке кода filter (таким образом может быть только один `endfilter` для одного блока filter). После выполнения `endfilter` инструкции, управление логически передается обратно механизму обработки исключений CLI.  
  
 Элемент управления может быть передано в блок filter только через механизм обработки исключений. Управление может быть передано из блока фильтра, за исключением случаев использования `throw` инструкций или путем выполнения последней `endfilter` инструкции. Не удается внедрить `try` блок `filter` блока. Если исключение внутри `filter` блока, оно перехватывается и значение 0 (`exception_continue_search`) возвращается.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `endfilter` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="fault" /> или <see langword="finally" /> блока исключения обратно обработчику исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|DC|Команда endfinally<br /><br /> endfault|Завершает `finally` или `fault` предложение блока исключения.|  
  
 Нет стек не вариантов поведения для данной инструкции.  
  
 `Endfinally` и `endfault` обозначения конца `finally` или `fault` предложения, поэтому Очистка стека можно продолжить работу, пока не будет вызван обработчик исключений. `endfinally` Или `endfault` инструкция передает управление обратно в механизм обработки исключений CLI. Этот механизм выполняет поиск следующего `finally` предложение в цепочке, если выход из защищенного блока был выполнен с помощью инструкции leave. Если выход из защищенного блока был выполнен с исключением, (CLI) выполняет поиск следующего `finally` или `fault`, или введите в обработчик, выбранный на первом этапе обработки исключений.  
  
 `endfinally` Инструкция может располагаться только внутри лексически `finally` блока. В отличие от `endfilter` инструкции, не требуется завершение блока с `endfinally` инструкция и может быть столько `endfinally` инструкции в блоке. Те же ограничения применяются к `endfault` инструкции и `fault` блока.  
  
 Управление не может быть передано в `finally` (или `fault`) блок за исключением через механизм обработки исключений. Управление может быть передано из `finally` (или `fault`) блок за исключением случаев использования `throw` инструкции или выполнении `endfinally` (или `endfault`) инструкции. В частности, вы не «попадает» из `finally` (или `fault`) блока или выполнять <xref:System.Reflection.Emit.OpCodes.Ret> или <xref:System.Reflection.Emit.OpCodes.Leave> инструкции в пределах `finally` (или `fault`) блока.  
  
 Обратите внимание, что `endfault` и `endfinally` инструкции являются псевдонимами — они соответствуют одному коду операции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `endfinally` (`endfault`) код операции, а также `ILGenerator` метод <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует блок памяти с определенным адресом, присваивая его начальному значению с заданным размером.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Задайте каждого местоположения в блок памяти, заданное значение.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Начальный адрес помещается в стек.  
  
2.  Начальное значение помещается в стек.  
  
3.  Число байтов для инициализации помещается в стек.  
  
4.  Число байт, значение инициализации и начальный адрес извлекаются из стека, и инициализация выполняется в соответствии с их значения.  
  
 `initblk` Номер наборы инструкций (`unsigned int32`) байтов, начиная с указанного адреса (типа `native int`, `&`, или `*`) для инициализации значение (типа `unsigned int8`). `initblk` предполагается, что начальный адрес выровнен по размеру машины.  
  
 Работу `initblk` инструкции может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> может быть создано исключение при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `initblk` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует каждое поле типа значения с определенным адресом пустой ссылкой или значением 0 соответствующего простого типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|Инициализирует тип значения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес типа значения для инициализации помещается в стек.  
  
2.  Адрес извлекается из стека; Тип значения по указанному адресу инициализируется как тип `typeTok`.  
  
 `initobj` Инструкция инициализирует каждое поле типа значения, заданные в стек адрес (типа `native int`, `&`, или `*`) пустой ссылкой или значением 0 соответствующего простого типа. После вызова этого метода экземпляр готов к метод для вызова конструктора. Если `typeTok` является ссылочным типом, эта инструкция действует так же, как `ldnull` следуют `stind.ref`.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` не вызывает метод конструктора. `Initobj` — предназначен для инициализации типов значений, тогда как `newobj` используется для размещения и инициализации объектов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `initobj` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Проверяет, является ли ссылка на объект (с типом <see langword="O" />) экземпляром определенного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|75 < `T` >|инструкции isinst `class`|Проверяет, может ли ссылка на объект является экземпляром класса `class`, возвращая пустую ссылку или экземпляр этого класса или интерфейса.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и проверяется, если он является экземпляром класса, заданного в `class`.  
  
3.  Результат (ссылка на объект или пустая ссылка) помещается в стек.  
  
 `Class` токен метаданных, указывающий требуемый класс. Если класс объекта на вершине стека реализует `class` (если `class` — это интерфейс) или является производным классом от `class` (если `class` — обычный класс) он приводится к типу `class` и результат помещается в стек, точно так, будто <xref:System.Reflection.Emit.OpCodes.Castclass> бы была вызвана. В противном случае — пустая ссылка помещается в стек. Если ссылка на объект является пустой ссылкой, затем `isinst` также возвращает пустую ссылку.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `isinst` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Прекращает выполнение текущего метода и переходит к заданному методу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|27 < `T` >|безусловный `method`|Прекращает выполнение текущего метода и переходит к заданному методу.|  
  
 Нет стек не вариантов поведения для данной инструкции.  
  
 `jmp` (Jump) инструкция передает управление методу, заданному параметром `method`, являющееся токен метаданных для ссылки на метод. Текущие аргументы передаются в метод назначения.  
  
 Стек вычислений должно быть пустым, если при выполнении данной инструкции. Соглашение о вызовах, число и тип аргументов по адресу назначения должно совпадать со текущего метода.  
  
 `jmp` Инструкция не может использоваться для передачи управления из `try`, `filter`, `catch`, или `finally` блока.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `jmp` код операции:  
  
-   ILGenerator.Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное значение индекса) в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|Загружает аргумент с индексом `index` в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение аргумента с `index` помещается в стек.  
  
 `ldarg` Инструкция помещает аргумент с индексом `index`, где аргументы индексируются, начиная с версии, 0 в стек вычислений. `ldarg` Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.  
  
 В процедурах, принимающих список аргументов переменной длины `ldarg` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи (в разделе <xref:System.Reflection.Emit.OpCodes.Arglist> инструкции для получения дополнительных сведений).  
  
 Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 0 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|02|ldarg.0|Загружает аргумент 0 в стек|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 0 помещается в стек.  
  
 `ldarg.0` Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 0.  
  
 `ldarg.0` Инструкция помещает аргумент с индексом 0 в стек вычислений. `ldarg.0` Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.  
  
 Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 1 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Загружает аргумент 1 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 1 помещается в стек.  
  
 `ldarg.1` Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 1.  
  
 `ldarg.1` Инструкция помещает аргумент с индексом 1 в стек вычислений. `ldarg.1` Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.  
  
 Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 2 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Загружает аргумент 2 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 2 помещается в стек.  
  
 `ldarg.2` Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 2.  
  
 `ldarg.2` Инструкция помещает аргумент с индексом 2 в стек вычислений. `ldarg.2` Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.  
  
 Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 3 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Загружает аргумент 3 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение аргумента с индексом 3 помещается в стек.  
  
 `ldarg.3` Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 3.  
  
 `ldarg.3` Инструкция помещает аргумент с индексом 3 в стек вычислений. `ldarg.3` Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.  
  
 Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное короткое значение индекса) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|Загружает аргумент с индексом `index` в стек, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение аргумента с `index` помещается в стек.  
  
 `ldarg.s` Инструкция обеспечивает эффективную кодировку для загрузки аргументов с индексом с 4 до 255.  
  
 `ldarg.s` Инструкция помещает аргумент с индексом `index`, где аргументы индексируются, начиная с версии, 0 в стек вычислений. `ldarg.s` Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.  
  
 В процедурах, принимающих список аргументов переменной длины `ldarg.s` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи (в разделе <xref:System.Reflection.Emit.OpCodes.Arglist> инструкции для получения дополнительных сведений).  
  
 Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarg.s` код операции:  
  
-   ILGenerator.Emit (код операции, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|Извлекает адрес аргумента с индексом `index`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес `addr` аргумента, с индексом `index` помещается в стек.  
  
 `ldarga` Инструкция извлекает адрес (типа `*`) аргумента, с индексом `index`, где аргументы индексируются, начиная с версии 0. Адрес `addr` всегда выравнивается по границам на конечном компьютере.  
  
 В процедурах, принимающих список аргументов переменной длины `ldarga` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.  
  
 `ldarga` используется для передачи параметров по ссылке. В остальных случаях <xref:System.Reflection.Emit.OpCodes.Ldarg> и <xref:System.Reflection.Emit.OpCodes.Starg> следует использовать.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarga` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента (короткая форма) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|Извлекает адрес аргумента с индексом `index`, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес `addr` аргумента, с индексом `index` помещается в стек.  
  
 `ldarga.s` (Краткая форма `ldarga`) следует использовать для аргумента числа от 0 до 255, и обеспечивает более эффективную кодировку.  
  
 `ldarga.s` Инструкция извлекает адрес (типа`*`) аргумента, с индексом `index`, где аргументы индексируются, начиная с версии 0. Адрес `addr` всегда выравнивается по границам на конечном компьютере.  
  
 В процедурах, принимающих список аргументов переменной длины `ldarga.s` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.  
  
 `ldarga.s` используется для передачи параметров по ссылке. В остальных случаях <xref:System.Reflection.Emit.OpCodes.Ldarg_S> и <xref:System.Reflection.Emit.OpCodes.Starg_S> следует использовать.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldarga.s` код операции:  
  
-   ILGenerator.Emit (код операции, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|Помещает значение `num` в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Обратите внимание, что существуют специальные короткие (и, следовательно, более эффективные) кодировки для целых чисел от -128 до 127 и особенно короткие кодировки для -1 до 8. Все короткие кодировки помещают 4-байтовые целые числа в стеке. Больше кодировки используются для 8-байтовые целые числа и 4 и 8 байт числа с плавающей запятой, а также 4-байтовых значений, которые не помещаются в короткие кодировки. Существует три способа для принудительной отправки целочисленная константа размером 8 байт в стек  
  
 1. Используйте <xref:System.Reflection.Emit.OpCodes.Ldc_I8> инструкции для константы, которые должны быть выражены в более чем 32 бита.  
  
 2. Используйте <xref:System.Reflection.Emit.OpCodes.Ldc_I4> инструкции, за которым следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для константы требуется от 9 до 32 бит.  
  
 3. Используйте инструкцию короткой формы, за которым следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, которые могут быть выражены в 8 или менее бит.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4` код операции:  
  
-   ILGenerator.Emit (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 0 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Помещает в стек 0 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 0 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Помещает в стек 1 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 1, помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 2 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Помещает 2 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 2 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 3 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Помещает 3 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 3 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 4 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Помещает 4 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 4 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 5 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Помещает 5 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 5 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.5` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 6 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Помещает 6 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 6 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.6` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 7 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Помещает 7 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 7 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.7` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 8 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Помещает 8 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение 8 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение –1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Помещает в стек значение -1 в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение -1, помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленное значение 0. Все короткие кодировки помещают целые числа размером 4 байта в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.m1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int8" /> в стек вычислений как <see langword="int32" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|1F < `int8` >|Инструкция ldc.i4.s `num`|Помещает `num` стек как `int32`, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 `ldc.i4.s` является более эффективную кодировку для помещения целых чисел от -128 до 127 в стек вычислений.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i4.s` код операции:  
  
-   ILGenerator.Emit (код операции, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.I8 `num`|Помещает `num` стек как `int64`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `int64` значение в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.i8` код операции:  
  
-   ILGenerator.Emit (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.R4 `num`|Помещает `num` стек как `F`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float32` значение в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.r4` код операции:  
  
-   ILGenerator.Emit (OpCode, один)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.R8 `num`|Помещает `num` стек как `F`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float64` значение в стек.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldc.r8` код операции:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент с заданным индексом массива на вершину стека вычислений в качестве типа, указанного в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|Загружает элемент с `index` на вершину стека как `typeTok`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Тип возвращаемого значения указан маркер `typeTok` в инструкции.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение верхней границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="native int" />, на вершину стека вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|97|ldelem.i|Загружает элемент с типом `native int` в `index` на вершину стека вычислений как `native int`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i` — `native int`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Загружает элемент с типом `int8` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i1` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i1` — `int8`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|92|ldelem.I2|Загружает элемент с типом `int16` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i2` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i2` — `int16`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Загружает элемент с типом `int32` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i4` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i4` — `int32`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int64" /> с заданным индексом массива на вершину стека вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|Загружает элемент с типом `int64` в `index` на вершину стека вычислений как `int64`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.i8` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i8` — `int64`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float32" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|98|ldelem.R4|Загружает элемент с типом `float32` в `index` на вершину стека как тип `F`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.r4` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r4` — `float32`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float64" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|99|ldelem.R8|Загружает элемент с типом `float64` в `index` на вершину стека как `F`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.r8` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r8` — `float64`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, содержащий ссылку на объект, на вершину стека вычислений как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Загружает элемент ссылку на `index` на вершину стека как `O`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.ref` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.ref` — тип `O` (ссылка на объект).  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|Загружает элемент с типом `unsigned int8` в `index` на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.u1` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u1` — `int8`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|93|ldelem.U2|Загружает элемент с типом `unsigned int16` по индексу на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.u2` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u2` — `int16`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|Загружает элемент с типом `unsigned int32` по индексу на вершину стека вычислений как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; значение, хранящееся в позиции `index` в `array` осуществляется поиск.  
  
4.  Значение помещается в стек.  
  
 `ldelem.u4` Инструкция загружает значение элемента с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u4` — `int32`.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> вызывается, если массив не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelem.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес элемента массива с заданным индексом на вершину стека вычислений как <see langword="&amp;" /> (управляемый указатель).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|Загружает адрес элемента массива с `index` на вершину стека вычислений как `&` (управляемый указатель).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; адрес, хранящийся в позиции `index` в `array` осуществляется поиск.  
  
4.  Адрес помещается в стек.  
  
 `ldelema` Используется для извлечения адреса объекта с определенного индекса в массиве объектов (типа `class`). `ldelema` Инструкция загружает адрес значения с индексом `index` (тип `native int`) в отсчитываемый от нуля одномерный массив `array` и помещает его в вершине стека. Массивы являются объектами, поэтому они представлены значением типа `O`. Значение должно быть типа `class` передаваемый с инструкцией.  
  
 Возвращаемое значение для `ldelema` является управляемым указателем (тип `&`).  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldelema` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет поиск значения поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Помещает в стек значение поля в указанный объект в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; найти значение указанного поля в объекте.  
  
3.  Значение, хранящееся в поле помещается в стек.  
  
 `ldfld` Инструкция помещает значение поля в объекте в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (типа `&`), неуправляемый указатель (типа `native int`), временный указатель (типа `*`), или экземпляр типа значения. Использование неуправляемого указателя не допускается в проверяемом коде. Поле объекта задается с помощью лексемы метаданных, которая должна ссылаться на поле-член. Тип возвращаемого значения является таким же, как связанные с этим полем. Поле может быть поле экземпляра (в этом случае объект не должен быть пустой ссылкой) или статическое поле.  
  
 `ldfld` Инструкция может предшествовать одной или обеих <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile> префиксы.  
  
 <xref:System.NullReferenceException> возникает, если объект имеет значение null, и поле не является статическим.  
  
 <xref:System.MissingFieldException> возникает, если указанное поле не найден в метаданных. Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинном коде, не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldfld` код операции:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ищет адрес поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Помещает адрес `field` в указанный объект в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; найти адрес указанного поля в объекте.  
  
3.  Адрес указанного поля помещается в стек.  
  
 `ldflda` Инструкция помещает адрес поля в объекте в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (типа `&`), неуправляемый указатель (типа `native int`), временный указатель (типа `*`), или экземпляр типа значения. Использование неуправляемого указателя не допускается в проверяемом коде. Поле объекта задается с помощью лексемы метаданных, которая должна ссылаться на поле-член.  
  
 Значение, возвращаемое `ldflda` является управляемым указателем (тип `&`), если объект помещается в стек как неуправляемый указатель, в этом случае обратный адрес является также неуправляемый указатель (типа `native int`).  
  
 `ldflda` Инструкция может предшествовать одной или обеих <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile> префиксы.  
  
 <xref:System.InvalidOperationException> возникает, если объект не входит в домен приложения, из которого доступе. Не удается загрузить адрес поля, которое не находится внутри доступ к домену приложения.  
  
 <xref:System.NullReferenceException> возникает, если объект имеет значение null, и поле не является статическим.  
  
 <xref:System.MissingFieldException> возникает, если указанное поле не найден в метаданных. Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинном коде, не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldflda` код операции:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий заданный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|LDFTN `method`|Помещает указатель на метод, заданный параметром `method` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Неуправляемый указатель в определенный метод помещается в стек.  
  
 Определенный метод (`method`) может быть вызван с помощью <xref:System.Reflection.Emit.OpCodes.Calli> инструкции, если она ссылается на управляемый метод (или заглушку, переходит из управляемого в неуправляемый код).  
  
 Возвращаемое значение ссылается на машинный код с помощью среды CLR, соглашение о вызовах. Этот метод указатель не передан в неуправляемый машинный код в виде подпрограммы обратного вызова.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldftn` код операции:  
  
-   ILGenerator.Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="native int" /> в стек вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Загружает `native int` по адресу `addr` стек как `native int`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i` Инструкция `native int` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `native int`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|46|ldind.i1|Загружает `int8` по адресу `addr` стек как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек...  
  
 `ldind.i1` Инструкция `int8` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|48|ldind.I2|Загружает `int16` по адресу `addr` стек как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i2` Инструкция `int16` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|Загружает `int32` по адресу `addr` стек как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i4` Инструкция `int32` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|4C|ldind.I8|Загружает `int64` по адресу `addr` стек как `int64`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.i8` Инструкция `int64` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int64`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|4E|ldind.R4|Загружает `float32` по адресу `addr` стек как тип `F`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.r4` Инструкция `float32` значение из указанного адреса (типа `native int`, `&`, или *) в стек как тип `F`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|4F|ldind.R8|Загружает `float64` по адресу `addr` стек как тип `F`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.r8` Инструкция `float64` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `float64`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку в стек вычислений ссылки на объект как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Загружает ссылку на объект по адресу `addr` стек как тип `O`|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; ссылка на объект, расположенный по адресу, выбирается.  
  
3.  Извлеченная ссылка помещается в стек.  
  
 `ldind.ref` Инструкция косвенно загружает ссылку на объект по указанному адресу (типа `native int`, `&`, или *) в стек как тип `O`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|47|ldind.U1|Загружает `unsigned int8` по адресу `addr` стек как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.u1` Инструкция `unsigned int8` значение из указанного адреса (типа`native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.u1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|49|ldind.U2|Загружает `unsigned int16` по адресу `addr` стек как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.u2` Инструкция `unsigned int16` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.u2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|4B|ldind.U4|Загружает `unsigned int32` по адресу `addr` стек как `int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; значение по адресу выбирается.  
  
3.  Извлеченное значение помещается в стек.  
  
 `ldind.u4` Инструкция `unsigned int32` значение из указанного адреса (типа `native int`, `&`, или *) в стек как `int32`.  
  
 Все `ldind` инструкции предназначены для <xref:System.Reflection.Emit.OpCodes.Ldobj> инструкция, определяющая соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до `int32` (не `native int`) когда они были загружены в стек вычислений. Значения с плавающей запятой, преобразуются в `F` введите при загрузке в стек вычислений.  
  
 Правильный формат Microsoft промежуточного языка MSIL гарантирует, что `ldind` инструкции используются в соответствии с типом указателя.  
  
 Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса по). Результаты всех инструкций MSIL, возвращающих адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), обеспечивается правильное выравнивание. Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП. Код, зависящий от порядка байтов может работать на всех платформах.  
  
 <xref:System.NullReferenceException> вызываемое при обнаружении недопустимого адреса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldind.u4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о числе элементов одномерного массива с индексацией от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|8E|ldlen|Помещает длина (типа `natural unsigned int`) массива в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив помещается в стек.  
  
2.  Ссылка на массив извлекается из стека и вычисляется длина.  
  
3.  Длина помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Длина возвращается в виде `natural unsigned int`.  
  
 <xref:System.NullReferenceException> вызывается, если ссылка на массив является пустой ссылкой.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldlen` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 0C &LT; `unsigned int16` >|ldloc `index`|Загружает в локальную переменную с индексом `index` в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение локальной переменной с указанным индексом помещается в стек.  
  
 `ldloc` Инструкция помещает содержимое локальной переменной с заданным индексом в стек вычислений, где локальные переменные, начиная от 0. Локальные переменные инициализируется значением 0 перед входом в метод, только если флаг инициализации метода равен true. Существует 65 535 (2 ^ 16 - 1) возможных локальных переменных (0-65 534). Индекс 65 535 является недопустимым, так как возможны реализации, использующие 2-байтовое целое число для отслеживания индекса и локальный, так и общее количество локальных данного метода. Если индекс 65 535 считался действительным, потребуется расширить целое число для отслеживания числа локальные переменные в этом методе.  
  
 `ldloc.0`, `ldloc.1`, `ldloc.2`, И `ldloc.3` инструкции обеспечивают эффективную кодировку для доступа к первым четырем локальным переменным.  
  
 Тип значения — типу локальной переменной, указанной в заголовке метода. См. раздел I. локальные переменные, которые меньше, чем 4 байта, расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `ldloc` код операции:  
  
-   ILGenerator.Emit (код операции, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|06|ldloc.0|Загружает в стек вычислений локальную переменную с индексом 0.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 0 помещается в стек.  
  
 `ldloc.0` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, разрешающее доступ к локальной переменной с индексом 0.  
  
 Тип значения — типу локальной переменной, указанной в заголовке метода. Локальные переменные, которые меньше, чем 4 байта, расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|07|ldloc.1|Загружает в стек вычислений локальную переменную с индексом 1.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 1 помещается в стек.  
  
 `ldloc.1` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, разрешающее доступ к локальной переменной с индексом 1.  
  
 Тип значения — типу локальной переменной, указанной в заголовке метода. Локальные переменные, которые меньше, чем 4 байта, расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|08|ldloc.2|Загружает в стек вычислений локальную переменную с индексом 2.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 2 помещается в стек.  
  
 `ldloc.2` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, разрешающее доступ к локальной переменной с индексом 2.  
  
 Тип значения — типу локальной переменной, указанной в заголовке метода. Локальные переменные, которые меньше, чем 4 байта, расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|09|ldloc.3|Загружает в стек вычислений локальную переменную с индексом 3.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение локальной переменной с индексом 3 помещается в стек.  
  
 `ldloc.3` особенно эффективный вариант кодировки <xref:System.Reflection.Emit.OpCodes.Ldloc>, разрешающее доступ к локальной переменной с индексом 3.  
  
 Тип значения — типу локальной переменной, указанной в заголовке метода. Локальные переменные, которые меньше, чем 4 байта, расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloc.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Загружает в локальную переменную с индексом `index` в стек, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение локальной переменной с указанным индексом помещается в стек.  
  
 `ldloc.s` Инструкция помещает содержимое локальной переменной с заданным индексом в стек вычислений, где локальные переменные, начиная от 0. Локальные переменные инициализируется значением 0 перед входом в метод, если флаг инициализации метода имеет значение true. Составляет 256 (2 ^ 8) возможных локальных переменных (0 – 255) в краткую форму, который является более эффективную кодировку чем `ldloc`.  
  
 Тип значения — типу локальной переменной, указанной в заголовке метода. См. раздел I. локальные переменные, которые меньше, чем 4 байта, расширяются до типа `int32` при загрузке в стек. Значения с плавающей запятой, расширяются до исходного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `ldloc.s` код операции:  
  
-   ILGenerator.Emit (код операции, LocalBuilder)  
  
-   ILGenerator.Emit (код операции, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Загружает адрес локальной переменной с `index` в стек вычислений.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес, хранящийся в локальной переменной с указанным индексом помещается в стек.  
  
 `ldloca` Инструкция помещает адрес локальной переменной с заданным индексом в стек, где локальных переменных, начиная от 0. Значение, помещаемое в стек, уже выровнено для использования с инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (типа `*`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloca` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Загружает адрес локальной переменной с `index` в стек вычислений, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес, хранящийся в локальной переменной с указанным индексом помещается в стек.  
  
 `ldloca.s` Инструкция помещает адрес локальной переменной с заданным индексом в стек, где локальных переменных, начиная от 0. Значение, помещаемое в стек, уже выровнено для использования с инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (типа `*`).  
  
 `ldloca.s` Инструкция обеспечивает эффективную кодировку для использования с локальными переменными от 0 до 255.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldloca.s` код операции:  
  
-   ILGenerator.Emit (код операции, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений пустую ссылку (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|14|метод ldnull|пустая ссылка на стек Push|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Пустая ссылка на объект помещается в стек.  
  
 `ldnull` Помещает в стек пустую ссылку (тип `O`) в стеке. Используется для инициализации расположения, прежде чем они заполняются данными или когда они станут устаревшими.  
  
 `ldnull` содержит пустую ссылку, которая не зависит от размера.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldnull` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует объект с типом значения, размещенный по указанному адресу, на вершину стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Копировать экземпляр типа значения `class` в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес объекта типа значение помещается в стек.  
  
2.  Адрес извлекается из стека и выполняется поиск экземпляра по этому адресу.  
  
3.  Значение объекта с заданным адресом помещается в стек.  
  
 `ldobj` Инструкция используется для передачи типа значения в качестве параметра.  
  
 `ldobj` Инструкция копирует значение, на который указывает `addrOfValObj` (типа `&`, `*`, или `native int`) в верхней части стека. Число копируемых байтов зависит от размера класса (как указано в `class` параметр). `class` Параметр является токен метаданных, представляющий тип значения.  
  
 Работу `ldobj` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldobj` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений значение статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Принудительная значение `field` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение поля помещается в стек.  
  
 `ldsfld` Инструкция помещает значение статического поля (общего для всех экземпляров класса) в стек. Имеет тип возвращаемого значения, связанные с маркером метаданных `field`.  
  
 `ldsfld` Инструкции может иметь <xref:System.Reflection.Emit.OpCodes.Volatile> префикс.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldsfld` код операции:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений адрес статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|7F < `T` >|метод ldsflda `field`|Принудительная адрес `field` в стеке|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес указанного поля помещается в стек.  
  
 `ldsflda` Инструкция помещает адрес статического поля (общего для всех экземпляров класса) в стек. Адрес может быть представлен как временный указатель (типа `*`) Если токен метаданных `field` ссылается на тип, управляемой памятью. В противном случае он соответствует неуправляемый указатель (типа `native int`). Обратите внимание, что `field` могут быть статическими глобального с присвоен относительный виртуальный адрес (смещение поля из базового адреса, по которому содержащего PE-файл загружается в память) где неуправляемой памяти.  
  
 `ldsflda` Инструкции может иметь <xref:System.Reflection.Emit.OpCodes.Volatile> префикс.  
  
 <xref:System.MissingFieldException> возникает, если поле не найдено в метаданных. Обычно это проверяется при преобразовании в машинный код, а не во время выполнения инструкции промежуточного языка Майкрософт (MSIL).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldsflda` код операции:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек ссылку на новый объект, представляющий строковой литерал, хранящийся в метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Помещает объект string для строковая лексема метаданных `mdToken`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в строку помещается в стек.  
  
 `ldstr` Инструкция помещает ссылку на объект (тип `O`) в новый строковый объект, представляющий заданный строковой литерал, хранящийся в метаданных. `ldstr` Инструкция выделяет нужное количество памяти и выполняет преобразование строкового литерала из формата, используемого в файле в строковый формат, необходимый во время выполнения.  
  
 Common Language Infrastructure (CLI) гарантирует, что результат до двух `ldstr` инструкций, ссылающихся на две лексемы метаданных, которые имеют ту же последовательность символов возврата же строковый объект (этот процесс называется «изоляцией строк»).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldstr` код операции:  
  
-   ILGenerator.Emit (OpCode, строка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует токен метаданных в его представление времени выполнения, а затем помещает в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|Преобразует токен метаданных в его представление времени выполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Переданная лексема преобразуется в `RuntimeHandle` и помещается в стек.  
  
 `ldtoken` Отправлений инструкции `RuntimeHandle` для заданным токеном метаданных. Объект `RuntimeHandle` может быть `fieldref/fielddef`, `methodref/methoddef`, или `typeref/typedef`.  
  
 Значение, помещаемое в стеке можно использовать в вызовах `Reflection` методы в системной библиотеке классов.  
  
 Дополнительные сведения о дескрипторах времени выполнения см. следующие классы: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, и <xref:System.RuntimeMethodHandle>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `ldtoken` код операции:  
  
-   ILGenerator.Emit (код операции, MethodInfo)  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий виртуальный метод, связанный с заданным объектом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|Помещает указатель объекта виртуального метода `method` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и адрес точки входа метода (как указано в токен метаданных `method`) производится поиск.  
  
3.  Указатель на `method` помещается в стек.  
  
 Неуправляемый указатель, помещенный в стек `ldvirtftn` инструкция может быть вызван с помощью <xref:System.Reflection.Emit.OpCodes.Calli> инструкции, если она ссылается на управляемый метод (или заглушку, переходит из управляемого в неуправляемый код).  
  
 Неуправляемый указатель ссылается на машинный код с помощью среды CLR, соглашение о вызовах. Этот метод указатель не передан в неуправляемый машинный код в виде подпрограммы обратного вызова.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ldvirtftn` код операции:  
  
-   ILGenerator.Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|DD < `int32` >|Оставьте `target`|Выполняет выход из защищенной области кода.|  
  
 Нет Переходные состояния стека для данной инструкции не.  
  
 `leave` Инструкция выполняет безусловную передачу управления конечной инструкции, представленной в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 `leave` Инструкция аналогичен `br` инструкции, но он может использоваться для выхода из `try`, `filter`, или `catch` блока, в то время как обычные инструкции перехода можно использовать только в таких блоков для передачи управления в его. `leave` Инструкция очищает стек вычислений и гарантирует, что соответствующие вокруг `finally` блоки выполняются.  
  
 Нельзя использовать `leave` инструкции, чтобы выйти из `finally` блока. В целях упрощения генерации кода обработчиков исключений допускается внутри блока catch для использования `leave` инструкции для передачи управления любой инструкции в пределах связанного `try` блока.  
  
 Если инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `leave` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|Выйдите из защищенной области кода, краткая форма.|  
  
 Нет Переходные состояния стека для данной инструкции не.  
  
 `leave.s` Инструкция выполняет безусловную передачу управления конечной инструкции, представленной как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.  
  
 `leave.s` Инструкция аналогичен `br` инструкции, но он может использоваться для выхода из `try`, `filter`, или `catch` блока, в то время как обычные инструкции перехода можно использовать только в таких блоков для передачи управления в его. `leave.s` Инструкция очищает стек вычислений и гарантирует, что соответствующие вокруг `finally` блоки выполняются.  
  
 Нельзя использовать `leave.s` инструкции, чтобы выйти из `finally` блока. В целях упрощения генерации кода обработчиков исключений допускается внутри блока catch для использования `leave.s` инструкции для передачи управления любой инструкции в пределах связанного `try` блока.  
  
 Если инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `leave.s` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выделяет определенное количество байтов из пула локальной динамической памяти и помещает в стек вычислений адрес (временный указатель с типом <see langword="*" />) первого выделенного байта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 0F|инструкции localloc|Выделите пространство в локальной куче.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Число байтов для распределения помещается в стек.  
  
2.  Число байтов, извлекается из стека; объем памяти, в зависимости от размера выделяется в локальной куче.  
  
3.  Указатель на первый байт выделенной памяти помещается в стек.  
  
 `localloc` Выделяет инструкция `size` (тип `natural unsigned int`) пул байтов из локальной динамической памяти и возвращает адрес (временный указатель, тип `*`) первого выделенного байта. Возвращаемый блок памяти, присваивается значение 0, только если флаг инициализации метода `true`. При выполнении текущего метода <xref:System.Reflection.Emit.OpCodes.Ret>, становятся доступными для повторного использования пула локальной памяти.  
  
 Полученный адрес выровнен, чтобы любой тип-примитив возможность сохранения с помощью `stind` инструкции (такие как <xref:System.Reflection.Emit.OpCodes.Stind_I4>) и загрузить с помощью `ldind` инструкции (например, <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 `localloc` Инструкция не может быть внутри `filter`, `catch`, `finally`, или `fault` блока.  
  
 <xref:System.StackOverflowException> возникает, если недостаточно памяти для обслуживания запроса.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `localloc` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на экземпляр определенного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|C6 < `T` >|Mkrefany `class`|Помещает ссылку типа `class` в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Указатель на элемент данных помещается в стек.  
  
2.  Указатель извлекается из стека и преобразуется в ссылку типа `class`.  
  
3.  Ссылка с определенным типом помещается в стек.  
  
 `mkrefany` Инструкция поддерживает передачу динамического типа ссылок. Указатель должен иметь тип `&`, `*`, или `native int`и содержать действительный адрес фрагмента данных. `Class` Класс токен, описывающий тип данных, который ссылается указатель. `Mkrefany` Помещает в стек, предоставляя непрозрачный дескриптор указателя и тип ссылку `class`.  
  
 Для ее передачи в метод, который требует в качестве параметра ссылку на типизированный находится только допустимой операцией типизированную ссылку. Вызываемый объект можно затем использовать <xref:System.Reflection.Emit.OpCodes.Refanytype> и <xref:System.Reflection.Emit.OpCodes.Refanyval> инструкциям, чтобы получить тип (класс) и адрес соответственно.  
  
 <xref:System.TypeLoadException> возникает, если `class` не найден. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mkrefany` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|5A|mul|Умножает два значения в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`.  
  
4.  Результат помещается в стек.  
  
 `mul` Умножает инструкция `value1` по `value2` и помещает результат в стек. Операции с целыми числами усекает верхние бит в случае переполнения.  
  
 В разделе <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> для целыми числами операцией с обработкой multiply.  
  
 Для типов с плавающей запятой 0 * бесконечность = NaN.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mul` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Умножает два целочисленных значения в стеке и выполняет проверку переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`, и выполняет проверку переполнения.  
  
4.  Результат помещается в стек.  
  
 `mul.ovf` Инструкция умножает целое `value1` по целому `value2` и помещает результат в стек. Исключение возникает в том случае, если результат не умещается в тип результата.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mul.ovf` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Умножает два значения без знака в стеке и выполняет проверку переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`, и выполняет проверку переполнения.  
  
4.  Результат помещается в стек.  
  
 `mul.ovf.un` Инструкция умножает целое число без знака `value1` , целое число без знака `value2` и помещает результат в стек. Исключение возникает в том случае, если результат не умещается в тип результата.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `mul.ovf.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Отвергает значение и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|65|Neg|Инвертирует значение, находящееся на вершине стека.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и инвертировано.  
  
3.  Результат помещается в стек.  
  
 `neg` Инструкция инвертирует значение и помещает результат в стеке. Тип возвращаемого значения совпадает с типом операнда.  
  
 Инверсии целочисленных значений является стандартным дополнение до двух отрицания. В частности Инверсия наибольшее отрицательное число (которая не поддерживает положительного эквивалента) возвращает наибольшее отрицательное число. Чтобы обнаружить переполнение, воспользуйтесь <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> инструкции вместо (вычитание из 0).  
  
 Инверсия числа с плавающей запятой не может вызвать переполнения, а операция над значением NaN возвращает значение NaN.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `neg` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на объект — новый одномерный массив с индексацией от нуля, состоящий из элементов заданного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Создает новый массив с элементами типа `etype`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Число элементов в массиве помещается в стек.  
  
2.  Число элементов, извлекается из стека и массив создается.  
  
3.  Ссылка на объект в новый массив помещается в стек.  
  
 `newarr` Инструкция помещает ссылку на объект (тип `O`) — новый одномерный массив отсчитываемый от нуля, элементы которого имеют тип `etype` (лексема метаданных, описывающая тип). Количество элементов в новом массиве должно указываться как `native int`. Действительный массив индексов диапазон от нуля до максимального числа элементов минус 1.  
  
 Элементы массива могут быть любого типа, включая типы значений.  
  
 Отсчитываемый от нуля одномерный массив массивы чисел создаются с помощью лексемы метаданных, указывающей соответствующий тип значения (<xref:System.Int32>и так далее). Элементы массива инициализируется значением 0 соответствующего типа.  
  
 Для одномерных массивов и многомерные массивы создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newobj> вместо `newarr`. Как правило, они создаются с помощью методов <xref:System.Array> в .NET Framework.  
  
 <xref:System.OutOfMemoryException> возникает, если памяти недостаточно для удовлетворения запроса.  
  
 <xref:System.OverflowException> возникает, если `numElems` меньше 0.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `newarr` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает новый объект или новый экземпляр типа значения и помещает ссылку на объект (тип <see langword="O" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Размещает неинициализированный объект или тип значения и вызывает метод конструктора `ctor`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Аргументы `arg1` через `argn` помещаются в стек в последовательности.  
  
2.  Аргументы `argn` через `arg1` извлекаются из стека и передаются в `ctor` для создания объекта.  
  
3.  Ссылка на новый объект помещается в стек.  
  
 `newobj` Инструкция создает новый объект или новый экземпляр типа значения. `Ctor` токен метаданных ( `methodref` или `methoddef` , должен быть помечен как конструктор), указывающее имя, класс и подпись для вызова конструктора.  
  
 `newobj` Инструкция выделяет новый экземпляр класса, связанного с `ctor` и инициализирует все поля нового экземпляра 0 (соответствующего типа) или пустыми ссылками. Затем он вызывает конструктор `ctor` с заданными аргументами, и вновь созданному экземпляру. После вызова конструктора инициализированный ссылка на объект (тип `O`) помещается в стек.  
  
 С точки зрения конструктора неинициализированный объект является аргументом 0 и выполните другие аргументы, передаваемые newobj в порядке.  
  
 Все отсчитываемый от нуля одномерные массивы создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newarr>, а не `newobj`. С другой стороны, другие массивы (имеющие несколько измерений или одномерные, но не от нуля) создаются с помощью `newobj`.  
  
 Типы значений не создаются обычно с помощью `newobj`. Они размещаются как аргументы или локальные переменные, с помощью `newarr` (для одномерных массивов отсчитываемый от нуля) или как поля объектов. После выделения памяти, они инициализируются с помощью <xref:System.Reflection.Emit.OpCodes.Initobj>. Однако `newobj` инструкция может использоваться для создания нового экземпляра типа значения в стеке, который затем может быть передан как аргумент, сохранен в локальной и т. д.  
  
 <xref:System.OutOfMemoryException> возникает, если памяти недостаточно для удовлетворения запроса.  
  
 <xref:System.MissingMethodException> вызывается, если метод конструктора `ctor` с указанным именем, класс и подпись не найден. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `newobj` код операции:  
  
-   ILGenerator.Emit (код операции, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заполняет пространство, если коды операции содержат исправления. Никаких значимых операций не выполняется, хотя может быть пройден цикл обработки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|00|nop|Выполняет операцию без поведение.|  
  
 Нет нет стека Переходные состояния для данной инструкции.  
  
 `nop` Операция не выполняет никаких действий. Он предназначен для заполнения в пространстве, если коды операции содержат исправления.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `nop` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение целочисленного значения, находящегося на вершине стека, и помещает результат в стек с тем же типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|66|not|Вычисляет побитовое дополнение значения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, после чего его побитового дополнения вычисляемый.  
  
3.  Результат помещается в стек.  
  
 `not` Инструкция вычисляет побитовое дополнение целочисленного значения и помещает результат в стек. Тип возвращаемого значения совпадает с типом операнда.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `not` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение двух целочисленных значений, находящихся на вершине стека, и помещает результат в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|60|или|Выполняет побитовую операцию или для двух целочисленных значений и возвращает целое число.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; поразрядное или вычислить.  
  
4.  Результат помещается в стек.  
  
 `or` Инструкция вычисляет побитовое или двух верхних значений в стеке, помещает результат в стек.  
  
 `Or` представляет собой операцию целыми числами.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `or` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Удаляет значение, находящееся на вершине стека.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|26|pop|Извлекает верхнее значение из стека.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Верхнее значение извлекается из стека.  
  
 `pop` Инструкция удаляет верхний элемент в стеке.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `pop` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что последующая операция, связанная с адресом массива, не выполняет никаких проверок во время выполнения и возвращает управляемый указатель, изменение которого запрещено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 1E|только для чтения.|Укажите, что операция адрес последующих массива не выполняет никаких проверок во время выполнения и возвращает управляемый указатель с ограниченной возможностью изменения.|  
  
 Этот префикс может использоваться только непосредственно предшествующего `ldelema` инструкция и вызовы специальные `Address` метод для массивов. Влияния на последующие операции двояко:  
  
1.  Во время выполнения операций по проверке типа не выполняется. Обратите внимание, что обычно выполняется неявная проверка типа для `ldelema` и `stelem` инструкциями по ссылке на тип массивов. Нет проверку типов во время выполнения для классы значений, поэтому `readonly` в этом случае является холостой.  
  
2.  Проверяющий обрабатывает результат операции взятия адреса как управляемый указатель с ограниченной возможностью изменения.  
  
 Считается, что указатель имеет ограниченную возможность изменения определяющем типе, контролирует ли значение можно изменить. Для классов значений, предоставляющих не открытые поля и методы, измените его значение в месте, курсор доступен только для чтения (поэтому имя префикса). В частности не предоставляют мутаторы классы, представляющие типы-примитивы (например, System.Int32) и таким образом, доступны только для чтения.  
  
 Ограниченный подобным образом управляемый указатель может использоваться только следующими способами:  
  
-   Как `object` параметр `ldfld`, `ldflda`, `stfld`, `call`, или`constrained callvirt` инструкции.  
  
-   Как `pointer` параметр `ldobj` инструкций или одной из `ldind` инструкции.  
  
-   Как `source` параметр `cpobj` инструкции.  
  
 Все остальные операции запрещены, включая `stobj`, `initobj`, или `mkrefany` операций или любой другой `stind` инструкции.  
  
 Назначение `readonly` префикс — для отключения проверки типа при выборке элемента из массива в универсальном коде. Например, выражение `arr[i].m()`, где тип элемента массива `arr` является универсальным типом, ограниченного до интерфейса с методом `m`, может компилироваться в следующий MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Без `readonly` префикса, `ldelema` будет выполнять проверку типов в случае инструкция где! 0 является ссылочным типом. Не только неэффективен эту проверку типа, но это семантически неправилен. Проверка типа `ldelema` является точным соответствием, то есть очень строгим. Если массив подклассы типа! 0, приведенный выше код не пройдут проверку типа.  
  
 Адрес элемента массива извлекается, а не элемента, чтобы получить дескриптор для `arr[i]` работает как типы значений и ссылочные типы что таким образом, может быть передан `constrained callvirt` инструкции.  
  
 В целом небезопасно пропускать проверку во время выполнения, если в массиве содержатся элементы ссылочного типа. В целях безопасности необходимо убедиться, что никакие изменения в массив выполняются через этот указатель. Это проверить правила проверки. Ограниченный управляемый указатель могут передаваться как объект вызовов методов экземпляра, поэтому он не является доступным только для чтения для типов значений, но не возникает проблем безопасности типа для типов значений.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `readonly` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает токен типа, внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Помещает в стек лексему типа, хранящуюся в ссылку с определенным типом.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Ссылка с определенным типом извлекается из стека и получить его соответствующий тип маркера.  
  
3.  Лексема типа помещается в стек.  
  
 Ссылка с определенным типом содержит токен типа и адрес экземпляра объекта.  
  
 `refanytype` Инструкция извлекает токен типа, внедренный в ссылку с определенным типом. В разделе <xref:System.Reflection.Emit.OpCodes.Mkrefany> сведения о создании ссылок с определенным типом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `refanytype` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает адрес (тип <see langword="&amp;" />), внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Помещает в стек адрес, хранящийся в ссылку с определенным типом.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Ссылка с определенным типом извлекается из стека и получить соответствующий адрес.  
  
3.  Адрес помещается в стек.  
  
 Ссылка с определенным типом содержит токен типа и адрес экземпляра объекта.  
  
 `refanyval` Инструкция извлекает адрес, внедренный в ссылку с определенным типом. Тип, внедренный в ссылку с определенным типом в стеке должны совпадать с типом, указанным `type` (токен метаданных, либо `typedef` или `typeref`). В разделе <xref:System.Reflection.Emit.OpCodes.Mkrefany> Дополнительные сведения.  
  
 <xref:System.InvalidCastException> возникает, если `type` не идентичен типу, хранящемуся в ссылку на тип (в этом случае `type` класса передается <xref:System.Reflection.Emit.OpCodes.Mkrefany> типизированную ссылку говорят, что инструкции, который создан).  
  
 <xref:System.TypeLoadException> возникает, если `type` не найден.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `refanyval` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|5D|REM|Помещает остаток от деления `value1` по `value2` в стек.|  
  
> [!NOTE]
>  ReplaceThisText  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Объект `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и остаток `value1` `div` `value2` вычисляется.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` `rem` `value2` удовлетворяет следующим условиям:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), и:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, знак (`result`) = знак (`value1`), где `div` деления инструкция, которая усекает к нулю.  
  
 Если `value2` равно нулю или `value1` = бесконечность, результатом будет NaN. Если `value2` бесконечно, результатом является `value1` (инвертировано для `-infinity`).  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException> Если `value2` равно нулю.  
  
 Обратите внимание, что на платформах на базе Intel <xref:System.OverflowException> возникает при вычислении (minint `rem` -1).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `rem` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение без знака на другое значение без знака и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|5E|REM.un|Помещает остаток от деления числа без знака `value1` на значение без знака `value2` в стек.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и остаток `value1` `div` `value2` вычисляется.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` `rem.un` `value2` удовлетворяет следующим условиям:  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), и:  
  
 0 = `result`  <  `value2`, где `div.un` инструкция деления числа без знака.  
  
 `rem.un` Инструкция вычисляет `result` и помещает в стек. `Rem.un` считает его аргументы целых чисел без знака, пока <xref:System.Reflection.Emit.OpCodes.Rem> обрабатывает их как целых чисел.  
  
 `Rem.un` не определен для чисел с плавающей запятой.  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException> Если `value2` равно нулю.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `rem.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет возврат из текущего метода, помещая возвращаемое значение (если имеется) из стека вычислений вызываемого метода в стек вычислений вызывающего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|2A|Возвращаемое значение|Возврат из метода, возможно, с возвращаемым значением.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Возвращаемое значение извлекается из стека вычислений вызываемого объекта.  
  
2.  Возвращаемое значение, полученное на шаге 1, помещается в стек вычислений вызывающего объекта.  
  
 Если возвращаемое значение отсутствует в стеке вычислений вызываемого объекта, возвращаемое значение отсутствует (нет стека вариантов поведения для метода, вызываемого и вызывающего объекта).  
  
 Тип возвращаемого значения, если таковые имеются, текущего метода определяет тип значения для выборки из верхней части стека и копируемого в стек метода, который вызвал текущий метод. В стеке вычислений текущего метода должен быть пустым, за исключением возвращаемого значения.  
  
 `ret` Инструкция не может использоваться для передачи управления из`try`, `filter`, `catch`, или `finally` блока. Изнутри `try` или `catch`, используйте <xref:System.Reflection.Emit.OpCodes.Leave> инструкцию с помощью назначения `ret` инструкция, которая находится за пределами всех блоков исключения. Поскольку `filter` и `finally` блоки логически являются частью механизма обработки исключений и не метода, в котором находится их код, правильно созданные инструкции промежуточного языка Майкрософт (MSIL) не выполняют возврат из внутри метода `filter` или `finally`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `ret` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущее исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 1A|заново создать|Возвращает текущее исключение.|  
  
 Нет стека Переходные состояния для данной инструкции.  
  
 `rethrow` Инструкция допускается только в теле `catch` обработчика. Метод создает исключение, которое было перехвачено этим обработчиком.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `rethrow` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение влево (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|62|Shl|Смещает целое число влево (с заполнением нулями).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Количество бит, помещается в стек.  
  
3.  Число бит и значения извлекаются из стека; значение смещается влево на указанное число бит.  
  
4.  Результат помещается в стек.  
  
 `shl` Инструкция смещает значение (типа `int32`, `int64` или `native int`) влево на указанное число бит. Число битов равно значение типа `int32` или `native int`. Возвращаемое значение не определено, если число бит, больше или равен ширине (в битах) заданного значения.  
  
 `Shl` вставляет нулевой разряд в нижнюю позицию при каждом смещении.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `shl` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение вправо (с знаковым битом) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|63|Shr|Смещает целое число вправо (с заполнением входа).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Количество бит, помещается в стек.  
  
3.  Число бит и значения извлекаются из стека; значение сдвигаются вправо на указанное число бит.  
  
4.  Результат помещается в стек.  
  
 `shr.un` Инструкция смещает значение (типа `int32`, `int64` или `native int`) вправо на указанное число бит. Число битов равно значение типа `int32` или `native int`. Возвращаемое значение не определено, если число бит, больше или равен ширине (в битах) заданного значения.  
  
 `Shr` реплицирует старших битов для каждой смены, сохраняя знак исходного значения в `result`.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `shr` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение без знака вправо (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|64|Shr.un|Смещает целое число вправо (с заполнением нулями).|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Количество бит, помещается в стек.  
  
3.  Число бит и значения извлекаются из стека; значение сдвигаются вправо на указанное число бит.  
  
4.  Результат помещается в стек.  
  
 `shr.un` Инструкция смещает значение (типа `int32`, `int64` или `native int`) вправо на указанное число бит. Число битов равно значение типа `int32`, `int64` или `native int`. Возвращаемое значение не определено, если число бит, больше или равен ширине (в битах) заданного значения.  
  
 `Shr.un` вставляет нулевой разряд в верхнюю позицию при каждом смещении.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `shr.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о размере (в байтах) заданного типа значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|Принудительная размер в байтах, тип значения в качестве `unsigned int32`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Размер (в байтах) заданного типа значения (`valType`) помещается в стек.  
  
 `valType` должен быть токен метаданных ( `typeref` или `typedef`), указывающий тип значения, ссылочный тип или параметр универсального типа.  
  
 Для ссылочного типа возвращаемый размер — размер значение ссылки, соответствующего типа (4 байта в 32-разрядных систем), не размер данных, хранящихся в объектах, на который ссылается значение ссылки. Параметр универсального типа может использоваться только в теле типа или метода, который определяет его. При создании экземпляра типа или метода, параметр универсального типа заменяется типом значения или ссылочным типом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sizeof` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение, находящееся на вершине стека извлекается и помещается в ячейку аргумента `num`.  
  
 `starg` Инструкция извлекает значение из стека и помещает его в ячейке аргумента `num`. Тип значения должен соответствовать типу аргумента, как указано в подписи текущего метода.  
  
 В процедурах, принимающих переменные списки аргументов `starg` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.  
  
 В случае использования аргументов, хранящих целочисленное значение меньше 4 байтов, значение усекается при перемещении из стека в аргумент. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `starg` код операции:  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение, находящееся на вершине стека извлекается и помещается в ячейку аргумента `num`.  
  
 `starg.s` Инструкция извлекает значение из стека и помещает его в ячейке аргумента `num`. Тип значения должен соответствовать типу аргумента, как указано в подписи текущего метода.  
  
 `starg.s` Инструкция обеспечивает эффективную кодировку для использования с первых 256 аргументов.  
  
 В процедурах, принимающих переменные списки аргументов `starg.s` инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.  
  
 В случае использования аргументов, хранящих целочисленное значение меньше 4 байтов, значение усекается при перемещении из стека в аргумент. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `starg.s` код операции:  
  
-   ILGenerator.Emit (код операции, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение в стеке вычислений, тип которого указан в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|Заменяет элемент массива с заданным индексом на значение типа `typeTok` в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Значение индекса `index`, на элемент в `array` помещается в стек.  
  
3.  Значение типа, указанного в инструкции помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem` Инструкция заменяет значение элемента с заданным индексом (с нуля) в одномерном массиве `array` со значением. Значение имеет тип, указанный в токен `typeTok` в инструкции.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="native int" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|9B|stelem.i|Заменяет элемент массива с заданным индексом `native int` значение в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.i` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `native int` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int8" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|Заменяет элемент массива с заданным индексом `int8` значение в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.i1` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int8` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int16" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Заменяет элемент массива с заданным индексом `int16` значение в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.i2` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int16` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|Заменяет элемент массива с заданным индексом `int32` значение в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.i4` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int32` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|Заменяет элемент массива с заданным индексом `int64` значение в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.i8` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `int64` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|Заменяет элемент массива с заданным индексом `float32` значение в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.r4` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `float32` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|Заменяет элемент массива с заданным индексом `float64` значение в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.r8` Инструкция заменяет значение элемента `index` в одномерном массиве `array` с `float64` значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение object ref (тип <see langword="O" />), находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Заменяет элемент массива с заданным индексом `ref` значение (типа `O`) в стеке.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект в массив, `array`, помещенный в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.  
  
 `stelem.ref` Инструкция заменяет значение элемента с заданным индексом в одномерном массиве `array` с `ref` (типа `O`) значение помещается в стек.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс является типом `native int`.  
  
 Обратите внимание, что `stelem.ref` неявное приведение этого значения для типа элемента `array` перед присвоением значения элементу массива. Это приведение может завершиться ошибкой, даже для проверяемого кода. Таким образом `stelem.ref` инструкция может вызывать <xref:System.InvalidCastException>. Для одномерных массивов с индексацией не от нуля и для многомерных массивов <xref:System.Array> класс предоставляет <xref:System.Array.SetValue%2A> метод.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем значение границы `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stelem.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение в поле объекта, по ссылке на объект или указателю, на новое значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Заменяет значение `field` объекта с новым значением.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект или указатель помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и указатель и ссылки объектов извлекаются из стека; значение `field` в объекте заменяется указанное значение.  
  
 `stfld` Инструкция заменяет значение поля объекта (тип `O`) или через указатель (типа `native int`, `&`, или `*`) с указанным значением. `Field` представляет собой лексему метаданных, которая ссылается на член ссылки на поле. `stfld` Инструкции может иметь префикс из одной или обеих <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> вызывается, если ссылка на объект или указатель является пустой ссылкой и нестатического поля.  
  
 <xref:System.MissingFieldException> возникает, если `field` не найден в метаданных. Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stfld` код операции:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="native int" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|DF|stind.i|Магазины `native int` значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.i` Хранилищ инструкция `native int` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i` инструкция использоваться в соответствии с типом указателя. Работу `stind.i` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int8" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|52|stind.i1|Магазины `int8` значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.i1` Хранилищ инструкция `int8` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i1` инструкция использоваться в соответствии с типом указателя. Работу `stind.i1` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int16" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|53|stind.I2|Магазины `int16` значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.i2` Хранилищ инструкция `int16` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.2i` инструкция использоваться в соответствии с типом указателя. Работу `stind.i2` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|54|stind.i4|Магазины `int32` значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.i4` Хранилищ инструкция `int32` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i4` инструкция использоваться в соответствии с типом указателя. Работу `stind.i4` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|55|stind.I8|Магазины `int64` значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.i8` Хранилищ инструкция `int64` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.i8` инструкция использоваться в соответствии с типом указателя. Работу `stind.i` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.i8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|56|stind.R4|Магазины `float32` значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.r4` Хранилищ инструкция `float32` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.r4` инструкция использоваться в соответствии с типом указателя. Работу `stind.r4` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.r4` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|57|stind.R8|Магазины `float64` значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.r8` Хранилищ инструкция `float64` значение по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.r8` инструкция использоваться в соответствии с типом указателя. Работу `stind.r8` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.r8` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение ссылки на объект по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|51|stind.ref|Хранит ссылку на объект (тип `O`) значение по указанному адресу.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `stind.ref` Инструкция сохраняет значение ссылки на объект по указанному адресу (тип `native int`, `*`, или `&`).  
  
 Требует обеспечения безопасности типов, `stind.ref` инструкция использоваться в соответствии с типом указателя. Работу `stind.ref` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stind.ref` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 0E &LT; `unsigned int16` >|stloc `index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 `stloc` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, где локальных переменных, начиная от 0. Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Правильные инструкции промежуточного языка Майкрософт (MSIL) требуют `index` быть допустимый локальный индекс. Для `stloc` инструкции, `index` должен находиться в диапазоне 0 — 65 534 включительно (в частности, недопустимо 65535). За исключением 65535 обусловлено прагматичное использование: возможны реализации, использующие 2-байтовое целое число для отслеживания как индекса локальной переменной, а также общее количество локальных данного метода. Если индекс 65 535 считался действительным, потребуется расширить целое число для отслеживания числа локальные переменные в этом методе.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `stloc` код операции:  
  
-   ILGenerator.Emit (код операции, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, короткое)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Извлекает значение из стека в локальную переменную 0.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 0.  
  
 `stloc.0` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 0. Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.0` является особенно эффективным кодировки для сохранения значений в локальной переменной 0.  
  
 При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.0` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Извлекает значение из стека в локальной переменной 1.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 1.  
  
 `stloc.1` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 1. Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.1` является особенно эффективным кодировки для сохранения значений в локальной переменной 1.  
  
 При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.1` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|0C|stloc.2|Извлекает значение из стека в локальную переменную 2|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную, индексированный по 2.  
  
 `stloc.2` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную, индексированный по 2. Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.2` является особенно эффективным кодировки для сохранения значений в локальной переменной 2.  
  
 При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.2` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Извлекает значение из стека в локальную переменную 3|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 3.  
  
 `stloc.3` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 3. Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.3` является особенно эффективным кодировки для сохранения значений в локальной переменной 3.  
  
 При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stloc.3` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом <paramref name="index" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`, краткая форма.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 `stloc.s` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, где локальных переменных, начиная от 0. Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.  
  
 `stloc.s` Инструкция обеспечивает эффективную кодировку для локальных переменных с 0 до 255.  
  
 При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от исходного размера (тип `F`) до размера аргумента.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `stloc.s` код операции:  
  
-   ILGenerator.Emit (код операции, LocalBuilder)  
  
-   ILGenerator.Emit (код операции, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует значение с заданным типом из стека вычислений в указанный адрес памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Сохраняет значение типа `class` из стека в память.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
2.  Объект типа значения типа `class` помещается в стек.  
  
3.  Объект и адрес извлекаются из стека; объект типа значения хранятся по адресу.  
  
 `stobj` Инструкция копирует объект типа значения в адрес, заданный этим адресом (указатель типа `native int`, `*`, или `&`). Число копируемых байтов зависит от размера класса, представленный `class`, токен метаданных, представляющий тип значения.  
  
 Работу `stobj` инструкция может быть изменено, непосредственно предшествующий <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксная инструкция.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти класс. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stobj` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение статического поля на значение из стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Заменяет значение в `field` заданным значением.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и сохраняется в `field`.  
  
 `stsfld` Инструкция заменяет значение статического поля на значение из стека. `field` представляет собой лексему метаданных, который должен ссылаться на элемент статического поля.  
  
 `stsfld` Инструкции может иметь префикс в <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> возникает, если поле не найдено в метаданных. Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинном коде, не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `stsfld` код операции:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно значение из другого и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|59|sub|Вычитает одно значение из другого и возвращает новое числовое значение.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1`.  
  
4.  Результат помещается в стек.  
  
 Не обнаружено переполнение для целочисленных операций (для управления переполнением правильную, в разделе <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Вычитание целых чисел заключает в оболочку, а не насыщение. Например: при условии, что 8-битовых целых чисел, где `value1` равен 0 и `value2` имеет значение 1, «оболочку» будет 255.  
  
 С плавающей запятой переполнения возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sub` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|DA|Sub.ovf|Вычитает одно целочисленное значение из другого и выполняет проверку переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Эта операция выполняется над знаковыми целочисленными значениями; для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sub.ovf` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение без знака из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|DB|Sub.ovf.un|Вычитает одно целочисленное значение без знака из другого и выполняет проверку переполнения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` проверкой переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> возникает, если результат не может быть представлено типом результата.  
  
 Эта операция выполняется над знаковыми целочисленными значениями; для значений с плавающей запятой, используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `sub.ovf.un` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Реализует таблицу переходов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Переключение (`N`, `t1`, `t2`... `tN`)|Выполняет переход к одному из `N` значения.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и управление передается инструкции, смещением, индекс по значению, где значение — меньше, чем `N`.  
  
 `switch` Инструкция реализует таблицу переходов. Недопустимый формат инструкции по `unsigned int32` представляет количество целевых объектов `N`, за которым следует `N` значений Int32 перехода целевых объектов. Эти целевые объекты отображаются в виде смещения (положительные или отрицательные) от начала инструкции, это `switch` инструкции.  
  
 `switch` Инструкция извлекает значение из стека и сравнивает его, как целое число без знака в `N`. Если значение меньше, чем `N`, выполнение передается в целевой объект, индекс которого соответствует значению, где цели нумеруются от 0 (например, первый целевой объект принимает значение 0, принимает значение 1, второй и т. д). Если значение больше или равно `N`, управление передается следующей инструкции (вниз).  
  
 Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.  
  
 Передавать из и управление `try`, `catch`, `filter`, и `finally` данная инструкция не может быть выполнена блоков. (Подобная передача строго ограничивается; вместо этого следует использовать инструкцию leave).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `switch` код операции. `Label[]` Аргумент — массив меток, представляющих 32-разрядные смещения.  
  
-   ILGenerator.Emit(OpCode, Label[])  
  
   
  
## Examples  
 В следующем образце кода показано использование `Switch` код операции для создания таблицы переходов с помощью массива <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет инструкцию вызова метода (префиксом которой является), предварительно удаляя кадр стека текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 14|заключительный фрагмент.|Последующий вызов завершает текущие методы.|  
  
 Нет Переходные состояния стека для данной инструкции не.  
  
 `tail` Префиксом должен предшествовать <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, или <xref:System.Reflection.Emit.OpCodes.Callvirt> инструкции. Указывает, что кадр стека текущего метода должны быть удалены перед выполнением инструкции вызова. Также подразумевает, что значение, возвращаемое из вызова следующих также является значением, возвращаемым значением текущего метода и вызов может быть преобразован в переход между методами.  
  
 Стек должен быть пустым, за исключением аргументов, передаваемых следующим вызовом. Инструкции инструкцией вызова должна быть возвратной. Таким образом является единственной допустимой последовательностью кода `tail. call` (или `calli` или `callvirt`). Правильные инструкции промежуточного языка Майкрософт (MSIL) не должна содержать ветвь для `call` инструкции, но они могут выполнять переход к последующей <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Текущий кадр не может быть отменено, если управление передается от ненадежного кода в доверенный код, так как это нарушит безопасность идентификации кода. Проверки безопасности .NET Framework, поэтому может привести к `tail` следует игнорировать, оставляя стандартного <xref:System.Reflection.Emit.OpCodes.Call> инструкции. Аналогичным образом, чтобы обеспечить выход синхронизированной области после возвращения вызова, `tail` префикс учитывается, если используется для выхода из метода, помеченного как синхронизированный.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `tail` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Экземпляр объекта Opcode.</param>
        <summary>Возвращает true или false, в зависимости от того, принимает ли заданный код операции однобайтовый аргумент.</summary>
        <returns>
          <see langword="True" /> или <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для поиска, какие коды операции MSIL имеют «короткую форму», для использования в оптимизированном коде.  
  
 `TakesSingleByteArgument` Возвращает `true` Если <xref:System.Reflection.Emit.OpCode> экземпляр принимает однобайтовый аргумент в следующих случаях:  
  
-   Код операции выполняет инструкцию перехода к однобайтовому адресу (например, <xref:System.Reflection.Emit.OpCodes.Br_S> и <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Код операции помещает однобайтовое значение в стек (например, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Код операции ссылается на переменную или аргумент с использованием однобайтовой «краткая форма» (например, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> и <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 В противном случае возвращает значение `false`.  
  
 В приведенном ниже примере показано использование функции `TakesSingleByteArgument` путем отражения для `OpCodes` класса и проверки ли каждый `OpCode` поле принимает однобайтовый аргумент.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает объект исключения, находящийся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|7A|throw|Создает исключение.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект (исключение) помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и исключения.  
  
 `throw` Инструкция создает объект исключения (типа `O`) в настоящее время в стеке.  
  
 <xref:System.NullReferenceException> вызывается, если ссылка на объект является пустой ссылкой.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `throw` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека, возможно, не выровнен по естественному размеру следующей непосредственно за ним инструкции <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> или <see langword="cpblk" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|Невыровненные. `alignment`|Указывает, что последующие указатель инструкции может быть невыровненным.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
 `Unaligned` Указывает, что адрес (неуправляемый указатель `native int`) в стеке может не быть выровненным по размеру следующей непосредственно за `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, или `cpblk` инструкции. То есть для <xref:System.Reflection.Emit.OpCodes.Ldind_I4> выравнивание адреса не может быть в 4-байтовой границе инструкции. Для `initblk` и `cpblk` выравнивание по умолчанию — зависит от архитектуры (4-байтовое для 32-разрядных процессоров, 8-байтовое для 64-разрядных процессоров). Необходимо использовать генераторы кода, не ограничивающие размер 32-разрядное слово `unaligned` Если выравнивание не известно во время компиляции размером 8 байт.  
  
 Значение выравнивания должно быть 1, 2 или 4 и означает, что созданный код следует предполагать, что адрес байтов двухбайтовый, или quad байтовое выравнивание, соответственно. Обратите внимание, что временной указатели (типа `*`) всегда выровнены.  
  
 Выравнивание для `cpblk` требует двух чисел (источника) и конечного использования инструкций, нет оказывает заметного влияния на производительность, если задан параметр only меньшее число.  
  
 `unaligned` И `volatile` префиксов, которые могут быть объединены в любом порядке. Они должны находиться непосредственно перед `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, или `cpblk` инструкции. Только <xref:System.Reflection.Emit.OpCodes.Volatile> префикс допускается для <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld> инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузки метода `unaligned` код операции:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
-   ILGenerator.Emit (код операции, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|79 < `T` >|Распаковка `valType`|Извлекает данные типа значения из `obj`, его упакованного представления.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и преобразуется в указатель типа значения.  
  
3.  Указатель типа значения помещается в стек.  
  
 Тип значения имеет два представления в Common Language Infrastructure (CLI):  
  
-   «Первичная» форма, используемый при внедрении типа значения внутри другого объекта.  
  
-   Форма «процессор», где данные в тип значения упаковываются в объект и существуют как независимая сущность.  
  
 `unbox` Инструкция преобразует ссылку на объект (тип `O`), упакованного представления тип значения в указатель типа значения (управляемый указатель типа `&`), ее распаковано формы. Заданный тип значения (`valType`) представляет собой лексему метаданных, указывающий тип содержащихся в объекте упакованный тип значения.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Box>, который требуется сделать копию типа значения для использования в объекте, `unbox` не требуется копировать тип значения из объекта. Обычно она просто вычисляет адрес типа значения, уже находящегося упакованного объекта.  
  
 <xref:System.InvalidCastException> возникает, если объект не упакован как `valType`.  
  
 <xref:System.NullReferenceException> вызывается, если ссылка на объект является пустой ссылкой.  
  
 <xref:System.TypeLoadException> возникает, если тип значения `valType` не найден. Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `unbox` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип, указанный в инструкции, из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.Any `typeTok`|Извлечение данных из `obj`, его упакованного представления.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и преобразуется в тип, указанный в инструкции.  
  
3.  Результирующий тип ссылки или значений объекта помещается в стек.  
  
 При применении к форме упакованный тип значения `unbox.any` инструкция извлекает значение, содержащееся в `obj` (типа `O`) и поэтому является эквивалентом `unbox` следуют `ldobj`.  
  
 При применении к ссылочному типу `unbox.any` инструкция действует так же, как `castclass` `typeTok`.  
  
 Если операнд `typeTok` является параметром универсального типа, то поведение во время выполнения определяется тип, который задан для этого параметра универсального типа.  
  
 <xref:System.InvalidCastException> возникает, если `obj` не является упакованным типом.  
  
 <xref:System.NullReferenceException> возникает, если `obj` является пустой ссылкой.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `unbox.any` код операции:  
  
-   ILGenerator.Emit (код операции, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека вычислений, возможно, является изменяемым и результаты чтения данной области невозможно кэшировать либо невозможно запретить множественные сохранения в эту область.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Указывает, что следующая за указателем ссылка является volatile.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  Адрес помещается в стек.  
  
 `volatile`. Указывает, что адрес является изменяемым (то есть, он может ссылаться извне для текущего потока выполнения) и результаты чтения данной области невозможно кэшировать либо множественные сохранения в это расположение не может быть отменено. Доступа `volatile` влияет только на доступ; любой другой доступ к папке должен быть помечен отдельно. Доступ к изменяемым адресам не должен осуществляться атомарным образом.  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned> И `volatile` префиксов, которые могут быть объединены в любом порядке. Они должны находиться непосредственно перед `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, или `cpblk` инструкции. Только `volatile` префикс допускается для <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld> инструкции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `volatile` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое исключающее ИЛИ двух верхних значений в стеке вычислений и помещает результат обратно в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:  
  
|Формат|Формат сборки|Описание:|  
|------------|---------------------|-----------------|  
|61|xor|Вычисляет побитовое исключающее или двух целочисленных значений и возвращает целое число.|  
  
 Изменения состояния стека в последовательном порядке, является:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; поразрядное исключающее или вычислить.  
  
4.  Побитовое исключающее или `value2` и `value1` помещается в стек.  
  
 `xor` Инструкция вычисляет побитовое исключающее или двух верхних значений в стеке и оставляет результат в стеке.  
  
 `Xor` представляет собой операцию целыми числами.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> можно использовать перегрузку метода `xor` код операции:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>