<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="OpCodes.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a136bc8fb48fe619f1be21928afbfcd9094d7463.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a136bc8fb48fe619f1be21928afbfcd9094d7463</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.OpCodes">
          <source>Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> class members (such as <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph>).</source>
          <target state="translated">Содержит поля, предоставляющие инструкции языка MSIL для выпуска элементами класса <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> (например, <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Подробное описание с кодами операций члена см. в документации Common Language Infrastructure (CLI), особенно «Раздел III набору инструкций CIL» и «Раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The following example demonstrates the construction of a dynamic method using <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> to emit <ph id="ph2">`OpCodes`</ph> into a <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">Ниже приведен пример создания динамического метода с использованием <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> для порождения <ph id="ph2">`OpCodes`</ph> в <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">Складывает два значения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>58</source>
          <target state="translated">58</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two numeric values, returning a new numeric value.</source>
          <target state="translated">Добавляет два числовых значения и возвращает новое числовое значение.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> добавляется <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</source>
          <target state="translated">Не обнаружено переполнение для целочисленных операций (для управления переполнением правильную, в разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Integer addition wraps, rather than saturates.</source>
          <target state="translated">Целое число со знаком сложения заключает в оболочку, а не насыщение.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>For example, assuming 8-bit integers where <ph id="ph1">`value1`</ph> is set to 255 and <ph id="ph2">`value2`</ph> is set to 1, the wrapped result is 0 rather than 256.</source>
          <target state="translated">Например, при условии, что 8-битовых целых чисел где <ph id="ph1">`value1`</ph> равно 255 и <ph id="ph2">`value2`</ph> имеет значение 1, будет получен результат 0, а не 256.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">С плавающей запятой переполнения возвращает <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) или <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</source>
          <target state="translated">Если нет записи для сочетания определенного типа (например, <ph id="ph1">`int32`</ph> и <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> и <ph id="ph4">`int64`</ph>), он является недопустимым Microsoft промежуточного языка MSIL и создает ошибку.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>operand</source>
          <target state="translated">Операнд</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value1 type</source>
          <target state="translated">Значение1 типа</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value2 type</source>
          <target state="translated">Тип value2</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>result type</source>
          <target state="translated">Тип результата</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`add`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Складывает два целых числа, выполняет проверку переполнения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>D6</source>
          <target state="translated">D6</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add.ovf</source>
          <target state="translated">Add.ovf</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two signed integer values with an overflow check.</source>
          <target state="translated">Складывает два значения целого числа со знаком и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> добавляется <ph id="ph4">`value2`</ph> проверкой переполнения.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не представлен в тип результата.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">Можно выполнить эту операцию для целых чисел со знаком.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">Для значений с плавающей запятой, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">Если нет записи для сочетания определенного типа (например, <ph id="ph1">`int32`</ph> и <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> и <ph id="ph4">`int64`</ph>), он имеет недопустимую инструкцию промежуточного языка Майкрософт (MSIL) и создает ошибку.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>operand</source>
          <target state="translated">Операнд</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value1 type</source>
          <target state="translated">Значение1 типа</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value2 type</source>
          <target state="translated">Тип value2</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>result type</source>
          <target state="translated">Тип результата</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`add.ovf`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Складывает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>D7</source>
          <target state="translated">D7</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add.ovf.un</source>
          <target state="translated">Add.ovf.un</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values with an overflow check.</source>
          <target state="translated">Добавляет два целочисленных значений без знака и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> добавляется <ph id="ph4">`value2`</ph> проверкой переполнения.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не представлен в тип результата.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">Можно выполнить эту операцию для целых чисел со знаком.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">Для значений с плавающей запятой, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">В следующей таблице перечислены допустимые типы операндов и их соответствующие типы данных результата.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">Если нет записи для сочетания определенного типа (например, <ph id="ph1">`int32`</ph> и <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> и <ph id="ph4">`int64`</ph>), он имеет недопустимую инструкцию промежуточного языка Майкрософт (MSIL) и создает ошибку.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>operand</source>
          <target state="translated">Операнд</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value1 type</source>
          <target state="translated">Значение1 типа</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value2 type</source>
          <target state="translated">Тип value2</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>result type</source>
          <target state="translated">Тип результата</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">add</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`add.ovf.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">Вычисляет побитовое И двух значений и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Instruction</source>
          <target state="translated">Инструкция</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>5F</source>
          <target state="translated">5F</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>and</source>
          <target state="translated">и</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Determines the bitwise AND of two integer values.</source>
          <target state="translated">Вычисляет побитовое и двух целочисленных значений.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> and <ph id="ph2">`value2`</ph> are popped from the stack; the bitwise AND of the two values is computed.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> и <ph id="ph2">`value2`</ph> извлекаются из стека; вычисляется побитовое и двух значений.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The <ph id="ph1">`and`</ph> instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated"><ph id="ph1">`and`</ph> Инструкция вычисляет побитовое и двух верхних значений в стеке и оставляет результат в стеке.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`And`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`And`</ph> представляет собой операцию целыми числами.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`and`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`and`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an unmanaged pointer to the argument list of the current method.</source>
          <target state="translated">Возвращает неуправляемый указатель на список аргументов текущего метода.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>FE 00</source>
          <target state="translated">FE 00</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>arglist</source>
          <target state="translated">arglist</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an argument list handle for the current method.</source>
          <target state="translated">Возвращает дескриптор списка аргументов для текущего метода.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">По этой операции выполняются не стек вычислений.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The <ph id="ph1">`arglist`</ph> instruction returns an opaque handle (an unmanaged pointer, of type <ph id="ph2">`native int`</ph>) that represents the argument list of the current method.</source>
          <target state="translated"><ph id="ph1">`arglist`</ph> Инструкция возвращает непрозрачный дескриптор (неуправляемый указатель типа <ph id="ph2">`native int`</ph>), представляющий список аргументов текущего метода.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>This handle is valid only during the lifetime of the current method.</source>
          <target state="translated">Этот дескриптор допустим только в течение времени существования текущего метода.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can, however, pass the handle to other methods as long as the current method is on the thread of control.</source>
          <target state="translated">Тем не менее, можно передает этот дескриптор для других методов, пока текущий метод в потоке управления.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can only execute the <ph id="ph1">`arglist`</ph> instruction within a method that takes a variable number of arguments.</source>
          <target state="translated">Может выполняться только <ph id="ph1">`arglist`</ph> инструкции в пределах метод, который принимает переменное число аргументов.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`arglist`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`arglist`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Transfers control to a target instruction if two values are equal.</source>
          <target state="translated">Передает управление конечной инструкции, если два значения равны.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>beq <ph id="ph1">`target`</ph></source>
          <target state="translated">beq <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if the two values are equal.</source>
          <target state="translated">Выполняет переход к цели инструкции по смещению <ph id="ph1">`target`</ph> Если два значения равны.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> равен <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The <ph id="ph1">`beq`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`beq`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> равен <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует так же, как при выполнении <ph id="ph1">`ceq`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">Допустимые типы операндов инкапсулированы ниже.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков (подобная передача строго ограничивается и необходимо использовать <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> инструкции вместо).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`beq`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Transfers control to a target instruction (short form) if two values are equal.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если два значения равны.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>beq.s <ph id="ph1">`target`</ph></source>
          <target state="translated">beq.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if equal, short form</source>
          <target state="translated">Выполняет переход к цели инструкции по смещению <ph id="ph1">`target`</ph> Если объекты равны, краткая форма</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> равен <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The <ph id="ph1">`beq.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`beq.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> равен <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует так же, как при выполнении <ph id="ph1">`ceq`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">Допустимые типы операндов инкапсулированы ниже.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков (подобная передача строго ограничивается и необходимо использовать <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> инструкции вместо).</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`beq.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Transfers control to a target instruction if the first value is greater than or equal to the second value.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение больше второго или равно ему.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>3C <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3C <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>bge <ph id="ph1">`target`</ph></source>
          <target state="translated">bge <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно значению второго.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The <ph id="ph1">`bge`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bge`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше или равно <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt.un`</ph> инструкции, за которым следует <ph id="ph2">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bge`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение больше второго или равно ему.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>2F <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">2F <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>bge.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно ему, краткая форма.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The <ph id="ph1">`bge.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bge.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше или равно <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt.un`</ph> инструкции, за которым следует <ph id="ph2">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bge.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>41 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">41 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>bge.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно ему (для значений без знака).</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The <ph id="ph1">`bge.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bge.un`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше или равно <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt`</ph> инструкции, за которым следует <ph id="ph2">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bge.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>bge.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше или равно ему (для значений без знака).</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The <ph id="ph1">`bge.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bge.un.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше или равно <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt`</ph> инструкции, за которым следует <ph id="ph2">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bge.un.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Transfers control to a target instruction if the first value is greater than the second value.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение больше второго.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>bgt <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The <ph id="ph1">`bgt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bgt`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше, чем <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bgt`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение больше второго.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>bgt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго краткая форма.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The <ph id="ph1">`bgt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bgt.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше, чем <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bgt.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>bgt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем значение второго (для значений без знака).</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The <ph id="ph1">`bgt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bgt.un`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше, чем <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt.un`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bgt.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>bgt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение больше, чем (для значений без знака).</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> больше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The <ph id="ph1">`bgt.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bgt.un.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> больше, чем <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt.un`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bgt.un.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение меньше второго значения или равно ему.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>3E <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3E <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ble <ph id="ph1">`target`</ph></source>
          <target state="translated">отключить <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно значению второго.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> меньше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The <ph id="ph1">`ble`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`ble`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> меньше или равно <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt`</ph> инструкции (<ph id="ph2">`cgt.un`</ph> для значений с плавающей запятой) следуют <ph id="ph3">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ble`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>31 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">31 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ble.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно ему, краткая форма.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> меньше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The <ph id="ph1">`ble.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`ble.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> меньше или равно <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) instruction followed by a<ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt`</ph> инструкции (<ph id="ph2">`cgt.un`</ph> для значений с плавающей запятой) инструкции, за которым следует<ph id="ph3">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ble.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>43 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">43 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ble.un <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно ему (для значений без знака).</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> меньше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The <ph id="ph1">`ble.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`ble.un`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> меньше или равно <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt.un`</ph> инструкции (<ph id="ph2">`cgt`</ph> для значений с плавающей запятой) следуют <ph id="ph3">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ble.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>36 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">36 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ble.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше или равно ему (для значений без знака).</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> меньше или равно <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The <ph id="ph1">`ble.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`ble.un.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> меньше или равно <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`cgt.un`</ph> инструкции (<ph id="ph2">`cgt`</ph> для значений с плавающей запятой) следуют <ph id="ph3">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ble.un.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Transfers control to a target instruction if the first value is less than the second value.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение меньше второго.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>blt <ph id="ph1">`target`</ph></source>
          <target state="translated">BLT <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго значения.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> — меньше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The <ph id="ph1">`blt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`blt`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> меньше или равно <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`blt`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго значения.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>blt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">BLT.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше, чем значение второго краткая форма.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> — меньше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The <ph id="ph1">`blt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`blt.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> — меньше, чем <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`blt.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции, если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>blt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">BLT.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго (для значений без знака).</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> — меньше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`blt.un`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> — меньше, чем <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt.un`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`blt.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>blt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">BLT.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если первое значение меньше второго (для значений без знака), краткая форма.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> — меньше, чем <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`blt.un`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> — меньше, чем <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`clt.un`</ph> инструкции, за которым следует <ph id="ph2">`brtrue`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`blt.un.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">Передает управление конечной инструкции в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>bne.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bne.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</source>
          <target state="translated">Ветвь в целевой объект инструкции с указанным смещением в случае двух целочисленных значений, не равно (значений без знака).</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> не равен <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bne.un`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> не равен <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`ceq`</ph> инструкции, за которым следует <ph id="ph2">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bne.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма) в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>bne.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bne.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</source>
          <target state="translated">Ветвь в целевой объект инструкции с указанным смещением в случае двух целочисленных значений, не равно (значений без знака), краткая форма.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; если <ph id="ph3">`value1`</ph> не равен <ph id="ph4">`value2`</ph>, выполняется операция перехода.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bne.un`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value1`</ph> не равен <ph id="ph3">`value2`</ph>, по сравнению с помощью целого числа без знака или неупорядоченных типа float.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">Действует аналогично выполнению <ph id="ph1">`ceq`</ph> инструкции, за которым следует <ph id="ph2">`brfalse`</ph> выполняет переход к соответствующей конечной инструкции.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`bne.un.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Converts a value type to an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>).</source>
          <target state="translated">Преобразует тип значения в ссылку на объект (тип <ph id="ph1">&lt;see langword="O" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>box <ph id="ph1">`valTypeToken`</ph></source>
          <target state="translated">Поле <ph id="ph1">`valTypeToken`</ph></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Convert a value type (of the type specified in <ph id="ph1">`valTypeToken`</ph>) to a true object reference.</source>
          <target state="translated">Преобразование типа значения (типа, указанного в <ph id="ph1">`valTypeToken`</ph>) для ссылки на объект, значение true.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type is pushed onto the stack.</source>
          <target state="translated">Тип значения помещается в стек.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The value type is popped from the stack; the <ph id="ph1">`box`</ph> operation is performed.</source>
          <target state="translated">Тип значения извлекается из стека; <ph id="ph1">`box`</ph> выполняется операция.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>An object reference to the resulting "boxed" value type is pushed onto the stack.</source>
          <target state="translated">Ссылки на объект в результирующий тип «процессор» значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">Тип значения имеет два представления в Common Language Infrastructure (CLI):</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'raw' form used when a value type is embedded within another object or on the stack.</source>
          <target state="translated">«Первичная» форма, используемый при внедрении типа значения в другом объекте или в стеке.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">Форма «процессор», где данные в тип значения упаковываются в объект и существуют как независимая сущность.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The <ph id="ph1">`box`</ph> instruction converts the 'raw' (unboxed) value type into an object reference (type <ph id="ph2">`O`</ph>).</source>
          <target state="translated"><ph id="ph1">`box`</ph> Инструкция преобразует тип значения «первичного» (распакованный) в ссылку на объект (тип <ph id="ph2">`O`</ph>).</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</source>
          <target state="translated">Это достигается путем создания нового объекта и копирования данных из типа значения во вновь выделенный объект.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">`valTypeToken`</ph> is a metadata token indicating the type of the value type on the stack.</source>
          <target state="translated"><ph id="ph1">`valTypeToken`</ph> токен метаданных, указывающий тип значения в стеке.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> возникает, если памяти недостаточно для удовлетворения запроса.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если класс не найден.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`box`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`box`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Unconditionally transfers control to a target instruction.</source>
          <target state="translated">Обеспечивает безусловную передачу управления конечной инструкции.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>br <ph id="ph1">`target`</ph></source>
          <target state="translated">br <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Branches to a target instruction at the specified offset.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">По этой операции выполняются не стек вычислений.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The <ph id="ph1">`br`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated"><ph id="ph1">`br`</ph> Инструкция выполняет безусловную передачу управления конечной инструкции.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`br`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Unconditionally transfers control to a target instruction (short form).</source>
          <target state="translated">Обеспечивает безусловную передачу управления конечной инструкции (короткая форма).</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>br.s <ph id="ph1">`target`</ph></source>
          <target state="translated">br.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Branches to a target instruction at the specified offset, short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, краткая форма.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">По этой операции выполняются не стек вычислений.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The <ph id="ph1">`br.s`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated"><ph id="ph1">`br.s`</ph> Инструкция выполняет безусловную передачу управления конечной инструкции.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`br.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</source>
          <target state="translated">Сообщает инфраструктуре CLI, что необходимо оповестить отладчик о достижении точки останова.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Description</source>
          <target state="translated">Описание</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>01</source>
          <target state="translated">01</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>break</source>
          <target state="translated">break</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>inform a debugger that a breakpoint has been reached.</source>
          <target state="translated">оповещение отладчик о достижении точки останова.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">По этой операции выполняются не стек вычислений.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction is for debugging support.</source>
          <target state="translated"><ph id="ph1">`break`</ph> Инструкция предназначена для поддержки отладки.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It signals the CLI to inform the debugger that a break point has been tripped.</source>
          <target state="translated">Она сообщает инфраструктуре CLI, необходимо оповестить отладчик о достижении точки останова.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It has no other effect on the interpreter state.</source>
          <target state="translated">Он имеет не влияет на состояние интерпретатора.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</source>
          <target state="translated"><ph id="ph1">`break`</ph> Инструкция имеет наименьший возможный размер Включение исправлений с помощью точки останова с минимальным воздействием на окружающий код.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction can trap to a debugger, do nothing, or raise a security exception.</source>
          <target state="translated"><ph id="ph1">`break`</ph> Инструкция может осуществляться отладчиком, не выполняют никаких действий или выдать исключение безопасности.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The exact behavior is implementation-defined.</source>
          <target state="translated">Точное поведение определяется реализацией.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`break`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`break`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), or zero.</source>
          <target state="translated">Передает управление конечной инструкции, если значением <ph id="ph1">&lt;paramref name="value" /&gt;</ph> является <ph id="ph2">&lt;see langword="false" /&gt;</ph>, пустая ссылка (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) или ноль.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brfalse <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brnull <ph id="ph1">`target`</ph></source>
          <target state="translated">brnull <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brzero <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек предыдущей операцией.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекаются из стека; Если <ph id="ph2">`value`</ph> — <ph id="ph3">`false`</ph>, переход на <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The <ph id="ph1">`brfalse`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated"><ph id="ph1">`brfalse`</ph> Инструкции (и ее псевдонимы <ph id="ph2">`brnull`</ph> и <ph id="ph3">`brzero`</ph>) передает управление указанной конечной инструкции, если <ph id="ph4">`value`</ph> (типа <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, ссылку на объект <ph id="ph7">`O`</ph>, управляемый указатель <ph id="ph8">`&amp;`</ph>, временный указатель <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) равно нулю (<ph id="ph11">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> не равно нулю (<ph id="ph2">`true`</ph>) продолжает выполнение следующей инструкции.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`brfalse`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference, or zero.</source>
          <target state="translated">Передает управление конечной инструкции, если значением <ph id="ph1">&lt;paramref name="value" /&gt;</ph> является <ph id="ph2">&lt;see langword="false" /&gt;</ph>, пустая ссылка или ноль.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brfalse.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brnull.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brnull.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brzero.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>, short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если <ph id="ph1">`false`</ph>, краткая форма.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек предыдущей операцией.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекаются из стека; Если <ph id="ph2">`value`</ph> — <ph id="ph3">`false`</ph>, переход на <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The <ph id="ph1">`brfalse.s`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated"><ph id="ph1">`brfalse.s`</ph> Инструкции (и ее псевдонимы <ph id="ph2">`brnull`</ph> и <ph id="ph3">`brzero`</ph>) передает управление указанной конечной инструкции, если <ph id="ph4">`value`</ph> (типа <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, ссылку на объект <ph id="ph7">`O`</ph>, управляемый указатель <ph id="ph8">`&amp;`</ph>, временный указатель <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) равно нулю (<ph id="ph11">`false`</ph>).</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> не равно нулю (<ph id="ph2">`true`</ph>) продолжает выполнение следующей инструкции.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`brfalse.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated">Передает управление конечной инструкции, если значение <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see langword="true" /&gt;</ph>, либо отличается от null и от нуля.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brtrue <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brinst <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>).</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если ненулевое значение (<ph id="ph1">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек предыдущей операцией.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекаются из стека; Если <ph id="ph2">`value`</ph> — <ph id="ph3">`true`</ph>, переход на <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The <ph id="ph1">`brtrue`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated"><ph id="ph1">`brtrue`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value`</ph> (тип <ph id="ph3">`native int`</ph>) имеет ненулевое значение (<ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> равно нулю (<ph id="ph2">`false`</ph>) продолжает выполнение следующей инструкции.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> является ссылкой на объект (тип <ph id="ph2">`O`</ph>) затем <ph id="ph3">`brinst`</ph> (псевдоним для <ph id="ph4">`brtrue`</ph>) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на пустой объект; см. раздел <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`brtrue`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Transfers control to a target instruction (short form) if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated">Передает управление конечной инструкции (короткая форма), если значение <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see langword="true" /&gt;</ph> либо отличается от null и от нуля.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brtrue.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brinst.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>), short form.</source>
          <target state="translated">Выполняет переход к конечной инструкции с указанным смещением, если ненулевое значение (<ph id="ph1">`true`</ph>), краткая форма.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек предыдущей операцией.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекаются из стека; Если <ph id="ph2">`value`</ph> — <ph id="ph3">`true`</ph>, переход на <ph id="ph4">`target`</ph>.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The <ph id="ph1">`brtrue.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated"><ph id="ph1">`brtrue.s`</ph> Инструкция передает управление указанной конечной инструкции, если <ph id="ph2">`value`</ph> (тип <ph id="ph3">`native int`</ph>) имеет ненулевое значение (<ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> равно нулю (<ph id="ph2">`false`</ph>) продолжает выполнение следующей инструкции.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> является ссылкой на объект (тип <ph id="ph2">`O`</ph>) затем <ph id="ph3">`brinst`</ph> (псевдоним для <ph id="ph4">`brtrue`</ph>) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на пустой объект; см. раздел <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">Целевая инструкция представляется как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`brtrue.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls the method indicated by the passed method descriptor.</source>
          <target state="translated">Вызывает метод, на который ссылается переданный дескриптор метода.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>call <ph id="ph1">`methodDesc`</ph></source>
          <target state="translated">Вызов <ph id="ph1">`methodDesc`</ph></target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Call the method described by <ph id="ph1">`methodDesc`</ph>.</source>
          <target state="translated">Вызовите метод, описанный <ph id="ph1">`methodDesc`</ph>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Аргументы метода <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argN`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</source>
          <target state="translated">Аргументы метода <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argN`</ph> извлекаются из стека; выполняется вызов метода с этими аргументами и управление передается методу, на который ссылается дескриптор метода.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">По завершении возвращаемое значение создается с помощью метода вызываемого объекта и отправлен в вызывающий код.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">Возвращаемое значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction calls the method indicated by the method descriptor passed with the instruction.</source>
          <target state="translated"><ph id="ph1">`call`</ph> Инструкция вызывает метод, передаваемый с инструкцией дескриптор метода.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</source>
          <target state="translated">Дескриптор метода представляет собой лексему метаданных, который указывает метод для вызова и количество, тип и порядок аргументов, которые были помещены в стек должен быть передан этому методу, а также соглашение о вызовах для использования.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction can be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix instruction to specify that the current method state should be released before transferring control.</source>
          <target state="translated"><ph id="ph1">`call`</ph> Инструкция может непосредственно предшествовать <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) префиксная инструкция для указания освобождение состояния текущего метода перед передачей управления.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</source>
          <target state="translated">Если вызов передает управление методу, более высокий уровень доверия, чем у исходного метода, кадр стека не освобождается.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Instead, the execution continues silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">Вместо этого выполнение продолжается так, словно <ph id="ph1">`tail`</ph> не был указан.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</source>
          <target state="translated">Токен метаданных содержит сведения, позволяющие определить, является ли вызов статического метода, метод экземпляра, виртуальный метод или глобальной функции.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</source>
          <target state="translated">Во всех этих случаях адрес назначения определяется исключительно на основании дескриптора метода (Сравните это с <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> инструкции для вызова виртуальных методов, где адрес назначения также зависит от типа среды выполнения экземпляра ссылка в стек перед <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Аргументы помещаются в стек в порядке слева направо.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">То есть первый аргумент вычисляется, а поместить в стек, затем второй аргумент, затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>There are three important special cases:</source>
          <target state="translated">Существует три важных особых случаях:</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</source>
          <target state="translated">Вызовы к экземпляру (или виртуальных) метода необходимо поместить ссылку на экземпляр перед любыми видимыми аргументов.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The instance reference must not be a null reference.</source>
          <target state="translated">Ссылка на экземпляр не должен быть пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The signature carried in the metadata does not contain an entry in the parameter list for the <ph id="ph1">`this`</ph> pointer; instead, it uses a bit to indicate whether the method requires passing the <ph id="ph2">`this`</ph> pointer.</source>
          <target state="translated">Подпись, передавая с метаданными не содержит запись в списке параметров для <ph id="ph1">`this`</ph> указателю; вместо этого используется бит, определяющий, требует ли метод передачи <ph id="ph2">`this`</ph> указателя.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>It is valid to call a virtual method using <ph id="ph1">`call`</ph> (rather than <ph id="ph2">`callvirt`</ph>); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</source>
          <target state="translated">Он допустим для вызова виртуального метода с помощью <ph id="ph1">`call`</ph> (а не <ph id="ph2">`callvirt`</ph>); это означает, что метод является будет обработан с помощью класса, заданного методом, а не как динамически из вызываемого объекта.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Note that a delegate's <ph id="ph1">`Invoke`</ph> method can be called with either the <ph id="ph2">`call`</ph> or <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">Обратите внимание, что делегат <ph id="ph1">`Invoke`</ph> метод может вызываться с помощью <ph id="ph2">`call`</ph> или <ph id="ph3">`callvirt`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> может быть вызвано, если система безопасности не позволяет вызывающей процедуре получить доступ к вызываемому методу.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">Проверка безопасности может возникнуть при преобразовании в машинный код, а не во время выполнения инструкции промежуточного языка Майкрософт (MSIL).</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction instead of emitting a <ph id="ph3">`call`</ph> instruction.</source>
          <target state="translated">При вызове методов класса System.Object в типах значений, рассмотрите возможность использования <ph id="ph1">`constrained`</ph> префикс <ph id="ph2">`callvirt`</ph> инструкции вместо выдача <ph id="ph3">`call`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">Это устраняет необходимость выпуска другой инструкции промежуточного языка в зависимости от того, является ли тип значения переопределяет метод, как избежать потенциальных проблем управления версиями.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">Рассмотрите возможность использования <ph id="ph1">`constrained`</ph> префикс при вызове методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">Эти проблемы описаны более подробно в <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> код операции.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`call`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`call`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (код операции, MethodInfo)</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> method is provided for <ph id="ph2">`varargs`</ph> calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> Метод предоставляется для <ph id="ph2">`varargs`</ph> вызовов.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method for normal calls.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> метод обычные вызовы.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</source>
          <target state="translated">Вызывает метод, заданный в стеке вычислений (как указатель на точку входа), с аргументами, описанными в соглашении о вызовах.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>calli <ph id="ph1">`callSiteDescr`</ph></source>
          <target state="translated">Calli <ph id="ph1">`callSiteDescr`</ph></target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method pointed to with arguments described by the calling convention.</source>
          <target state="translated">Вызывает метод по указателю с аргументами, описанными в соглашении о вызовах.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Аргументы метода <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argN`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is pushed onto the stack.</source>
          <target state="translated">Указатель на точку входа метода помещается в стек.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the method entry pointer are popped from the stack; the call to the method is performed.</source>
          <target state="translated">Аргументы метода <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argN`</ph> и указатель на точку входа метода извлекаются из стека; выполняется вызов метода.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">По завершении возвращаемое значение создается с помощью метода вызываемого объекта и отправлен в вызывающий код.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">Возвращаемое значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction calls the method entry pointer with the arguments <ph id="ph2">`arg1`</ph> through <ph id="ph3">`argN`</ph>.</source>
          <target state="translated"><ph id="ph1">`calli`</ph> Инструкция вызывает указатель на точку входа метода с аргументами <ph id="ph2">`arg1`</ph> через <ph id="ph3">`argN`</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The types of these arguments are described by the specific calling convention (<ph id="ph1">`callSiteDesc`</ph>).</source>
          <target state="translated">Типы этих аргументов описаны определенным соглашением о вызовах (<ph id="ph1">`callSiteDesc`</ph>).</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> prefix (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) to specify that the current method state should be released before transferring control.</source>
          <target state="translated"><ph id="ph1">`calli`</ph> Инструкция может непосредственно предшествовать <ph id="ph2">`tail`</ph> префикс (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) для указания освобождение состояния текущего метода перед передачей управления.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">Если вызов передает управление методу более высокий уровень доверия, чем у исходного метода кадр стека не удаляется. Вместо этого выполнение продолжается так, как если бы <ph id="ph1">`tail`</ph> не был указан.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</source>
          <target state="translated">Указатель на точку входа метода предполагается определенный указатель на машинный код (конечного компьютера), допустимым образом вызван с аргументами, описанными в соглашении о вызовах (лексема метаданных для отдельной подписи).</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Such a pointer can be created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> instructions, or passed in from native code.</source>
          <target state="translated">Такой указатель можно создать с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> инструкции, и переданный из машинного кода.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The calling convention is not checked dynamically, so code that uses a <ph id="ph1">`calli`</ph> instruction does not work correctly if the destination does not actually use the specified calling convention.</source>
          <target state="translated">Соглашение о вызовах не проверяется динамически, поэтому код, использующий <ph id="ph1">`calli`</ph> инструкций не работает правильно, если конечный метод не использует соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Аргументы помещаются в стек в порядке слева направо.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">То есть первый аргумент вычисляется, а поместить в стек, затем второй аргумент, затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</source>
          <target state="translated">Последовательности кода программисту для экземпляра или виртуального метода необходимо поместить ссылку на экземпляр (он не должен быть пустой ссылкой) перед любыми видимыми аргументов.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if the system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> может быть вызвано, если система безопасности не позволяет вызывающей процедуре получить доступ к вызываемому методу.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">Проверка безопасности происходит на этапе преобразования инструкций промежуточного языка Майкрософт (MSIL) в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> methods can be used to perform a <ph id="ph2">`calli`</ph> instruction on the stack.</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> методы можно использовать для выполнения <ph id="ph2">`calli`</ph> инструкции в стеке.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Note that <ph id="ph1">`calli`</ph> should be called through the below methods rather than using the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> class to place the instruction directly on the stack.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`calli`</ph> должен вызываться через ниже методов, а не с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> класса для помещения инструкции непосредственно в стеке.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</source>
          <target state="translated">ILGenerator.EmitCalli (код операции, CallingConventions, тип, Type [], Type[]) для вызовов с помощью управляемых соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</source>
          <target state="translated">ILGenerator.EmitCalli (Opcode Type[]) CallingConvention, тип, для вызовов с помощью неуправляемых соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</source>
          <target state="translated">Вызывает метод объекта с поздней привязкой и помещает возвращаемое значение в стек вычислений.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>callvirt <ph id="ph1">`method`</ph></source>
          <target state="translated">callvirt <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a specific method associated with <ph id="ph1">`obj`</ph>.</source>
          <target state="translated">Вызывает определенный метод, связанный с <ph id="ph1">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`obj`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">Аргументы метода <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argN`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the object reference <ph id="ph3">`obj`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <ph id="ph4">`obj`</ph> referred to by the method metadata token.</source>
          <target state="translated">Аргументы метода <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argN`</ph> и ссылка на объект <ph id="ph3">`obj`</ph> извлекаются из стека; выполняется вызов метода с этими аргументами и управление передается методу в <ph id="ph4">`obj`</ph> ссылается метод токен метаданных.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">По завершении возвращаемое значение создается с помощью метода вызываемого объекта и отправлен в вызывающий код.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">Возвращаемое значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction calls a late-bound method on an object.</source>
          <target state="translated"><ph id="ph1">`callvirt`</ph> Инструкция вызывает метод позднего связывания объекта.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the method is chosen based on the runtime type of <ph id="ph1">`obj`</ph> rather than the compile-time class visible in the method pointer.</source>
          <target state="translated">То есть метод зависит от типа времени выполнения <ph id="ph1">`obj`</ph> вместо класса во время компиляции, видимого в указателе метода.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> can be used to call both virtual and instance methods.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> можно использовать для вызова виртуальных методов и методов экземпляра.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix to specify that the current stack frame should be released before transferring control.</source>
          <target state="translated"><ph id="ph1">`callvirt`</ph> Инструкция может непосредственно предшествовать <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) префикс для указания отжатии текущий кадр стека перед передачей управления.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</source>
          <target state="translated">Если вызов передает управление методу более высокий уровень доверия, чем у исходного метода кадр стека не удаляется.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The method metadata token provides the name, class and signature of the method to call.</source>
          <target state="translated">Токен метаданных метода предоставляет имя, класс и сигнатуру метода для вызова.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The class associated with <ph id="ph1">`obj`</ph> is the class of which it is an instance.</source>
          <target state="translated">Класс, связанный с <ph id="ph1">`obj`</ph> — это класс, экземпляр которого он является.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the class defines a non-static method that matches the indicated method name and signature, this method is called.</source>
          <target state="translated">Если класс определяет нестатический метод, который соответствует указанное имя и подпись, этот метод вызывается.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Otherwise all classes in the base class chain of this class are checked in order.</source>
          <target state="translated">В противном случае все классы в цепочке базовый класс этого класса проверяются по порядку.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>It is an error if no method is found.</source>
          <target state="translated">Считается ошибкой, если метод не найден.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> pops the object and the associated arguments off the evaluation stack before calling the method.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> Извлекает объект и соответствующие аргументы из стека вычислений перед вызовом метода.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the method has a return value, it is pushed on the stack upon method completion.</source>
          <target state="translated">Если метод имеет возвращаемое значение, он помещается в стек по завершении метода.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>On the callee side, the <ph id="ph1">`obj`</ph> parameter is accessed as argument 0, <ph id="ph2">`arg1`</ph> as argument 1, and so on.</source>
          <target state="translated">На стороне вызываемой <ph id="ph1">`obj`</ph> параметра доступно в качестве аргумента 0, <ph id="ph2">`arg1`</ph> как аргумент 1 и т. д.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">Аргументы помещаются в стек в порядке слева направо.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">То есть первый аргумент вычисляется, а поместить в стек, затем второй аргумент, затем третий, пока все необходимые аргументы не на вершине стека в порядке убывания.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The instance reference <ph id="ph1">`obj`</ph> (always required for <ph id="ph2">`callvirt`</ph>) must be pushed before any of the user-visible arguments.</source>
          <target state="translated">Ссылка на экземпляр <ph id="ph1">`obj`</ph> (всегда требуется для <ph id="ph2">`callvirt`</ph>) должна быть стек перед всеми видимыми аргументов.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</source>
          <target state="translated">Подпись (передается в токен метаданных) не должны содержать запись в списке параметров для этого указателя.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Note that a virtual method can also be called using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">Обратите внимание, что виртуальный метод может также вызываться с использованием <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <ph id="ph2">`obj`</ph> or any of its base classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> возникает, если нестатический метод с указанным именем и подписью не удалось найти в классе, связанном с <ph id="ph2">`obj`</ph> или любого из его базовых классов.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if obj is null.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если obj имеет значение null.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> возникает, если система безопасности не позволяет вызывающей процедуре получить доступ к вызываемому методу.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The security check may occur when the CIL is converted to native code rather than at run time.</source>
          <target state="translated">Проверка безопасности обычно происходит, когда CIL-ФАЙЛ преобразуется в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated">При вызове методов класса System.Object в типах значений, рассмотрите возможность использования <ph id="ph1">`constrained`</ph> префикс <ph id="ph2">`callvirt`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">Это устраняет необходимость выпуска другой инструкции промежуточного языка в зависимости от того, является ли тип значения переопределяет метод, как избежать потенциальных проблем управления версиями.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">Рассмотрите возможность использования <ph id="ph1">`constrained`</ph> префикс при вызове методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">Эти проблемы описаны более подробно в <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> код операции.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`callvirt`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`callvirt`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (код операции, MethodInfo)</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Attempts to cast an object passed by reference to the specified class.</source>
          <target state="translated">Предпринимает попытку привести объект, передаваемый по ссылке, к указанному классу.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>castclass <ph id="ph1">`class`</ph></source>
          <target state="translated">castclass <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Casts an object to a new object of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Приводит объект новый объект типа <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The object reference is popped from the stack; the referenced object is cast as the specified <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Ссылка на объект извлекается из стека; Указанный объект приводится как указанный <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If successful, a new object reference is pushed onto the stack.</source>
          <target state="translated">В случае успеха новая ссылка на объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The <ph id="ph1">`castclass`</ph> instruction attempts to cast the object reference (type <ph id="ph2">`O`</ph>) atop the stack to a specified class.</source>
          <target state="translated"><ph id="ph1">`castclass`</ph> Инструкция пытается выполнить преобразование ссылки на объект (тип <ph id="ph2">`O`</ph>) на вершине стека к указанному классу.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The new class is specified by a metadata token indicating the desired class.</source>
          <target state="translated">Новый класс, указанный с помощью лексемы метаданных, указывающий нужный класс.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Если класс объекта на вершине стека не реализует новый класс (новый класс — интерфейс), а не производным классом от нового класса то <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the object reference is a null reference, <ph id="ph1">`castclass`</ph> succeeds and returns the new object as a null reference.</source>
          <target state="translated">Если ссылка на объект является пустой ссылкой, <ph id="ph1">`castclass`</ph> завершается успешно и возвращает новый объект как пустую ссылку.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if obj cannot be cast to class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> возникает, если obj не может быть приведен к классу.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если не удается найти класс.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`castclass`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`castclass`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Compares two values.</source>
          <target state="translated">Сравнивает два значения.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If they are equal, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Если они равны, целочисленное значение 1 (<ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>FE 01</source>
          <target state="translated">FE 01</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ceq</source>
          <target state="translated">ceq</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> equals <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Помещает в стек 1, если <ph id="ph1">`value1`</ph> равняется <ph id="ph2">`value2`</ph>; в противном случае помещает в стек 0.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is compared to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> сравнивается с <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> равен <ph id="ph2">`value2`</ph>, 1 помещается в стек; в противном случае 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The <ph id="ph1">`ceq`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`ceq`</ph> Сравнивает инструкция <ph id="ph2">`value1`</ph> и <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, then 1 (of type <ph id="ph3">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> равен <ph id="ph2">`value2`</ph>, нажмите 1 (типа <ph id="ph3">`int32`</ph>) помещается в стек.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Otherwise 0 (of type <ph id="ph1">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">В противном случае — 0 (типа <ph id="ph1">`int32`</ph>) помещается в стек.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>For floating-point number, <ph id="ph1">`ceq`</ph> will return 0 if the numbers are unordered (either or both are NaN).</source>
          <target state="translated">Числа с плавающей запятой <ph id="ph1">`ceq`</ph> возвращает 0, если числа неупорядочены (одно или оба значения имеют тип NaN).</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The infinite values are equal to themselves.</source>
          <target state="translated">Бесконечные значения равны на самих себя.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ceq`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ceq`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Compares two values.</source>
          <target state="translated">Сравнивает два значения.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Если первое значение больше второго, целочисленное значение 1 (<ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>FE 02</source>
          <target state="translated">FE 02</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>cgt</source>
          <target state="translated">cgt</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Помещает в стек 1, если <ph id="ph1">`value1`</ph> больше, чем <ph id="ph2">`value2`</ph>; в противном случае помещает в стек 0.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`cgt`</ph> проверяет <ph id="ph4">`value1`</ph> больше, чем <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> больше, чем <ph id="ph2">`value2`</ph>, 1 помещается в стек; в противном случае 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The <ph id="ph1">`cgt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`cgt`</ph> Сравнивает инструкция <ph id="ph2">`value1`</ph> и <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> строго больше <ph id="ph2">`value2`</ph>, то <ph id="ph3">`int32`</ph> помещается значение 1 в стек.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">В противном случае <ph id="ph1">`int32`</ph> значение 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>For floating-point numbers, <ph id="ph1">`cgt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">Для чисел с плавающей запятой <ph id="ph1">`cgt`</ph> возвращает 0, если числа неупорядочены (то есть, если один или оба аргумента имеют значение NaN).</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`cgt`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Compares two unsigned or unordered values.</source>
          <target state="translated">Сравнивает два значения без знака или два неупорядоченных значения.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Если первое значение больше второго, целочисленное значение 1 (<ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>FE 03</source>
          <target state="translated">FE 03</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>cgt.un</source>
          <target state="translated">или cgt.un</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">Помещает в стек 1, если <ph id="ph1">`value1`</ph> больше, чем <ph id="ph2">`value2`</ph>; в противном случае помещает в стек 0 (для значений без знака).</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt.un`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`cgt.un`</ph> проверяет <ph id="ph4">`value1`</ph> больше, чем <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> больше, чем <ph id="ph2">`value2`</ph>, 1 помещается в стек; в противном случае 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is <ph id="ph2">`true`</ph> :</source>
          <target state="translated"><ph id="ph1">`int32`</ph> В стеке помещается значение 1, если выполняется одно из следующих <ph id="ph2">`true`</ph> :</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">Для чисел с плавающей запятой <ph id="ph1">`value1`</ph> не упорядочен по отношению к <ph id="ph2">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">Для целых значений <ph id="ph1">`value1`</ph> строго больше <ph id="ph2">`value2`</ph> при сравнении чисел без знака.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Otherwise an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">В противном случае <ph id="ph1">`int32`</ph> значение 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`cgt.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Throws <ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph> if value is not a finite number.</source>
          <target state="translated">Создает исключение <ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph>, если значение не является конечным числом.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>C3</source>
          <target state="translated">C3</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ckfinite</source>
          <target state="translated">Ckfinite</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if value is not a finite number.</source>
          <target state="translated">исключение <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> , если значение не является конечным числом.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack..</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек...</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the <ph id="ph2">`ckfinite`</ph> instruction is performed on it.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека и <ph id="ph2">`ckfinite`</ph> инструкций, выполняемых в ней.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается обратно в стек, если исключение не возникает.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The <ph id="ph1">`ckfinite instruction`</ph> throws <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> if <ph id="ph3">`value`</ph> (a floating-point number) is either a "not a number" value (NaN) or a <ph id="ph4">`+-`</ph> infinity value.</source>
          <target state="translated"><ph id="ph1">`ckfinite instruction`</ph> Вызывает <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> Если <ph id="ph3">`value`</ph> (число с плавающей запятой) имеет значение «не число» значением (NaN) или <ph id="ph4">`+-`</ph> значение бесконечности.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`Ckfinite`</ph> leaves the value on the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`Ckfinite`</ph> оставляет значение в стеке, если исключение не возникает.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Execution is unspecified if <ph id="ph1">`value`</ph> is not a floating-point number.</source>
          <target state="translated">Выполнение не определено, если <ph id="ph1">`value`</ph> не является числом с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> is thrown if <ph id="ph2">`value`</ph> is not a 'normal' number.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> возникает, если <ph id="ph2">`value`</ph> не имеет значение «normal».</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Note that a special exception or a derived class of <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> may be more appropriate, passing the incorrect value to the exception handler.</source>
          <target state="translated">Обратите внимание, что специальное исключение или производный класс <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> может оказаться более удобным, передачи неверного значения обработчику исключений.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ckfinite`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ckfinite`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Compares two values.</source>
          <target state="translated">Сравнивает два значения.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If the first value is less than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Если первое значение меньше второго, целочисленное значение 1 (<ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>FE 04</source>
          <target state="translated">FE 04</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>clt</source>
          <target state="translated">Средство регистрации звонков</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">Помещает в стек 1, если <ph id="ph1">`value1`</ph> — меньше, чем <ph id="ph2">`value2`</ph>; в противном случае помещает в стек 0.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The stack transitional behavior, in sequential order, is: <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является: <ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`clt`</ph> проверяет <ph id="ph4">`value1`</ph> — меньше, чем <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> — меньше, чем <ph id="ph2">`value2`</ph>, 1 помещается в стек; в противном случае 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The <ph id="ph1">`clt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`clt`</ph> Сравнивает инструкция <ph id="ph2">`value1`</ph> и <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> является строго меньше <ph id="ph2">`value2`</ph>, то <ph id="ph3">`int32`</ph> помещается значение 1 в стек.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">В противном случае <ph id="ph1">`int32`</ph> значение 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>For floating-point numbers, <ph id="ph1">`clt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">Для чисел с плавающей запятой <ph id="ph1">`clt`</ph> возвращает 0, если числа неупорядочены (то есть, если один или оба аргумента имеют значение NaN).</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`clt`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Compares the unsigned or unordered values <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> and <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>.</source>
          <target state="translated">Сравнивает два значения без знака или два неупорядоченных значения <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> и <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>, then the integer value 1 <ph id="ph3">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">Если значение <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> меньше значения <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>, целочисленное значение 1 (<ph id="ph3">&lt;see langword="(int32" /&gt;</ph>) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>FE 05</source>
          <target state="translated">FE 05</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>clt.un</source>
          <target state="translated">CLT.un</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">Помещает в стек 1, если <ph id="ph1">`value1`</ph> — меньше, чем <ph id="ph2">`value2`</ph>; в противном случае помещает в стек 0 (для значений без знака).</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt.un`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`clt.un`</ph> проверяет <ph id="ph4">`value1`</ph> — меньше, чем <ph id="ph5">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">Если <ph id="ph1">`value1`</ph> — меньше, чем <ph id="ph2">`value2`</ph>, 1 помещается в стек; в противном случае 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The <ph id="ph1">`clt.un`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`clt.un`</ph> Сравнивает инструкция <ph id="ph2">`value1`</ph> и <ph id="ph3">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is true:</source>
          <target state="translated"><ph id="ph1">`int32`</ph> В стеке помещается значение 1, если выполняется хотя бы одно из следующих действий:</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> (as for <ph id="ph3">`clt`</ph>).</source>
          <target state="translated"><ph id="ph1">`value1`</ph> является строго меньше <ph id="ph2">`value2`</ph> (как для <ph id="ph3">`clt`</ph>).</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">Для чисел с плавающей запятой <ph id="ph1">`value1`</ph> не упорядочен по отношению к <ph id="ph2">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">Для целых значений <ph id="ph1">`value1`</ph> является строго меньше <ph id="ph2">`value2`</ph> при сравнении чисел без знака.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">В противном случае <ph id="ph1">`int32`</ph> значение 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`clt.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Constrains the type on which a virtual method call is made.</source>
          <target state="translated">Ограничивает тип, для которого был вызван виртуальный метод.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>constrained.</source>
          <target state="translated">ограничение.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Call a virtual method on a type constrained to be type <ph id="ph1">`T`</ph>.</source>
          <target state="translated">Вызов виртуального метода в типе ограничена до типа <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is permitted only on a <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph> Префикса разрешается только в <ph id="ph2">`callvirt`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The state of the MSIL stack at this point must be as follows:</source>
          <target state="translated">Состояние стека MSIL на этом этапе может выглядеть следующим образом:</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A managed pointer, <ph id="ph1">`ptr`</ph>, is pushed onto the stack.</source>
          <target state="translated">Управляемый указатель, <ph id="ph1">`ptr`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The type of <ph id="ph1">`ptr`</ph> must be a managed pointer (<ph id="ph2">`&amp;`</ph>) to <ph id="ph3">`thisType`</ph>.</source>
          <target state="translated">Тип <ph id="ph1">`ptr`</ph> должен быть управляемым указателем (<ph id="ph2">`&amp;`</ph>) для <ph id="ph3">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Note that this is different from the case of an unprefixed <ph id="ph1">`callvirt`</ph> instruction, which expects a reference of <ph id="ph2">`thisType`</ph>.</source>
          <target state="translated">Обратите внимание, что это отличается от применения без префикса <ph id="ph1">`callvirt`</ph> инструкции, которая ожидает ссылку из <ph id="ph2">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack, just as with an unprefixed <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">Аргументы метода <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argN`</ph> помещаются в стек, как и в случае без префикса <ph id="ph3">`callvirt`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is designed to allow <ph id="ph2">`callvirt`</ph> instructions to be made in a uniform way independent of whether <ph id="ph3">`thisType`</ph> is a value type or a reference type.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph> Префикс позволяет <ph id="ph2">`callvirt`</ph> инструкциям, чтобы быть независимы в единую, каким образом следует ли <ph id="ph3">`thisType`</ph> является типом значения или ссылочным типом.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>When a <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> instruction has been prefixed by <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, the instruction is executed as follows:</source>
          <target state="translated">Когда <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> предваряться инструкция <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, инструкция выполняется следующим образом:</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a reference type (as opposed to a value type) then <ph id="ph2">`ptr`</ph> is dereferenced and passed as the 'this' pointer to the <ph id="ph3">`callvirt`</ph> of <ph id="ph4">`method`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`thisType`</ph> является ссылочным типом (в отличие от типа значения), затем <ph id="ph2">`ptr`</ph> разыменован и передается как указатель «this» для <ph id="ph3">`callvirt`</ph> из <ph id="ph4">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> implements <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is passed unmodified as the 'this' pointer to a <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> instruction, for the implementation of <ph id="ph7">`method`</ph> by <ph id="ph8">`thisType`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`thisType`</ph> является типом значения и <ph id="ph2">`thisType`</ph> реализует <ph id="ph3">`method`</ph> затем <ph id="ph4">`ptr`</ph> передается без изменений как указатель «this» для <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> инструкции для реализации <ph id="ph7">`method`</ph> по <ph id="ph8">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> does not implement <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is dereferenced, boxed, and passed as the 'this' pointer to the <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> instruction.</source>
          <target state="translated">Если <ph id="ph1">`thisType`</ph> является типом значения и <ph id="ph2">`thisType`</ph> не реализует <ph id="ph3">`method`</ph> затем <ph id="ph4">`ptr`</ph> разыменован, упаковывается и передается как указатель «this» для <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>This last case can occur only when <ph id="ph1">`method`</ph> was defined on <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Enum&gt;</ph> and not overridden by <ph id="ph5">`thisType`</ph>.</source>
          <target state="translated">Этот последний случай может произойти, только если <ph id="ph1">`method`</ph> была определена в <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, или <ph id="ph4">&lt;xref:System.Enum&gt;</ph> и не переопределяется <ph id="ph5">`thisType`</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>In this case, the boxing causes a copy of the original object to be made.</source>
          <target state="translated">В этом случае упаковка приводит копию исходного объекта должна быть выполнена.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, because none of the methods of <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Enum&gt;</ph> modify the state of the object, this fact cannot be detected.</source>
          <target state="translated">Тем не менее поскольку ни один из методов <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, и <ph id="ph3">&lt;xref:System.Enum&gt;</ph> изменения состояния объекта, не удается обнаружить этот факт.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix supports IL generators that create generic code.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph> Префикс поддерживает генераторы промежуточного языка, которые создают универсальный код.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Normally the <ph id="ph1">`callvirt`</ph> instruction is not valid on value types.</source>
          <target state="translated">Обычно <ph id="ph1">`callvirt`</ph> инструкция не является допустимой для типов значений.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <ph id="ph1">`ptr`</ph> and the method being called.</source>
          <target state="translated">Вместо этого она необходима, компиляторы IL эффективно выполняют 'this' преобразования, описанные выше, во время компиляции, в зависимости от типа <ph id="ph1">`ptr`</ph> и вызываемого метода.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, when <ph id="ph1">`ptr`</ph> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</source>
          <target state="translated">Тем не менее, если <ph id="ph1">`ptr`</ph> является универсальным типом, неизвестным во время компиляции невозможно сделать это преобразование во время компиляции.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <ph id="ph2">`ptr`</ph> is a value type or a reference type.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph> Opcode позволяет компиляторам промежуточного языка вызов виртуальной функции в единую, каким образом независимо от ли <ph id="ph2">`ptr`</ph> является типом значения или ссылочным типом.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Although it is intended for the case where <ph id="ph1">`thisType`</ph> is a generic type variable, the <ph id="ph2">`constrained`</ph> prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</source>
          <target state="translated">Несмотря на то, что он предназначен для случая где <ph id="ph1">`thisType`</ph> является переменной универсального типа <ph id="ph2">`constrained`</ph> префикс также работает для неуниверсальных типов и может уменьшить сложность создания виртуальных вызовов на языках, в которых скрывается различие между типами значений и ссылочные типы.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix also avoids potential versioning problems with value types.</source>
          <target state="translated">С помощью <ph id="ph1">`constrained`</ph> префикс также избегает потенциальных проблем управления версиями с типами значений.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</source>
          <target state="translated">Если <ph id="ph1">`constrained`</ph> префикс не используется, в зависимости от того, является ли тип значения переопределяет метод System.Object извлекаются разные IL.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>For example, if a value type <ph id="ph1">`V`</ph> overrides the Object.ToString() method, a <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> instruction is emitted; if it does not, a <ph id="ph4">`box`</ph> instruction and a <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> instruction are emitted.</source>
          <target state="translated">Например, если тип значения <ph id="ph1">`V`</ph> переопределяет метод Object.ToString() <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> создается инструкция; Если нет, <ph id="ph4">`box`</ph> инструкции и <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> выдаются инструкции.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</source>
          <target state="translated">Проблема может возникнуть в первом примере, если переопределение позже будет удалено, а в последнем случае, если переопределение будет добавлено.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph> Префикс может также быть использован для вызова методов интерфейса для типов значений, так как метод типов значений, реализующий метод интерфейса можно изменить с помощью <ph id="ph2">`MethodImpl`</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</source>
          <target state="translated">Если <ph id="ph1">`constrained`</ph> префикс не используется, компилятор вынужден выбирать, какие значения методы типа, чтобы подключить во время компиляции.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</source>
          <target state="translated">С помощью <ph id="ph1">`constrained`</ph> префикс позволяет MSIL для привязки к методу, который реализует метод интерфейса во время выполнения, а не во время компиляции.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`constrained`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`constrained`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в тип <ph id="ph1">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>D3</source>
          <target state="translated">D3</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>conv.i</source>
          <target state="translated">conv.i</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Convert to <ph id="ph1">`native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`native int`</ph>и помещает <ph id="ph2">`native int`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The <ph id="ph1">`conv.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.i`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int8" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в <ph id="ph1">&lt;see langword="int8" /&gt;</ph>, а затем расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>67</source>
          <target state="translated">67</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>conv.i1</source>
          <target state="translated">conv.i1</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int8`</ph>и помещает <ph id="ph2">`int32`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The <ph id="ph1">`conv.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i1`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.i1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int16" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в <ph id="ph1">&lt;see langword="int16" /&gt;</ph>, а затем расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>68</source>
          <target state="translated">68</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>conv.i2</source>
          <target state="translated">conv.I2</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int16`</ph>и помещает <ph id="ph2">`int32`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The <ph id="ph1">`conv.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i2`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.i2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в тип <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>69</source>
          <target state="translated">69</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>conv.i4</source>
          <target state="translated">conv.i4</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Convert to <ph id="ph1">`int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int32`</ph>и помещает <ph id="ph2">`int32`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The <ph id="ph1">`conv.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i4`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.i4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в тип <ph id="ph1">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>6A</source>
          <target state="translated">6A</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>conv.i8</source>
          <target state="translated">conv.I8</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int64`</ph>и помещает <ph id="ph2">`int64`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The <ph id="ph1">`conv.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i8`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.i8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="native int" /&gt;</ph> со знаком и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>D4</source>
          <target state="translated">D4</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>conv.ovf.i</source>
          <target state="translated">conv.ovf.i</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Convert to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`native int`</ph> (в стеке как <ph id="ph2">`native int`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The <ph id="ph1">`conv.ovf.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="native int" /&gt;</ph> со знаком и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>8A</source>
          <target state="translated">8A</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>conv.ovf.i.un</source>
          <target state="translated">conv.ovf.i.un</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts an unsigned value to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`native int`</ph> (в стеке как <ph id="ph2">`native int`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The <ph id="ph1">`conv.ovf.i.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int8" /&gt;</ph> со знаком, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>B3</source>
          <target state="translated">B3</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>conv.ovf.i1</source>
          <target state="translated">conv.ovf.i1</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Convert to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int8`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The <ph id="ph1">`conv.ovf.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i1`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int8" /&gt;</ph> со знаком, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>82</source>
          <target state="translated">82</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>conv.ovf.i1.un</source>
          <target state="translated">conv.ovf.i1.un</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`int8`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The <ph id="ph1">`conv.ovf.i1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i1.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i1.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extending it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int16" /&gt;</ph> со знаком, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>B5</source>
          <target state="translated">B5</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>conv.ovf.i2</source>
          <target state="translated">conv.ovf.I2</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Convert to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int16`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The <ph id="ph1">`conv.ovf.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i2`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int16" /&gt;</ph> со знаком, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>83</source>
          <target state="translated">83</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>conv.ovf.i2.un</source>
          <target state="translated">conv.ovf.I2.un</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`int16`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The <ph id="ph1">`conv.ovf.i2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i2.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i2.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int32" /&gt;</ph> со знаком и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>B7</source>
          <target state="translated">B7</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>conv.ovf.i4</source>
          <target state="translated">conv.ovf.i4</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Convert to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int32`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The <ph id="ph1">`conv.ovf.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i4`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int32" /&gt;</ph> со знаком и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>84</source>
          <target state="translated">84</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>conv.ovf.i4.un</source>
          <target state="translated">conv.ovf.i4.un</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`int32`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The <ph id="ph1">`conv.ovf.i4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i4.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i4.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int64" /&gt;</ph> со знаком и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>B9</source>
          <target state="translated">B9</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>conv.ovf.i8</source>
          <target state="translated">conv.ovf.I8</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Convert to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int64`</ph> (в стеке как <ph id="ph2">`int64`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The <ph id="ph1">`conv.ovf.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i8`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="int64" /&gt;</ph> со знаком и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>85</source>
          <target state="translated">85</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>conv.ovf.i8.un</source>
          <target state="translated">conv.ovf.I8.un</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`int64`</ph> (в стеке как <ph id="ph2">`int64`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The <ph id="ph1">`conv.ovf.i8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i8.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.i8.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph> и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>D5</source>
          <target state="translated">D5</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>conv.ovf.u</source>
          <target state="translated">conv.ovf.u</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Convert to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`unsigned native int`</ph> (в стеке как <ph id="ph2">`native int`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The <ph id="ph1">`conv.ovf.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph> и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>8B</source>
          <target state="translated">8B</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>conv.ovf.u.un</source>
          <target state="translated">conv.ovf.u.un</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts un unsigned value to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение в без знака <ph id="ph1">`unsigned native int`</ph> (в стеке как <ph id="ph2">`native int`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The <ph id="ph1">`conv.ovf.u.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.uvf.u.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.uvf.u.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph>, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>B4</source>
          <target state="translated">B4</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>conv.ovf.u1</source>
          <target state="translated">conv.ovf.U1</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Convert to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`unsigned int8`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The <ph id="ph1">`conv.ovf.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u1`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph>, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>86</source>
          <target state="translated">86</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>conv.ovf.u1.un</source>
          <target state="translated">conv.ovf.U1.un</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`unsigned int8`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The <ph id="ph1">`conv.ovf.u1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u1.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u1.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph>, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>B6</source>
          <target state="translated">B6</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>conv.ovf.u2</source>
          <target state="translated">conv.ovf.u2</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Convert to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`unsigned int16`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The <ph id="ph1">`conv.ovf.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u2`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph>, расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph> и создает исключение <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>87</source>
          <target state="translated">87</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>conv.ovf.u2.un</source>
          <target state="translated">conv.ovf.u2.un</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`unsigned int16`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The <ph id="ph1">`conv.ovf.u2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u2.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u2.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>B8</source>
          <target state="translated">B8</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>conv.ovf.u4</source>
          <target state="translated">conv.ovf.U4</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Convert to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`unsigned int32`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The <ph id="ph1">`conv.ovf.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u4`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>88</source>
          <target state="translated">88</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>conv.ovf.u4.un</source>
          <target state="translated">conv.ovf.u4.un</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`unsigned int32`</ph> (в стеке как <ph id="ph2">`int32`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The <ph id="ph1">`conv.ovf.u4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u4.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u4.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение со знаком на вершине стека вычислений в <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph> и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>BA</source>
          <target state="translated">BA</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>conv.ovf.u8</source>
          <target state="translated">conv.ovf.u8</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Convert to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразовать <ph id="ph1">`unsigned int64`</ph> (в стеке как <ph id="ph2">`int64`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The <ph id="ph1">`conv.ovf.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u8`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">Преобразует значение без знака на вершине стека вычислений в значение <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph> и создает исключение <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>89</source>
          <target state="translated">89</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>conv.ovf.u8.un</source>
          <target state="translated">conv.ovf.u8.un</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">Преобразует значение без знака <ph id="ph1">`unsigned int64`</ph> (в стеке как <ph id="ph2">`int64`</ph>) и создает исключение в случае переполнения.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">Если происходит переполнение, создается исключение.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The <ph id="ph1">`conv.ovf.u8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u8.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">Если значение слишком велико или слишком мало для представления в целевой тип, выдается исключение.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усечь число к нулю.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.ovf.i`</ph> или <ph id="ph3">`conv.ovf.u`</ph> используются, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.ovf.u8.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Converts the unsigned integer value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">Преобразование целочисленного значения без знака на вершине стека вычислений в <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>76</source>
          <target state="translated">76</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>conv.r.un</source>
          <target state="translated">conv.r.un</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Convert unsigned integer to floating-point, pushing <ph id="ph1">`F`</ph> on stack.</source>
          <target state="translated">Преобразовать целое число без знака для чисел с плавающей запятой, помещает <ph id="ph1">`F`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.r.un`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting a floating-point type to an integer the <ph id="ph1">`result`</ph> returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целочисленный <ph id="ph1">`result`</ph> возвращается не указан.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a <ph id="ph2">`float32`</ph>, if this is wide enough to represent the integer without loss of precision, or else a <ph id="ph3">`float64`</ph>.</source>
          <target state="translated"><ph id="ph1">`conv.r.un`</ph> Операция принимает целое число из стека, интерпретирует его как число без знака и заменяет числом с плавающей запятой, чтобы представить целое число: либо <ph id="ph2">`float32`</ph>, если это достаточно широкой, чтобы представить целое число без потери точности или else <ph id="ph3">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.r.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в тип <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>6B</source>
          <target state="translated">6B</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>conv.r4</source>
          <target state="translated">conv.R4</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Convert to <ph id="ph1">`float32`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`float32`</ph>и помещает <ph id="ph2">`F`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The <ph id="ph1">`conv.r4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.r4`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.r4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float64" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в тип <ph id="ph1">&lt;see langword="float64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>6C</source>
          <target state="translated">6C</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>conv.r8</source>
          <target state="translated">conv.R8</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Convert to <ph id="ph1">`float64`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`float64`</ph>и помещает <ph id="ph2">`F`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The <ph id="ph1">`conv.r8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.r8`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.r8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, а затем расширяет его до <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>E0</source>
          <target state="translated">E0</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>conv.u</source>
          <target state="translated">conv.u</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Convert to <ph id="ph1">`unsigned native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`unsigned native int`</ph>и помещает <ph id="ph2">`native int`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The <ph id="ph1">`conv.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.u`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph>, а затем расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>D2</source>
          <target state="translated">D2</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>conv.u1</source>
          <target state="translated">conv.U1</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int8`</ph>и помещает <ph id="ph2">`int32`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The <ph id="ph1">`conv.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u1`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.u1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph>, а затем расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>D1</source>
          <target state="translated">D1</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>conv.u2</source>
          <target state="translated">conv.u2</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int16`</ph>и помещает <ph id="ph2">`int32`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The <ph id="ph1">`conv.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u2`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.u2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, а затем расширяет его до <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>6D</source>
          <target state="translated">6D</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>conv.u4</source>
          <target state="translated">conv.U4</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Convert to <ph id="ph1">`unsigned int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`unsigned int32`</ph>и помещает <ph id="ph2">`int32`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The <ph id="ph1">`conv.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u4`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.u4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Преобразует верхнее значение в стеке вычислений в <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, а затем расширяет его до <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>6E</source>
          <target state="translated">6E</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>conv.u8</source>
          <target state="translated">conv.u8</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">Преобразовать <ph id="ph1">`int64`</ph>и помещает <ph id="ph2">`int64`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, а преобразование выполняется операция.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">Если преобразование прошло успешно, результирующее значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The <ph id="ph1">`conv.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u8`</ph> Преобразует код операции <ph id="ph2">`value`</ph> на вершине стека в тип, заданный в коде операции и оставляет преобразованное значение на вершине стека.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">Целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> когда они были загружены в стек вычислений (если не <ph id="ph2">`conv.i`</ph> или <ph id="ph3">`conv.u`</ph> используется, в этом случае результат также имеет <ph id="ph4">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">Преобразование чисел с плавающей запятой в целые усекает число к нулю.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">При преобразовании из <ph id="ph1">`float64`</ph> для <ph id="ph2">`float32`</ph>, точность может быть потеряно.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> слишком велик для размещения в <ph id="ph2">`float32 (F)`</ph>, плюс бесконечность (если <ph id="ph3">`value`</ph> является положительным) или минус бесконечность (если <ph id="ph4">`value`</ph> является отрицательным) возвращается.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">Если при преобразовании одного целочисленного типа в другой возникает переполнение, усекаются битов высокого порядка.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">Если результат меньше <ph id="ph1">`int32`</ph>, значение выполняется с расширением знака для заполнения области.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">Если переполнение происходит преобразование типа с плавающей запятой в целое число, возвращаемое значение не определено.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">Нет когда-либо исключения при использовании данного поля.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> эквивалентные инструкции, которые будет вызывать исключение, если тип результата не может быть правильно результирующее значение.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`conv.u8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copies a specified number bytes from a source address to a destination address.</source>
          <target state="translated">Копирует заданное число байт из исходного адреса в конечный.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>FE 17</source>
          <target state="translated">FE 17</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>cpblk</source>
          <target state="translated">cpblk</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copy data from one memory block to another.</source>
          <target state="translated">Копирует данные из одного блока памяти в другое.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The destination address is pushed onto the stack.</source>
          <target state="translated">Конечный адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The source address is pushed onto the stack.</source>
          <target state="translated">Исходный адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes to copy is pushed onto the stack.</source>
          <target state="translated">Число байтов для копирования помещается в стек.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</source>
          <target state="translated">Число байтов, адрес источника и целевой адрес извлекаются из стека; указанное число байтов копируются из исходного адреса на указанный адрес назначения.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction copies a number (type <ph id="ph2">`unsigned int32`</ph>) of bytes from a source address (of type <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, or <ph id="ph5">`&amp;`</ph>) to a destination address (of type <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, or <ph id="ph8">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph> Инструкция копирует число (типа <ph id="ph2">`unsigned int32`</ph>) байтов из исходного адреса (типа <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, или <ph id="ph5">`&amp;`</ph>) по адресу назначения (типа <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, или <ph id="ph8">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The behavior of <ph id="ph1">`cpblk`</ph> is unspecified if the source and destination areas overlap.</source>
          <target state="translated">Поведение <ph id="ph1">`cpblk`</ph> не указан при перекрытии исходного и конечного областей.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">`cpblk`</ph> assumes that both the source and destination addressed are aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph> предполагается, что исходный и конечный адреса выровнены по размеру машины.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction can be immediately preceded by the <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> instruction to indicate that either the source or the destination is unaligned.</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph> Инструкция может непосредственно предшествовать <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> инструкции, чтобы указать, что исходный или конечный адрес не выровнен.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The operation of the <ph id="ph1">`cpblk`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`cpblk`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может быть создано исключение при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpblk`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`cpblk`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies the value type located at the address of an object (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph2">&lt;see langword="*" /&gt;</ph> or <ph id="ph3">&lt;see langword="native int" /&gt;</ph>) to the address of the destination object (type <ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph5">&lt;see langword="*" /&gt;</ph> or <ph id="ph6">&lt;see langword="native int" /&gt;</ph>).</source>
          <target state="translated">Копирует тип значения по адресу объекта (с типом <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph2">&lt;see langword="*" /&gt;</ph> или <ph id="ph3">&lt;see langword="native int" /&gt;</ph>) и помещает его по адресу конечного объекта (с типом <ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph5">&lt;see langword="*" /&gt;</ph> или <ph id="ph6">&lt;see langword="native int" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>cpobj <ph id="ph1">`classTok`</ph></source>
          <target state="translated">cpobj <ph id="ph1">`classTok`</ph></target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies a value type from a source object to a destination object.</source>
          <target state="translated">Копирует тип значения из исходного объекта в целевой объект.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The destination object reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на конечный объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The source object reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на исходный объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</source>
          <target state="translated">Обе ссылки на объекты извлекаются из стека; Тип значения по адресу объекта источника копируется на адрес целевого объекта.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The behavior of <ph id="ph1">`cpobj`</ph> is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <ph id="ph2">`classTok`</ph> (a <ph id="ph3">`typeref`</ph> or <ph id="ph4">`typedef`</ph>), or if <ph id="ph5">`classTok`</ph> does not represent a value type.</source>
          <target state="translated">Поведение <ph id="ph1">`cpobj`</ph> не определено, если исходный и целевой объект ссылки не являются указателями на экземпляры класса, представленного маркером класс <ph id="ph2">`classTok`</ph> ( <ph id="ph3">`typeref`</ph> или <ph id="ph4">`typedef`</ph>), или если <ph id="ph5">`classTok`</ph> не представляет Тип значения.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может быть создано исключение при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpobj`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`cpobj`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values and pushes the result as a floating-point (type <ph id="ph1">&lt;see langword="F" /&gt;</ph>) or quotient (type <ph id="ph2">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Делит одно значение на другое и помещает результат в стек вычислений как число с плавающей запятой (с типом <ph id="ph1">&lt;see langword="F" /&gt;</ph>) или как частное (с типом <ph id="ph2">&lt;see langword="int32" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>5B</source>
          <target state="translated">5B</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>div</source>
          <target state="translated">div</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values to return a quotient or floating-point result.</source>
          <target state="translated">Делит одно значение возвращает частное или результат с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> делится на <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 удовлетворяет следующим условиям:</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>&amp;#124; <ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, and:</source>
          <target state="translated">&amp;#124;<ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, и:</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>sign(<ph id="ph1">`result`</ph>) = +, if sign(<ph id="ph2">`value1`</ph>) = sign(<ph id="ph3">`value2`</ph>), or -, if sign(<ph id="ph4">`value1`</ph>) ~= sign(<ph id="ph5">`value2`</ph>)</source>
          <target state="translated">знак (<ph id="ph1">`result`</ph>) = +, если знак (<ph id="ph2">`value1`</ph>) = знак (<ph id="ph3">`value2`</ph>), или-, если знак (<ph id="ph4">`value1`</ph>) ~ = знак (<ph id="ph5">`value2`</ph>)</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The <ph id="ph1">`div`</ph> instruction computes the result and pushes it on the stack.</source>
          <target state="translated"><ph id="ph1">`div`</ph> Инструкция вычисляет результат и помещает его в стеке.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integer division truncates towards zero.</source>
          <target state="translated">Целочисленное деление усекает к нулю.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Division of a finite number by zero produces the correctly signed infinite value.</source>
          <target state="translated">Деление конечного числа на ноль создает правильно подписанного бесконечное значение.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</source>
          <target state="translated">Деление ноля на ноль или бесконечности на бесконечность возвращает значение NaN (не числовое).</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Any number divided by infinity will produce a zero value.</source>
          <target state="translated">Деление любого числа на бесконечность сформирует нулевое значение.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if the result cannot be represented in the result type.</source>
          <target state="translated">Целочисленные операции создают исключение <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> Если результат невозможно представить в типе результата.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>This can happen if <ph id="ph1">`value1`</ph> is the maximum negative value, and <ph id="ph2">`value2`</ph> is -1.</source>
          <target state="translated">Это может произойти, если <ph id="ph1">`value1`</ph> — это максимальное значение отрицательное, и <ph id="ph2">`value2`</ph> — -1.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Целочисленные операции создают исключение <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> Если <ph id="ph2">`value2`</ph> равно нулю.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Note that on Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint div -1).</source>
          <target state="translated">Обратите внимание, что для платформ на основе Intel <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает при вычислении (minint div -1).</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Floating-point operations never throw an exception (they produce NaNs or infinities instead).</source>
          <target state="translated">Операции с плавающей запятой не генерируют исключений (они возвращают значения NaN или бесконечность).</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`div`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two unsigned integer values and pushes the result (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Делит одно целочисленное значение без знака на другое и помещает результат (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) в стек вычислений.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>5C</source>
          <target state="translated">5C</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>div.un</source>
          <target state="translated">div.un</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two values, unsigned, returning a quotient.</source>
          <target state="translated">Делит одно значение без знака, возврат частного.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> делится на <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The <ph id="ph1">`div.un`</ph> instruction computes <ph id="ph2">`value1`</ph> divided by <ph id="ph3">`value2`</ph>, both taken as unsigned integers, and pushes the <ph id="ph4">`result`</ph> on the stack.</source>
          <target state="translated"><ph id="ph1">`div.un`</ph> Инструкция вычисляет <ph id="ph2">`value1`</ph> деленная <ph id="ph3">`value2`</ph>, без целых чисел без знака и помещает <ph id="ph4">`result`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`div.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</source>
          <target state="translated">Копирует текущее верхнее значение в стеке вычислений и помещает копию в стек вычислений.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>25</source>
          <target state="translated">25</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>dup</source>
          <target state="translated">Dup</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Duplicates the value on the top of the stack.</source>
          <target state="translated">Дублирует значению на вершине стека.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is popped off of the stack for duplication.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека для дублирования.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается обратно в стек.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>A duplicate value is pushed onto the stack.</source>
          <target state="translated">Повторяющееся значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The <ph id="ph1">`dup`</ph> instruction duplicates the top element of the stack, and leaves two identical values atop it.</source>
          <target state="translated"><ph id="ph1">`dup`</ph> Инструкция дублирует верхний элемент стека и оставляет два одинаковых значения на вершине стека.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`dup`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`dup`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="filter" /&gt;</ph> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">Передает управление из предложения <ph id="ph1">&lt;see langword="filter" /&gt;</ph> исключения обратно в обработчик исключений CLI.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>FE 11</source>
          <target state="translated">FE 11</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>endfilter</source>
          <target state="translated">Команда endfilter</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>End filter clause of SEH exception handling.</source>
          <target state="translated">Конец предложения filter обработки исключений SEH.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is popped from the stack; <ph id="ph2">`endfilter`</ph> is executed and control is transferred to the exception handler.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекаются из стека; <ph id="ph2">`endfilter`</ph> выполняется и управление передается обработчику исключений.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`Value`</ph> (which must be of type <ph id="ph2">`int32`</ph> and is one of a specific set of values) is returned from the filter clause.</source>
          <target state="translated"><ph id="ph1">`Value`</ph> (который должен быть типа <ph id="ph2">`int32`</ph> и является одним из определенного набора значений) возвращается из предложения filter.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>It should be one of:</source>
          <target state="translated">Он должен быть одним из:</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) to continue searching for an exception handler</source>
          <target state="translated"><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) для продолжения поиска для обработчика исключений</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</source>
          <target state="translated"><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) — начать второй этап обработки исключений, в котором блоки finally выполняются до обработчик, связанный с данным предложением filter находится.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Upon discovery, the handler is executed.</source>
          <target state="translated">После обнаружения обработчик выполняется.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Other integer values will produce unspecified results.</source>
          <target state="translated">Другие целочисленные значения сформирует результаты не определены.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</source>
          <target state="translated">Точка входа фильтра, как показано в таблице исключений метода, должны быть первой инструкции в блоке кода filter.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The <ph id="ph1">`endfilter`</ph> instruction must be the last instruction in the filter's code block (hence there can only be one <ph id="ph2">`endfilter`</ph> for any single filter block).</source>
          <target state="translated"><ph id="ph1">`endfilter`</ph> Инструкция должна быть последней инструкции в блоке кода filter (таким образом может быть только один <ph id="ph2">`endfilter`</ph> для одного блока filter).</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>After executing the <ph id="ph1">`endfilter`</ph> instruction, control logically flows back to the CLI exception handling mechanism.</source>
          <target state="translated">После выполнения <ph id="ph1">`endfilter`</ph> инструкции, управление логически передается обратно механизму обработки исключений CLI.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred into a filter block except through the exception mechanism.</source>
          <target state="translated">Элемент управления может быть передано в блок filter только через механизм обработки исключений.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred out of a filter block except through the use of a <ph id="ph1">`throw`</ph> instruction or by executing the final <ph id="ph2">`endfilter`</ph> instruction.</source>
          <target state="translated">Управление может быть передано из блока фильтра, за исключением случаев использования <ph id="ph1">`throw`</ph> инструкций или путем выполнения последней <ph id="ph2">`endfilter`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>You cannot embed a <ph id="ph1">`try`</ph> block within a <ph id="ph2">`filter`</ph> block.</source>
          <target state="translated">Не удается внедрить <ph id="ph1">`try`</ph> блок <ph id="ph2">`filter`</ph> блока.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>If an exception is thrown inside the <ph id="ph1">`filter`</ph> block, it is intercepted and a value of 0 (<ph id="ph2">`exception_continue_search`</ph>) is returned.</source>
          <target state="translated">Если исключение внутри <ph id="ph1">`filter`</ph> блока, оно перехватывается и значение 0 (<ph id="ph2">`exception_continue_search`</ph>) возвращается.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfilter`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`endfilter`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="fault" /&gt;</ph> or <ph id="ph2">&lt;see langword="finally" /&gt;</ph> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">Передает управление из предложения <ph id="ph1">&lt;see langword="fault" /&gt;</ph> или <ph id="ph2">&lt;see langword="finally" /&gt;</ph> блока исключения обратно обработчику исключений CLI.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>DC</source>
          <target state="translated">DC</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfinally</source>
          <target state="translated">Команда endfinally</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfault</source>
          <target state="translated">endfault</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Ends the <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph> clause of an exception block.</source>
          <target state="translated">Завершает <ph id="ph1">`finally`</ph> или <ph id="ph2">`fault`</ph> предложение блока исключения.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">Нет стек не вариантов поведения для данной инструкции.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source><ph id="ph1">`Endfinally`</ph> and <ph id="ph2">`endfault`</ph> signal the end of the <ph id="ph3">`finally`</ph> or <ph id="ph4">`fault`</ph> clause so that stack unwinding can continue until the exception handler is invoked.</source>
          <target state="translated"><ph id="ph1">`Endfinally`</ph> и <ph id="ph2">`endfault`</ph> обозначения конца <ph id="ph3">`finally`</ph> или <ph id="ph4">`fault`</ph> предложения, поэтому Очистка стека можно продолжить работу, пока не будет вызван обработчик исключений.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The <ph id="ph1">`endfinally`</ph> or <ph id="ph2">`endfault`</ph> instruction transfers control back to the CLI exception mechanism.</source>
          <target state="translated"><ph id="ph1">`endfinally`</ph> Или <ph id="ph2">`endfault`</ph> инструкция передает управление обратно в механизм обработки исключений CLI.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The mechanism then searches for the next <ph id="ph1">`finally`</ph> clause in the chain if the protected block was exited with a leave instruction.</source>
          <target state="translated">Этот механизм выполняет поиск следующего <ph id="ph1">`finally`</ph> предложение в цепочке, если выход из защищенного блока был выполнен с помощью инструкции leave.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>If the protected block was exited with an exception, the CLI will search for the next <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph>, or enter the exception handler chosen during the first pass of exception handling.</source>
          <target state="translated">Если выход из защищенного блока был выполнен с исключением, (CLI) выполняет поиск следующего <ph id="ph1">`finally`</ph> или <ph id="ph2">`fault`</ph>, или введите в обработчик, выбранный на первом этапе обработки исключений.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>An <ph id="ph1">`endfinally`</ph> instruction might only appear lexically within a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated"><ph id="ph1">`endfinally`</ph> Инструкция может располагаться только внутри лексически <ph id="ph2">`finally`</ph> блока.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Unlike the <ph id="ph1">`endfilter`</ph> instruction, there is no requirement that the block end with an <ph id="ph2">`endfinally`</ph> instruction, and there can be as many <ph id="ph3">`endfinally`</ph> instructions within the block as required.</source>
          <target state="translated">В отличие от <ph id="ph1">`endfilter`</ph> инструкции, не требуется завершение блока с <ph id="ph2">`endfinally`</ph> инструкция и может быть столько <ph id="ph3">`endfinally`</ph> инструкции в блоке.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>These same restrictions apply to the <ph id="ph1">`endfault`</ph> instruction and the <ph id="ph2">`fault`</ph> block.</source>
          <target state="translated">Те же ограничения применяются к <ph id="ph1">`endfault`</ph> инструкции и <ph id="ph2">`fault`</ph> блока.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred into a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the exception mechanism.</source>
          <target state="translated">Управление не может быть передано в <ph id="ph1">`finally`</ph> (или <ph id="ph2">`fault`</ph>) блок за исключением через механизм обработки исключений.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred out of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the use of a <ph id="ph3">`throw`</ph> instruction or executing the <ph id="ph4">`endfinally`</ph> (or <ph id="ph5">`endfault`</ph>) instruction.</source>
          <target state="translated">Управление может быть передано из <ph id="ph1">`finally`</ph> (или <ph id="ph2">`fault`</ph>) блок за исключением случаев использования <ph id="ph3">`throw`</ph> инструкции или выполнении <ph id="ph4">`endfinally`</ph> (или <ph id="ph5">`endfault`</ph>) инструкции.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>In particular, you cannot "fall out" of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block or to execute a <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction within a <ph id="ph5">`finally`</ph> (or <ph id="ph6">`fault`</ph>) block.</source>
          <target state="translated">В частности, вы не «попадает» из <ph id="ph1">`finally`</ph> (или <ph id="ph2">`fault`</ph>) блока или выполнять <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> или <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> инструкции в пределах <ph id="ph5">`finally`</ph> (или <ph id="ph6">`fault`</ph>) блока.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Note that the <ph id="ph1">`endfault`</ph> and <ph id="ph2">`endfinally`</ph> instructions are aliases - they correspond to the same opcode.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`endfault`</ph> и <ph id="ph2">`endfinally`</ph> инструкции являются псевдонимами — они соответствуют одному коду операции.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) opcode, as well as the <ph id="ph4">`ILGenerator`</ph> method <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) код операции, а также <ph id="ph4">`ILGenerator`</ph> метод <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.EndExceptionBlock()</source>
          <target state="translated">ILGenerator.EndExceptionBlock()</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Initializes a specified block of memory at a specific address to a given size and initial value.</source>
          <target state="translated">Инициализирует блок памяти с определенным адресом, присваивая его начальному значению с заданным размером.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>FE 18</source>
          <target state="translated">FE 18</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>initblk</source>
          <target state="translated">initblk</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Set each location in a block of memory to a given value.</source>
          <target state="translated">Задайте каждого местоположения в блок памяти, заданное значение.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>A starting address is pushed onto the stack.</source>
          <target state="translated">Начальный адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>An initialization value is pushed onto the stack.</source>
          <target state="translated">Начальное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes to initialize is pushed onto the stack.</source>
          <target state="translated">Число байтов для инициализации помещается в стек.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</source>
          <target state="translated">Число байт, значение инициализации и начальный адрес извлекаются из стека, и инициализация выполняется в соответствии с их значения.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The <ph id="ph1">`initblk`</ph> instruction sets the number (<ph id="ph2">`unsigned int32`</ph>) of bytes starting at the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) to the initialization value (of type <ph id="ph6">`unsigned int8`</ph>).</source>
          <target state="translated"><ph id="ph1">`initblk`</ph> Номер наборы инструкций (<ph id="ph2">`unsigned int32`</ph>) байтов, начиная с указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или <ph id="ph5">`*`</ph>) для инициализации значение (типа <ph id="ph6">`unsigned int8`</ph>).</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">`initblk`</ph> assumes that the starting address is aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`initblk`</ph> предполагается, что начальный адрес выровнен по размеру машины.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The operation of the <ph id="ph1">`initblk`</ph> instructions can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`initblk`</ph> инструкции может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может быть создано исключение при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initblk`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`initblk`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated">Инициализирует каждое поле типа значения с определенным адресом пустой ссылкой или значением 0 соответствующего простого типа.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></source>
          <target state="translated"><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes a value type.</source>
          <target state="translated">Инициализирует тип значения.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address of the value type to initialize is pushed onto the stack.</source>
          <target state="translated">Адрес типа значения для инициализации помещается в стек.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address is popped from the stack; the value type at the specified address is initialized as type <ph id="ph1">`typeTok`</ph>.</source>
          <target state="translated">Адрес извлекается из стека; Тип значения по указанному адресу инициализируется как тип <ph id="ph1">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The <ph id="ph1">`initobj`</ph> instruction initializes each field of the value type specified by the pushed address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or <ph id="ph4">`*`</ph>) to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated"><ph id="ph1">`initobj`</ph> Инструкция инициализирует каждое поле типа значения, заданные в стек адрес (типа <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, или <ph id="ph4">`*`</ph>) пустой ссылкой или значением 0 соответствующего простого типа.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>After this method is called, the instance is ready for a constructor method to be called.</source>
          <target state="translated">После вызова этого метода экземпляр готов к метод для вызова конструктора.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>If <ph id="ph1">`typeTok`</ph> is a reference type, this instruction has the same effect as <ph id="ph2">`ldnull`</ph> followed by <ph id="ph3">`stind.ref`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`typeTok`</ph> является ссылочным типом, эта инструкция действует так же, как <ph id="ph2">`ldnull`</ph> следуют <ph id="ph3">`stind.ref`</ph>.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> does not call the constructor method.</source>
          <target state="translated">В отличие от <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> не вызывает метод конструктора.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`Initobj`</ph> is intended for initializing value types, while <ph id="ph2">`newobj`</ph> is used to allocate and initialize objects.</source>
          <target state="translated"><ph id="ph1">`Initobj`</ph> — предназначен для инициализации типов значений, тогда как <ph id="ph2">`newobj`</ph> используется для размещения и инициализации объектов.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initobj`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`initobj`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests whether an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) is an instance of a particular class.</source>
          <target state="translated">Проверяет, является ли ссылка на объект (с типом <ph id="ph1">&lt;see langword="O" /&gt;</ph>) экземпляром определенного класса.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>isinst <ph id="ph1">`class`</ph></source>
          <target state="translated">инструкции isinst <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests if an object reference is an instance of <ph id="ph1">`class`</ph>, returning either a null reference or an instance of that class or interface.</source>
          <target state="translated">Проверяет, может ли ссылка на объект является экземпляром класса <ph id="ph1">`class`</ph>, возвращая пустую ссылку или экземпляр этого класса или интерфейса.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The object reference is popped from the stack and tested to see if it is an instance of the class passed in <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Ссылка на объект извлекается из стека и проверяется, если он является экземпляром класса, заданного в <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The result (either an object reference or a null reference) is pushed onto the stack.</source>
          <target state="translated">Результат (ссылка на объект или пустая ссылка) помещается в стек.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">`Class`</ph> is a metadata token indicating the desired class.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> токен метаданных, указывающий требуемый класс.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the class of the object on the top of the stack implements <ph id="ph1">`class`</ph> (if <ph id="ph2">`class`</ph> is an interface) or is a derived class of <ph id="ph3">`class`</ph> (if <ph id="ph4">`class`</ph> is a regular class) then it is cast to type <ph id="ph5">`class`</ph> and the result is pushed on the stack, exactly as though <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> had been called.</source>
          <target state="translated">Если класс объекта на вершине стека реализует <ph id="ph1">`class`</ph> (если <ph id="ph2">`class`</ph> — это интерфейс) или является производным классом от <ph id="ph3">`class`</ph> (если <ph id="ph4">`class`</ph> — обычный класс) он приводится к типу <ph id="ph5">`class`</ph> и результат помещается в стек, точно так, будто <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> бы была вызвана.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Otherwise, a null reference is pushed on the stack.</source>
          <target state="translated">В противном случае — пустая ссылка помещается в стек.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the object reference itself is a null reference, then <ph id="ph1">`isinst`</ph> likewise returns a null reference.</source>
          <target state="translated">Если ссылка на объект является пустой ссылкой, затем <ph id="ph1">`isinst`</ph> также возвращает пустую ссылку.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если не удается найти класс.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`isinst`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`isinst`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exits current method and jumps to specified method.</source>
          <target state="translated">Прекращает выполнение текущего метода и переходит к заданному методу.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>jmp <ph id="ph1">`method`</ph></source>
          <target state="translated">безусловный <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exit current method and jump to specified method.</source>
          <target state="translated">Прекращает выполнение текущего метода и переходит к заданному методу.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">Нет стек не вариантов поведения для данной инструкции.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> (jump) instruction transfers control to the method specified by <ph id="ph2">`method`</ph>, which is a metadata token for a method reference.</source>
          <target state="translated"><ph id="ph1">`jmp`</ph> (Jump) инструкция передает управление методу, заданному параметром <ph id="ph2">`method`</ph>, являющееся токен метаданных для ссылки на метод.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The current arguments are transferred to the destination method.</source>
          <target state="translated">Текущие аргументы передаются в метод назначения.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The evaluation stack must be empty when this instruction is executed.</source>
          <target state="translated">Стек вычислений должно быть пустым, если при выполнении данной инструкции.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The calling convention, number and type of arguments at the destination address must match that of the current method.</source>
          <target state="translated">Соглашение о вызовах, число и тип аргументов по адресу назначения должно совпадать со текущего метода.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> instruction cannot be used to transferred control out of a <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated"><ph id="ph1">`jmp`</ph> Инструкция не может использоваться для передачи управления из <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, или <ph id="ph5">`finally`</ph> блока.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`jmp`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`jmp`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (код операции, MethodInfo)</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Loads an argument (referenced by a specified index value) onto the stack.</source>
          <target state="translated">Загружает аргумент (на который ссылается указанное значение индекса) в стек.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ldarg <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">Загружает аргумент с индексом <ph id="ph1">`index`</ph> в стек.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение аргумента с <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg`</ph> Инструкция помещает аргумент с индексом <ph id="ph2">`index`</ph>, где аргументы индексируются, начиная с версии, 0 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg`</ph> Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">В процедурах, принимающих список аргументов переменной длины <ph id="ph1">`ldarg`</ph> инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи (в разделе <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> инструкции для получения дополнительных сведений).</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarg`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, короткое)</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Loads the argument at index 0 onto the evaluation stack.</source>
          <target state="translated">Загружает аргумент с индексом 0 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>02</source>
          <target state="translated">02</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ldarg.0</source>
          <target state="translated">ldarg.0</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Load argument 0 onto stack</source>
          <target state="translated">Загружает аргумент 0 в стек</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The argument value at index 0 is pushed onto the stack.</source>
          <target state="translated">Значение аргумента с индексом 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction is an efficient encoding for loading the argument value at index 0.</source>
          <target state="translated"><ph id="ph1">`ldarg.0`</ph> Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 0.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction pushes the argument indexed at 0 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.0`</ph> Инструкция помещает аргумент с индексом 0 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.0`</ph> Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.0`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarg.0`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Loads the argument at index 1 onto the evaluation stack.</source>
          <target state="translated">Загружает аргумент с индексом 1 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>03</source>
          <target state="translated">03</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ldarg.1</source>
          <target state="translated">ldarg.1</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Load argument 1 onto stack.</source>
          <target state="translated">Загружает аргумент 1 в стек.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The argument value at index 1 is pushed onto the stack.</source>
          <target state="translated">Значение аргумента с индексом 1 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction is an efficient encoding for loading the argument value at index 1.</source>
          <target state="translated"><ph id="ph1">`ldarg.1`</ph> Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 1.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction pushes the argument indexed at 1 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.1`</ph> Инструкция помещает аргумент с индексом 1 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.1`</ph> Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarg.1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Loads the argument at index 2 onto the evaluation stack.</source>
          <target state="translated">Загружает аргумент с индексом 2 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>04</source>
          <target state="translated">04</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ldarg.2</source>
          <target state="translated">ldarg.2</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Load argument 2 onto stack.</source>
          <target state="translated">Загружает аргумент 2 в стек.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The argument value at index 2 is pushed onto the stack.</source>
          <target state="translated">Значение аргумента с индексом 2 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction is an efficient encoding for loading the argument value at index 2.</source>
          <target state="translated"><ph id="ph1">`ldarg.2`</ph> Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 2.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction pushes the argument indexed at 2 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.2`</ph> Инструкция помещает аргумент с индексом 2 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.2`</ph> Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarg.2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Loads the argument at index 3 onto the evaluation stack.</source>
          <target state="translated">Загружает аргумент с индексом 3 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>05</source>
          <target state="translated">05</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ldarg.3</source>
          <target state="translated">ldarg.3</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Load argument 3 onto stack.</source>
          <target state="translated">Загружает аргумент 3 в стек.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The argument value at index 3 is pushed onto the stack.</source>
          <target state="translated">Значение аргумента с индексом 3 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction is an efficient encoding for loading the argument value at index 3.</source>
          <target state="translated"><ph id="ph1">`ldarg.3`</ph> Инструкция является эффективную кодировку для загрузки значения аргумента с индексом 3.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction pushes the argument indexed at 3 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.3`</ph> Инструкция помещает аргумент с индексом 3 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.3`</ph> Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.3`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarg.3`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Loads the argument (referenced by a specified short form index) onto the evaluation stack.</source>
          <target state="translated">Загружает аргумент (на который ссылается указанное короткое значение индекса) в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ldarg.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">Загружает аргумент с индексом <ph id="ph1">`index`</ph> в стек, краткая форма.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение аргумента с <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction is an efficient encoding for loading arguments indexed from 4 through 255.</source>
          <target state="translated"><ph id="ph1">`ldarg.s`</ph> Инструкция обеспечивает эффективную кодировку для загрузки аргументов с индексом с 4 до 255.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.s`</ph> Инструкция помещает аргумент с индексом <ph id="ph2">`index`</ph>, где аргументы индексируются, начиная с версии, 0 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.s`</ph> Инструкция может использоваться для загрузки типа значения или элементарного значения в стек, копируя его из входящего аргумента.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">Тип значения аргумента совпадает с типом аргумента, определяемое параметром подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">В процедурах, принимающих список аргументов переменной длины <ph id="ph1">`ldarg.s`</ph> инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи (в разделе <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> инструкции для получения дополнительных сведений).</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Аргументы, содержащие целочисленные значения меньше 4 байтов расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarg.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, byte)</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Load an argument address onto the evaluation stack.</source>
          <target state="translated">Загружает адрес аргумента в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ldarga <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Извлекает адрес аргумента с индексом <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Адрес <ph id="ph1">`addr`</ph> аргумента, с индексом <ph id="ph2">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The <ph id="ph1">`ldarga`</ph> instruction fetches the address (of type <ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldarga`</ph> Инструкция извлекает адрес (типа <ph id="ph2">`*`</ph>) аргумента, с индексом <ph id="ph3">`index`</ph>, где аргументы индексируются, начиная с версии 0.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">Адрес <ph id="ph1">`addr`</ph> всегда выравнивается по границам на конечном компьютере.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">В процедурах, принимающих список аргументов переменной длины <ph id="ph1">`ldarga`</ph> инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source><ph id="ph1">`ldarga`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga`</ph> используется для передачи параметров по ссылке.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> should be used.</source>
          <target state="translated">В остальных случаях <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> следует использовать.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarga`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, короткое)</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Load an argument address, in short form, onto the evaluation stack.</source>
          <target state="translated">Загружает адрес аргумента (короткая форма) в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ldarga.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">Извлекает адрес аргумента с индексом <ph id="ph1">`index`</ph>, краткая форма.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Адрес <ph id="ph1">`addr`</ph> аргумента, с индексом <ph id="ph2">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> (the short form of <ph id="ph2">`ldarga`</ph>) should be used for argument numbers 0 through 255, and is a more efficient encoding.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> (Краткая форма <ph id="ph2">`ldarga`</ph>) следует использовать для аргумента числа от 0 до 255, и обеспечивает более эффективную кодировку.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The <ph id="ph1">`ldarga.s`</ph> instruction fetches the address (of type<ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> Инструкция извлекает адрес (типа<ph id="ph2">`*`</ph>) аргумента, с индексом <ph id="ph3">`index`</ph>, где аргументы индексируются, начиная с версии 0.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">Адрес <ph id="ph1">`addr`</ph> всегда выравнивается по границам на конечном компьютере.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">В процедурах, принимающих список аргументов переменной длины <ph id="ph1">`ldarga.s`</ph> инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> используется для передачи параметров по ссылке.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> should be used.</source>
          <target state="translated">В остальных случаях <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> следует использовать.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldarga.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, byte)</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает переданное значение с типом <ph id="ph1">&lt;see langword="int32" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ldc.i4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes the value <ph id="ph1">`num`</ph> onto the stack.</source>
          <target state="translated">Помещает значение <ph id="ph1">`num`</ph> в стек.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение <ph id="ph1">`num`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</source>
          <target state="translated">Обратите внимание, что существуют специальные короткие (и, следовательно, более эффективные) кодировки для целых чисел от -128 до 127 и особенно короткие кодировки для -1 до 8.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>All short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают 4-байтовые целые числа в стеке.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</source>
          <target state="translated">Больше кодировки используются для 8-байтовые целые числа и 4 и 8 байт числа с плавающей запятой, а также 4-байтовых значений, которые не помещаются в короткие кодировки.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>There are three ways to push an 8 byte integer constant onto the stack</source>
          <target state="translated">Существует три способа для принудительной отправки целочисленная константа размером 8 байт в стек</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> instruction for constants that must be expressed in more than 32 bits.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> инструкции для константы, которые должны быть выражены в более чем 32 бита.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> instruction followed by a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that require 9 to 32 bits.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> инструкции, за которым следует <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> для константы требуется от 9 до 32 бит.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use a short form instruction followed by a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that can be expressed in 8 or fewer bits.</source>
          <target state="translated">Используйте инструкцию короткой формы, за которым следует <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> для констант, которые могут быть выражены в 8 или менее бит.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ILGenerator.Emit(OpCode, int)</source>
          <target state="translated">ILGenerator.Emit (OpCode, int)</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes the integer value of 0 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 0 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ldc.i4.0</source>
          <target state="translated">ldc.i4.0</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes 0 onto the stack.</source>
          <target state="translated">Помещает в стек 0 в стек.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The value 0 is pushed onto the stack.</source>
          <target state="translated">Значение 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.0`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.0`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes the integer value of 1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 1 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ldc.i4.1</source>
          <target state="translated">ldc.i4.1</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes 1 onto the stack.</source>
          <target state="translated">Помещает в стек 1 в стек.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The value 1 is pushed onto the stack.</source>
          <target state="translated">Значение 1, помещается в стек.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes the integer value of 2 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 2 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ldc.i4.2</source>
          <target state="translated">ldc.i4.2</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes 2 onto the stack.</source>
          <target state="translated">Помещает 2 в стек.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The value 2 is pushed onto the stack.</source>
          <target state="translated">Значение 2 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes the integer value of 3 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 3 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ldc.i4.3</source>
          <target state="translated">ldc.i4.3</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes 3 onto the stack.</source>
          <target state="translated">Помещает 3 в стек.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The value 3 is pushed onto the stack.</source>
          <target state="translated">Значение 3 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.3`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.3`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes the integer value of 4 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 4 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>1A</source>
          <target state="translated">1A</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ldc.i4.4</source>
          <target state="translated">ldc.i4.4</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes 4 onto the stack.</source>
          <target state="translated">Помещает 4 в стек.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The value 4 is pushed onto the stack.</source>
          <target state="translated">Значение 4 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes the integer value of 5 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 5 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>1B</source>
          <target state="translated">1B</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ldc.i4.5</source>
          <target state="translated">ldc.i4.5</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes 5 onto the stack.</source>
          <target state="translated">Помещает 5 в стек.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The value 5 is pushed onto the stack.</source>
          <target state="translated">Значение 5 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.5`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.5`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes the integer value of 6 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 6 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>1C</source>
          <target state="translated">1C</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ldc.i4.6</source>
          <target state="translated">ldc.i4.6</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes 6 onto the stack.</source>
          <target state="translated">Помещает 6 в стек.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The value 6 is pushed onto the stack.</source>
          <target state="translated">Значение 6 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.6`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.6`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes the integer value of 7 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 7 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>1D</source>
          <target state="translated">1D</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ldc.i4.7</source>
          <target state="translated">ldc.i4.7</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes 7 onto the stack.</source>
          <target state="translated">Помещает 7 в стек.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The value 7 is pushed onto the stack.</source>
          <target state="translated">Значение 7 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.7`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.7`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes the integer value of 8 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение 8 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>1E</source>
          <target state="translated">1E</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ldc.i4.8</source>
          <target state="translated">ldc.i4.8</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes 8 onto the stack.</source>
          <target state="translated">Помещает 8 в стек.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The value 8 is pushed onto the stack.</source>
          <target state="translated">Значение 8 помещается в стек.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes the integer value of -1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Помещает целочисленное значение –1 в стек вычислений как <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>15</source>
          <target state="translated">15</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ldc.i4.m1</source>
          <target state="translated">ldc.i4.m1</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes -1 onto the stack.</source>
          <target state="translated">Помещает в стек значение -1 в стек.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The value -1 is pushed onto the stack.</source>
          <target state="translated">Значение -1, помещается в стек.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">Это специальная короткая кодировка для принудительной отправки целочисленное значение 0.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">Все короткие кодировки помещают целые числа размером 4 байта в стеке.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.m1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.m1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes the supplied <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, short form.</source>
          <target state="translated">Помещает переданное значение с типом <ph id="ph1">&lt;see langword="int8" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph> (короткая форма).</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ldc.i4.s <ph id="ph1">`num`</ph></source>
          <target state="translated">Инструкция ldc.i4.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int32`</ph>, short form.</source>
          <target state="translated">Помещает <ph id="ph1">`num`</ph> стек как <ph id="ph2">`int32`</ph>, краткая форма.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение <ph id="ph1">`num`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source><ph id="ph1">`ldc.i4.s`</ph> is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldc.i4.s`</ph> является более эффективную кодировку для помещения целых чисел от -128 до 127 в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i4.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, byte)</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Помещает переданное значение с типом <ph id="ph1">&lt;see langword="int64" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ldc.i8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.I8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">Помещает <ph id="ph1">`num`</ph> стек как <ph id="ph2">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение <ph id="ph1">`num`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>This encoding pushes an <ph id="ph1">`int64`</ph> value onto the stack.</source>
          <target state="translated">Эта кодировка помещает <ph id="ph1">`int64`</ph> значение в стек.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.i8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ILGenerator.Emit(OpCode, long)</source>
          <target state="translated">ILGenerator.Emit (OpCode, long)</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Помещает переданное значение с типом <ph id="ph1">&lt;see langword="float32" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="F" /&gt;</ph> (число с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ldc.r4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.R4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">Помещает <ph id="ph1">`num`</ph> стек как <ph id="ph2">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение <ph id="ph1">`num`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>This encoding pushes a <ph id="ph1">`float32`</ph> value onto the stack.</source>
          <target state="translated">Эта кодировка помещает <ph id="ph1">`float32`</ph> значение в стек.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.r4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ILGenerator.Emit(OpCode, single)</source>
          <target state="translated">ILGenerator.Emit (OpCode, один)</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Помещает переданное значение с типом <ph id="ph1">&lt;see langword="float64" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="F" /&gt;</ph> (число с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ldc.r8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.R8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">Помещает <ph id="ph1">`num`</ph> стек как <ph id="ph2">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение <ph id="ph1">`num`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>This encoding pushes a <ph id="ph1">`float64`</ph> value onto the stack.</source>
          <target state="translated">Эта кодировка помещает <ph id="ph1">`float64`</ph> значение в стек.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldc.r8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ILGenerator.Emit(OpCode, double)</source>
          <target state="translated">ILGenerator.Emit (OpCode, double)</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</source>
          <target state="translated">Загружает элемент с заданным индексом массива на вершину стека вычислений в качестве типа, указанного в инструкции.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ldelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">ldelem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`typeTok`</ph>.</source>
          <target state="translated">Загружает элемент с <ph id="ph1">`index`</ph> на вершину стека как <ph id="ph2">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The <ph id="ph1">`ldelem`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The type of the return value is specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">Тип возвращаемого значения указан маркер <ph id="ph1">`typeTok`</ph> в инструкции.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the upper bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение верхней границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a specified array index onto the top of the evaluation stack as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент массива с заданным индексом, имеющий тип <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, на вершину стека вычислений как <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>97</source>
          <target state="translated">97</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ldelem.i</source>
          <target state="translated">ldelem.i</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">`native int`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`native int`</ph> в <ph id="ph2">`index`</ph> на вершину стека вычислений как <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The <ph id="ph1">`ldelem.i`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The return value for <ph id="ph1">`ldelem.i`</ph> is <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.i`</ph> — <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.i`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент типа <ph id="ph1">&lt;see langword="int8" /&gt;</ph> с заданным индексом массива на вершину стека вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>90</source>
          <target state="translated">90</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ldelem.i1</source>
          <target state="translated">ldelem.i1</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">`int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`int8`</ph> в <ph id="ph2">`index`</ph> на вершину стека вычислений как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The <ph id="ph1">`ldelem.i1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i1`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The return value for <ph id="ph1">`ldelem.i1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.i1`</ph> — <ph id="ph2">`int8`</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.i1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент типа <ph id="ph1">&lt;see langword="int16" /&gt;</ph> с заданным индексом массива на вершину стека вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>92</source>
          <target state="translated">92</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ldelem.i2</source>
          <target state="translated">ldelem.I2</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">`int16`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`int16`</ph> в <ph id="ph2">`index`</ph> на вершину стека вычислений как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The <ph id="ph1">`ldelem.i2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i2`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The return value for <ph id="ph1">`ldelem.i2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.i2`</ph> — <ph id="ph2">`int16`</ph>.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.i2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент типа <ph id="ph1">&lt;see langword="int32" /&gt;</ph> с заданным индексом массива на вершину стека вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>94</source>
          <target state="translated">94</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ldelem.i4</source>
          <target state="translated">ldelem.i4</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">`int32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`int32`</ph> в <ph id="ph2">`index`</ph> на вершину стека вычислений как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The <ph id="ph1">`ldelem.i4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i4`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The return value for <ph id="ph1">`ldelem.i4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.i4`</ph> — <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.i4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент типа <ph id="ph1">&lt;see langword="int64" /&gt;</ph> с заданным индексом массива на вершину стека вычислений как <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>96</source>
          <target state="translated">96</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ldelem.i8</source>
          <target state="translated">ldelem.i8</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">`int64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`int64`</ph> в <ph id="ph2">`index`</ph> на вершину стека вычислений как <ph id="ph3">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The <ph id="ph1">`ldelem.i8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i8`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The return value for <ph id="ph1">`ldelem.i8`</ph> is <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.i8`</ph> — <ph id="ph2">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.i8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Загружает элемент массива с заданным индексом, имеющий тип <ph id="ph1">&lt;see langword="float32" /&gt;</ph>, на вершину стека вычислений как <ph id="ph2">&lt;see langword="F" /&gt;</ph> (число с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>98</source>
          <target state="translated">98</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ldelem.r4</source>
          <target state="translated">ldelem.R4</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">`float32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`float32`</ph> в <ph id="ph2">`index`</ph> на вершину стека как тип <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The <ph id="ph1">`ldelem.r4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.r4`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The return value for <ph id="ph1">`ldelem.r4`</ph> is <ph id="ph2">`float32`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.r4`</ph> — <ph id="ph2">`float32`</ph>.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой преобразуются в тип <ph id="ph1">`F`</ph> при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.r4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">Загружает элемент массива с заданным индексом, имеющий тип <ph id="ph1">&lt;see langword="float64" /&gt;</ph>, на вершину стека вычислений как <ph id="ph2">&lt;see langword="F" /&gt;</ph> (число с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>99</source>
          <target state="translated">99</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ldelem.r8</source>
          <target state="translated">ldelem.R8</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">`float64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`float64`</ph> в <ph id="ph2">`index`</ph> на вершину стека как <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The <ph id="ph1">`ldelem.r8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.r8`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The return value for <ph id="ph1">`ldelem.r8`</ph> is <ph id="ph2">`float64`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.r8`</ph> — <ph id="ph2">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой преобразуются в тип <ph id="ph1">`F`</ph> при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.r8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference).</source>
          <target state="translated">Загружает элемент массива с заданным индексом, содержащий ссылку на объект, на вершину стека вычислений как <ph id="ph1">&lt;see langword="O" /&gt;</ph> (ссылка на объект).</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>9A</source>
          <target state="translated">9A</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ldelem.ref</source>
          <target state="translated">ldelem.ref</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element with an object reference at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`O`</ph>.</source>
          <target state="translated">Загружает элемент ссылку на <ph id="ph1">`index`</ph> на вершину стека как <ph id="ph2">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The <ph id="ph1">`ldelem.ref`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.ref`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The return value for <ph id="ph1">`ldelem.ref`</ph> is type <ph id="ph2">`O`</ph> (object reference).</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.ref`</ph> — тип <ph id="ph2">`O`</ph> (ссылка на объект).</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.ref`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.ref`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент типа <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> с заданным индексом массива на вершину стека вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>91</source>
          <target state="translated">91</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ldelem.u1</source>
          <target state="translated">ldelem.u1</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">`unsigned int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`unsigned int8`</ph> в <ph id="ph2">`index`</ph> на вершину стека вычислений как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The <ph id="ph1">`ldelem.u1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.u1`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The return value for <ph id="ph1">`ldelem.u1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.u1`</ph> — <ph id="ph2">`int8`</ph>.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.u1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент типа <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> с заданным индексом массива на вершину стека вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>93</source>
          <target state="translated">93</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ldelem.u2</source>
          <target state="translated">ldelem.U2</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">`unsigned int16`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`unsigned int16`</ph> по индексу на вершину стека вычислений как <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The <ph id="ph1">`ldelem.u2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.u2`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The return value for <ph id="ph1">`ldelem.u2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.u2`</ph> — <ph id="ph2">`int16`</ph>.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.u2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">Загружает элемент типа <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> с заданным индексом массива на вершину стека вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>95</source>
          <target state="translated">95</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ldelem.u4</source>
          <target state="translated">ldelem.u4</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">`unsigned int32`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Загружает элемент с типом <ph id="ph1">`unsigned int32`</ph> по индексу на вершину стека вычислений как <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; значение, хранящееся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The <ph id="ph1">`ldelem.u4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.u4`</ph> Инструкция загружает значение элемента с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The return value for <ph id="ph1">`ldelem.u4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelem.u4`</ph> — <ph id="ph2">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if array does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> вызывается, если массив не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelem.u4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> (managed pointer).</source>
          <target state="translated">Загружает адрес элемента массива с заданным индексом на вершину стека вычислений как <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> (управляемый указатель).</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ldelema <ph id="ph1">`class`</ph></source>
          <target state="translated">ldelema <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at <ph id="ph1">`index`</ph> onto the top of the evaluation stack as type <ph id="ph2">`&amp;`</ph> (managed pointer).</source>
          <target state="translated">Загружает адрес элемента массива с <ph id="ph1">`index`</ph> на вершину стека вычислений как <ph id="ph2">`&amp;`</ph> (управляемый указатель).</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the address stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> и <ph id="ph2">`array`</ph> извлекаются из стека; адрес, хранящийся в позиции <ph id="ph3">`index`</ph> в <ph id="ph4">`array`</ph> осуществляется поиск.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> is used to retrieve the address of an object at a particular index in an array of objects (of type <ph id="ph2">`class`</ph>).</source>
          <target state="translated"><ph id="ph1">`ldelema`</ph> Используется для извлечения адреса объекта с определенного индекса в массиве объектов (типа <ph id="ph2">`class`</ph>).</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> instruction loads the address of the value at index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelema`</ph> Инструкция загружает адрес значения с индексом <ph id="ph2">`index`</ph> (тип <ph id="ph3">`native int`</ph>) в отсчитываемый от нуля одномерный массив <ph id="ph4">`array`</ph> и помещает его в вершине стека.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The value must be of type <ph id="ph1">`class`</ph> passed with the instruction.</source>
          <target state="translated">Значение должно быть типа <ph id="ph1">`class`</ph> передаваемый с инструкцией.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The return value for <ph id="ph1">`ldelema`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>).</source>
          <target state="translated">Возвращаемое значение для <ph id="ph1">`ldelema`</ph> является управляемым указателем (тип <ph id="ph2">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelema`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldelema`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Finds the value of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">Выполняет поиск значения поля в объекте, ссылка на который находится в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ldfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Pushes the value of a field in a specified object onto the stack.</source>
          <target state="translated">Помещает в стек значение поля в указанный объект в стек.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект (или указатель) помещается в стек.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</source>
          <target state="translated">Ссылка на объект (или указатель) извлекается из стека; найти значение указанного поля в объекте.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The value stored in the field is pushed onto the stack.</source>
          <target state="translated">Значение, хранящееся в поле помещается в стек.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction pushes the value of a field located in an object onto the stack.</source>
          <target state="translated"><ph id="ph1">`ldfld`</ph> Инструкция помещает значение поля в объекте в стек.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">Объект должен находиться в стеке как ссылка на объект (тип <ph id="ph1">`O`</ph>), управляемый указатель (типа <ph id="ph2">`&amp;`</ph>), неуправляемый указатель (типа <ph id="ph3">`native int`</ph>), временный указатель (типа <ph id="ph4">`*`</ph>), или экземпляр типа значения.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">Использование неуправляемого указателя не допускается в проверяемом коде.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">Поле объекта задается с помощью лексемы метаданных, которая должна ссылаться на поле-член.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The return type is the same as the one associated with the field.</source>
          <target state="translated">Тип возвращаемого значения является таким же, как связанные с этим полем.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The field may be either an instance field (in which case the object must not be a null reference) or a static field.</source>
          <target state="translated">Поле может быть поле экземпляра (в этом случае объект не должен быть пустой ссылкой) или статическое поле.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated"><ph id="ph1">`ldfld`</ph> Инструкция может предшествовать одной или обеих <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> префиксы.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если объект имеет значение null, и поле не является статическим.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> возникает, если указанное поле не найден в метаданных.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинном коде, не во время выполнения.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldfld`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldfld`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Finds the address of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">Ищет адрес поля в объекте, ссылка на который находится в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ldflda <ph id="ph1">`field`</ph></source>
          <target state="translated">ldflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Pushes the address of <ph id="ph1">`field`</ph> in a specified object onto the stack.</source>
          <target state="translated">Помещает адрес <ph id="ph1">`field`</ph> в указанный объект в стек.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект (или указатель) помещается в стек.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</source>
          <target state="translated">Ссылка на объект (или указатель) извлекается из стека; найти адрес указанного поля в объекте.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of the specified field is pushed onto the stack.</source>
          <target state="translated">Адрес указанного поля помещается в стек.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction pushes the address of a field located in an object onto the stack.</source>
          <target state="translated"><ph id="ph1">`ldflda`</ph> Инструкция помещает адрес поля в объекте в стек.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">Объект должен находиться в стеке как ссылка на объект (тип <ph id="ph1">`O`</ph>), управляемый указатель (типа <ph id="ph2">`&amp;`</ph>), неуправляемый указатель (типа <ph id="ph3">`native int`</ph>), временный указатель (типа <ph id="ph4">`*`</ph>), или экземпляр типа значения.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">Использование неуправляемого указателя не допускается в проверяемом коде.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">Поле объекта задается с помощью лексемы метаданных, которая должна ссылаться на поле-член.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The value returned by <ph id="ph1">`ldflda`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type <ph id="ph3">`native int`</ph>).</source>
          <target state="translated">Значение, возвращаемое <ph id="ph1">`ldflda`</ph> является управляемым указателем (тип <ph id="ph2">`&amp;`</ph>), если объект помещается в стек как неуправляемый указатель, в этом случае обратный адрес является также неуправляемый указатель (типа <ph id="ph3">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated"><ph id="ph1">`ldflda`</ph> Инструкция может предшествовать одной или обеих <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> префиксы.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown if the object is not within the application domain from which it is being accessed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> возникает, если объект не входит в домен приложения, из которого доступе.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of a field that is not inside the accessing application domain cannot be loaded.</source>
          <target state="translated">Не удается загрузить адрес поля, которое не находится внутри доступ к домену приложения.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если объект имеет значение null, и поле не является статическим.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> возникает, если указанное поле не найден в метаданных.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинном коде, не во время выполнения.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldflda`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldflda`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a specific method onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений неуправляемый указатель (с типом <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) на машинный код, реализующий заданный метод.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ldftn <ph id="ph1">`method`</ph></source>
          <target state="translated">LDFTN <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes a pointer to a method referenced by <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">Помещает указатель на метод, заданный параметром <ph id="ph1">`method`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The unmanaged pointer to a specific method is pushed onto the stack.</source>
          <target state="translated">Неуправляемый указатель в определенный метод помещается в стек.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The specific method (<ph id="ph1">`method`</ph>) can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">Определенный метод (<ph id="ph1">`method`</ph>) может быть вызван с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> инструкции, если она ссылается на управляемый метод (или заглушку, переходит из управляемого в неуправляемый код).</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The value returned points to native code using the CLR calling convention.</source>
          <target state="translated">Возвращаемое значение ссылается на машинный код с помощью среды CLR, соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">Этот метод указатель не передан в неуправляемый машинный код в виде подпрограммы обратного вызова.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldftn`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldftn`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (код операции, MethodInfo)</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="native int" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>4D</source>
          <target state="translated">4D</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ldind.i</source>
          <target state="translated">ldind.i</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads the <ph id="ph1">`native int`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`native int`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The <ph id="ph1">`ldind.i`</ph> instruction indirectly loads a <ph id="ph2">`native int`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`native int`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i`</ph> Инструкция <ph id="ph2">`native int`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.i`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="int8" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>46</source>
          <target state="translated">46</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ldind.i1</source>
          <target state="translated">ldind.i1</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads the <ph id="ph1">`int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`int8`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The fetched value is pushed onto the stack..</source>
          <target state="translated">Извлеченное значение помещается в стек...</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The <ph id="ph1">`ldind.i1`</ph> instruction indirectly loads an <ph id="ph2">`int8`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i1`</ph> Инструкция <ph id="ph2">`int8`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.i1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="int16" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>48</source>
          <target state="translated">48</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ldind.i2</source>
          <target state="translated">ldind.I2</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads the <ph id="ph1">`int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`int16`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The <ph id="ph1">`ldind.i2`</ph> instruction indirectly loads an <ph id="ph2">`int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i2`</ph> Инструкция <ph id="ph2">`int16`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.i2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="int32" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>4A</source>
          <target state="translated">4A</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ldind.i4</source>
          <target state="translated">ldind.i4</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads the <ph id="ph1">`int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`int32`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The <ph id="ph1">`ldind.i4`</ph> instruction indirectly loads an <ph id="ph2">`int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i4`</ph> Инструкция <ph id="ph2">`int32`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.i4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="int64" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>4C</source>
          <target state="translated">4C</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ldind.i8</source>
          <target state="translated">ldind.I8</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads the <ph id="ph1">`int64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`int64`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The <ph id="ph1">`ldind.i8`</ph> instruction indirectly loads an <ph id="ph2">`int64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int64`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i8`</ph> Инструкция <ph id="ph2">`int64`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`int64`</ph>.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.i8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="float32" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="F" /&gt;</ph> (число с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>4E</source>
          <target state="translated">4E</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ldind.r4</source>
          <target state="translated">ldind.R4</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads the <ph id="ph1">`float32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`float32`</ph> по адресу <ph id="ph2">`addr`</ph> стек как тип <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The <ph id="ph1">`ldind.r4`</ph> instruction indirectly loads a <ph id="ph2">`float32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a type <ph id="ph5">`F`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.r4`</ph> Инструкция <ph id="ph2">`float32`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как тип <ph id="ph5">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.r4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="float64" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="F" /&gt;</ph> (число с плавающей запятой).</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>4F</source>
          <target state="translated">4F</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ldind.r8</source>
          <target state="translated">ldind.R8</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads the <ph id="ph1">`float64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`float64`</ph> по адресу <ph id="ph2">`addr`</ph> стек как тип <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The <ph id="ph1">`ldind.r8`</ph> instruction indirectly loads a <ph id="ph2">`float64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`float64`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.r8`</ph> Инструкция <ph id="ph2">`float64`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`float64`</ph>.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.r8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads an object reference as a type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference) onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку в стек вычислений ссылки на объект как <ph id="ph1">&lt;see langword="O" /&gt;</ph> (ссылка на объект).</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>50</source>
          <target state="translated">50</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ldind.ref</source>
          <target state="translated">ldind.ref</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads the object reference at address <ph id="ph1">`addr`</ph> onto the stack as a type <ph id="ph2">`O`</ph></source>
          <target state="translated">Загружает ссылку на объект по адресу <ph id="ph1">`addr`</ph> стек как тип <ph id="ph2">`O`</ph></target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address is popped from the stack; the object reference located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; ссылка на объект, расположенный по адресу, выбирается.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The fetched reference is pushed onto the stack.</source>
          <target state="translated">Извлеченная ссылка помещается в стек.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The <ph id="ph1">`ldind.ref`</ph> instruction indirectly loads the object reference the specified address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or *) onto the stack as type <ph id="ph4">`O`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.ref`</ph> Инструкция косвенно загружает ссылку на объект по указанному адресу (типа <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, или *) в стек как тип <ph id="ph4">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.ref`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.ref`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>47</source>
          <target state="translated">47</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ldind.u1</source>
          <target state="translated">ldind.U1</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads the <ph id="ph1">`unsigned int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`unsigned int8`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The <ph id="ph1">`ldind.u1`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int8`</ph> value from the specified address (of type<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.u1`</ph> Инструкция <ph id="ph2">`unsigned int8`</ph> значение из указанного адреса (типа<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.u1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>49</source>
          <target state="translated">49</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ldind.u2</source>
          <target state="translated">ldind.U2</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads the <ph id="ph1">`unsigned int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`unsigned int16`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The <ph id="ph1">`ldind.u2`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.u2`</ph> Инструкция <ph id="ph2">`unsigned int16`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.u2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated">Выполняет косвенную загрузку значения с типом <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> в стек вычислений как <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>4B</source>
          <target state="translated">4B</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ldind.u4</source>
          <target state="translated">ldind.U4</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads the <ph id="ph1">`unsigned int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">Загружает <ph id="ph1">`unsigned int32`</ph> по адресу <ph id="ph2">`addr`</ph> стек как <ph id="ph3">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">Адрес извлекается из стека; значение по адресу выбирается.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">Извлеченное значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The <ph id="ph1">`ldind.u4`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.u4`</ph> Инструкция <ph id="ph2">`unsigned int32`</ph> значение из указанного адреса (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или *) в стек как <ph id="ph5">`int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">Все <ph id="ph1">`ldind`</ph> инструкции предназначены для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> инструкция, определяющая соответствующий встроенный класс значения.</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">Обратите внимание, что целочисленные значения размером менее 4 байтов расширяются до <ph id="ph1">`int32`</ph> (не <ph id="ph2">`native int`</ph>) когда они были загружены в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">Значения с плавающей запятой, преобразуются в <ph id="ph1">`F`</ph> введите при загрузке в стек вычислений.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Правильный формат Microsoft промежуточного языка MSIL гарантирует, что <ph id="ph1">`ldind`</ph> инструкции используются в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">Адрес, первоначально помещенный в стек, которые должны быть выровнены по размеру объектов на компьютере или <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> может произойти (см. <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префикса по).</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">Результаты всех инструкций MSIL, возвращающих адреса (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>), обеспечивается правильное выравнивание.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">Для типов данных больше 1 байта порядок байтов зависит от конечного ЦП.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">Код, зависящий от порядка байтов может работать на всех платформах.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызываемое при обнаружении недопустимого адреса.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldind.u4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений сведения о числе элементов одномерного массива с индексацией от нуля.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>8E</source>
          <target state="translated">8E</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ldlen</source>
          <target state="translated">ldlen</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the length (of type <ph id="ph1">`natural unsigned int`</ph>) of an array on the stack.</source>
          <target state="translated">Помещает длина (типа <ph id="ph1">`natural unsigned int`</ph>) массива в стеке.</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>An object reference to an array is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив помещается в стек.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The array reference is popped from the stack and the length is computed.</source>
          <target state="translated">Ссылка на массив извлекается из стека и вычисляется длина.</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is pushed onto the stack.</source>
          <target state="translated">Длина помещается в стек.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is returned as a <ph id="ph1">`natural unsigned int`</ph>.</source>
          <target state="translated">Длина возвращается в виде <ph id="ph1">`natural unsigned int`</ph>.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the array reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызывается, если ссылка на массив является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldlen`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldlen`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с указанным индексом.</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>FE 0C &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0C &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ldloc <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">Загружает в локальную переменную с индексом <ph id="ph1">`index`</ph> в стек.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">Значение локальной переменной с указанным индексом помещается в стек.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloc`</ph> Инструкция помещает содержимое локальной переменной с заданным индексом в стек вычислений, где локальные переменные, начиная от 0.</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</source>
          <target state="translated">Локальные переменные инициализируется значением 0 перед входом в метод, только если флаг инициализации метода равен true.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>There are 65,535 (2^16-1) local variables possible (0-65,534).</source>
          <target state="translated">Существует 65 535 (2 ^ 16 - 1) возможных локальных переменных (0-65 534).</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</source>
          <target state="translated">Индекс 65 535 является недопустимым, так как возможны реализации, использующие 2-байтовое целое число для отслеживания индекса и локальный, так и общее количество локальных данного метода.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">Если индекс 65 535 считался действительным, потребуется расширить целое число для отслеживания числа локальные переменные в этом методе.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, and <ph id="ph4">`ldloc.3`</ph> instructions provide an efficient encoding for accessing the first four local variables.</source>
          <target state="translated"><ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, И <ph id="ph4">`ldloc.3`</ph> инструкции обеспечивают эффективную кодировку для доступа к первым четырем локальным переменным.</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Тип значения — типу локальной переменной, указанной в заголовке метода.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">См. раздел I. локальные переменные, которые меньше, чем 4 байта, расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`ldloc`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (код операции, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, короткое)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 0.</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>06</source>
          <target state="translated">06</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ldloc.0</source>
          <target state="translated">ldloc.0</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 0.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The local variable value at the index 0 is pushed onto the stack.</source>
          <target state="translated">Значение локальной переменной с индексом 0 помещается в стек.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source><ph id="ph1">`ldloc.0`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 0.</source>
          <target state="translated"><ph id="ph1">`ldloc.0`</ph> особенно эффективный вариант кодировки <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, разрешающее доступ к локальной переменной с индексом 0.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Тип значения — типу локальной переменной, указанной в заголовке метода.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Локальные переменные, которые меньше, чем 4 байта, расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.0`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldloc.0`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 1.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>07</source>
          <target state="translated">07</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ldloc.1</source>
          <target state="translated">ldloc.1</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 1.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The local variable value at the index 1 is pushed onto the stack.</source>
          <target state="translated">Значение локальной переменной с индексом 1 помещается в стек.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source><ph id="ph1">`ldloc.1`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 1.</source>
          <target state="translated"><ph id="ph1">`ldloc.1`</ph> особенно эффективный вариант кодировки <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, разрешающее доступ к локальной переменной с индексом 1.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Тип значения — типу локальной переменной, указанной в заголовке метода.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Локальные переменные, которые меньше, чем 4 байта, расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldloc.1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 2.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>08</source>
          <target state="translated">08</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ldloc.2</source>
          <target state="translated">ldloc.2</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 2.</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The local variable value at the index 2 is pushed onto the stack.</source>
          <target state="translated">Значение локальной переменной с индексом 2 помещается в стек.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source><ph id="ph1">`ldloc.2`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 2.</source>
          <target state="translated"><ph id="ph1">`ldloc.2`</ph> особенно эффективный вариант кодировки <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, разрешающее доступ к локальной переменной с индексом 2.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Тип значения — типу локальной переменной, указанной в заголовке метода.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Локальные переменные, которые меньше, чем 4 байта, расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldloc.2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 3.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>09</source>
          <target state="translated">09</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ldloc.3</source>
          <target state="translated">ldloc.3</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с индексом 3.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The local variable value at the index 3 is pushed onto the stack.</source>
          <target state="translated">Значение локальной переменной с индексом 3 помещается в стек.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source><ph id="ph1">`ldloc.3`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 3.</source>
          <target state="translated"><ph id="ph1">`ldloc.3`</ph> особенно эффективный вариант кодировки <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, разрешающее доступ к локальной переменной с индексом 3.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Тип значения — типу локальной переменной, указанной в заголовке метода.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">Локальные переменные, которые меньше, чем 4 байта, расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.3`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldloc.3`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">Загружает в стек вычислений локальную переменную с указанным индексом (короткая форма).</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ldloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">Загружает в локальную переменную с индексом <ph id="ph1">`index`</ph> в стек, краткая форма.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">Значение локальной переменной с указанным индексом помещается в стек.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The <ph id="ph1">`ldloc.s`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloc.s`</ph> Инструкция помещает содержимое локальной переменной с заданным индексом в стек вычислений, где локальные переменные, начиная от 0.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</source>
          <target state="translated">Локальные переменные инициализируется значением 0 перед входом в метод, если флаг инициализации метода имеет значение true.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than <ph id="ph1">`ldloc`</ph>.</source>
          <target state="translated">Составляет 256 (2 ^ 8) возможных локальных переменных (0 – 255) в краткую форму, который является более эффективную кодировку чем <ph id="ph1">`ldloc`</ph>.</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">Тип значения — типу локальной переменной, указанной в заголовке метода.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">См. раздел I. локальные переменные, которые меньше, чем 4 байта, расширяются до типа <ph id="ph1">`int32`</ph> при загрузке в стек.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">Значения с плавающей запятой, расширяются до исходного размера (тип <ph id="ph1">`F`</ph>).</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`ldloc.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (код операции, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, byte)</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">Загружает в стек вычислений адрес локальной переменной с указанным индексом.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>FE OD &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE OD &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ldloca <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack.</source>
          <target state="translated">Загружает адрес локальной переменной с <ph id="ph1">`index`</ph> в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">Адрес, хранящийся в локальной переменной с указанным индексом помещается в стек.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The <ph id="ph1">`ldloca`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloca`</ph> Инструкция помещает адрес локальной переменной с заданным индексом в стек, где локальных переменных, начиная от 0.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">Значение, помещаемое в стек, уже выровнено для использования с инструкциями, как <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">Результатом является временный указатель (типа <ph id="ph1">`*`</ph>).</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldloca`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, короткое)</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">Загружает в стек вычислений адрес локальной переменной с указанным индексом (короткая форма).</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ldloca.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack, short form.</source>
          <target state="translated">Загружает адрес локальной переменной с <ph id="ph1">`index`</ph> в стек вычислений, краткая форма.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">Адрес, хранящийся в локальной переменной с указанным индексом помещается в стек.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloca.s`</ph> Инструкция помещает адрес локальной переменной с заданным индексом в стек, где локальных переменных, начиная от 0.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">Значение, помещаемое в стек, уже выровнено для использования с инструкциями, как <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">Результатом является временный указатель (типа <ph id="ph1">`*`</ph>).</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction provides an efficient encoding for use with the local variables 0 through 255.</source>
          <target state="translated"><ph id="ph1">`ldloca.s`</ph> Инструкция обеспечивает эффективную кодировку для использования с локальными переменными от 0 до 255.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldloca.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, byte)</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Pushes a null reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений пустую ссылку (тип <ph id="ph1">&lt;see langword="O" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ldnull</source>
          <target state="translated">метод ldnull</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>push a null reference onto the stack</source>
          <target state="translated">пустая ссылка на стек Push</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>A null object reference is pushed onto the stack.</source>
          <target state="translated">Пустая ссылка на объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> pushes a null reference (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> Помещает в стек пустую ссылку (тип <ph id="ph2">`O`</ph>) в стеке.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>This is used to initialize locations before they are populated with data, or when they become deprecated.</source>
          <target state="translated">Используется для инициализации расположения, прежде чем они заполняются данными или когда они станут устаревшими.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> provides a null reference that is size-independent.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> содержит пустую ссылку, которая не зависит от размера.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldnull`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldnull`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copies the value type object pointed to by an address to the top of the evaluation stack.</source>
          <target state="translated">Копирует объект с типом значения, размещенный по указанному адресу, на вершину стека вычислений.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ldobj <ph id="ph1">`class`</ph></source>
          <target state="translated">ldobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copy instance of value type <ph id="ph1">`class`</ph> to the stack.</source>
          <target state="translated">Копировать экземпляр типа значения <ph id="ph1">`class`</ph> в стек.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address of a value type object is pushed onto the stack.</source>
          <target state="translated">Адрес объекта типа значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address is popped from the stack and the instance at that particular address is looked up.</source>
          <target state="translated">Адрес извлекается из стека и выполняется поиск экземпляра по этому адресу.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The value of the object stored at that address is pushed onto the stack.</source>
          <target state="translated">Значение объекта с заданным адресом помещается в стек.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction is used to pass a value type as a parameter.</source>
          <target state="translated"><ph id="ph1">`ldobj`</ph> Инструкция используется для передачи типа значения в качестве параметра.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction copies the value pointed to by <ph id="ph2">`addrOfValObj`</ph> (of type <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`native int`</ph>) to the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldobj`</ph> Инструкция копирует значение, на который указывает <ph id="ph2">`addrOfValObj`</ph> (типа <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`native int`</ph>) в верхней части стека.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The number of bytes copied depends on the size of the class (as specified by the <ph id="ph1">`class`</ph> parameter).</source>
          <target state="translated">Число копируемых байтов зависит от размера класса (как указано в <ph id="ph1">`class`</ph> параметр).</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`class`</ph> parameter is a metadata token representing the value type.</source>
          <target state="translated"><ph id="ph1">`class`</ph> Параметр является токен метаданных, представляющий тип значения.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The operation of the <ph id="ph1">`ldobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`ldobj`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если не удается найти класс.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldobj`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldobj`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Pushes the value of a static field onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений значение статического поля.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ldsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Push the value of <ph id="ph1">`field`</ph> on the stack.</source>
          <target state="translated">Принудительная значение <ph id="ph1">`field`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The value of the specific field is pushed onto the stack.</source>
          <target state="translated">Значение поля помещается в стек.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction pushes the value of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated"><ph id="ph1">`ldsfld`</ph> Инструкция помещает значение статического поля (общего для всех экземпляров класса) в стек.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The return type is that associated with the passed metadata token <ph id="ph1">`field`</ph>.</source>
          <target state="translated">Имеет тип возвращаемого значения, связанные с маркером метаданных <ph id="ph1">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated"><ph id="ph1">`ldsfld`</ph> Инструкции может иметь <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> префикс.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsfld`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldsfld`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Pushes the address of a static field onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений адрес статического поля.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ldsflda <ph id="ph1">`field`</ph></source>
          <target state="translated">метод ldsflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Push the address of <ph id="ph1">`field`</ph> on the stack</source>
          <target state="translated">Принудительная адрес <ph id="ph1">`field`</ph> в стеке</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address of a specific field is pushed onto the stack.</source>
          <target state="translated">Адрес указанного поля помещается в стек.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction pushes the address of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated"><ph id="ph1">`ldsflda`</ph> Инструкция помещает адрес статического поля (общего для всех экземпляров класса) в стек.</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address may be represented as a transient pointer (type <ph id="ph1">`*`</ph>) if the metadata token <ph id="ph2">`field`</ph> refers to a type whose memory is managed.</source>
          <target state="translated">Адрес может быть представлен как временный указатель (типа <ph id="ph1">`*`</ph>) Если токен метаданных <ph id="ph2">`field`</ph> ссылается на тип, управляемой памятью.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Otherwise, it corresponds to an unmanaged pointer (type <ph id="ph1">`native int`</ph>).</source>
          <target state="translated">В противном случае он соответствует неуправляемый указатель (типа <ph id="ph1">`native int`</ph>).</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Note that <ph id="ph1">`field`</ph> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`field`</ph> могут быть статическими глобального с присвоен относительный виртуальный адрес (смещение поля из базового адреса, по которому содержащего PE-файл загружается в память) где неуправляемой памяти.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated"><ph id="ph1">`ldsflda`</ph> Инструкции может иметь <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> префикс.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> возникает, если поле не найдено в метаданных.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</source>
          <target state="translated">Обычно это проверяется при преобразовании в машинный код, а не во время выполнения инструкции промежуточного языка Майкрософт (MSIL).</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsflda`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldsflda`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a new object reference to a string literal stored in the metadata.</source>
          <target state="translated">Помещает в стек ссылку на новый объект, представляющий строковой литерал, хранящийся в метаданных.</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ldstr <ph id="ph1">`mdToken`</ph></source>
          <target state="translated">ldstr <ph id="ph1">`mdToken`</ph></target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a string object for the metadata string token <ph id="ph1">`mdToken`</ph>.</source>
          <target state="translated">Помещает объект string для строковая лексема метаданных <ph id="ph1">`mdToken`</ph>.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>An object reference to a string is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в строку помещается в стек.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new string object representing the specific string literal stored in the metadata.</source>
          <target state="translated"><ph id="ph1">`ldstr`</ph> Инструкция помещает ссылку на объект (тип <ph id="ph2">`O`</ph>) в новый строковый объект, представляющий заданный строковой литерал, хранящийся в метаданных.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</source>
          <target state="translated"><ph id="ph1">`ldstr`</ph> Инструкция выделяет нужное количество памяти и выполняет преобразование строкового литерала из формата, используемого в файле в строковый формат, необходимый во время выполнения.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The Common Language Infrastructure (CLI) guarantees that the result of two <ph id="ph1">`ldstr`</ph> instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</source>
          <target state="translated">Common Language Infrastructure (CLI) гарантирует, что результат до двух <ph id="ph1">`ldstr`</ph> инструкций, ссылающихся на две лексемы метаданных, которые имеют ту же последовательность символов возврата же строковый объект (этот процесс называется «изоляцией строк»).</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldstr`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldstr`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ILGenerator.Emit(OpCode, string)</source>
          <target state="translated">ILGenerator.Emit (OpCode, строка)</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</source>
          <target state="translated">Преобразует токен метаданных в его представление времени выполнения, а затем помещает в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ldtoken <ph id="ph1">`token`</ph></source>
          <target state="translated">ldtoken <ph id="ph1">`token`</ph></target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation.</source>
          <target state="translated">Преобразует токен метаданных в его представление времени выполнения.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The passed token is converted to a <ph id="ph1">`RuntimeHandle`</ph> and pushed onto the stack.</source>
          <target state="translated">Переданная лексема преобразуется в <ph id="ph1">`RuntimeHandle`</ph> и помещается в стек.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The <ph id="ph1">`ldtoken`</ph> instruction pushes a <ph id="ph2">`RuntimeHandle`</ph> for the specified metadata token.</source>
          <target state="translated"><ph id="ph1">`ldtoken`</ph> Отправлений инструкции <ph id="ph2">`RuntimeHandle`</ph> для заданным токеном метаданных.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>A <ph id="ph1">`RuntimeHandle`</ph> can be a <ph id="ph2">`fieldref/fielddef`</ph>, a <ph id="ph3">`methodref/methoddef`</ph>, or a <ph id="ph4">`typeref/typedef`</ph>.</source>
          <target state="translated">Объект <ph id="ph1">`RuntimeHandle`</ph> может быть <ph id="ph2">`fieldref/fielddef`</ph>, <ph id="ph3">`methodref/methoddef`</ph>, или <ph id="ph4">`typeref/typedef`</ph>.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The value pushed on the stack can be used in calls to <ph id="ph1">`Reflection`</ph> methods in the system class library.</source>
          <target state="translated">Значение, помещаемое в стеке можно использовать в вызовах <ph id="ph1">`Reflection`</ph> методы в системной библиотеке классов.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>For information on runtime handles, see the following classes: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, and <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о дескрипторах времени выполнения см. следующие классы: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, и <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldtoken`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`ldtoken`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (код операции, MethodInfo)</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений неуправляемый указатель (с типом <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) на машинный код, реализующий виртуальный метод, связанный с заданным объектом.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ldvirtftn <ph id="ph1">`method`</ph></source>
          <target state="translated">ldvirtftn <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes the pointer to an object's virtual method <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">Помещает указатель объекта виртуального метода <ph id="ph1">`method`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <ph id="ph1">`method`</ph>) is looked up.</source>
          <target state="translated">Ссылка на объект извлекается из стека и адрес точки входа метода (как указано в токен метаданных <ph id="ph1">`method`</ph>) производится поиск.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The pointer to <ph id="ph1">`method`</ph> is pushed onto the stack.</source>
          <target state="translated">Указатель на <ph id="ph1">`method`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The resulting unmanaged pointer pushed onto the stack by the <ph id="ph1">`ldvirtftn`</ph> instruction can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">Неуправляемый указатель, помещенный в стек <ph id="ph1">`ldvirtftn`</ph> инструкция может быть вызван с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> инструкции, если она ссылается на управляемый метод (или заглушку, переходит из управляемого в неуправляемый код).</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The unmanaged pointer points to native code using the CLR calling convention.</source>
          <target state="translated">Неуправляемый указатель ссылается на машинный код с помощью среды CLR, соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">Этот метод указатель не передан в неуправляемый машинный код в виде подпрограммы обратного вызова.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldvirtftn`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ldvirtftn`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (код операции, MethodInfo)</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code, unconditionally transferring control to a specific target instruction.</source>
          <target state="translated">Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>leave <ph id="ph1">`target`</ph></source>
          <target state="translated">Оставьте <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code.</source>
          <target state="translated">Выполняет выход из защищенной области кода.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">Нет Переходные состояния стека для данной инструкции не.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated"><ph id="ph1">`leave`</ph> Инструкция выполняет безусловную передачу управления конечной инструкции, представленной в виде 4 байта со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated"><ph id="ph1">`leave`</ph> Инструкция аналогичен <ph id="ph2">`br`</ph> инструкции, но он может использоваться для выхода из <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, или <ph id="ph5">`catch`</ph> блока, в то время как обычные инструкции перехода можно использовать только в таких блоков для передачи управления в его.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated"><ph id="ph1">`leave`</ph> Инструкция очищает стек вычислений и гарантирует, что соответствующие вокруг <ph id="ph2">`finally`</ph> блоки выполняются.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>You cannot use a <ph id="ph1">`leave`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">`leave`</ph> инструкции, чтобы выйти из <ph id="ph2">`finally`</ph> блока.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">В целях упрощения генерации кода обработчиков исключений допускается внутри блока catch для использования <ph id="ph1">`leave`</ph> инструкции для передачи управления любой инструкции в пределах связанного <ph id="ph2">`try`</ph> блока.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`leave`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`leave`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</source>
          <target state="translated">Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции (короткая форма).</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>leave.s <ph id="ph1">`target`</ph></source>
          <target state="translated">leave.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exit a protected region of code, short form.</source>
          <target state="translated">Выйдите из защищенной области кода, краткая форма.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">Нет Переходные состояния стека для данной инструкции не.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated"><ph id="ph1">`leave.s`</ph> Инструкция выполняет безусловную передачу управления конечной инструкции, представленной как 1 байт со знаком смещение от начала инструкции, которая следует за текущей инструкцией.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated"><ph id="ph1">`leave.s`</ph> Инструкция аналогичен <ph id="ph2">`br`</ph> инструкции, но он может использоваться для выхода из <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, или <ph id="ph5">`catch`</ph> блока, в то время как обычные инструкции перехода можно использовать только в таких блоков для передачи управления в его.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated"><ph id="ph1">`leave.s`</ph> Инструкция очищает стек вычислений и гарантирует, что соответствующие вокруг <ph id="ph2">`finally`</ph> блоки выполняются.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>You cannot use a <ph id="ph1">`leave.s`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">`leave.s`</ph> инструкции, чтобы выйти из <ph id="ph2">`finally`</ph> блока.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave.s`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">В целях упрощения генерации кода обработчиков исключений допускается внутри блока catch для использования <ph id="ph1">`leave.s`</ph> инструкции для передачи управления любой инструкции в пределах связанного <ph id="ph2">`try`</ph> блока.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`leave.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`leave.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <ph id="ph1">&lt;see langword="*" /&gt;</ph>) of the first allocated byte onto the evaluation stack.</source>
          <target state="translated">Выделяет определенное количество байтов из пула локальной динамической памяти и помещает в стек вычислений адрес (временный указатель с типом <ph id="ph1">&lt;see langword="*" /&gt;</ph>) первого выделенного байта.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>FE 0F</source>
          <target state="translated">FE 0F</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>localloc</source>
          <target state="translated">инструкции localloc</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocate space from the local heap.</source>
          <target state="translated">Выделите пространство в локальной куче.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes to be allocated is pushed onto the stack.</source>
          <target state="translated">Число байтов для распределения помещается в стек.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</source>
          <target state="translated">Число байтов, извлекается из стека; объем памяти, в зависимости от размера выделяется в локальной куче.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>A pointer to the first byte of the allocated memory is pushed onto the stack.</source>
          <target state="translated">Указатель на первый байт выделенной памяти помещается в стек.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction allocates <ph id="ph2">`size`</ph> (type <ph id="ph3">`natural unsigned int`</ph>) bytes from the local dynamic memory pool and returns the address (a transient pointer, type <ph id="ph4">`*`</ph>) of the first allocated byte.</source>
          <target state="translated"><ph id="ph1">`localloc`</ph> Выделяет инструкция <ph id="ph2">`size`</ph> (тип <ph id="ph3">`natural unsigned int`</ph>) пул байтов из локальной динамической памяти и возвращает адрес (временный указатель, тип <ph id="ph4">`*`</ph>) первого выделенного байта.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The block of memory returned is initialized to 0 only if the initialize flag on the method is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Возвращаемый блок памяти, присваивается значение 0, только если флаг инициализации метода <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>When the current method executes a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, the local memory pool is made available for reuse.</source>
          <target state="translated">При выполнении текущего метода <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, становятся доступными для повторного использования пула локальной памяти.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The resulting address is aligned so that any primitive data type can be stored there using the <ph id="ph1">`stind`</ph> instructions (such as <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) and loaded using the <ph id="ph3">`ldind`</ph> instructions (such as <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</source>
          <target state="translated">Полученный адрес выровнен, чтобы любой тип-примитив возможность сохранения с помощью <ph id="ph1">`stind`</ph> инструкции (такие как <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) и загрузить с помощью <ph id="ph3">`ldind`</ph> инструкции (например, <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction cannot occur within a <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, or <ph id="ph5">`fault`</ph> block.</source>
          <target state="translated"><ph id="ph1">`localloc`</ph> Инструкция не может быть внутри <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, или <ph id="ph5">`fault`</ph> блока.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> is thrown if there is insufficient memory to service the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> возникает, если недостаточно памяти для обслуживания запроса.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`localloc`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`localloc`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference to an instance of a specific type onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений ссылку на экземпляр определенного типа.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>mkrefany <ph id="ph1">`class`</ph></source>
          <target state="translated">Mkrefany <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference of type <ph id="ph1">`class`</ph> onto the stack.</source>
          <target state="translated">Помещает ссылку типа <ph id="ph1">`class`</ph> в стек.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>A pointer to piece of data is pushed onto the stack.</source>
          <target state="translated">Указатель на элемент данных помещается в стек.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer is popped and converted to a typed reference of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">Указатель извлекается из стека и преобразуется в ссылку типа <ph id="ph1">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The typed reference is pushed onto the stack.</source>
          <target state="translated">Ссылка с определенным типом помещается в стек.</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The <ph id="ph1">`mkrefany`</ph> instruction supports the passing of dynamically typed references.</source>
          <target state="translated"><ph id="ph1">`mkrefany`</ph> Инструкция поддерживает передачу динамического типа ссылок.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer must be of type <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, or <ph id="ph3">`native int`</ph>, and hold the valid address of a piece of data.</source>
          <target state="translated">Указатель должен иметь тип <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, или <ph id="ph3">`native int`</ph>и содержать действительный адрес фрагмента данных.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Class`</ph> is the class token describing the type of the data referenced by the pointer.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> Класс токен, описывающий тип данных, который ссылается указатель.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Mkrefany`</ph> pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <ph id="ph2">`class`</ph>.</source>
          <target state="translated"><ph id="ph1">`Mkrefany`</ph> Помещает в стек, предоставляя непрозрачный дескриптор указателя и тип ссылку <ph id="ph2">`class`</ph>.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</source>
          <target state="translated">Для ее передачи в метод, который требует в качестве параметра ссылку на типизированный находится только допустимой операцией типизированную ссылку.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The callee can then use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> instructions to retrieve the type (class) and the address respectively.</source>
          <target state="translated">Вызываемый объект можно затем использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> инструкциям, чтобы получить тип (класс) и адрес соответственно.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`class`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если <ph id="ph2">`class`</ph> не найден.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mkrefany`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`mkrefany`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values and pushes the result on the evaluation stack.</source>
          <target state="translated">Умножает два значения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>5A</source>
          <target state="translated">5A</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>mul</source>
          <target state="translated">mul</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values on the stack.</source>
          <target state="translated">Умножает два значения в стеке.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> умножается на <ph id="ph4">`value2`</ph>.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The <ph id="ph1">`mul`</ph> instruction multiplies <ph id="ph2">`value1`</ph> by <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated"><ph id="ph1">`mul`</ph> Умножает инструкция <ph id="ph2">`value1`</ph> по <ph id="ph3">`value2`</ph> и помещает результат в стек.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Integer operations silently truncate the upper bits on overflow.</source>
          <target state="translated">Операции с целыми числами усекает верхние бит в случае переполнения.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> for an integer-specific multiply operation with overflow handling.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> для целыми числами операцией с обработкой multiply.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>For floating-point types, 0 * infinity = NaN.</source>
          <target state="translated">Для типов с плавающей запятой 0 * бесконечность = NaN.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`mul`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Умножает два целочисленных значения, выполняет проверку переполнения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>D8</source>
          <target state="translated">D8</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>mul.ovf</source>
          <target state="translated">mul.ovf</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values on the stack with an overflow check.</source>
          <target state="translated">Умножает два целочисленных значения в стеке и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> умножается на <ph id="ph4">`value2`</ph>, и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The <ph id="ph1">`mul.ovf`</ph> instruction multiplies integer <ph id="ph2">`value1`</ph> by integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated"><ph id="ph1">`mul.ovf`</ph> Инструкция умножает целое <ph id="ph2">`value1`</ph> по целому <ph id="ph3">`value2`</ph> и помещает результат в стек.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">Исключение возникает в том случае, если результат не умещается в тип результата.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`mul.ovf`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Умножает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>D9</source>
          <target state="translated">D9</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>mul.ovf.un</source>
          <target state="translated">mul.ovf.un</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned values on the stack with an overflow check.</source>
          <target state="translated">Умножает два значения без знака в стеке и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value1`</ph> умножается на <ph id="ph4">`value2`</ph>, и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The <ph id="ph1">`mul.ovf.un`</ph> instruction multiplies unsigned integer <ph id="ph2">`value1`</ph> by unsigned integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated"><ph id="ph1">`mul.ovf.un`</ph> Инструкция умножает целое число без знака <ph id="ph2">`value1`</ph> , целое число без знака <ph id="ph3">`value2`</ph> и помещает результат в стек.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">Исключение возникает в том случае, если результат не умещается в тип результата.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`mul.ovf.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates a value and pushes the result onto the evaluation stack.</source>
          <target state="translated">Отвергает значение и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>65</source>
          <target state="translated">65</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>neg</source>
          <target state="translated">Neg</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates the value currently on top of the stack.</source>
          <target state="translated">Инвертирует значение, находящееся на вершине стека.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is popped from the stack and negated.</source>
          <target state="translated">Значение извлекается из стека и инвертировано.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The <ph id="ph1">`neg`</ph> instruction negates value and pushes the result on top of the stack.</source>
          <target state="translated"><ph id="ph1">`neg`</ph> Инструкция инвертирует значение и помещает результат в стеке.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">Тип возвращаемого значения совпадает с типом операнда.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negation of integral values is standard two's complement negation.</source>
          <target state="translated">Инверсии целочисленных значений является стандартным дополнение до двух отрицания.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</source>
          <target state="translated">В частности Инверсия наибольшее отрицательное число (которая не поддерживает положительного эквивалента) возвращает наибольшее отрицательное число.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>To detect this overflow use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> instruction instead (that is, subtract from 0).</source>
          <target state="translated">Чтобы обнаружить переполнение, воспользуйтесь <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> инструкции вместо (вычитание из 0).</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negating a floating-point number cannot overflow, and negating NaN returns NaN.</source>
          <target state="translated">Инверсия числа с плавающей запятой не может вызвать переполнения, а операция над значением NaN возвращает значение NaN.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`neg`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`neg`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений ссылку на объект — новый одномерный массив с индексацией от нуля, состоящий из элементов заданного типа.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>newarr <ph id="ph1">`etype`</ph></source>
          <target state="translated">newarr <ph id="ph1">`etype`</ph></target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Creates a new array with elements of type <ph id="ph1">`etype`</ph>.</source>
          <target state="translated">Создает новый массив с элементами типа <ph id="ph1">`etype`</ph>.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the array is pushed onto the stack.</source>
          <target state="translated">Число элементов в массиве помещается в стек.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements is popped from the stack and the array is created.</source>
          <target state="translated">Число элементов, извлекается из стека и массив создается.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>An object reference to the new array is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в новый массив помещается в стек.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The <ph id="ph1">`newarr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new zero-based, one-dimensional array whose elements are of type <ph id="ph3">`etype`</ph> (a metadata token describing the type).</source>
          <target state="translated"><ph id="ph1">`newarr`</ph> Инструкция помещает ссылку на объект (тип <ph id="ph2">`O`</ph>) — новый одномерный массив отсчитываемый от нуля, элементы которого имеют тип <ph id="ph3">`etype`</ph> (лексема метаданных, описывающая тип).</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the new array should be specified as a <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Количество элементов в новом массиве должно указываться как <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Valid array indexes range from zero to the maximum number of elements minus one.</source>
          <target state="translated">Действительный массив индексов диапазон от нуля до максимального числа элементов минус 1.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The elements of an array can be any type, including value types.</source>
          <target state="translated">Элементы массива могут быть любого типа, включая типы значений.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and so on).</source>
          <target state="translated">Отсчитываемый от нуля одномерный массив массивы чисел создаются с помощью лексемы метаданных, указывающей соответствующий тип значения (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>и так далее).</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Elements of the array are initialized to 0 of the appropriate type.</source>
          <target state="translated">Элементы массива инициализируется значением 0 соответствующего типа.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Nonzero-based one-dimensional arrays and multidimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> rather than <ph id="ph2">`newarr`</ph>.</source>
          <target state="translated">Для одномерных массивов и многомерные массивы создаются с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> вместо <ph id="ph2">`newarr`</ph>.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>More commonly, they are created using the methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class in the .NET Framework.</source>
          <target state="translated">Как правило, они создаются с помощью методов <ph id="ph1">&lt;xref:System.Array&gt;</ph> в .NET Framework.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> возникает, если памяти недостаточно для удовлетворения запроса.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if <ph id="ph2">`numElems`</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если <ph id="ph2">`numElems`</ph> меньше 0.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newarr`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`newarr`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Creates a new object or a new instance of a value type, pushing an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">Создает новый объект или новый экземпляр типа значения и помещает ссылку на объект (тип <ph id="ph1">&lt;see langword="O" /&gt;</ph>) в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>newobj <ph id="ph1">`ctor`</ph></source>
          <target state="translated">newobj <ph id="ph1">`ctor`</ph></target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Allocates an uninitialized object or value type and calls the constructor method <ph id="ph1">`ctor`</ph>.</source>
          <target state="translated">Размещает неинициализированный объект или тип значения и вызывает метод конструктора <ph id="ph1">`ctor`</ph>.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argn`</ph> are pushed on the stack in sequence.</source>
          <target state="translated">Аргументы <ph id="ph1">`arg1`</ph> через <ph id="ph2">`argn`</ph> помещаются в стек в последовательности.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`argn`</ph> through <ph id="ph2">`arg1`</ph> are popped from the stack and passed to <ph id="ph3">`ctor`</ph> for object creation.</source>
          <target state="translated">Аргументы <ph id="ph1">`argn`</ph> через <ph id="ph2">`arg1`</ph> извлекаются из стека и передаются в <ph id="ph3">`ctor`</ph> для создания объекта.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>A reference to the new object is pushed onto the stack.</source>
          <target state="translated">Ссылка на новый объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction creates a new object or a new instance of a value type.</source>
          <target state="translated"><ph id="ph1">`newobj`</ph> Инструкция создает новый объект или новый экземпляр типа значения.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">`Ctor`</ph> is a metadata token (a <ph id="ph2">`methodref`</ph> or <ph id="ph3">`methoddef`</ph> that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</source>
          <target state="translated"><ph id="ph1">`Ctor`</ph> токен метаданных ( <ph id="ph2">`methodref`</ph> или <ph id="ph3">`methoddef`</ph> , должен быть помечен как конструктор), указывающее имя, класс и подпись для вызова конструктора.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction allocates a new instance of the class associated with <ph id="ph2">`ctor`</ph> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</source>
          <target state="translated"><ph id="ph1">`newobj`</ph> Инструкция выделяет новый экземпляр класса, связанного с <ph id="ph2">`ctor`</ph> и инициализирует все поля нового экземпляра 0 (соответствующего типа) или пустыми ссылками.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>It then calls the constructor <ph id="ph1">`ctor`</ph> with the given arguments along with the newly created instance.</source>
          <target state="translated">Затем он вызывает конструктор <ph id="ph1">`ctor`</ph> с заданными аргументами, и вновь созданному экземпляру.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>After the constructor has been called, the now initialized object reference (type <ph id="ph1">`O`</ph>) is pushed on the stack.</source>
          <target state="translated">После вызова конструктора инициализированный ссылка на объект (тип <ph id="ph1">`O`</ph>) помещается в стек.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</source>
          <target state="translated">С точки зрения конструктора неинициализированный объект является аргументом 0 и выполните другие аргументы, передаваемые newobj в порядке.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>All zero-based, one-dimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, not <ph id="ph2">`newobj`</ph>.</source>
          <target state="translated">Все отсчитываемый от нуля одномерные массивы создаются с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, а не <ph id="ph2">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">С другой стороны, другие массивы (имеющие несколько измерений или одномерные, но не от нуля) создаются с помощью <ph id="ph1">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Value types are not usually created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">Типы значений не создаются обычно с помощью <ph id="ph1">`newobj`</ph>.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>They are usually allocated either as arguments or local variables, using <ph id="ph1">`newarr`</ph> (for zero-based, one-dimensional arrays), or as fields of objects.</source>
          <target state="translated">Они размещаются как аргументы или локальные переменные, с помощью <ph id="ph1">`newarr`</ph> (для одномерных массивов отсчитываемый от нуля) или как поля объектов.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Once allocated, they are initialized using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</source>
          <target state="translated">После выделения памяти, они инициализируются с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>However, the <ph id="ph1">`newobj`</ph> instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</source>
          <target state="translated">Однако <ph id="ph1">`newobj`</ph> инструкция может использоваться для создания нового экземпляра типа значения в стеке, который затем может быть передан как аргумент, сохранен в локальной и т. д.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> возникает, если памяти недостаточно для удовлетворения запроса.</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a constructor method <ph id="ph2">`ctor`</ph> with the indicated name, class and signature could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> вызывается, если метод конструктора <ph id="ph2">`ctor`</ph> с указанным именем, класс и подпись не найден.</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newobj`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`newobj`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>ILGenerator.Emit(OpCode, ConstructorInfo)</source>
          <target state="translated">ILGenerator.Emit (код операции, ConstructorInfo)</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Fills space if opcodes are patched.</source>
          <target state="translated">Заполняет пространство, если коды операции содержат исправления.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>No meaningful operation is performed although a processing cycle can be consumed.</source>
          <target state="translated">Никаких значимых операций не выполняется, хотя может быть пройден цикл обработки.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>00</source>
          <target state="translated">00</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>nop</source>
          <target state="translated">nop</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Performs an operation without behavior.</source>
          <target state="translated">Выполняет операцию без поведение.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>There is no stack transitional behavior defined for this instruction.</source>
          <target state="translated">Нет нет стека Переходные состояния для данной инструкции.</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The <ph id="ph1">`nop`</ph> operation does nothing.</source>
          <target state="translated"><ph id="ph1">`nop`</ph> Операция не выполняет никаких действий.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>It is intended to fill in space if opcodes are patched.</source>
          <target state="translated">Он предназначен для заполнения в пространстве, если коды операции содержат исправления.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`nop`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`nop`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</source>
          <target state="translated">Вычисляет побитовое дополнение целочисленного значения, находящегося на вершине стека, и помещает результат в стек с тем же типом.</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>66</source>
          <target state="translated">66</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>not</source>
          <target state="translated">not</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of a value.</source>
          <target state="translated">Вычисляет побитовое дополнение значения.</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is popped from the stack and its bitwise complement computed.</source>
          <target state="translated"><ph id="ph1">`value`</ph> извлекается из стека, после чего его побитового дополнения вычисляемый.</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The <ph id="ph1">`not`</ph> instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</source>
          <target state="translated"><ph id="ph1">`not`</ph> Инструкция вычисляет побитовое дополнение целочисленного значения и помещает результат в стек.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">Тип возвращаемого значения совпадает с типом операнда.</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`not`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`not`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</source>
          <target state="translated">Вычисляет побитовое дополнение двух целочисленных значений, находящихся на вершине стека, и помещает результат в стек.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>60</source>
          <target state="translated">60</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>or</source>
          <target state="translated">или</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Computes the bitwise OR of two integer values, returns an integer.</source>
          <target state="translated">Выполняет побитовую операцию или для двух целочисленных значений и возвращает целое число.</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise OR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; поразрядное или вычислить.</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The <ph id="ph1">`or`</ph> instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</source>
          <target state="translated"><ph id="ph1">`or`</ph> Инструкция вычисляет побитовое или двух верхних значений в стеке, помещает результат в стек.</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`Or`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Or`</ph> представляет собой операцию целыми числами.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`or`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`or`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Removes the value currently on top of the evaluation stack.</source>
          <target state="translated">Удаляет значение, находящееся на вершине стека.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>26</source>
          <target state="translated">26</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>pop</source>
          <target state="translated">pop</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Pops the top value from the stack.</source>
          <target state="translated">Извлекает верхнее значение из стека.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The top value is popped from the stack.</source>
          <target state="translated">Верхнее значение извлекается из стека.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The <ph id="ph1">`pop`</ph> instruction removes the top element from the stack.</source>
          <target state="translated"><ph id="ph1">`pop`</ph> Инструкция удаляет верхний элемент в стеке.</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`pop`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`pop`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix1">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix2">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix3">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix4">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix5">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix6">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix7">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefixref">
          <source>This is a reserved instruction.</source>
          <target state="translated">Эта инструкция зарезервирована.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</source>
          <target state="translated">Указывает, что последующая операция, связанная с адресом массива, не выполняет никаких проверок во время выполнения и возвращает управляемый указатель, изменение которого запрещено.</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>FE 1E</source>
          <target state="translated">FE 1E</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>readonly.</source>
          <target state="translated">только для чтения.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</source>
          <target state="translated">Укажите, что операция адрес последующих массива не выполняет никаких проверок во время выполнения и возвращает управляемый указатель с ограниченной возможностью изменения.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>This prefix can only appear immediately preceding the <ph id="ph1">`ldelema`</ph> instruction and calls to the special <ph id="ph2">`Address`</ph> method on arrays.</source>
          <target state="translated">Этот префикс может использоваться только непосредственно предшествующего <ph id="ph1">`ldelema`</ph> инструкция и вызовы специальные <ph id="ph2">`Address`</ph> метод для массивов.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Its effect on the subsequent operation is twofold:</source>
          <target state="translated">Влияния на последующие операции двояко:</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>At run time, no type check operation is performed.</source>
          <target state="translated">Во время выполнения операций по проверке типа не выполняется.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Note that there is normally an implicit type check for the <ph id="ph1">`ldelema`</ph> and <ph id="ph2">`stelem`</ph> instructions when used on reference type arrays.</source>
          <target state="translated">Обратите внимание, что обычно выполняется неявная проверка типа для <ph id="ph1">`ldelema`</ph> и <ph id="ph2">`stelem`</ph> инструкциями по ссылке на тип массивов.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>There is never a run-time type check for value classes, so <ph id="ph1">`readonly`</ph> is a no-op in that case.</source>
          <target state="translated">Нет проверку типов во время выполнения для классы значений, поэтому <ph id="ph1">`readonly`</ph> в этом случае является холостой.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</source>
          <target state="translated">Проверяющий обрабатывает результат операции взятия адреса как управляемый указатель с ограниченной возможностью изменения.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</source>
          <target state="translated">Считается, что указатель имеет ограниченную возможность изменения определяющем типе, контролирует ли значение можно изменить.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</source>
          <target state="translated">Для классов значений, предоставляющих не открытые поля и методы, измените его значение в месте, курсор доступен только для чтения (поэтому имя префикса).</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</source>
          <target state="translated">В частности не предоставляют мутаторы классы, представляющие типы-примитивы (например, System.Int32) и таким образом, доступны только для чтения.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>A managed pointer restricted in this fashion can be used only in the following ways:</source>
          <target state="translated">Ограниченный подобным образом управляемый указатель может использоваться только следующими способами:</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`object`</ph> parameter for the <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, or<ph id="ph6">`constrained callvirt`</ph> instructions.</source>
          <target state="translated">Как <ph id="ph1">`object`</ph> параметр <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, или<ph id="ph6">`constrained callvirt`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`pointer`</ph> parameter to the <ph id="ph2">`ldobj`</ph> instruction or to one of the <ph id="ph3">`ldind`</ph> instructions.</source>
          <target state="translated">Как <ph id="ph1">`pointer`</ph> параметр <ph id="ph2">`ldobj`</ph> инструкций или одной из <ph id="ph3">`ldind`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`source`</ph> parameter to the <ph id="ph2">`cpobj`</ph> instruction.</source>
          <target state="translated">Как <ph id="ph1">`source`</ph> параметр <ph id="ph2">`cpobj`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>All other operations disallowed, including the <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, or <ph id="ph3">`mkrefany`</ph> operations, or any of the <ph id="ph4">`stind`</ph> instructions.</source>
          <target state="translated">Все остальные операции запрещены, включая <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, или <ph id="ph3">`mkrefany`</ph> операций или любой другой <ph id="ph4">`stind`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The purpose of the <ph id="ph1">`readonly`</ph> prefix is to avoid a type check when fetching an element from an array in generic code.</source>
          <target state="translated">Назначение <ph id="ph1">`readonly`</ph> префикс — для отключения проверки типа при выборке элемента из массива в универсальном коде.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For example, the expression <ph id="ph1">`arr[i].m()`</ph>, where the element type of the array <ph id="ph2">`arr`</ph> is a generic type that has been constrained to have an interface with method <ph id="ph3">`m`</ph>, might compile to the following MSIL.</source>
          <target state="translated">Например, выражение <ph id="ph1">`arr[i].m()`</ph>, где тип элемента массива <ph id="ph2">`arr`</ph> является универсальным типом, ограниченного до интерфейса с методом <ph id="ph3">`m`</ph>, может компилироваться в следующий MSIL.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Without the <ph id="ph1">`readonly`</ph> prefix, the <ph id="ph2">`ldelema`</ph> instruction would perform a type check in the case where !0 was a reference type.</source>
          <target state="translated">Без <ph id="ph1">`readonly`</ph> префикса, <ph id="ph2">`ldelema`</ph> будет выполнять проверку типов в случае инструкция где! 0 является ссылочным типом.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Not only is this type check inefficient, but it is semantically incorrect.</source>
          <target state="translated">Не только неэффективен эту проверку типа, но это семантически неправилен.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The type check for <ph id="ph1">`ldelema`</ph> is an exact match, which is too strong.</source>
          <target state="translated">Проверка типа <ph id="ph1">`ldelema`</ph> является точным соответствием, то есть очень строгим.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>If the array held subclasses of type !0, the code above would fail the type check.</source>
          <target state="translated">Если массив подклассы типа! 0, приведенный выше код не пройдут проверку типа.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The address of the array element is fetched, instead of the element itself, in order to have a handle for <ph id="ph1">`arr[i]`</ph> that works for both value types and reference types, and thus can be passed to the <ph id="ph2">`constrained callvirt`</ph> instruction.</source>
          <target state="translated">Адрес элемента массива извлекается, а не элемента, чтобы получить дескриптор для <ph id="ph1">`arr[i]`</ph> работает как типы значений и ссылочные типы что таким образом, может быть передан <ph id="ph2">`constrained callvirt`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</source>
          <target state="translated">В целом небезопасно пропускать проверку во время выполнения, если в массиве содержатся элементы ссылочного типа.</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</source>
          <target state="translated">В целях безопасности необходимо убедиться, что никакие изменения в массив выполняются через этот указатель.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier rules ensure this.</source>
          <target state="translated">Это проверить правила проверки.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</source>
          <target state="translated">Ограниченный управляемый указатель могут передаваться как объект вызовов методов экземпляра, поэтому он не является доступным только для чтения для типов значений, но не возникает проблем безопасности типа для типов значений.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`readonly`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`readonly`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Retrieves the type token embedded in a typed reference.</source>
          <target state="translated">Извлекает токен типа, внедренный в ссылку с определенным типом.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>FE 1D</source>
          <target state="translated">FE 1D</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>refanytype</source>
          <target state="translated">refanytype</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Pushes the type token stored in a typed reference.</source>
          <target state="translated">Помещает в стек лексему типа, хранящуюся в ссылку с определенным типом.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на тип значения помещается в стек.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The typed reference is popped from the stack and its corresponding type token retrieved.</source>
          <target state="translated">Ссылка с определенным типом извлекается из стека и получить его соответствующий тип маркера.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The type token is pushed onto the stack.</source>
          <target state="translated">Лексема типа помещается в стек.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">Ссылка с определенным типом содержит токен типа и адрес экземпляра объекта.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The <ph id="ph1">`refanytype`</ph> instruction retrieves the type token embedded in the typed reference.</source>
          <target state="translated"><ph id="ph1">`refanytype`</ph> Инструкция извлекает токен типа, внедренный в ссылку с определенным типом.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for information on creating typed references.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> сведения о создании ссылок с определенным типом.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanytype`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`refanytype`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Retrieves the address (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>) embedded in a typed reference.</source>
          <target state="translated">Извлекает адрес (тип <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>), внедренный в ссылку с определенным типом.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>refanyval <ph id="ph1">`type`</ph></source>
          <target state="translated">refanyval <ph id="ph1">`type`</ph></target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Pushes the address stored in a typed reference.</source>
          <target state="translated">Помещает в стек адрес, хранящийся в ссылку с определенным типом.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на тип значения помещается в стек.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The typed reference is popped from the stack and the corresponding address retrieved.</source>
          <target state="translated">Ссылка с определенным типом извлекается из стека и получить соответствующий адрес.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">Ссылка с определенным типом содержит токен типа и адрес экземпляра объекта.</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The <ph id="ph1">`refanyval`</ph> instruction retrieves the address embedded in the a typed reference.</source>
          <target state="translated"><ph id="ph1">`refanyval`</ph> Инструкция извлекает адрес, внедренный в ссылку с определенным типом.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The type embedded in the typed reference supplied on the stack must match the type specified by <ph id="ph1">`type`</ph> (a metadata token, either a <ph id="ph2">`typedef`</ph> or a <ph id="ph3">`typeref`</ph>).</source>
          <target state="translated">Тип, внедренный в ссылку с определенным типом в стеке должны совпадать с типом, указанным <ph id="ph1">`type`</ph> (токен метаданных, либо <ph id="ph2">`typedef`</ph> или <ph id="ph3">`typeref`</ph>).</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for related content.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> Дополнительные сведения.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> is not identical to the type stored in the type reference (in this case, <ph id="ph3">`type`</ph> is the class supplied to the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction that constructed said typed reference).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> возникает, если <ph id="ph2">`type`</ph> не идентичен типу, хранящемуся в ссылку на тип (в этом случае <ph id="ph3">`type`</ph> класса передается <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> типизированную ссылку говорят, что инструкции, который создан).</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если <ph id="ph2">`type`</ph> не найден.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanyval`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`refanyval`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Divides two values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">Делит одно значение на другое и помещает остаток в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>5D</source>
          <target state="translated">5D</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>rem</source>
          <target state="translated">REM</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Pushes the remainder of dividing <ph id="ph1">`value1`</ph> by <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">Помещает остаток от деления <ph id="ph1">`value1`</ph> по <ph id="ph2">`value2`</ph> в стек.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ReplaceThisText</source>
          <target state="translated">ReplaceThisText</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>A <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">Объект <ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека и остаток <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> вычисляется.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> удовлетворяет следующим условиям:</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), и:</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, sign(<ph id="ph3">`result`</ph>) = sign(<ph id="ph4">`value1`</ph>), where <ph id="ph5">`div`</ph> is the division instruction that truncates towards zero.</source>
          <target state="translated">0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, знак (<ph id="ph3">`result`</ph>) = знак (<ph id="ph4">`value1`</ph>), где <ph id="ph5">`div`</ph> деления инструкция, которая усекает к нулю.</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is zero or <ph id="ph2">`value1`</ph> is infinity the result is NaN.</source>
          <target state="translated">Если <ph id="ph1">`value2`</ph> равно нулю или <ph id="ph2">`value1`</ph> = бесконечность, результатом будет NaN.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is infinity, the result is <ph id="ph2">`value1`</ph> (negated for <ph id="ph3">`-infinity`</ph>).</source>
          <target state="translated">Если <ph id="ph1">`value2`</ph> бесконечно, результатом является <ph id="ph2">`value1`</ph> (инвертировано для <ph id="ph3">`-infinity`</ph>).</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Целочисленные операции создают исключение <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> Если <ph id="ph2">`value2`</ph> равно нулю.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Note that on the Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint <ph id="ph2">`rem`</ph> -1).</source>
          <target state="translated">Обратите внимание, что на платформах на базе Intel <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает при вычислении (minint <ph id="ph2">`rem`</ph> -1).</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`rem`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Divides two unsigned values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">Делит одно значение без знака на другое значение без знака и помещает остаток в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>5E</source>
          <target state="translated">5E</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>rem.un</source>
          <target state="translated">REM.un</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Pushes the remainder of dividing unsigned <ph id="ph1">`value1`</ph> by unsigned <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">Помещает остаток от деления числа без знака <ph id="ph1">`value1`</ph> на значение без знака <ph id="ph2">`value2`</ph> в стек.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека и остаток <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> вычисляется.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> удовлетворяет следующим условиям:</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x(<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x (<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), и:</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>0 = <ph id="ph1">`result`</ph><ph id="ph2"> &lt; </ph><ph id="ph3">`value2`</ph>, where <ph id="ph4">`div.un`</ph> is the unsigned division instruction.</source>
          <target state="translated">0 = <ph id="ph1">`result`</ph> <ph id="ph2"> &lt; </ph> <ph id="ph3">`value2`</ph>, где <ph id="ph4">`div.un`</ph> инструкция деления числа без знака.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The <ph id="ph1">`rem.un`</ph> instruction computes <ph id="ph2">`result`</ph> and pushes it on the stack.</source>
          <target state="translated"><ph id="ph1">`rem.un`</ph> Инструкция вычисляет <ph id="ph2">`result`</ph> и помещает в стек.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> treats its arguments as unsigned integers, while <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> treats them as signed integers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> считает его аргументы целых чисел без знака, пока <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> обрабатывает их как целых чисел.</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> is unspecified for floating-point numbers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> не определен для чисел с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">Целочисленные операции создают исключение <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> Если <ph id="ph2">`value2`</ph> равно нулю.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`rem.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</source>
          <target state="translated">Выполняет возврат из текущего метода, помещая возвращаемое значение (если имеется) из стека вычислений вызываемого метода в стек вычислений вызывающего метода.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>2A</source>
          <target state="translated">2A</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ret</source>
          <target state="translated">Возвращаемое значение</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from method, possibly returning a value.</source>
          <target state="translated">Возврат из метода, возможно, с возвращаемым значением.</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value is popped from the callee evaluation stack.</source>
          <target state="translated">Возвращаемое значение извлекается из стека вычислений вызываемого объекта.</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value obtained in step 1 is pushed onto the caller evaluation stack.</source>
          <target state="translated">Возвращаемое значение, полученное на шаге 1, помещается в стек вычислений вызывающего объекта.</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</source>
          <target state="translated">Если возвращаемое значение отсутствует в стеке вычислений вызываемого объекта, возвращаемое значение отсутствует (нет стека вариантов поведения для метода, вызываемого и вызывающего объекта).</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</source>
          <target state="translated">Тип возвращаемого значения, если таковые имеются, текущего метода определяет тип значения для выборки из верхней части стека и копируемого в стек метода, который вызвал текущий метод.</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The evaluation stack for the current method must be empty except for the value to be returned.</source>
          <target state="translated">В стеке вычислений текущего метода должен быть пустым, за исключением возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The <ph id="ph1">`ret`</ph> instruction cannot be used to transfer control out of a<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated"><ph id="ph1">`ret`</ph> Инструкция не может использоваться для передачи управления из<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, или <ph id="ph5">`finally`</ph> блока.</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>From within a <ph id="ph1">`try`</ph> or <ph id="ph2">`catch`</ph>, use the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction with a destination of a <ph id="ph4">`ret`</ph> instruction that is outside all enclosing exception blocks.</source>
          <target state="translated">Изнутри <ph id="ph1">`try`</ph> или <ph id="ph2">`catch`</ph>, используйте <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> инструкцию с помощью назначения <ph id="ph4">`ret`</ph> инструкция, которая находится за пределами всех блоков исключения.</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Because the <ph id="ph1">`filter`</ph> and <ph id="ph2">`finally`</ph> blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a <ph id="ph3">`filter`</ph> or <ph id="ph4">`finally`</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">`filter`</ph> и <ph id="ph2">`finally`</ph> блоки логически являются частью механизма обработки исключений и не метода, в котором находится их код, правильно созданные инструкции промежуточного языка Майкрософт (MSIL) не выполняют возврат из внутри метода <ph id="ph3">`filter`</ph> или <ph id="ph4">`finally`</ph>.</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ret`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`ret`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception.</source>
          <target state="translated">Возвращает текущее исключение.</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>FE 1A</source>
          <target state="translated">FE 1A</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>rethrow</source>
          <target state="translated">заново создать</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception</source>
          <target state="translated">Возвращает текущее исключение.</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>No stack transition behavior is defined for this instruction.</source>
          <target state="translated">Нет стека Переходные состояния для данной инструкции.</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The <ph id="ph1">`rethrow`</ph> instruction is only permitted within the body of a <ph id="ph2">`catch`</ph> handler.</source>
          <target state="translated"><ph id="ph1">`rethrow`</ph> Инструкция допускается только в теле <ph id="ph2">`catch`</ph> обработчика.</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>It throws the same exception that was caught by this handler.</source>
          <target state="translated">Метод создает исключение, которое было перехвачено этим обработчиком.</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rethrow`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`rethrow`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Смещает целочисленное значение влево (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>62</source>
          <target state="translated">62</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>shl</source>
          <target state="translated">Shl</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer to the left (shifting in zeros).</source>
          <target state="translated">Смещает целое число влево (с заполнением нулями).</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">Количество бит, помещается в стек.</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</source>
          <target state="translated">Число бит и значения извлекаются из стека; значение смещается влево на указанное число бит.</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The <ph id="ph1">`shl`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) left by the specified number of bits.</source>
          <target state="translated"><ph id="ph1">`shl`</ph> Инструкция смещает значение (типа <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> или <ph id="ph4">`native int`</ph>) влево на указанное число бит.</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">Число битов равно значение типа <ph id="ph1">`int32`</ph> или <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">Возвращаемое значение не определено, если число бит, больше или равен ширине (в битах) заданного значения.</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source><ph id="ph1">`Shl`</ph> inserts a zero bit in the lowest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shl`</ph> вставляет нулевой разряд в нижнюю позицию при каждом смещении.</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shl`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`shl`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Смещает целочисленное значение вправо (с знаковым битом) на заданное число бит и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>63</source>
          <target state="translated">63</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>shr</source>
          <target state="translated">Shr</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer to the right (shifting in sign).</source>
          <target state="translated">Смещает целое число вправо (с заполнением входа).</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">Количество бит, помещается в стек.</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">Число бит и значения извлекаются из стека; значение сдвигаются вправо на указанное число бит.</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated"><ph id="ph1">`shr.un`</ph> Инструкция смещает значение (типа <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> или <ph id="ph4">`native int`</ph>) вправо на указанное число бит.</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">Число битов равно значение типа <ph id="ph1">`int32`</ph> или <ph id="ph2">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">Возвращаемое значение не определено, если число бит, больше или равен ширине (в битах) заданного значения.</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source><ph id="ph1">`Shr`</ph> replicates the high order bit on each shift, preserving the sign of the original value in the <ph id="ph2">`result`</ph>.</source>
          <target state="translated"><ph id="ph1">`Shr`</ph> реплицирует старших битов для каждой смены, сохраняя знак исходного значения в <ph id="ph2">`result`</ph>.</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`shr`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">Смещает целочисленное значение без знака вправо (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>64</source>
          <target state="translated">64</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>shr.un</source>
          <target state="translated">Shr.un</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an integer to the right (shifting in zeroes).</source>
          <target state="translated">Смещает целое число вправо (с заполнением нулями).</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">Количество бит, помещается в стек.</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">Число бит и значения извлекаются из стека; значение сдвигаются вправо на указанное число бит.</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated"><ph id="ph1">`shr.un`</ph> Инструкция смещает значение (типа <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> или <ph id="ph4">`native int`</ph>) вправо на указанное число бит.</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> or <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">Число битов равно значение типа <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> или <ph id="ph3">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">Возвращаемое значение не определено, если число бит, больше или равен ширине (в битах) заданного значения.</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source><ph id="ph1">`Shr.un`</ph> inserts a zero bit in the highest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shr.un`</ph> вставляет нулевой разряд в верхнюю позицию при каждом смещении.</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`shr.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</source>
          <target state="translated">Помещает в стек вычислений сведения о размере (в байтах) заданного типа значения.</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>FE 1C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 1C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>sizeof <ph id="ph1">`valType`</ph></source>
          <target state="translated">sizeof <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Push the size, in bytes, of a value type as an <ph id="ph1">`unsigned int32`</ph>.</source>
          <target state="translated">Принудительная размер в байтах, тип значения в качестве <ph id="ph1">`unsigned int32`</ph>.</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The size (in bytes) of the supplied value type (<ph id="ph1">`valType`</ph>) is pushed onto the stack.</source>
          <target state="translated">Размер (в байтах) заданного типа значения (<ph id="ph1">`valType`</ph>) помещается в стек.</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source><ph id="ph1">`valType`</ph> must be a metadata token (a <ph id="ph2">`typeref`</ph> or <ph id="ph3">`typedef`</ph>) that specifies a value type, reference type, or generic type parameter.</source>
          <target state="translated"><ph id="ph1">`valType`</ph> должен быть токен метаданных ( <ph id="ph2">`typeref`</ph> или <ph id="ph3">`typedef`</ph>), указывающий тип значения, ссылочный тип или параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</source>
          <target state="translated">Для ссылочного типа возвращаемый размер — размер значение ссылки, соответствующего типа (4 байта в 32-разрядных систем), не размер данных, хранящихся в объектах, на который ссылается значение ссылки.</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>A generic type parameter can be used only in the body of the type or method that defines it.</source>
          <target state="translated">Параметр универсального типа может использоваться только в теле типа или метода, который определяет его.</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</source>
          <target state="translated">При создании экземпляра типа или метода, параметр универсального типа заменяется типом значения или ссылочным типом.</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sizeof`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`sizeof`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index.</source>
          <target state="translated">Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>FE 0B &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0B &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>starg <ph id="ph1">`num`</ph></source>
          <target state="translated">starg <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">Значение, находящееся на вершине стека извлекается и помещается в ячейку аргумента <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The <ph id="ph1">`starg`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated"><ph id="ph1">`starg`</ph> Инструкция извлекает значение из стека и помещает его в ячейке аргумента <ph id="ph2">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">Тип значения должен соответствовать типу аргумента, как указано в подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">В процедурах, принимающих переменные списки аргументов <ph id="ph1">`starg`</ph> инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.</target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">В случае использования аргументов, хранящих целочисленное значение меньше 4 байтов, значение усекается при перемещении из стека в аргумент.</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`starg`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, короткое)</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</source>
          <target state="translated">Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом (короткая форма).</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>starg.s <ph id="ph1">`num`</ph></source>
          <target state="translated">starg.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>, short form.</source>
          <target state="translated">Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента <ph id="ph1">`num`</ph>, краткая форма.</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">Значение, находящееся на вершине стека извлекается и помещается в ячейку аргумента <ph id="ph1">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated"><ph id="ph1">`starg.s`</ph> Инструкция извлекает значение из стека и помещает его в ячейке аргумента <ph id="ph2">`num`</ph>.</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">Тип значения должен соответствовать типу аргумента, как указано в подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction provides an efficient encoding for use with the first 256 arguments.</source>
          <target state="translated"><ph id="ph1">`starg.s`</ph> Инструкция обеспечивает эффективную кодировку для использования с первых 256 аргументов.</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">В процедурах, принимающих переменные списки аргументов <ph id="ph1">`starg.s`</ph> инструкция может использоваться только для исходных фиксированных аргументов, не указанные в переменной части подписи.</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">В случае использования аргументов, хранящих целочисленное значение меньше 4 байтов, значение усекается при перемещении из стека в аргумент.</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`starg.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, byte)</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение в стеке вычислений, тип которого указан в инструкции.</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>stelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">stelem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at the supplied index with a value of type <ph id="ph1">`typeTok`</ph> on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение типа <ph id="ph1">`typeTok`</ph> в стеке.</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An index value, <ph id="ph1">`index`</ph>, to an element in <ph id="ph2">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Значение индекса <ph id="ph1">`index`</ph>, на элемент в <ph id="ph2">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A value of the type specified in the instruction is pushed onto the stack.</source>
          <target state="translated">Значение типа, указанного в инструкции помещается в стек.</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The <ph id="ph1">`stelem`</ph> instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <ph id="ph2">`array`</ph> with the value.</source>
          <target state="translated"><ph id="ph1">`stelem`</ph> Инструкция заменяет значение элемента с заданным индексом (с нуля) в одномерном массиве <ph id="ph2">`array`</ph> со значением.</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value has the type specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">Значение имеет тип, указанный в токен <ph id="ph1">`typeTok`</ph> в инструкции.</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="native int" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>9B</source>
          <target state="translated">9B</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>stelem.i</source>
          <target state="translated">stelem.i</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`native int`</ph> value on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`native int`</ph> значение в стеке.</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The <ph id="ph1">`stelem.i`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`native int`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i`</ph> Инструкция заменяет значение элемента <ph id="ph2">`index`</ph> в одномерном массиве <ph id="ph3">`array`</ph> с <ph id="ph4">`native int`</ph> значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.i`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение <ph id="ph1">&lt;see langword="int8" /&gt;</ph>, находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>9C</source>
          <target state="translated">9C</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>stelem.i1</source>
          <target state="translated">stelem.i1</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int8`</ph> value on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`int8`</ph> значение в стеке.</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The <ph id="ph1">`stelem.i1`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int8`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i1`</ph> Инструкция заменяет значение элемента <ph id="ph2">`index`</ph> в одномерном массиве <ph id="ph3">`array`</ph> с <ph id="ph4">`int8`</ph> значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.i1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int16" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение <ph id="ph1">&lt;see langword="int16" /&gt;</ph>, находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>9D</source>
          <target state="translated">9D</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>stelem.i2</source>
          <target state="translated">stelem.i2</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int16`</ph> value on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`int16`</ph> значение в стеке.</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The <ph id="ph1">`stelem.i2`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int16`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i2`</ph> Инструкция заменяет значение элемента <ph id="ph2">`index`</ph> в одномерном массиве <ph id="ph3">`array`</ph> с <ph id="ph4">`int16`</ph> значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.i2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>9E</source>
          <target state="translated">9E</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>stelem.i4</source>
          <target state="translated">stelem.i4</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int32`</ph> value on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`int32`</ph> значение в стеке.</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The <ph id="ph1">`stelem.i4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int32`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i4`</ph> Инструкция заменяет значение элемента <ph id="ph2">`index`</ph> в одномерном массиве <ph id="ph3">`array`</ph> с <ph id="ph4">`int32`</ph> значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.i4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>9F</source>
          <target state="translated">9F</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>stelem.i8</source>
          <target state="translated">stelem.i8</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int64`</ph> value on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`int64`</ph> значение в стеке.</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The <ph id="ph1">`stelem.i8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int64`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i8`</ph> Инструкция заменяет значение элемента <ph id="ph2">`index`</ph> в одномерном массиве <ph id="ph3">`array`</ph> с <ph id="ph4">`int64`</ph> значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.i8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение <ph id="ph1">&lt;see langword="float32" /&gt;</ph>, находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A0</source>
          <target state="translated">A0</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>stelem.r4</source>
          <target state="translated">stelem.r4</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float32`</ph> value on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`float32`</ph> значение в стеке.</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The <ph id="ph1">`stelem.r4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float32`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.r4`</ph> Инструкция заменяет значение элемента <ph id="ph2">`index`</ph> в одномерном массиве <ph id="ph3">`array`</ph> с <ph id="ph4">`float32`</ph> значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.r4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение <ph id="ph1">&lt;see langword="float64" /&gt;</ph>, находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A1</source>
          <target state="translated">A1</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>stelem.r8</source>
          <target state="translated">stelem.r8</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float64`</ph> value on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`float64`</ph> значение в стеке.</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The <ph id="ph1">`stelem.r8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float64`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.r8`</ph> Инструкция заменяет значение элемента <ph id="ph2">`index`</ph> в одномерном массиве <ph id="ph3">`array`</ph> с <ph id="ph4">`float64`</ph> значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.r8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces the array element at a given index with the object ref value (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) on the evaluation stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом на значение object ref (тип <ph id="ph1">&lt;see langword="O" /&gt;</ph>), находящееся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A2</source>
          <target state="translated">A2</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>stelem.ref</source>
          <target state="translated">stelem.ref</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`ref`</ph> value (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated">Заменяет элемент массива с заданным индексом <ph id="ph1">`ref`</ph> значение (типа <ph id="ph2">`O`</ph>) в стеке.</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект в массив, <ph id="ph1">`array`</ph>, помещенный в стек.</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">Допустимый индекс элемента в <ph id="ph1">`array`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива с заданным индексом.</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The <ph id="ph1">`stelem.ref`</ph> instruction replaces the value of the element at the supplied index in the one-dimensional array <ph id="ph2">`array`</ph> with the <ph id="ph3">`ref`</ph> (type <ph id="ph4">`O`</ph>) value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.ref`</ph> Инструкция заменяет значение элемента с заданным индексом в одномерном массиве <ph id="ph2">`array`</ph> с <ph id="ph3">`ref`</ph> (типа <ph id="ph4">`O`</ph>) значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">Массивы являются объектами, поэтому они представлены значением типа <ph id="ph1">`O`</ph>.</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">Индекс является типом <ph id="ph1">`native int`</ph>.</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Note that <ph id="ph1">`stelem.ref`</ph> implicitly casts the supplied value to the element type of <ph id="ph2">`array`</ph> before assigning the value to the array element.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`stelem.ref`</ph> неявное приведение этого значения для типа элемента <ph id="ph2">`array`</ph> перед присвоением значения элементу массива.</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>This cast can fail, even for verified code.</source>
          <target state="translated">Это приведение может завершиться ошибкой, даже для проверяемого кода.</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Thus the <ph id="ph1">`stelem.ref`</ph> instruction can throw <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</source>
          <target state="translated">Таким образом <ph id="ph1">`stelem.ref`</ph> инструкция может вызывать <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class provides a <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> method.</source>
          <target state="translated">Для одномерных массивов с индексацией не от нуля и для многомерных массивов <ph id="ph1">&lt;xref:System.Array&gt;</ph> класс предоставляет <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> возникает, если <ph id="ph2">`index`</ph> является отрицательным или больше, чем значение границы <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> возникает, если <ph id="ph2">`array`</ph> не содержит элементов требуемого типа.</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.ref`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stelem.ref`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value stored in the field of an object reference or pointer with a new value.</source>
          <target state="translated">Заменяет значение в поле объекта, по ссылке на объект или указателю, на новое значение.</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>stfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value of <ph id="ph1">`field`</ph> of the object with a new value.</source>
          <target state="translated">Заменяет значение <ph id="ph1">`field`</ph> объекта с новым значением.</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>An object reference or pointer is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект или указатель помещается в стек.</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The value and the object reference/pointer are popped from the stack; the value of <ph id="ph1">`field`</ph> in the object is replaced with the supplied value.</source>
          <target state="translated">Значение и указатель и ссылки объектов извлекаются из стека; значение <ph id="ph1">`field`</ph> в объекте заменяется указанное значение.</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction replaces the value of a field of an object (type <ph id="ph2">`O`</ph>) or via a pointer (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) with a given value.</source>
          <target state="translated"><ph id="ph1">`stfld`</ph> Инструкция заменяет значение поля объекта (тип <ph id="ph2">`O`</ph>) или через указатель (типа <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, или <ph id="ph5">`*`</ph>) с указанным значением.</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">`Field`</ph> is a metadata token that refers to a field member reference.</source>
          <target state="translated"><ph id="ph1">`Field`</ph> представляет собой лексему метаданных, которая ссылается на член ссылки на поле.</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction can have a prefix of either or both of <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`stfld`</ph> Инструкции может иметь префикс из одной или обеих <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference or pointer is a null reference and the field isn't static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызывается, если ссылка на объект или указатель является пустой ссылкой и нестатического поля.</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if <ph id="ph2">`field`</ph> is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> возникает, если <ph id="ph2">`field`</ph> не найден в метаданных.</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</source>
          <target state="translated">Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуется в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stfld`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stfld`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Сохраняет значение с типом <ph id="ph1">&lt;see langword="native int" /&gt;</ph> по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>DF</source>
          <target state="translated">DF</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>stind.i</source>
          <target state="translated">stind.i</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a <ph id="ph1">`native int`</ph> value at a given address.</source>
          <target state="translated">Магазины <ph id="ph1">`native int`</ph> значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The <ph id="ph1">`stind.i`</ph> instruction stores a <ph id="ph2">`native int`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i`</ph> Хранилищ инструкция <ph id="ph2">`native int`</ph> значение по указанному адресу (тип <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.i`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.i`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.i`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Сохраняет значение с типом <ph id="ph1">&lt;see langword="int8" /&gt;</ph> по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>52</source>
          <target state="translated">52</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>stind.i1</source>
          <target state="translated">stind.i1</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores an <ph id="ph1">`int8`</ph> value at a given address.</source>
          <target state="translated">Магазины <ph id="ph1">`int8`</ph> значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The <ph id="ph1">`stind.i1`</ph> instruction stores an <ph id="ph2">`int8`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i1`</ph> Хранилищ инструкция <ph id="ph2">`int8`</ph> значение по указанному адресу (тип <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i1`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.i1`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The operation of the <ph id="ph1">`stind.i1`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.i1`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.i1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Сохраняет значение с типом <ph id="ph1">&lt;see langword="int16" /&gt;</ph> по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>53</source>
          <target state="translated">53</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>stind.i2</source>
          <target state="translated">stind.I2</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores an <ph id="ph1">`int16`</ph> value at a given address.</source>
          <target state="translated">Магазины <ph id="ph1">`int16`</ph> значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The <ph id="ph1">`stind.i2`</ph> instruction stores an <ph id="ph2">`int16`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i2`</ph> Хранилищ инструкция <ph id="ph2">`int16`</ph> значение по указанному адресу (тип <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Type safe operation requires that the <ph id="ph1">`stind.2i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.2i`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The operation of the <ph id="ph1">`stind.i2`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.i2`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.i2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Сохраняет значение с типом <ph id="ph1">&lt;see langword="int32" /&gt;</ph> по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>54</source>
          <target state="translated">54</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>stind.i4</source>
          <target state="translated">stind.i4</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores an <ph id="ph1">`int32`</ph> value at a given address.</source>
          <target state="translated">Магазины <ph id="ph1">`int32`</ph> значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The <ph id="ph1">`stind.i4`</ph> instruction stores an <ph id="ph2">`int32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i4`</ph> Хранилищ инструкция <ph id="ph2">`int32`</ph> значение по указанному адресу (тип <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.i4`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The operation of the <ph id="ph1">`stind.i4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.i4`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.i4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Сохраняет значение с типом <ph id="ph1">&lt;see langword="int64" /&gt;</ph> по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>55</source>
          <target state="translated">55</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>stind.i8</source>
          <target state="translated">stind.I8</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores an <ph id="ph1">`int64`</ph> value at a given address.</source>
          <target state="translated">Магазины <ph id="ph1">`int64`</ph> значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The <ph id="ph1">`stind.i8`</ph> instruction stores an <ph id="ph2">`int64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i8`</ph> Хранилищ инструкция <ph id="ph2">`int64`</ph> значение по указанному адресу (тип <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.i8`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.i`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.i8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Сохраняет значение с типом <ph id="ph1">&lt;see langword="float32" /&gt;</ph> по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>56</source>
          <target state="translated">56</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>stind.r4</source>
          <target state="translated">stind.R4</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a <ph id="ph1">`float32`</ph> value at a given address.</source>
          <target state="translated">Магазины <ph id="ph1">`float32`</ph> значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The <ph id="ph1">`stind.r4`</ph> instruction stores a <ph id="ph2">`float32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.r4`</ph> Хранилищ инструкция <ph id="ph2">`float32`</ph> значение по указанному адресу (тип <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.r4`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The operation of the <ph id="ph1">`stind.r4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.r4`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r4`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.r4`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">Сохраняет значение с типом <ph id="ph1">&lt;see langword="float64" /&gt;</ph> по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>57</source>
          <target state="translated">57</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>stind.r8</source>
          <target state="translated">stind.R8</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a <ph id="ph1">`float64`</ph> value at a given address.</source>
          <target state="translated">Магазины <ph id="ph1">`float64`</ph> значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The <ph id="ph1">`stind.r8`</ph> instruction stores a <ph id="ph2">`float64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.r8`</ph> Хранилищ инструкция <ph id="ph2">`float64`</ph> значение по указанному адресу (тип <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, или <ph id="ph5">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.r8`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The operation of the <ph id="ph1">`stind.r8`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.r8`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r8`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.r8`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores a object reference value at a supplied address.</source>
          <target state="translated">Сохраняет значение ссылки на объект по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>51</source>
          <target state="translated">51</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>stind.ref</source>
          <target state="translated">stind.ref</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores an object reference (type <ph id="ph1">`O`</ph>) value at a given address.</source>
          <target state="translated">Хранит ссылку на объект (тип <ph id="ph1">`O`</ph>) значение по указанному адресу.</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">Значение и адрес извлекаются из стека; значение хранится по адресу.</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The <ph id="ph1">`stind.ref`</ph> instruction stores an object reference value at the supplied address (type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.ref`</ph> Инструкция сохраняет значение ссылки на объект по указанному адресу (тип <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, или <ph id="ph4">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Type safe operation requires that the <ph id="ph1">`stind.ref`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">Требует обеспечения безопасности типов, <ph id="ph1">`stind.ref`</ph> инструкция использоваться в соответствии с типом указателя.</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The operation of the <ph id="ph1">`stind.ref`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stind.ref`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`addr`</ph> не выровнен естественным образом для данного типа аргумента, который содержится в суффиксе инструкции.</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.ref`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stind.ref`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</source>
          <target state="translated">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с заданным индексом.</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>FE 0E &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0E &amp;LT; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>stloc <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Извлекает значение из стека и сохраняет его в локальной переменной <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Значение извлекается из стека и помещается в локальную переменную <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The <ph id="ph1">`stloc`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`stloc`</ph> Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с номером <ph id="ph2">`index`</ph>, где локальных переменных, начиная от 0.</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную.</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions require that <ph id="ph1">`index`</ph> be a valid local index.</source>
          <target state="translated">Правильные инструкции промежуточного языка Майкрософт (MSIL) требуют <ph id="ph1">`index`</ph> быть допустимый локальный индекс.</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>For the <ph id="ph1">`stloc`</ph> instruction, <ph id="ph2">`index`</ph> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</source>
          <target state="translated">Для <ph id="ph1">`stloc`</ph> инструкции, <ph id="ph2">`index`</ph> должен находиться в диапазоне 0 — 65 534 включительно (в частности, недопустимо 65535).</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</source>
          <target state="translated">За исключением 65535 обусловлено прагматичное использование: возможны реализации, использующие 2-байтовое целое число для отслеживания как индекса локальной переменной, а также общее количество локальных данного метода.</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">Если индекс 65 535 считался действительным, потребуется расширить целое число для отслеживания числа локальные переменные в этом методе.</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`stloc`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (код операции, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (OpCode, короткое)</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</source>
          <target state="translated">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 0.</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>0A</source>
          <target state="translated">0A</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>stloc.0</source>
          <target state="translated">stloc.0</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops a value from the stack into local variable 0.</source>
          <target state="translated">Извлекает значение из стека в локальную переменную 0.</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>A value is popped off of the stack and placed in the local variable indexed by 0.</source>
          <target state="translated">Значение извлекается из стека и помещается в локальную переменную с индексом 0.</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The <ph id="ph1">`stloc.0`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</source>
          <target state="translated"><ph id="ph1">`stloc.0`</ph> Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 0.</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source><ph id="ph1">`stloc.0`</ph> is an especially efficient encoding for storing values in local variable 0.</source>
          <target state="translated"><ph id="ph1">`stloc.0`</ph> является особенно эффективным кодировки для сохранения значений в локальной переменной 0.</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную.</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.0`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stloc.0`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</source>
          <target state="translated">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 1.</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>0B</source>
          <target state="translated">0B</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>stloc.1</source>
          <target state="translated">stloc.1</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops a value from the stack into local variable 1.</source>
          <target state="translated">Извлекает значение из стека в локальной переменной 1.</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>A value is popped off of the stack and placed in the local variable indexed by 1.</source>
          <target state="translated">Значение извлекается из стека и помещается в локальную переменную с индексом 1.</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The <ph id="ph1">`stloc.1`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</source>
          <target state="translated"><ph id="ph1">`stloc.1`</ph> Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 1.</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source><ph id="ph1">`stloc.1`</ph> is an especially efficient encoding for storing values in local variable 1.</source>
          <target state="translated"><ph id="ph1">`stloc.1`</ph> является особенно эффективным кодировки для сохранения значений в локальной переменной 1.</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную.</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.1`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stloc.1`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</source>
          <target state="translated">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 2.</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>0C</source>
          <target state="translated">0C</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>stloc.2</source>
          <target state="translated">stloc.2</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops a value from the stack into local variable 2</source>
          <target state="translated">Извлекает значение из стека в локальную переменную 2</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>A value is popped off of the stack and placed in the local variable indexed by 2.</source>
          <target state="translated">Значение извлекается из стека и помещается в локальную переменную, индексированный по 2.</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The <ph id="ph1">`stloc.2`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</source>
          <target state="translated"><ph id="ph1">`stloc.2`</ph> Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную, индексированный по 2.</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source><ph id="ph1">`stloc.2`</ph> is an especially efficient encoding for storing values in local variable 2.</source>
          <target state="translated"><ph id="ph1">`stloc.2`</ph> является особенно эффективным кодировки для сохранения значений в локальной переменной 2.</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную.</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.2`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stloc.2`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</source>
          <target state="translated">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 3.</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>0D</source>
          <target state="translated">0D</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>stloc.3</source>
          <target state="translated">stloc.3</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops a value from the stack into local variable 3</source>
          <target state="translated">Извлекает значение из стека в локальную переменную 3</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>A value is popped off of the stack and placed in the local variable indexed by 3.</source>
          <target state="translated">Значение извлекается из стека и помещается в локальную переменную с индексом 3.</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The <ph id="ph1">`stloc.3`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</source>
          <target state="translated"><ph id="ph1">`stloc.3`</ph> Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 3.</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source><ph id="ph1">`stloc.3`</ph> is an especially efficient encoding for storing values in local variable 3.</source>
          <target state="translated"><ph id="ph1">`stloc.3`</ph> является особенно эффективным кодировки для сохранения значений в локальной переменной 3.</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную.</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.3`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stloc.3`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <ph id="ph1">&lt;paramref name="index" /&gt;</ph> (short form).</source>
          <target state="translated">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом <ph id="ph1">&lt;paramref name="index" /&gt;</ph> (короткая форма).</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>stloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">Извлекает значение из стека и сохраняет его в локальной переменной <ph id="ph1">`index`</ph>, краткая форма.</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">Значение извлекается из стека и помещается в локальную переменную <ph id="ph1">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`stloc.s`</ph> Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с номером <ph id="ph2">`index`</ph>, где локальных переменных, начиная от 0.</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">Тип значения должен совпадать тип локальной переменной, указанной в локальной подписи текущего метода.</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction provides an efficient encoding for local variables 0 through 255.</source>
          <target state="translated"><ph id="ph1">`stloc.s`</ph> Инструкция обеспечивает эффективную кодировку для локальных переменных с 0 до 255.</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">При сохранении в локальные переменные, содержащие целочисленные значения меньше 4 байтов, значение усекается при перемещении из стека в локальную переменную.</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">Значения с плавающей запятой округляются от исходного размера (тип <ph id="ph1">`F`</ph>) до размера аргумента.</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc.s`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`stloc.s`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (код операции, LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, byte)</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Copies a value of a specified type from the evaluation stack into a supplied memory address.</source>
          <target state="translated">Копирует значение с заданным типом из стека вычислений в указанный адрес памяти.</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>stobj <ph id="ph1">`class`</ph></source>
          <target state="translated">stobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Stores a value of type <ph id="ph1">`class`</ph> from the stack into memory.</source>
          <target state="translated">Сохраняет значение типа <ph id="ph1">`class`</ph> из стека в память.</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>A value type object of type <ph id="ph1">`class`</ph> is pushed onto the stack.</source>
          <target state="translated">Объект типа значения типа <ph id="ph1">`class`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The object and the address are popped from the stack; the value type object is stored at the address.</source>
          <target state="translated">Объект и адрес извлекаются из стека; объект типа значения хранятся по адресу.</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The <ph id="ph1">`stobj`</ph> instruction copies the value type object into the address specified by the address (a pointer of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stobj`</ph> Инструкция копирует объект типа значения в адрес, заданный этим адресом (указатель типа <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, или <ph id="ph4">`&amp;`</ph>).</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The number of bytes copied depends on the size of the class represented by <ph id="ph1">`class`</ph>, a metadata token representing a value type.</source>
          <target state="translated">Число копируемых байтов зависит от размера класса, представленный <ph id="ph1">`class`</ph>, токен метаданных, представляющий тип значения.</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The operation of the <ph id="ph1">`stobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">Работу <ph id="ph1">`stobj`</ph> инструкция может быть изменено, непосредственно предшествующий <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> префиксная инструкция.</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если не удается найти класс.</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stobj`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stobj`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value of a static field with a value from the evaluation stack.</source>
          <target state="translated">Заменяет значение статического поля на значение из стека вычислений.</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>stsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value in <ph id="ph1">`field`</ph> with a supplied value.</source>
          <target state="translated">Заменяет значение в <ph id="ph1">`field`</ph> заданным значением.</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is popped from the stack and stored in <ph id="ph1">`field`</ph>.</source>
          <target state="translated">Значение извлекается из стека и сохраняется в <ph id="ph1">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction replaces the value of a static field with a value from the stack.</source>
          <target state="translated"><ph id="ph1">`stsfld`</ph> Инструкция заменяет значение статического поля на значение из стека.</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">`field`</ph> is a metadata token that must refer to a static field member.</source>
          <target state="translated"><ph id="ph1">`field`</ph> представляет собой лексему метаданных, который должен ссылаться на элемент статического поля.</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction may be prefixed by <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`stsfld`</ph> Инструкции может иметь префикс в <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> возникает, если поле не найдено в метаданных.</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">Обычно это проверяется инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинном коде, не во время выполнения.</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stsfld`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`stsfld`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit(OpCode, FieldInfo)</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another and pushes the result onto the evaluation stack.</source>
          <target state="translated">Вычитает одно значение из другого и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>59</source>
          <target state="translated">59</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>sub</source>
          <target state="translated">sub</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another, returning a new numeric value.</source>
          <target state="translated">Вычитает одно значение из другого и возвращает новое числовое значение.</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value2`</ph> вычитается из <ph id="ph4">`value1`</ph>.</target>       </trans-unit>
        <trans-unit id="4303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="4304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</source>
          <target state="translated">Не обнаружено переполнение для целочисленных операций (для управления переполнением правильную, в разделе <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Integer subtraction wraps, rather than saturates.</source>
          <target state="translated">Вычитание целых чисел заключает в оболочку, а не насыщение.</target>       </trans-unit>
        <trans-unit id="4306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>For example: assuming 8-bit integers, where <ph id="ph1">`value1`</ph> is set to 0 and <ph id="ph2">`value2`</ph> is set to 1, the "wrapped" result will be 255.</source>
          <target state="translated">Например: при условии, что 8-битовых целых чисел, где <ph id="ph1">`value1`</ph> равен 0 и <ph id="ph2">`value2`</ph> имеет значение 1, «оболочку» будет 255.</target>       </trans-unit>
        <trans-unit id="4307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">С плавающей запятой переполнения возвращает <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) или <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</target>       </trans-unit>
        <trans-unit id="4308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`sub`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4310" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Вычитает одно целочисленное значение из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="4311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>DA</source>
          <target state="translated">DA</target>       </trans-unit>
        <trans-unit id="4316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>sub.ovf</source>
          <target state="translated">Sub.ovf</target>       </trans-unit>
        <trans-unit id="4317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another with an overflow check.</source>
          <target state="translated">Вычитает одно целочисленное значение из другого и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="4318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value2`</ph> вычитается из <ph id="ph4">`value1`</ph> проверкой переполнения.</target>       </trans-unit>
        <trans-unit id="4322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="4323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="4324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">Эта операция выполняется над знаковыми целочисленными значениями; для значений с плавающей запятой, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`sub.ovf`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4327" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">Вычитает одно целочисленное значение без знака из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</target>       </trans-unit>
        <trans-unit id="4328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>DB</source>
          <target state="translated">DB</target>       </trans-unit>
        <trans-unit id="4333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>sub.ovf.un</source>
          <target state="translated">Sub.ovf.un</target>       </trans-unit>
        <trans-unit id="4334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another with an overflow check.</source>
          <target state="translated">Вычитает одно целочисленное значение без знака из другого и выполняет проверку переполнения.</target>       </trans-unit>
        <trans-unit id="4335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; <ph id="ph3">`value2`</ph> вычитается из <ph id="ph4">`value1`</ph> проверкой переполнения.</target>       </trans-unit>
        <trans-unit id="4339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">Результат помещается в стек.</target>       </trans-unit>
        <trans-unit id="4340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> возникает, если результат не может быть представлено типом результата.</target>       </trans-unit>
        <trans-unit id="4341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">Эта операция выполняется над знаковыми целочисленными значениями; для значений с плавающей запятой, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf.un`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`sub.ovf.un`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4344" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Implements a jump table.</source>
          <target state="translated">Реализует таблицу переходов.</target>       </trans-unit>
        <trans-unit id="4345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></source>
          <target state="translated">45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</source>
          <target state="translated">Переключение (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</target>       </trans-unit>
        <trans-unit id="4351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Jumps to one of <ph id="ph1">`N`</ph> values.</source>
          <target state="translated">Выполняет переход к одному из <ph id="ph1">`N`</ph> значения.</target>       </trans-unit>
        <trans-unit id="4352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">Значение помещается в стек.</target>       </trans-unit>
        <trans-unit id="4354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <ph id="ph1">`N`</ph>.</source>
          <target state="translated">Значение извлекается из стека и управление передается инструкции, смещением, индекс по значению, где значение — меньше, чем <ph id="ph1">`N`</ph>.</target>       </trans-unit>
        <trans-unit id="4355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction implements a jump table.</source>
          <target state="translated"><ph id="ph1">`switch`</ph> Инструкция реализует таблицу переходов.</target>       </trans-unit>
        <trans-unit id="4356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The format of the instruction is an <ph id="ph1">`unsigned int32`</ph> representing the number of targets <ph id="ph2">`N`</ph>, followed by <ph id="ph3">`N`</ph> int32 values specifying jump targets.</source>
          <target state="translated">Недопустимый формат инструкции по <ph id="ph1">`unsigned int32`</ph> представляет количество целевых объектов <ph id="ph2">`N`</ph>, за которым следует <ph id="ph3">`N`</ph> значений Int32 перехода целевых объектов.</target>       </trans-unit>
        <trans-unit id="4357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>These targets are represented as offsets (positive or negative) from the beginning of the instruction following this <ph id="ph1">`switch`</ph> instruction.</source>
          <target state="translated">Эти целевые объекты отображаются в виде смещения (положительные или отрицательные) от начала инструкции, это <ph id="ph1">`switch`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction pops a value off the stack and compares it, as an unsigned integer, to <ph id="ph2">`N`</ph>.</source>
          <target state="translated"><ph id="ph1">`switch`</ph> Инструкция извлекает значение из стека и сравнивает его, как целое число без знака в <ph id="ph2">`N`</ph>.</target>       </trans-unit>
        <trans-unit id="4359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If value is less than <ph id="ph1">`N`</ph>, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</source>
          <target state="translated">Если значение меньше, чем <ph id="ph1">`N`</ph>, выполнение передается в целевой объект, индекс которого соответствует значению, где цели нумеруются от 0 (например, первый целевой объект принимает значение 0, принимает значение 1, второй и т. д).</target>       </trans-unit>
        <trans-unit id="4360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the value is greater than or equal to <ph id="ph1">`N`</ph>, execution continues at the next instruction (fall through).</source>
          <target state="translated">Если значение больше или равно <ph id="ph1">`N`</ph>, управление передается следующей инструкции (вниз).</target>       </trans-unit>
        <trans-unit id="4361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">Если конечная инструкция содержит один или несколько кодов префикс, управление может быть передано только первый из этих префиксов.</target>       </trans-unit>
        <trans-unit id="4362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">Передавать из и управление <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, и <ph id="ph4">`finally`</ph> данная инструкция не может быть выполнена блоков.</target>       </trans-unit>
        <trans-unit id="4363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>(Such transfers are severely restricted and must use the leave instruction instead).</source>
          <target state="translated">(Подобная передача строго ограничивается; вместо этого следует использовать инструкцию leave).</target>       </trans-unit>
        <trans-unit id="4364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`switch`</ph> opcode.</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`switch`</ph> код операции.</target>       </trans-unit>
        <trans-unit id="4365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`Label[]`</ph> argument is an array of Labels representing 32-bit offsets.</source>
          <target state="translated"><ph id="ph1">`Label[]`</ph> Аргумент — массив меток, представляющих 32-разрядные смещения.</target>       </trans-unit>
        <trans-unit id="4366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>ILGenerator.Emit(OpCode, Label[])</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label[])</target>       </trans-unit>
        <trans-unit id="4367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following code sample illustrates the use of the <ph id="ph1">`Switch`</ph> opcode to generate a jump table using an array of <ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>.</source>
          <target state="translated">В следующем образце кода показано использование <ph id="ph1">`Switch`</ph> код операции для создания таблицы переходов с помощью массива <ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</source>
          <target state="translated">Выполняет инструкцию вызова метода (префиксом которой является), предварительно удаляя кадр стека текущего метода.</target>       </trans-unit>
        <trans-unit id="4369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>FE 14</source>
          <target state="translated">FE 14</target>       </trans-unit>
        <trans-unit id="4374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>tail.</source>
          <target state="translated">заключительный фрагмент.</target>       </trans-unit>
        <trans-unit id="4375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Subsequent call terminates current methods</source>
          <target state="translated">Последующий вызов завершает текущие методы.</target>       </trans-unit>
        <trans-unit id="4376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>There is no stack transition behavior defined for this instruction.</source>
          <target state="translated">Нет Переходные состояния стека для данной инструкции не.</target>       </trans-unit>
        <trans-unit id="4377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The <ph id="ph1">`tail`</ph> prefix instruction must immediately precede a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`tail`</ph> Префиксом должен предшествовать <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, или <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It indicates that the current method's stack frame should be removed before the call instruction is executed.</source>
          <target state="translated">Указывает, что кадр стека текущего метода должны быть удалены перед выполнением инструкции вызова.</target>       </trans-unit>
        <trans-unit id="4379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</source>
          <target state="translated">Также подразумевает, что значение, возвращаемое из вызова следующих также является значением, возвращаемым значением текущего метода и вызов может быть преобразован в переход между методами.</target>       </trans-unit>
        <trans-unit id="4380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The stack must be empty except for the arguments being transferred by the following call.</source>
          <target state="translated">Стек должен быть пустым, за исключением аргументов, передаваемых следующим вызовом.</target>       </trans-unit>
        <trans-unit id="4381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The instruction following the call instruction must be a ret. Thus the only valid code sequence is <ph id="ph1">`tail. call`</ph> (or <ph id="ph2">`calli`</ph> or <ph id="ph3">`callvirt`</ph>).</source>
          <target state="translated">Инструкции инструкцией вызова должна быть возвратной. Таким образом является единственной допустимой последовательностью кода <ph id="ph1">`tail. call`</ph> (или <ph id="ph2">`calli`</ph> или <ph id="ph3">`callvirt`</ph>).</target>       </trans-unit>
        <trans-unit id="4382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the <ph id="ph1">`call`</ph> instruction, but they may branch to the subsequent <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</source>
          <target state="translated">Правильные инструкции промежуточного языка Майкрософт (MSIL) не должна содержать ветвь для <ph id="ph1">`call`</ph> инструкции, но они могут выполнять переход к последующей <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</source>
          <target state="translated">Текущий кадр не может быть отменено, если управление передается от ненадежного кода в доверенный код, так как это нарушит безопасность идентификации кода.</target>       </trans-unit>
        <trans-unit id="4384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The .NET Framework security checks can therefore cause the <ph id="ph1">`tail`</ph> to be ignored, leaving a standard <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">Проверки безопасности .NET Framework, поэтому может привести к <ph id="ph1">`tail`</ph> следует игнорировать, оставляя стандартного <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the <ph id="ph1">`tail`</ph> prefix is ignored when used to exit a method that is marked synchronized.</source>
          <target state="translated">Аналогичным образом, чтобы обеспечить выход синхронизированной области после возвращения вызова, <ph id="ph1">`tail`</ph> префикс учитывается, если используется для выхода из метода, помеченного как синхронизированный.</target>       </trans-unit>
        <trans-unit id="4386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`tail`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`tail`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>An instance of an Opcode object.</source>
          <target state="translated">Экземпляр объекта Opcode.</target>       </trans-unit>
        <trans-unit id="4389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Returns true or false if the supplied opcode takes a single byte argument.</source>
          <target state="translated">Возвращает true или false, в зависимости от того, принимает ли заданный код операции однобайтовый аргумент.</target>       </trans-unit>
        <trans-unit id="4390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">&lt;see langword="True" /&gt;</ph> or <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="True" /&gt;</ph> или <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</source>
          <target state="translated">Этот метод можно использовать для поиска, какие коды операции MSIL имеют «короткую форму», для использования в оптимизированном коде.</target>       </trans-unit>
        <trans-unit id="4392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">`TakesSingleByteArgument`</ph> returns <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> instance takes a single byte argument in the following cases:</source>
          <target state="translated"><ph id="ph1">`TakesSingleByteArgument`</ph> Возвращает <ph id="ph2">`true`</ph> Если <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> экземпляр принимает однобайтовый аргумент в следующих случаях:</target>       </trans-unit>
        <trans-unit id="4393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode performs a branch instruction to a byte-sized address (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</source>
          <target state="translated">Код операции выполняет инструкцию перехода к однобайтовому адресу (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode pushes a byte value onto the stack (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</source>
          <target state="translated">Код операции помещает однобайтовое значение в стек (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode references a variable or argument via the byte-sized "short form" (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</source>
          <target state="translated">Код операции ссылается на переменную или аргумент с использованием однобайтовой «краткая форма» (например, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="4396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Otherwise, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">В противном случае возвращает значение <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The example below demonstrates the use of <ph id="ph1">`TakesSingleByteArgument`</ph> by reflecting on to the <ph id="ph2">`OpCodes`</ph> class and testing to see whether each <ph id="ph3">`OpCode`</ph> field takes a single-byte argument.</source>
          <target state="translated">В приведенном ниже примере показано использование функции <ph id="ph1">`TakesSingleByteArgument`</ph> путем отражения для <ph id="ph2">`OpCodes`</ph> класса и проверки ли каждый <ph id="ph3">`OpCode`</ph> поле принимает однобайтовый аргумент.</target>       </trans-unit>
        <trans-unit id="4398" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws the exception object currently on the evaluation stack.</source>
          <target state="translated">Создает объект исключения, находящийся в стеке вычислений.</target>       </trans-unit>
        <trans-unit id="4399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>7A</source>
          <target state="translated">7A</target>       </trans-unit>
        <trans-unit id="4404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>throw</source>
          <target state="translated">throw</target>       </trans-unit>
        <trans-unit id="4405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws an exception.</source>
          <target state="translated">Создает исключение.</target>       </trans-unit>
        <trans-unit id="4406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>An object reference (to an exception) is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект (исключение) помещается в стек.</target>       </trans-unit>
        <trans-unit id="4408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The object reference is popped from the stack and the exception thrown.</source>
          <target state="translated">Ссылка на объект извлекается из стека и исключения.</target>       </trans-unit>
        <trans-unit id="4409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The <ph id="ph1">`throw`</ph> instruction throws the exception object (type <ph id="ph2">`O`</ph>) currently on the stack.</source>
          <target state="translated"><ph id="ph1">`throw`</ph> Инструкция создает объект исключения (типа <ph id="ph2">`O`</ph>) в настоящее время в стеке.</target>       </trans-unit>
        <trans-unit id="4410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызывается, если ссылка на объект является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="4411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`throw`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`throw`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4413" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>, <ph id="ph2">&lt;see langword="stind" /&gt;</ph>, <ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>, <ph id="ph4">&lt;see langword="stfld" /&gt;</ph>, <ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>, <ph id="ph6">&lt;see langword="stobj" /&gt;</ph>, <ph id="ph7">&lt;see langword="initblk" /&gt;</ph>, or <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph> instruction.</source>
          <target state="translated">Указывает, что адрес на вершине стека, возможно, не выровнен по естественному размеру следующей непосредственно за ним инструкции <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>, <ph id="ph2">&lt;see langword="stind" /&gt;</ph>, <ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>, <ph id="ph4">&lt;see langword="stfld" /&gt;</ph>, <ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>, <ph id="ph6">&lt;see langword="stobj" /&gt;</ph>, <ph id="ph7">&lt;see langword="initblk" /&gt;</ph> или <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>unaligned.</source>
          <target state="translated">Невыровненные.</target>       </trans-unit>
        <trans-unit id="4420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that the subsequent pointer instruction may be unaligned.</source>
          <target state="translated">Указывает, что последующие указатель инструкции может быть невыровненным.</target>       </trans-unit>
        <trans-unit id="4421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source><ph id="ph1">`Unaligned`</ph> specifies that the address (an unmanaged pointer, <ph id="ph2">`native int`</ph>) on the stack might not be aligned to the natural size of the immediately following <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, or <ph id="ph10">`cpblk`</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`Unaligned`</ph> Указывает, что адрес (неуправляемый указатель <ph id="ph2">`native int`</ph>) в стеке может не быть выровненным по размеру следующей непосредственно за <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, или <ph id="ph10">`cpblk`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>That is, for a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> instruction the alignment of the address may not be to a 4-byte boundary.</source>
          <target state="translated">То есть для <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> выравнивание адреса не может быть в 4-байтовой границе инструкции.</target>       </trans-unit>
        <trans-unit id="4425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>For <ph id="ph1">`initblk`</ph> and <ph id="ph2">`cpblk`</ph> the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</source>
          <target state="translated">Для <ph id="ph1">`initblk`</ph> и <ph id="ph2">`cpblk`</ph> выравнивание по умолчанию — зависит от архитектуры (4-байтовое для 32-разрядных процессоров, 8-байтовое для 64-разрядных процессоров).</target>       </trans-unit>
        <trans-unit id="4426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Code generators that do not restrict their output to a 32-bit word size must use <ph id="ph1">`unaligned`</ph> if the alignment is not known at compile time to be 8-byte.</source>
          <target state="translated">Необходимо использовать генераторы кода, не ограничивающие размер 32-разрядное слово <ph id="ph1">`unaligned`</ph> Если выравнивание не известно во время компиляции размером 8 байт.</target>       </trans-unit>
        <trans-unit id="4427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</source>
          <target state="translated">Значение выравнивания должно быть 1, 2 или 4 и означает, что созданный код следует предполагать, что адрес байтов двухбайтовый, или quad байтовое выравнивание, соответственно.</target>       </trans-unit>
        <trans-unit id="4428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Note that transient pointers (type <ph id="ph1">`*`</ph>) are always aligned.</source>
          <target state="translated">Обратите внимание, что временной указатели (типа <ph id="ph1">`*`</ph>) всегда выровнены.</target>       </trans-unit>
        <trans-unit id="4429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>While the alignment for a <ph id="ph1">`cpblk`</ph> instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</source>
          <target state="translated">Выравнивание для <ph id="ph1">`cpblk`</ph> требует двух чисел (источника) и конечного использования инструкций, нет оказывает заметного влияния на производительность, если задан параметр only меньшее число.</target>       </trans-unit>
        <trans-unit id="4430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The <ph id="ph1">`unaligned`</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated"><ph id="ph1">`unaligned`</ph> И <ph id="ph2">`volatile`</ph> префиксов, которые могут быть объединены в любом порядке.</target>       </trans-unit>
        <trans-unit id="4431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">Они должны находиться непосредственно перед <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, или <ph id="ph8">`cpblk`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Only the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">Только <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> префикс допускается для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`unaligned`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузки метода <ph id="ph2">`unaligned`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit(OpCode, Label)</target>       </trans-unit>
        <trans-unit id="4435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(Opcode, Byte)</source>
          <target state="translated">ILGenerator.Emit (код операции, Byte)</target>       </trans-unit>
        <trans-unit id="4436" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Converts the boxed representation of a value type to its unboxed form.</source>
          <target state="translated">Преобразует тип значения из упакованной формы в распакованную.</target>       </trans-unit>
        <trans-unit id="4437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>unbox <ph id="ph1">`valType`</ph></source>
          <target state="translated">Распаковка <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="4443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Extracts the value type data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">Извлекает данные типа значения из <ph id="ph1">`obj`</ph>, его упакованного представления.</target>       </trans-unit>
        <trans-unit id="4444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект помещается в стек.</target>       </trans-unit>
        <trans-unit id="4446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The object reference is popped from the stack and unboxed to a value type pointer.</source>
          <target state="translated">Ссылка на объект извлекается из стека и преобразуется в указатель типа значения.</target>       </trans-unit>
        <trans-unit id="4447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The value type pointer is pushed onto the stack.</source>
          <target state="translated">Указатель типа значения помещается в стек.</target>       </trans-unit>
        <trans-unit id="4448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">Тип значения имеет два представления в Common Language Infrastructure (CLI):</target>       </trans-unit>
        <trans-unit id="4449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'raw' form used when a value type is embedded within another object.</source>
          <target state="translated">«Первичная» форма, используемый при внедрении типа значения внутри другого объекта.</target>       </trans-unit>
        <trans-unit id="4450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">Форма «процессор», где данные в тип значения упаковываются в объект и существуют как независимая сущность.</target>       </trans-unit>
        <trans-unit id="4451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The <ph id="ph1">`unbox`</ph> instruction converts the object reference (type <ph id="ph2">`O`</ph>), the boxed representation of a value type, to a value type pointer (a managed pointer, type <ph id="ph3">`&amp;`</ph>), its unboxed form.</source>
          <target state="translated"><ph id="ph1">`unbox`</ph> Инструкция преобразует ссылку на объект (тип <ph id="ph2">`O`</ph>), упакованного представления тип значения в указатель типа значения (управляемый указатель типа <ph id="ph3">`&amp;`</ph>), ее распаковано формы.</target>       </trans-unit>
        <trans-unit id="4452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The supplied value type (<ph id="ph1">`valType`</ph>) is a metadata token indicating the type of value type contained within the boxed object.</source>
          <target state="translated">Заданный тип значения (<ph id="ph1">`valType`</ph>) представляет собой лексему метаданных, указывающий тип содержащихся в объекте упакованный тип значения.</target>       </trans-unit>
        <trans-unit id="4453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, which is required to make a copy of a value type for use in the object, <ph id="ph2">`unbox`</ph> is not required to copy the value type from the object.</source>
          <target state="translated">В отличие от <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, который требуется сделать копию типа значения для использования в объекте, <ph id="ph2">`unbox`</ph> не требуется копировать тип значения из объекта.</target>       </trans-unit>
        <trans-unit id="4454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Typically it simply computes the address of the value type that is already present inside of the boxed object.</source>
          <target state="translated">Обычно она просто вычисляет адрес типа значения, уже находящегося упакованного объекта.</target>       </trans-unit>
        <trans-unit id="4455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if the object is not boxed as <ph id="ph2">`valType`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> возникает, если объект не упакован как <ph id="ph2">`valType`</ph>.</target>       </trans-unit>
        <trans-unit id="4456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> вызывается, если ссылка на объект является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="4457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the value type <ph id="ph2">`valType`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, если тип значения <ph id="ph2">`valType`</ph> не найден.</target>       </trans-unit>
        <trans-unit id="4458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">Обычно это обнаруживается инструкции промежуточного языка Майкрософт (MSIL) преобразуются в машинный код, а не во время выполнения.</target>       </trans-unit>
        <trans-unit id="4459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`unbox`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="4461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Converts the boxed representation of a type specified in the instruction to its unboxed form.</source>
          <target state="translated">Преобразует тип, указанный в инструкции, из упакованной формы в распакованную.</target>       </trans-unit>
        <trans-unit id="4462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены инструкция в шестнадцатеричном формате и формате сборки промежуточного языка MSIL Microsoft, а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>unbox.any <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">unbox.Any <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="4468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Extract the data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">Извлечение данных из <ph id="ph1">`obj`</ph>, его упакованного представления.</target>       </trans-unit>
        <trans-unit id="4469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">Ссылка на объект <ph id="ph1">`obj`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The object reference is popped from the stack and unboxed to the type specified in the instruction.</source>
          <target state="translated">Ссылка на объект извлекается из стека и преобразуется в тип, указанный в инструкции.</target>       </trans-unit>
        <trans-unit id="4472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The resulting object reference or value type is pushed onto the stack.</source>
          <target state="translated">Результирующий тип ссылки или значений объекта помещается в стек.</target>       </trans-unit>
        <trans-unit id="4473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to the boxed form of a value type, the <ph id="ph1">`unbox.any`</ph> instruction extracts the value contained within <ph id="ph2">`obj`</ph> (of type <ph id="ph3">`O`</ph>), and is therefore equivalent to <ph id="ph4">`unbox`</ph> followed by <ph id="ph5">`ldobj`</ph>.</source>
          <target state="translated">При применении к форме упакованный тип значения <ph id="ph1">`unbox.any`</ph> инструкция извлекает значение, содержащееся в <ph id="ph2">`obj`</ph> (типа <ph id="ph3">`O`</ph>) и поэтому является эквивалентом <ph id="ph4">`unbox`</ph> следуют <ph id="ph5">`ldobj`</ph>.</target>       </trans-unit>
        <trans-unit id="4474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to a reference type, the <ph id="ph1">`unbox.any`</ph> instruction has the same effect as <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</source>
          <target state="translated">При применении к ссылочному типу <ph id="ph1">`unbox.any`</ph> инструкция действует так же, как <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</target>       </trans-unit>
        <trans-unit id="4475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>If the operand <ph id="ph1">`typeTok`</ph> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</source>
          <target state="translated">Если операнд <ph id="ph1">`typeTok`</ph> является параметром универсального типа, то поведение во время выполнения определяется тип, который задан для этого параметра универсального типа.</target>       </trans-unit>
        <trans-unit id="4476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is not a boxed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> возникает, если <ph id="ph2">`obj`</ph> не является упакованным типом.</target>       </trans-unit>
        <trans-unit id="4477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> возникает, если <ph id="ph2">`obj`</ph> является пустой ссылкой.</target>       </trans-unit>
        <trans-unit id="4478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox.any`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`unbox.any`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (код операции, Type)</target>       </trans-unit>
        <trans-unit id="4480" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">Указывает, что адрес на вершине стека вычислений, возможно, является изменяемым и результаты чтения данной области невозможно кэшировать либо невозможно запретить множественные сохранения в эту область.</target>       </trans-unit>
        <trans-unit id="4481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>FE 13</source>
          <target state="translated">FE 13</target>       </trans-unit>
        <trans-unit id="4486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>volatile.</source>
          <target state="translated">volatile.</target>       </trans-unit>
        <trans-unit id="4487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Indicates that the subsequent pointer reference is volatile.</source>
          <target state="translated">Указывает, что следующая за указателем ссылка является volatile.</target>       </trans-unit>
        <trans-unit id="4488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">Адрес помещается в стек.</target>       </trans-unit>
        <trans-unit id="4490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source><ph id="ph1">`volatile`</ph>.</source>
          <target state="translated"><ph id="ph1">`volatile`</ph>.</target>       </trans-unit>
        <trans-unit id="4491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">Указывает, что адрес является изменяемым (то есть, он может ссылаться извне для текущего потока выполнения) и результаты чтения данной области невозможно кэшировать либо множественные сохранения в это расположение не может быть отменено.</target>       </trans-unit>
        <trans-unit id="4492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Marking an access as <ph id="ph1">`volatile`</ph> affects only that single access; other accesses to the same location must be marked separately.</source>
          <target state="translated">Доступа <ph id="ph1">`volatile`</ph> влияет только на доступ; любой другой доступ к папке должен быть помечен отдельно.</target>       </trans-unit>
        <trans-unit id="4493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Access to volatile locations need not be performed atomically.</source>
          <target state="translated">Доступ к изменяемым адресам не должен осуществляться атомарным образом.</target>       </trans-unit>
        <trans-unit id="4494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> И <ph id="ph2">`volatile`</ph> префиксов, которые могут быть объединены в любом порядке.</target>       </trans-unit>
        <trans-unit id="4495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">Они должны находиться непосредственно перед <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, или <ph id="ph8">`cpblk`</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Only the <ph id="ph1">`volatile`</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">Только <ph id="ph1">`volatile`</ph> префикс допускается для <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="4497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`volatile`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`volatile`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4499" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</source>
          <target state="translated">Вычисляет побитовое исключающее ИЛИ двух верхних значений в стеке вычислений и помещает результат обратно в стек.</target>       </trans-unit>
        <trans-unit id="4500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">В следующей таблице перечислены данная инструкция в шестнадцатеричном формате и формате сборки промежуточного языка Майкрософт (MSIL), а также краткое описание:</target>       </trans-unit>
        <trans-unit id="4501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Format</source>
          <target state="translated">Формат</target>       </trans-unit>
        <trans-unit id="4502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Assembly Format</source>
          <target state="translated">Формат сборки</target>       </trans-unit>
        <trans-unit id="4503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="4504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>61</source>
          <target state="translated">61</target>       </trans-unit>
        <trans-unit id="4505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>xor</source>
          <target state="translated">xor</target>       </trans-unit>
        <trans-unit id="4506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of two integer values and returns an integer.</source>
          <target state="translated">Вычисляет побитовое исключающее или двух целочисленных значений и возвращает целое число.</target>       </trans-unit>
        <trans-unit id="4507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">Изменения состояния стека в последовательном порядке, является:</target>       </trans-unit>
        <trans-unit id="4508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise XOR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> извлекаются из стека; поразрядное исключающее или вычислить.</target>       </trans-unit>
        <trans-unit id="4511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The bitwise XOR of <ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">Побитовое исключающее или <ph id="ph1">`value2`</ph> и <ph id="ph2">`value1`</ph> помещается в стек.</target>       </trans-unit>
        <trans-unit id="4512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The <ph id="ph1">`xor`</ph> instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated"><ph id="ph1">`xor`</ph> Инструкция вычисляет побитовое исключающее или двух верхних значений в стеке и оставляет результат в стеке.</target>       </trans-unit>
        <trans-unit id="4513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`Xor`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Xor`</ph> представляет собой операцию целыми числами.</target>       </trans-unit>
        <trans-unit id="4514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`xor`</ph> opcode:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> можно использовать перегрузку метода <ph id="ph2">`xor`</ph> код операции:</target>       </trans-unit>
        <trans-unit id="4515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>