<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeBuilder.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines and creates new instances of classes during run time.</source>
          <target state="translated">Определяет и создает новые экземпляры классов во время выполнения.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is the root class used to control the creation of dynamic classes in the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> корневой класс, используемый для создания динамических классов во время выполнения.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</source>
          <target state="translated">Она предоставляет набор подпрограмм, которые используются для определения классов, добавления методов и полей и создания класса в модуле.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A new <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be created from a dynamic module by calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Новый <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> могут создаваться из динамического модуля, вызвав <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> метод, возвращающий <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit provides the following options for defining types:</source>
          <target state="translated">Порождение отражения предоставляет следующие возможности для определения типов:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name.</source>
          <target state="translated">Определение класса или интерфейса с заданным именем.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name and attributes.</source>
          <target state="translated">Определение класса или интерфейса с заданным именем и атрибутами.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, and base class.</source>
          <target state="translated">Определение класса с заданным именем, атрибутами и базового класса.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</source>
          <target state="translated">Определение класса с заданным именем, атрибутов, базового класса и набор интерфейсов, реализуемых в классе.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and packing size.</source>
          <target state="translated">Определение класса с заданным именем, атрибутов, базового класса и упаковочный размер.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the class size as a whole.</source>
          <target state="translated">Определение класса с заданным именем, атрибутов, базового класса и размера класса в целом.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</source>
          <target state="translated">Определение класса с заданным именем, атрибутов, базового класса, упаковочный размер и размер класса в целом.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>To create an array type, pointer type, or byref type for an incomplete type that is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method, <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Чтобы создать тип массива, тип указателя или тип byref для неполного типа, представленного <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , используйте <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> метода <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> метод, или <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> метода, соответственно.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Before a type is used, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> method must be called.</source>
          <target state="translated">Прежде чем использовать тип, <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> метод должен вызываться.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> completes the creation of the type.</source>
          <target state="translated"><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> завершения создания типа.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Following the call to <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, the caller can instantiate the type by using the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and invoke members of the type by using the <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Следующий за вызовом <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, вызывающий объект может создать экземпляр типа с помощью <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> метода и вызывать члены типа с помощью <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It is an error to invoke methods that change the implementation of a type after <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> has been called.</source>
          <target state="translated">Это ошибка для вызова методов, изменяющих реализацию типа после <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> был вызван.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>For example, the common language runtime throws an exception if the caller tries to add new members to a type.</source>
          <target state="translated">Например общеязыковая среда выполнения создает исключение, если вызывающий объект пытается добавить новые элементы к типу.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A class initializer is created by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Инициализатор класса создается с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> returns a <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> возвращает <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Nested types are defined by calling one of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Вложенные типы определяются путем вызова одного из <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Attributes</source>
          <target state="translated">Атрибуты</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class uses the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration to further specify the characteristics of the type to be created:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Класс использует <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> перечисления для указания характеристики типа должен быть создан:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Interfaces are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attributes.</source>
          <target state="translated">Интерфейсы задаются с помощью <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> атрибуты.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Concrete classes (classes that cannot be extended) are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Конкретные классы (классы, которые не могут быть расширены) задаются с помощью <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Several attributes determine type visibility.</source>
          <target state="translated">Несколько атрибутов определяют видимость типов.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>If <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is specified, the class loader lays out fields in the order they are read from metadata.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> указан, загрузчик классов располагает поля в порядке их считывания из метаданных.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The class loader considers the specified packing size but ignores any specified field offsets.</source>
          <target state="translated">Загрузчик классов считает, что заданный размер, но не учитывает любые заданные смещения полей.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The metadata preserves the order in which the field definitions are emitted.</source>
          <target state="translated">Метаданные сохраняет порядок, в котором создаются определения полей.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Even across a merge, the metadata will not reorder the field definitions.</source>
          <target state="translated">Даже при объединении метаданные не будет переупорядочивать определения полей.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The loader will honor the specified field offsets only if <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is specified.</source>
          <target state="translated">Загрузчик будет поддерживать только если указанное поле смещения <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> указано.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Known Issues</source>
          <target state="translated">Известные проблемы</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</source>
          <target state="translated">Порождение отражения не проверяет, реализовал ли неабстрактный класс, реализующий интерфейс, все методы, объявленные в интерфейсе.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</source>
          <target state="translated">Тем не менее если класс не реализует все методы, объявленные в интерфейсе, среда выполнения не загружается класс.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Type&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Type&gt;</ph> class are not fully implemented in the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class.</source>
          <target state="translated">Несмотря на то что <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> является производным от <ph id="ph2">&lt;xref:System.Type&gt;</ph>, некоторые из абстрактных методов, определенных в <ph id="ph3">&lt;xref:System.Type&gt;</ph> класс еще не полностью реализованы в <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Calls to these <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> methods throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Эти вызовы <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> методы создают исключение <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The desired functionality can be obtained by retrieving the created type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and reflecting on the retrieved type.</source>
          <target state="translated">Необходимые функции можно получить путем получения созданного типа с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и отражения полученного типа.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>This section contains two code examples.</source>
          <target state="translated">Этот раздел содержит два примера кода.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The first example shows how to create a dynamic type with a field, constructor, property, and method.</source>
          <target state="translated">В первом примере показано, как создать динамический тип с полем, конструктор, свойство и метод.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The second example builds a method dynamically from user input.</source>
          <target state="translated">Во втором примере создает метод динамически из введенных пользователем данных.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example one<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Один пример<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code example shows how to define a dynamic assembly with one module.</source>
          <target state="translated">В следующем примере кода показано определение динамическую сборку с одним модулем.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The module in the example assembly contains one type, <ph id="ph1">`MyDynamicType`</ph>, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</source>
          <target state="translated">Модуль в этой сборке содержит один тип <ph id="ph1">`MyDynamicType`</ph>, который имеет закрытое поле, свойство, которое возвращает и задает закрытое поле, конструкторы, которые инициируют закрытое поле и метод, который умножает число на предоставленный пользователем на закрытое поле значение и возвращает результат.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> field is specified when the assembly is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> Поле указано при создании сборки.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> or used in another program.</source>
          <target state="translated">Сразу же использовать код сборки и сборка сохраняется на диск, чтобы можно было проанализировать с помощью <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> или использовать в другой программе.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example two<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Второй пример<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code sample demonstrates how to build a dynamic type by using <ph id="ph1">`TypeBuilder`</ph>.</source>
          <target state="translated">В следующем образце кода показано, как построить динамический тип с помощью <ph id="ph1">`TypeBuilder`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken such as Demand, Assert, and so on.</source>
          <target state="translated">Выполняемое действие безопасности, например Demand, Assert и т. д.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">Набор разрешений, к которому применяется действие.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this type.</source>
          <target state="translated">Добавляет декларативную безопасность в этот тип.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">`AddDeclarativeSecurity`</ph> may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</source>
          <target state="translated"><ph id="ph1">`AddDeclarativeSecurity`</ph> может быть вызван несколько раз для каждого вызова, указав действие по обеспечению безопасности (например, требование, Assert или Deny) и набор разрешений, применяемых к данному действию.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</source>
          <target state="translated">В .NET Framework версий 1.0, 1.1 и 2.0 декларативные атрибуты безопасности применении к типу с помощью этого метода, хранятся в старом формате метаданных XML.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The following example demonstrates the use of the <ph id="ph1">`AddDeclarativeSecurity`</ph> method to add a security demand for <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag to a dynamic type named <ph id="ph4">`MyDynamicClass`</ph>, in an assembly named EmittedExample.dll.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`AddDeclarativeSecurity`</ph> метод, чтобы добавить требование безопасности для <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> флаг динамический тип с именем <ph id="ph4">`MyDynamicClass`</ph>, в сборке с именем EmittedExample.dll.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The example produces no console output; after you run it, you can use <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine EmittedExample.dll.</source>
          <target state="translated">В примере получается выходные данные консоли; После запуска, можно использовать <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для изучения EmittedExample.dll.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In <ph id="ph1">`MyDynamicClass`</ph>, open the <ph id="ph2">`.class public auto ansi`</ph> statement to see the declarative permission.</source>
          <target state="translated">В <ph id="ph1">`MyDynamicClass`</ph>откройте <ph id="ph2">`.class public auto ansi`</ph> инструкцию, чтобы увидеть декларативного разрешения.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated">Недопустимый параметр <ph id="ph1">&lt;paramref name="action" /&gt;</ph> (недопустимы значения <ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> и <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</source>
          <target state="translated">Набор разрешений <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> содержит действие, добавленное ранее с помощью <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The interface that this type implements.</source>
          <target state="translated">Интерфейс, реализуемый данным типом.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>Adds an interface that this type implements.</source>
          <target state="translated">Добавляет интерфейс, реализуемый данным типом.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The following code sample demonstrates the implementation of an interface on a dynamically created type using <ph id="ph1">`AddInterfaceImplementation`</ph>.</source>
          <target state="translated">В следующем образце кода демонстрируется реализация интерфейса для динамически созданного типа с помощью <ph id="ph1">`AddInterfaceImplementation`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Извлекает динамическую сборку, которая содержит определение данного типа.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Извлекает динамическую сборку, которая содержит определение данного типа.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Returns the full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Возвращает полное имя этого типа, дополненное отображаемым именем сборки.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Полное имя этого типа, дополненное отображаемым именем сборки.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The format of the returned string is the concatenation of the full name of the type (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) and the display name of the assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), separated by a comma and a space.</source>
          <target state="translated">Формат возвращаемой строки представляет собой объединение полного имени типа (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) и отображаемое имя сборки (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), разделив их запятой и пробелом.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> описание формата отображаемого имени сборки.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Version Information</source>
          <target state="translated">Сведения о версии</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</source>
          <target state="translated">В .NET Framework версий 1.0 и 1.1 значение этого свойства не включает культуры или открытого ключа.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Возвращает базовый тип этого типа.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Возвращает базовый тип этого типа.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for the class.</source>
          <target state="translated">Создает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> для этого класса.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>After defining fields and methods on the class, <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> is called in order to load its <ph id="ph2">&lt;see langword="Type" /&gt;</ph> object.</source>
          <target state="translated">После определения полей и методов в классе вызывается метод <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> для загрузки его объекта <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Returns the new <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for this class.</source>
          <target state="translated">Возвращает новый объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> для этого класса.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If this type is a nested type, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method must be called on the enclosing type before it is called on the nested type.</source>
          <target state="translated">Если этот тип является вложенным типом, <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод должен вызываться для включающего типа, прежде чем он будет вызван на вложенный тип.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the current type derives from an incomplete type or implements incomplete interfaces, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the parent type and the interface types before calling it on the current type.</source>
          <target state="translated">Если текущий тип является производным от неполного типа или реализует неполные интерфейсы, вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод для родительского типа и типов интерфейса перед вызовом этого метода для текущего типа.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the enclosing type will generate a <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Если включающий тип содержит поле, которое является типом значения, определенные как вложенный тип (например, поля, представляет собой перечисление, определенные как вложенный тип), вызов <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод для включающего типа создаст <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</source>
          <target state="translated">Это так, как загрузчик не удается определить размер включающего типа до завершения вложенного типа.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The caller should define a handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event to complete the definition of the nested type by calling <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the nested type.</source>
          <target state="translated">Вызывающий объект должен быть определен обработчик для <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> событий для завершения определения вложенного типа путем вызова <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> на <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объект, предоставляющий вложенный тип.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The code example for this topic shows how to define such an event handler.</source>
          <target state="translated">В примере кода для этого раздела показано, как определить такие обработчик событий.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>A type is created only once, no matter how many times the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Тип создается только один раз, независимо от того, как много раз <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>All calls return the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Возвращает все вызовы, такой же <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The following code example shows how to define an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event, in order to call the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on a nested type during a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> call on the enclosing type.</source>
          <target state="translated">В следующем примере кода показано, как определить обработчик событий для <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> событий для вызова <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод для вложенного типа во время <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> вызова для включающего типа.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The enclosing type has not been created.</source>
          <target state="translated">Включающий тип не создан.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is non-abstract and contains an abstract method.</source>
          <target state="translated">Этот тип не является абстрактным, а содержит абстрактный метод.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is not an abstract class or an interface and has a method without a method body.</source>
          <target state="translated">Этот тип не является абстрактным классом или интерфейсом, а содержит метод без тела метода.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type contains invalid Microsoft intermediate language (MSIL) code.</source>
          <target state="translated">Тип содержит неверный код на языке MSIL.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</source>
          <target state="translated">Конечный адрес ветвления задан с использованием однобайтового смещения, но он находится на расстоянии более 127 байт от ветви.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type cannot be loaded.</source>
          <target state="translated">Не удалось загрузить тип.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>For example, it contains a <ph id="ph1">&lt;see langword="static" /&gt;</ph> method that has the calling convention <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</source>
          <target state="translated">Например, он содержит метод <ph id="ph1">&lt;see langword="static" /&gt;</ph>, имеющий соглашение о вызовах <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object that represents this type.</source>
          <target state="translated">Получает объект <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph>, представляющий этот тип.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>An object that represents this type.</source>
          <target state="translated">Объект, представляющий этот тип.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>Gets the method that declared the current generic type parameter.</source>
          <target state="translated">Возвращает метод, который объявил текущий параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>, представляющий метод, который объявил текущий тип, если текущий тип является параметром универсального типа; в противном случае — <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">При порождении кода, представленного параметром универсального типа <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> объекта, а не <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Returns the type that declared this type.</source>
          <target state="translated">Возвращает тип, объявивший этот тип.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>The type that declared this type.</source>
          <target state="translated">Тип, объявивший этот тип.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new constructor to the dynamic type.</source>
          <target state="translated">Добавляет новый конструктор в динамический тип.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Атрибуты конструктора.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Соглашение о вызовах конструктора.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Типы параметров конструктора.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Adds a new constructor to the type, with the given attributes and signature.</source>
          <target state="translated">Добавляет в тип новый конструктор с заданными атрибутами и сигнатурой.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The defined constructor.</source>
          <target state="translated">Определенный конструктор.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</source>
          <target state="translated">Если не определить конструктор для динамического типа, автоматически предоставляется конструктор по умолчанию, и он вызывает конструктор базового класса по умолчанию.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you define a constructor for your dynamic type, a default constructor is not provided.</source>
          <target state="translated">Если определить конструктор для динамического типа, конструктор по умолчанию не предоставляется.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>You have the following options for providing a default constructor in addition to the constructor you defined:</source>
          <target state="translated">Имеются следующие параметры для конструктора по умолчанию в дополнение к определенному вами конструктору:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that simply calls the default constructor of the base class, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> method to create one (and optionally restrict access to it).</source>
          <target state="translated">Если требуется конструктор по умолчанию, который просто вызывает конструктор по умолчанию базового класса, можно использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> метод, чтобы создать его (и при необходимости ограничить доступ к нему).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Do not provide an implementation for this default constructor.</source>
          <target state="translated">Предоставляет реализацию этого конструктора по умолчанию.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do, an exception is thrown when you try to use the constructor.</source>
          <target state="translated">В противном случае исключение при попытке использовать конструктор.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>No exception is thrown when the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Исключение не возникает, когда <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> method to create one, and provide your own implementation.</source>
          <target state="translated">Если конструктор по умолчанию, который выполняет нечто большее, нежели просто вызов конструктора по умолчанию базового класса или другого конструктора, которая вызывает базовый класс или, производящий другие полностью, необходимо использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> метод для ее создания, и предоставить собственную реализацию.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">В следующем образце кода показано использование <ph id="ph1">`DefineConstructor`</ph> для установки определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> для заполнения MSIL.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Атрибуты конструктора.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Соглашение о вызовах конструктора.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Типы параметров конструктора.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива типов.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</source>
          <target state="translated">Добавляет в тип новый конструктор с заданными атрибутами, сигнатурой и настраиваемыми модификаторами.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The defined constructor.</source>
          <target state="translated">Определенный конструктор.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Эта перегрузка предназначен для разработки управляемых компиляторов.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Дополнительные сведения о настраиваемых модификаторов см. в документации объектах.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">Размер <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> или <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> не равен размеру <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> object representing the attributes to be applied to the constructor.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph>, представляющий атрибуты, применяемые к конструктору.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Defines the default constructor.</source>
          <target state="translated">Определяет конструктор по умолчанию.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The constructor defined here will simply call the default constructor of the parent.</source>
          <target state="translated">Определенный здесь конструктор просто вызовет конструктор по умолчанию родительского элемента.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Returns the constructor.</source>
          <target state="translated">Возвращает конструктор.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</source>
          <target state="translated">Конструктор по умолчанию определяется автоматически, его не нужно вызывать этот метод только в следующих ситуациях.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</source>
          <target state="translated">Определен другой конструктор, а также конструктор по умолчанию, который просто вызывает конструктор базового класса.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You want to set the attributes on the default constructor to something other than <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, and <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</source>
          <target state="translated">Чтобы задать атрибуты конструктора по умолчанию на что-то отличное от <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, и <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">В следующем образце кода показано использование <ph id="ph1">`DefineConstructor`</ph> для установки определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> для заполнения MSIL.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The parent type (base type) does not have a default constructor.</source>
          <target state="translated">У родительского типа (базового типа) нет конструктора по умолчанию.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The name of the event.</source>
          <target state="translated">Имя события.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The attributes of the event.</source>
          <target state="translated">Атрибуты события.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type of the event.</source>
          <target state="translated">Тип события.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>Adds a new event to the type, with the given name, attributes and event type.</source>
          <target state="translated">Добавляет новое событие в тип с заданным именем, атрибутами и типом события.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The defined event.</source>
          <target state="translated">Определенное событие.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new field to the dynamic type.</source>
          <target state="translated">Добавляет новое поле к динамическому типу.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Имя поля.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Тип поля.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Атрибуты поля.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, and field type.</source>
          <target state="translated">Добавляет новое поле в тип с заданным именем, атрибутами и типом поля.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">Определенное поле.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="type" /&gt;</ph> имеет значение System.Void.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">Общий размер был указан для родительского класса этого поля.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Имя поля.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Тип поля.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the required custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Массив типов, представляющих обязательные настраиваемые модификаторы для поля, например <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the optional custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Массив типов, представляющих необязательные настраиваемые модификаторы для поля, например <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Атрибуты поля.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</source>
          <target state="translated">Добавляет новое поле в тип с заданным именем, атрибутами, типом поля и настраиваемыми модификаторами.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">Определенное поле.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Эта перегрузка предназначен для разработки управляемых компиляторов.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="type" /&gt;</ph> имеет значение System.Void.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">Общий размер был указан для родительского класса этого поля.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of names for the generic type parameters.</source>
          <target state="translated">Массив имен для параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to set their constraints.</source>
          <target state="translated">Определяет параметры универсального типа для текущего типа, указывая их количество и имена, и возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>, которые можно использовать для задания их ограничений.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define the constraints of the generic type parameters for the current type.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>, которые можно использовать для определения ограничений параметров универсального типа для текущего типа.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method makes the current type a generic type.</source>
          <target state="translated">Вызов этого метода делает текущий тип является универсальным типом.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>If the method is called again on the same type, an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Если метод вызывается снова на тот же тип, <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</source>
          <target state="translated">В следующем примере кода создается универсальный тип с двумя параметрами типа и сохраняет их в сборке GenericEmitExample1.dll.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the generated types.</source>
          <target state="translated">Можно использовать <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для просмотра в создаваемых типов.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>For a more detailed explanation of the steps involved in defining a dynamic generic type, see <bpt id="p1">[</bpt>How to: Define a Generic Type with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Более подробное описание действий, необходимых при определении динамического универсального типа см. в разделе <bpt id="p1">[</bpt>как: определение универсального типа с помощью порождаемого отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this type.</source>
          <target state="translated">Для этого типа уже были определены параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="names" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="names" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> является пустым массивом.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Имя, используемое для ссылки на данные.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The blob of data.</source>
          <target state="translated">Большой двоичный объект данных.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Атрибуты поля.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Определяет инициализированное поле данных в разделе .sdata переносимого исполняемого (PE) файла.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Поле для ссылки на данные.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">Поле, созданная с помощью этого метода будет <ph id="ph1">`static`</ph>, даже если не включать <ph id="ph2">`FieldAttributes.Static`</ph> в <ph id="ph3">`attributes`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</source>
          <target state="translated">Размер данных не больше нуля либо не меньше 0x3f0000.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> или <ph id="ph2">&lt;paramref name="data" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> был вызван ранее.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a method to the type.</source>
          <target state="translated">Добавляет метод к типу.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The name of the method.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Adds a new method to the type, with the specified name and method attributes.</source>
          <target state="translated">Добавляет новый метод в тип с указанным именем и атрибутами метода.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, представляющий вновь определенный метод.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Если вы не знаете подписи метода во время определения метода, используйте перегрузку этого метода.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Например типы параметров и возвращаемого типа универсального метода может указываться с параметрами универсального типа метода, которые должны быть определены после добавления метода в тип.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Параметры и тип возвращаемого значения метода можно установить позднее с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This method overload defines a method with <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Эта перегрузка метода определяет метод с <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>If you need to define a method without a signature, with a different calling convention, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overload.</source>
          <target state="translated">Если вам необходимо определить метод без подписи, с другой соглашение о вызовах, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The following code example defines a generic method named <ph id="ph1">`DemoMethod`</ph> whose parameter type and return type are specified by its generic type parameters.</source>
          <target state="translated">В следующем примере кода определяется универсальный метод с именем <ph id="ph1">`DemoMethod`</ph> , тип параметра и тип возвращаемого значения задаются с помощью его параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The method is defined without a signature, using the standard calling convention.</source>
          <target state="translated">Метод определен без подписи, используя стандартное соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method is used to make <ph id="ph2">`DemoMethod`</ph> a generic method, and the newly defined type parameters are then used for the signature and return type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> Метод используется для создания <ph id="ph2">`DemoMethod`</ph> универсального метода и вновь определенный тип параметров используются для подписи и тип возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The name of the method.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The calling convention of the method.</source>
          <target state="translated">Соглашение о вызовах метода.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Adds a new method to the type, with the specified name, method attributes, and calling convention.</source>
          <target state="translated">Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, представляющий вновь определенный метод.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Если вы не знаете подписи метода во время определения метода, используйте перегрузку этого метода.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Например типы параметров и возвращаемого типа универсального метода может указываться с параметрами универсального типа метода, которые должны быть определены после добавления метода в тип.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Параметры и тип возвращаемого значения метода можно установить позднее с помощью <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type of the parent of this method is an interface and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Тип родительского элемента данного метода является интерфейсом, и этот метод не является виртуальным (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Типы параметров метода.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, and method signature.</source>
          <target state="translated">Добавляет новый метод в тип с указанным именем, атрибутами метода и сигнатурой метода.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined method.</source>
          <target state="translated">Определенный метод.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">В следующем образце кода показано использование <ph id="ph1">`DefineMethod`</ph> можно задать определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> для заполнения MSIL.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the method.</source>
          <target state="translated">Соглашение о вызовах метода.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Типы параметров метода.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</source>
          <target state="translated">Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах и сигнатурой метода.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, представляющий вновь определенный метод.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">В следующем образце кода показано использование <ph id="ph1">`DefineMethod`</ph> можно задать определенной подписи и атрибутов конструктора на динамическом типе и возврата соответствующего <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> для заполнения MSIL.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">Имя метода.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the method.</source>
          <target state="translated">Соглашение о вызовах метода.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа метода.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа метода.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Типы параметров метода.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива типов.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</source>
          <target state="translated">Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах, сигнатурой метода и настраиваемыми модификаторами.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object representing the newly added method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, представляющий добавленный метод.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this overload if you need to specify custom modifiers.</source>
          <target state="translated">Используйте этот перегруженный метод, если требуется указать пользовательские модификаторы.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overloads to define the method and then use the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method to define the parameter and return types with custom modifiers.</source>
          <target state="translated">Если требуется указать пользовательские модификаторы, после создания метода, как и, например, с универсальным методом, типы параметров задаются его параметры универсального типа можно использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> перегруженных версий метода для определения метод, а затем с помощью <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> метод для определения параметра и возвращают типы с пользовательские модификаторы.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Дополнительные сведения о настраиваемых модификаторов см. в документации объектах.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">Размер <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> или <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> не равен размеру <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method body to be used.</source>
          <target state="translated">Тело метода, которое будет использоваться.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>This should be a <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">Должно быть объектом <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method whose declaration is to be used.</source>
          <target state="translated">Метод, объявление которого будет использоваться.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Specifies a given method body that implements a given method declaration, potentially with a different name.</source>
          <target state="translated">Задает тело данного метода, реализующее объявление данного метода, возможно, с другим именем.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Do not use this method to emit method overrides or interface implementations.</source>
          <target state="translated">Не используйте этот метод для создания перегрузки метода или реализации интерфейса.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</source>
          <target state="translated">Переопределение метода базового класса или реализовать метод интерфейса, просто создайте метод с тем же именем и сигнатурой, что и метод должен быть переопределен или реализован, как показано в следующем примере кода.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is used when a method body and a method declaration have different names.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> Метод используется, когда тела метода и в объявлении метода имеют разные имена.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</source>
          <target state="translated">Например класс может переопределить метод базового класса и также предоставить отдельную реализацию элемента интерфейса с тем же именем, как показано в следующем примере кода.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`DefineMethodOverride`</ph> defines a <ph id="ph2">`methodimpl`</ph>, which consists of a pair of metadata tokens.</source>
          <target state="translated"><ph id="ph1">`DefineMethodOverride`</ph> Определяет <ph id="ph2">`methodimpl`</ph>, который состоит из пары токены метаданных.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>One token points to an implementation, and the other token points to a declaration that the body implements.</source>
          <target state="translated">Один маркер указывает на реализацию, а также других маркеров точек с объявлением, реализующий текст.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The body must be defined on the type the method impl is defined on, and the body must be virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
          <target state="translated">Текст должен быть определен в тип, определенный метод impl на и текст должен представлять виртуальный (<ph id="ph1">`Overridable`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</source>
          <target state="translated">Объявления можно сделать для метода, определенного на интерфейс, реализованный тип, метод для производного класса или метода, определенного в типе.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is on an interface only, the slot defined for the interface is altered.</source>
          <target state="translated">Если объявление является только на интерфейсе, ячейка, заданная для интерфейса изменяется.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</source>
          <target state="translated">При объявлении метода в базовом типе, ячейка для этого метода переопределяется, и любые дубликаты переопределенного метода также заменяются.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The overridden method cannot be the actual method that is declared.</source>
          <target state="translated">Переопределенный метод не может быть фактический метод, который объявлен.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</source>
          <target state="translated">Если метод находится на том же типе, ячейка заменяется, и любые дубликаты заменяемого метода переопределяются.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For more information about method impls, see <ph id="ph1">`MethodImpl`</ph> in the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Дополнительные сведения о методе impls см. в разделе <ph id="ph1">`MethodImpl`</ph> в объектах документации.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is called, some features of <ph id="ph2">`methodInfoBody`</ph> cannot be changed.</source>
          <target state="translated">После <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> вызывается метод, некоторые функции <ph id="ph2">`methodInfoBody`</ph> не может быть изменено.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, you cannot apply an attribute to a generic type parameter of <ph id="ph1">`methodInfoBody`</ph> by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> method.</source>
          <target state="translated">Например, нельзя применять атрибут к параметру универсального типа <ph id="ph1">`methodInfoBody`</ph> с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method, do so after all characteristics of <ph id="ph2">`methodInfoBody`</ph> have been defined.</source>
          <target state="translated">Если необходимо использовать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> метод, сделать это после все характеристики <ph id="ph2">`methodInfoBody`</ph> определено.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The following code example contains an interface <ph id="ph1">`I`</ph> with a method <ph id="ph2">`M()`</ph>, a base class <ph id="ph3">`A`</ph> that implements the interface, and a derived class <ph id="ph4">`C`</ph> that overrides the base class implementation of <ph id="ph5">`M()`</ph> and also provides a separate explicit implementation of <ph id="ph6">`I.M()`</ph>.</source>
          <target state="translated">В следующем примере кода содержит интерфейс <ph id="ph1">`I`</ph> с методом <ph id="ph2">`M()`</ph>, базовый класс <ph id="ph3">`A`</ph> , реализующий интерфейс и производный класс <ph id="ph4">`C`</ph> , переопределяет реализацию базового класса <ph id="ph5">`M()`</ph> , а также Предоставляет отдельную явную реализацию <ph id="ph6">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`main()`</ph> method of the code example shows how to emit the derived class <ph id="ph2">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`main()`</ph> Метод в примере кода показано, как выпустить производный класс <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The override of <ph id="ph1">`A.M()`</ph> is accomplished simply by emitting a method <ph id="ph2">`M()`</ph> with the same signature.</source>
          <target state="translated">Переопределение метода <ph id="ph1">`A.M()`</ph> выполняется путем выпуска метода <ph id="ph2">`M()`</ph> с такой же сигнатурой.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>However, to provide a separate implementation of <ph id="ph1">`I.M()`</ph>, you must define a method body and then use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method to associate that method body with a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing <ph id="ph4">`I.M()`</ph>.</source>
          <target state="translated">Тем не менее для обеспечения отдельные реализации <ph id="ph1">`I.M()`</ph>, необходимо определить тела метода и затем использовать <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> способ сопоставления, тело метода с <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> представляющий <ph id="ph4">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The name of the method body does not matter.</source>
          <target state="translated">Имя тела метода не имеет значения.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The code example creates an instance of the emitted class.</source>
          <target state="translated">В примере кода создается экземпляр выпущенного класса.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`I.M()`</ph>, and uses it to invoke the emitted class's explicit interface implementation.</source>
          <target state="translated">Он получает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> для объекта <ph id="ph2">`I.M()`</ph>, и использует его, чтобы вызвать класс, порожденный явную реализацию интерфейса.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It then obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`A.M()`</ph>, and uses it to invoke the emitted class's override of that method.</source>
          <target state="translated">Затем происходит получение <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> для объекта <ph id="ph2">`A.M()`</ph>и использует его для вызова выпущенного класса переопределения этого метода.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> does not belong to this class.</source>
          <target state="translated">Объект <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> не принадлежит к этому классу.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> или <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> is not the type represented by this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Объявляющий тип <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> не является типом, представленным этим <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a nested type.</source>
          <target state="translated">Определяет вложенный тип.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The short name of the type.</source>
          <target state="translated">Краткое имя объекта.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Defines a nested type, given its name.</source>
          <target state="translated">Определяет вложенный тип с заданным именем.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The defined nested type.</source>
          <target state="translated">Определенный вложенный тип.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Этот метод можно использовать для создания вложенных типов даже после <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод вызван для включающего типа.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> для заказа, в котором следует выполнять вложенных и вложенных типов.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Повторяющееся имя не обязательно создается, если <ph id="ph1">`name`</ph> совпадало с именем ранее определенного типа или вложенного типа.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Длина <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю или больше 1023.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Эта операция создаст тип с повторяющимся <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> в текущей сборке.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The short name of the type.</source>
          <target state="translated">Краткое имя объекта.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the type.</source>
          <target state="translated">Атрибуты типа.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>Defines a nested type, given its name and attributes.</source>
          <target state="translated">Определяет вложенный тип с заданным именем и атрибутами.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The defined nested type.</source>
          <target state="translated">Определенный вложенный тип.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Этот метод можно использовать для создания вложенных типов даже после <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод вызван для включающего типа.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> для заказа, в котором следует выполнять вложенных и вложенных типов.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Повторяющееся имя не обязательно создается, если <ph id="ph1">`name`</ph> совпадало с именем ранее определенного типа или вложенного типа.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Не указан вложенный атрибут.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is sealed.</source>
          <target state="translated">Этот тип запечатан.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an array.</source>
          <target state="translated">Этот тип является массивом.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Длина <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю или больше 1023.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Эта операция создаст тип с повторяющимся <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> в текущей сборке.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The short name of the type.</source>
          <target state="translated">Краткое имя объекта.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes of the type.</source>
          <target state="translated">Атрибуты типа.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Тип, который вложенный тип расширяет.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines a nested type, given its name, attributes, and the type that it extends.</source>
          <target state="translated">Определяет вложенный тип на основе его имени, атрибутов и типа, который он расширяет.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined nested type.</source>
          <target state="translated">Определенный вложенный тип.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Этот метод можно использовать для создания вложенных типов даже после <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод вызван для включающего типа.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> для заказа, в котором следует выполнять вложенных и вложенных типов.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Повторяющееся имя не обязательно создается, если <ph id="ph1">`name`</ph> совпадало с именем ранее определенного типа или вложенного типа.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Не указан вложенный атрибут.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is sealed.</source>
          <target state="translated">Этот тип запечатан.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an array.</source>
          <target state="translated">Этот тип является массивом.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Длина <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю или больше 1023.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Эта операция создаст тип с повторяющимся <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> в текущей сборке.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Краткое имя объекта.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Атрибуты типа.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Тип, который вложенный тип расширяет.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Общий размер типа.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</source>
          <target state="translated">Определяет вложенный тип по заданным имени, атрибутам, общему размеру типа и типу, который он расширяет.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">Определенный вложенный тип.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Этот метод можно использовать для создания вложенных типов даже после <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод вызван для включающего типа.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> для заказа, в котором следует выполнять вложенных и вложенных типов.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Повторяющееся имя не обязательно создается, если <ph id="ph1">`name`</ph> совпадало с именем ранее определенного типа или вложенного типа.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Не указан вложенный атрибут.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is sealed.</source>
          <target state="translated">Этот тип запечатан.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an array.</source>
          <target state="translated">Этот тип является массивом.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Длина <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю или больше 1023.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Эта операция создаст тип с повторяющимся <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> в текущей сборке.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The short name of the type.</source>
          <target state="translated">Краткое имя объекта.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the type.</source>
          <target state="translated">Атрибуты типа.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Тип, который вложенный тип расширяет.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">Размер упаковки типа.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</source>
          <target state="translated">Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и размеру упаковки.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The defined nested type.</source>
          <target state="translated">Определенный вложенный тип.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Этот метод можно использовать для создания вложенных типов даже после <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод вызван для включающего типа.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> для заказа, в котором следует выполнять вложенных и вложенных типов.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Повторяющееся имя не обязательно создается, если <ph id="ph1">`name`</ph> совпадало с именем ранее определенного типа или вложенного типа.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Не указан вложенный атрибут.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is sealed.</source>
          <target state="translated">Этот тип запечатан.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an array.</source>
          <target state="translated">Этот тип является массивом.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Длина <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю или больше 1023.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Эта операция создаст тип с повторяющимся <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> в текущей сборке.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The short name of the type.</source>
          <target state="translated">Краткое имя объекта.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes of the type.</source>
          <target state="translated">Атрибуты типа.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the nested type extends.</source>
          <target state="translated">Тип, расширяемый вложенным типом.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The interfaces that the nested type implements.</source>
          <target state="translated">Интерфейсы, реализуемые вложенным типом.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</source>
          <target state="translated">Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и интерфейсам, которые он реализует.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The defined nested type.</source>
          <target state="translated">Определенный вложенный тип.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Этот метод можно использовать для создания вложенных типов даже после <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод вызван для включающего типа.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Вложенный тип должен быть завершен, прежде чем можно отразить с помощью метода <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">См. в описании <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> для заказа, в котором следует выполнять вложенных и вложенных типов.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Повторяющееся имя не обязательно создается, если <ph id="ph1">`name`</ph> совпадало с именем ранее определенного типа или вложенного типа.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Будут повторяться, полных имен должен совпадать, включая пространство имен и все вложенные типы.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Не указан вложенный атрибут.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is sealed.</source>
          <target state="translated">Этот тип запечатан.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an array.</source>
          <target state="translated">Этот тип является массивом.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Длина <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю или больше 1023.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Эта операция создаст тип с повторяющимся <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> в текущей сборке.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>An element of the <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Элемент массива <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> является <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Краткое имя объекта.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null values.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Атрибуты типа.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Тип, который вложенный тип расширяет.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">Размер упаковки типа.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Общий размер типа.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Defines a nested type, given its name, attributes, size, and the type that it extends.</source>
          <target state="translated">Определяет вложенный тип на основе его имени, атрибутов, размера и типа, который он расширяет.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">Определенный вложенный тип.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Определяет метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Имя метода <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Имя библиотеки DLL, в которой определен метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Соглашение о вызове метода.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Типы параметров метода.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Собственное соглашение о вызове.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Собственная кодировка метода.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Определяет метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> с учетом его имени, имени библиотеки DLL, в которой определен метод, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Определенный метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Некоторые DLL импорта атрибутов (см. в описании <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) не могут быть заданы как аргументы для этого метода.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Например, атрибут импорта DLL <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> должны быть добавлены после <ph id="ph2">`PInvoke`</ph> создается метод, если метод возвращает значение.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">В примере, как это сделать.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">В следующем примере демонстрируется использование <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> метод для создания <ph id="ph2">`PInvoke`</ph> метод и как добавить <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> флаг флаги реализации метода после создания <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, с помощью <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>методы.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Чтобы получить возвращаемое значение ненулевое, необходимо добавить <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">В примере создается динамическая сборка с одним динамическим модулем и одного типа, <ph id="ph1">`MyType`</ph>, который содержит <ph id="ph2">`PInvoke`</ph> метод.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated"><ph id="ph1">`PInvoke`</ph> Метод представляет Win32 <ph id="ph2">`GetTickCount`</ph> функции.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">При запуске данного примера выполняет <ph id="ph1">`PInvoke`</ph> метод.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Он также сохраняет динамическую сборку как PInvokeTest.dll.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Можно использовать <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для изучения <ph id="ph1">`MyType`</ph> класса и <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> в Visual Basic) <ph id="ph4">`PInvoke`</ph> метод, он содержит.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Можно компилировать программы Visual Basic или C#, которая использует статический <ph id="ph1">`MyType.GetTickCount`</ph> метода, включая ссылку на библиотеку DLL, при запуске csc.exe или vbc.exe; например, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Метод не является статическим.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Родительский тип является интерфейсом.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Метод является абстрактным.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Метод был определен ранее.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> или <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> или <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Имя метода <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Имя библиотеки DLL, в которой определен метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Имя точки входа в библиотеке DLL.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Соглашение о вызове метода.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Типы параметров метода.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Собственное соглашение о вызове.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Собственная кодировка метода.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Определяет метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Определенный метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Некоторые DLL импорта атрибутов (см. в описании <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) не могут быть заданы как аргументы для этого метода.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Например, атрибут импорта DLL <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> должны быть добавлены после <ph id="ph2">`PInvoke`</ph> создается метод, если метод возвращает значение.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">В примере, как это сделать.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">В следующем примере кода демонстрируется использование <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> метод для создания <ph id="ph2">`PInvoke`</ph> метод и как добавить <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> флаг флаги реализации метода после создания <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, с помощью <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Чтобы получить возвращаемое значение ненулевое, необходимо добавить <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">В примере создается динамическая сборка с одним динамическим модулем и одного типа, <ph id="ph1">`MyType`</ph>, который содержит <ph id="ph2">`PInvoke`</ph> метод.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated"><ph id="ph1">`PInvoke`</ph> Метод представляет Win32 <ph id="ph2">`GetTickCount`</ph> функции.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">При запуске данного примера выполняет <ph id="ph1">`PInvoke`</ph> метод.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Он также сохраняет динамическую сборку как PInvokeTest.dll.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Можно использовать <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для изучения <ph id="ph1">`MyType`</ph> класса и <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> в Visual Basic) <ph id="ph4">`PInvoke`</ph> метод, он содержит.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Можно компилировать программы Visual Basic или C#, которая использует статический <ph id="ph1">`MyType.GetTickCount`</ph> метода, включая ссылку на библиотеку DLL, при запуске csc.exe или vbc.exe; например, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Метод не является статическим.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Родительский тип является интерфейсом.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Метод является абстрактным.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Метод был определен ранее.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> или <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> или <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Имя метода <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Имя библиотеки DLL, в которой определен метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Имя точки входа в библиотеке DLL.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Атрибуты метода.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Соглашение о вызове метода.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Возвращаемый тип метода.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа метода.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа метода.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Типы параметров метода.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива типов.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Собственное соглашение о вызове.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Собственная кодировка метода.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags, and custom modifiers for the parameters and return type.</source>
          <target state="translated">Определяет метод <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода, флагов <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> и настраиваемых модификаторов для параметров и возвращаемого типа.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the defined <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, представляющий определенный метод <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Некоторые DLL импорта атрибутов (см. в описании <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) не могут быть заданы как аргументы для этого метода.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Например, атрибут импорта DLL <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> должны быть добавлены после <ph id="ph2">`PInvoke`</ph> создается метод, если метод возвращает значение.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">В примере, как это сделать.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Дополнительные сведения о настраиваемых модификаторов см. в документации объектах.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the [<ph id="ph1">\]</ph>, Type<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, Type<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, Type<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, Type<ph id="ph10">\[</ph><ph id="ph11">\]</ph><ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt; method to create a <ph id="ph13">`PInvoke`</ph> method, and how to add the <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">В следующем примере кода демонстрируется использование [<ph id="ph1">\]</ph>, тип<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, тип<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, тип<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, тип<ph id="ph10">\[</ph> <ph id="ph11">\]</ph> <ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A &gt; для создания <ph id="ph13">`PInvoke`</ph> метод и добавление <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> флаг флаги реализации метода после создания <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, с помощью <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">В примере создается динамическая сборка с одним динамическим модулем и одного типа, <ph id="ph1">`MyType`</ph>, который содержит <ph id="ph2">`PInvoke`</ph> метод.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated"><ph id="ph1">`PInvoke`</ph> Метод представляет Win32 <ph id="ph2">`GetTickCount`</ph> функции.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Чтобы получить возвращаемое значение ненулевое, необходимо добавить <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example uses an overload that does not specify custom modifiers.</source>
          <target state="translated">В примере перегрузку, которая не задает пользовательские модификаторы.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To specify custom modifiers, change the example code to use this method overload instead.</source>
          <target state="translated">Чтобы указать пользовательские модификаторы, измените пример кода, вместо этого использовать перегрузку этого метода.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">При запуске данного примера выполняет <ph id="ph1">`PInvoke`</ph> метод.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Он также сохраняет динамическую сборку как PInvokeTest.dll.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Можно использовать <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для изучения <ph id="ph1">`MyType`</ph> класса и <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> в Visual Basic) <ph id="ph4">`PInvoke`</ph> метод, он содержит.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Можно компилировать программы Visual Basic или C#, которая использует статический <ph id="ph1">`MyType.GetTickCount`</ph> метода, включая ссылку на библиотеку DLL, при запуске csc.exe или vbc.exe; например, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Метод не является статическим.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Родительский тип является интерфейсом.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Метод является абстрактным.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Метод был определен ранее.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> или <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">Размер <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> или <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> не равен размеру <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> или <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new property to the type.</source>
          <target state="translated">Добавляет новое свойство в тип.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">Имя свойства.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Атрибуты свойства.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Типы параметров свойства.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name and property signature.</source>
          <target state="translated">Добавляет новое свойство в тип с заданным именем и сигнатурой свойства.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">Заданное свойство.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates how to define a dynamic property and obtain a <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> for specification.</source>
          <target state="translated">В следующем образце кода показано, как определить динамическое свойство и получить <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> для спецификации.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Note that a <ph id="ph1">`PropertyBuilder`</ph> must also have a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, which will house the IL logic for the property.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`PropertyBuilder`</ph> должен существовать соответствующий <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, который будет размещается IL-код для свойства.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов массива <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">Имя свойства.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Атрибуты свойства.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Соглашение о вызовах методов доступа свойства.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Типы параметров свойства.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</source>
          <target state="translated">Добавляет новое свойство в тип с заданным именем, атрибутами, соглашением о вызове и сигнатурой свойства.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">Заданное свойство.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов массива <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">Имя свойства.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Атрибуты свойства.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа свойства.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа свойства.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Типы параметров свойства.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива типов.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, property signature, and custom modifiers.</source>
          <target state="translated">Добавляет новое свойство в тип с заданным именем, сигнатурой свойства и настраиваемыми модификаторами.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">Заданное свойство.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Эта перегрузка предназначен для разработки управляемых компиляторов.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Дополнительные сведения о настраиваемых модификаторов см. в документации объектах.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> равно <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated">Один из элементов массива <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">Имя свойства.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Атрибуты свойства.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Соглашение о вызовах методов доступа свойства.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа свойства.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, для возвращаемого типа свойства.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Типы параметров свойства.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Массив массивов типов.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива массивов.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <ph id="ph1">&lt;see langword="null" /&gt;</ph> вместо массива типов.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</source>
          <target state="translated">Добавляет новое свойство в тип с заданным именем, соглашением о вызове, сигнатурой свойства и настраиваемыми модификаторами.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">Заданное свойство.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Эта перегрузка предназначен для разработки управляемых компиляторов.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Дополнительные сведения о настраиваемых модификаторов см. в документации объектах.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Эта перегрузка метода впервые появился в <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздней версии.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов массива <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Defines the initializer for this type.</source>
          <target state="translated">Определяет инициализатор для этого типа.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Returns a type initializer.</source>
          <target state="translated">Возвращает инициализатор типа.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The initializer created is always public.</source>
          <target state="translated">Созданный инициализатор всегда является открытым.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The following code sample demonstrates how to create an initialization constructor using <ph id="ph1">`DefineTypeInitializer`</ph>.</source>
          <target state="translated">В следующем образце кода показано, как создать конструктор инициализации с помощью <ph id="ph1">`DefineTypeInitializer`</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Содержащий тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Имя, используемое для ссылки на данные.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated">Параметр <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> не может содержать внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">Размер поля данных.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Атрибуты поля.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> section of the portable executable (PE) file.</source>
          <target state="translated">Определяет неинициализированное поле данных в разделе <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> переносимого исполняемого (PE) файла.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Поле для ссылки на данные.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">Поле, созданная с помощью этого метода будет <ph id="ph1">`static`</ph>, даже если не включать <ph id="ph2">`FieldAttributes.Static`</ph> в <ph id="ph3">`attributes`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineUninitializedData`</ph> to create an uninitialized data field in a dynamic type:</source>
          <target state="translated">В следующем образце кода показано использование <ph id="ph1">`DefineUninitializedData`</ph> Создание неинициализированное поле данных в динамическом типе:</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Длина параметра <ph id="ph1">&lt;paramref name="name" /&gt;</ph> равна нулю.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="size" /&gt;</ph> меньше или равно нулю либо больше или равно 0x003f0000.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Извлекает полный путь данного типа.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Извлекает полный путь данного типа.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</source>
          <target state="translated">Возвращаемый формат — «полноеИмяВключающегоТипа + имяВложенногоТипа» для вложенных типов и «typeName» для типов, не являющегося вложенным.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>Gets a value that indicates the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Получает значение, указывающее ковариацию и особые ограничения текущего параметра универсального типа.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Побитовое сочетание значений <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph>, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">При порождении кода, представленного параметром универсального типа <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> объекта, а не <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</source>
          <target state="translated">Возвращает позицию параметра типа в списке параметров типа универсального типа, в котором объявлен этот параметр.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</source>
          <target state="translated">Если текущий объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> представляет параметр универсального типа, позиция параметра типа в списке параметров типа универсального типа, который объявил параметр. В противном случае — не определено.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">При порождении кода, представленного параметром универсального типа <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> объекта, а не <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent a generic type parameter, the value of this property is undefined.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> не представляет параметр универсального типа, значение этого свойства не определено.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents a generic type parameter.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> свойство, чтобы определить, является ли текущий <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> представляет параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The constructed generic type whose constructor is returned.</source>
          <target state="translated">Сконструированный универсальный тип, конструктор которого возвращается.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A constructor on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which constructor of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Конструктор в определении универсального типа <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, который указывает, какой конструктор <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> следует вернуть.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</source>
          <target state="translated">Возвращает конструктор указанного сконструированного универсального типа, соответствующего указанному конструктору определения универсального типа.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object that represents the constructor of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, which specifies a constructor belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, представляющий конструктор <ph id="ph2">&lt;paramref name="type" /&gt;</ph>, соответствующий <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, который указывает конструктор, принадлежащий определению универсального типа <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> Метод предоставляет способ получения <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> , представляющий Конструктор сконструированный универсальный тип, определение универсального типа, представленного <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents a constructor of <ph id="ph6">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Например, предположим, что у вас есть <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляющий тип <ph id="ph2">`G&lt;T&gt;`</ph> в синтаксис C# (<ph id="ph3">`G(Of T)`</ph> в Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> в C++) и <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> , представляющий конструктор <ph id="ph6">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Предположим, что <ph id="ph1">`G&lt;T&gt;`</ph> содержит универсальный метод с параметром типа <ph id="ph2">`U`</ph> , создающий экземпляр сконструированного типа <ph id="ph3">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In order to emit the code to create an instance of the constructed type, you need a <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents the constructor of this constructed type — in other words, that creates an instance of <ph id="ph2">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Чтобы создать код для создания экземпляра сконструированного типа, необходимо <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> , представляющий конструктор этого сконструированного типа — другими словами, который создает экземпляр <ph id="ph2">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Чтобы сделать это, сначала нужно вызвать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта, указав <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> , представляющий <ph id="ph4">`U`</ph> в качестве аргумента типа.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents the constructor of <ph id="ph5">`G&lt;U&gt;`</ph> as parameter <ph id="ph6">`constructor`</ph>.</source>
          <target state="translated">Затем вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> возвращаемое значение метода <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метода в качестве параметра <ph id="ph3">`type`</ph> и <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> , представляющий конструктор <ph id="ph5">`G&lt;U&gt;`</ph> как параметр <ph id="ph6">`constructor`</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Возвращает значение <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекта необходимо выпустить вызов функции.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">Пример кода демонстрирует этот сценарий.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">В следующем примере кода содержит исходный код для универсального класса с именем <ph id="ph1">`Sample`</ph> , содержит параметр типа с именем <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">Класс имеет поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, а также универсальный метод с именем <ph id="ph3">`GM`</ph> со своим параметром типа с именем <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> создает экземпляр <ph id="ph2">`Sample`</ph>, заменяя собственный параметр типа <ph id="ph3">`U`</ph> для параметра типа <ph id="ph4">`Sample`</ph>и сохраняет входной параметр в <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Этот исходный код скомпилирован, но не используется. Вы можете просмотреть ее с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> и сравнивают его код, созданный классом <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Код в классе <ph id="ph1">`Example`</ph> демонстрирует использование <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> метод для создания универсального кода.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph> Метод класса <ph id="ph2">`Example`</ph> создает динамическую сборку, содержащую класс с именем <ph id="ph3">`Sample`</ph> и использует <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> метод, чтобы сделать ее универсальной, добавив параметр типа с именем <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Конструктор по умолчанию и поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, добавляются к классу <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> добавляется и преобразуются в универсальный метод, с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Параметр типа <ph id="ph1">`GM`</ph> называется <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">После определения параметра типа, сигнатуры <ph id="ph1">`GM`</ph> добавляется с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Тип возвращаемого значения и нет необходимости или настраиваемые модификаторы, поэтому все параметры этого метода, <ph id="ph1">`null`</ph> за исключением <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> задает тип параметра метода только <ph id="ph4">`U`</ph>, параметр типа универсального метода.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Тело метода создает экземпляр сконструированного типа <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> в Visual Basic), назначает параметр метода для <ph id="ph3">`Field`</ph>, а затем выводит значение <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents the default constructor of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> instruction that creates the instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> Метод используется для создания <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> , представляющий конструктор по умолчанию сконструированного универсального типа <ph id="ph3">`Sample&lt;U&gt;`</ph> в <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> инструкция, которая создает экземпляр.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Пустой тип определяется для хранения метода точки входа <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">В теле <ph id="ph1">`Main`</ph>, статический <ph id="ph2">`GM`</ph> сконструированный универсальный тип вызывается метод <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> в Visual Basic), с типом <ph id="ph5">&lt;xref:System.String&gt;</ph> замещен <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">При запуске примера кода, она сохраняет порожденную сборку как TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Можно запустить TypeBuilderGetFieldExample.exe и использовании <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для сравнения порожденного кода с кодом <ph id="ph1">`Sample`</ph> класс, который компилируется в примере сам.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> не представляет универсальный тип.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="type" /&gt;</ph> не является параметром типа <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Объявляющий тип <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> не является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Объявляющий тип <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> не является определением универсального типа <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Это должен быть одноразрядный флаг из объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, как в методах <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и др.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the public and non-public constructors defined for this class, as specified.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, представляющий открытые или не открытые (в зависимости от того, что указано) конструкторы, которые определены для данного класса.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the specified constructors defined for this class.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, предоставляющий указанные конструкторы для данного класса.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">Если конструкторы не определены, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the custom attributes defined for this type.</source>
          <target state="translated">Возвращает настраиваемые атрибуты, определенные для данного типа.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Указывает, следует ли выполнять поиск атрибутов в цепочке наследования этого члена.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">Возвращает все настраиваемые атрибуты, определенные для данного типа.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this type.</source>
          <target state="translated">Возвращает массив объектов, представляющих все настраиваемые атрибуты этого типа.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">В настоящее время этот метод не поддерживается для неполных типов.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Извлечение типа выполняется с помощью метода <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph>, а затем вызывается<ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> на возвращенном типе <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Тип атрибута для поиска.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Возвращаются только те атрибуты, которые можно назначить этому типу.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Указывает, следует ли выполнять поиск атрибутов в цепочке наследования этого члена.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes of the current type that are assignable to a specified type.</source>
          <target state="translated">Возвращает все настраиваемые атрибуты текущего типа, которые можно назначить указанному типу.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes defined on the current type.</source>
          <target state="translated">Массив настраиваемых атрибутов, определенных для текущего типа.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">В настоящее время этот метод не поддерживается для неполных типов.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Извлечение типа выполняется с помощью метода <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph>, а затем вызывается<ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> на возвращенном типе <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type must be a type provided by the underlying runtime system.</source>
          <target state="translated">Тип должен быть типом, предоставленным базовой системой среды выполнения.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Calling this method always throws <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</source>
          <target state="translated">При вызове этого метода всегда возникает исключение <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">Этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>No value is returned.</source>
          <target state="translated">Возвращаемое значение отсутствует.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">Этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to search for.</source>
          <target state="translated">Имя искомого события.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Побитовое сочетание значений <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, ограничивающее поиск.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the event with the specified name.</source>
          <target state="translated">Возвращает событие с указанным именем.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if there are no matches.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющий событие, объявленное или наследованное этим типом с указанным именем, или <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если сопоставления отсутствуют.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the events defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Возвращает события, определенные текущим объектом <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns the public events declared or inherited by this type.</source>
          <target state="translated">Возвращает открытые события, объявленные или наследованные данным типом.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the public events declared or inherited by this type.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, предоставляющий открытые события, объявленные или наследованные данным типом.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>An empty array is returned if there are no public events.</source>
          <target state="translated">Если открытые события отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Побитовое сочетание значений <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, ограничивающее поиск.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public events that are declared by this type.</source>
          <target state="translated">Возвращает открытые и не являющиеся открытыми события, объявленные данным типом.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the events declared or inherited by this type that match the specified binding flags.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющий события, объявленные или наследованные этим типом, которые соответствуют указанным флагам связывания.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching events.</source>
          <target state="translated">Если соответствующие события отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a field defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Возвращает поле, определенное текущим объектом <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to get.</source>
          <target state="translated">Имя получаемого поля.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Это должен быть одноразрядный флаг из объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, как в методах <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и др.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the field specified by the given name.</source>
          <target state="translated">Возвращает поле, указанное данным именем.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, предоставляющий объявленное или наследованное данным типом поле с указанным именем и открытым или не являющимся открытым модификатором.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If there are no matches then <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Если совпадения отсутствуют, возвращается значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The constructed generic type whose field is returned.</source>
          <target state="translated">Сконструированный универсальный тип, поле которого возвращается.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A field on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which field of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Поле в определении универсального типа <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, которое указывает, какое поле <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> следует вернуть.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</source>
          <target state="translated">Возвращает поле указанного сконструированного универсального типа, соответствующее указанному полю определения универсального типа.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object that represents the field of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, which specifies a field belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющий поле <ph id="ph2">&lt;paramref name="type" /&gt;</ph>, соответствующее <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, который указывает поле, принадлежащее определению универсального типа <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents a field of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> Метод предоставляет способ получения <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> объект, который представляет сконструированный универсальный тип, определение универсального типа, представленного поле <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents a field <ph id="ph6">`public T F`</ph> in C# syntax (<ph id="ph7">`Public F As T`</ph> in Visual Basic, <ph id="ph8">`public: T F`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Например, предположим, что у вас есть <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляющий тип <ph id="ph2">`G&lt;T&gt;`</ph> в синтаксис C# (<ph id="ph3">`G(Of T)`</ph> в Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> в C++) и <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> , представляющий поле <ph id="ph6">`public T F`</ph> в синтаксис C# (<ph id="ph7">`Public F As T`</ph>в Visual Basic <ph id="ph8">`public: T F`</ph> в C++), определяется <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls field <ph id="ph4">`F`</ph> on that instance.</source>
          <target state="translated">Предположим, что <ph id="ph1">`G&lt;T&gt;`</ph> содержит универсальный метод с параметром типа <ph id="ph2">`U`</ph> , создающий экземпляр сконструированного типа <ph id="ph3">`G&lt;U&gt;`</ph> и вызывает поле <ph id="ph4">`F`</ph> на этом экземпляре.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents <ph id="ph2">`F`</ph> on the constructed type — in other words, that is of type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Чтобы выпустить вызов функции, вы должны <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> , представляющий <ph id="ph2">`F`</ph> для сконструированного типа — другими словами, которое принадлежит типу <ph id="ph3">`U`</ph> вместо типа <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Чтобы сделать это, сначала нужно вызвать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта, указав <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> , представляющий <ph id="ph4">`U`</ph> в качестве аргумента типа.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents <ph id="ph5">`F`</ph> as parameter <ph id="ph6">`field`</ph>.</source>
          <target state="translated">Затем вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> возвращаемое значение метода <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метода в качестве параметра <ph id="ph3">`type`</ph> и <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> , представляющий <ph id="ph5">`F`</ph> как параметр <ph id="ph6">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Возвращает значение <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> объекта необходимо выпустить вызов функции.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">Пример кода демонстрирует этот сценарий.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter named <ph id="ph1">`T`</ph>.</source>
          <target state="translated">В следующем примере кода содержит исходный код для универсального класса с именем Sample, который имеет параметр типа с именем <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">Класс имеет поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, а также универсальный метод с именем <ph id="ph3">`GM`</ph> со своим параметром типа с именем <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> создает экземпляр <ph id="ph2">`Sample`</ph>, заменяя собственный параметр типа <ph id="ph3">`U`</ph> для параметра типа <ph id="ph4">`Sample`</ph>и сохраняет входной параметр в <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Этот исходный код скомпилирован, но не используется. Вы можете просмотреть ее с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> и сравнивают его код, созданный классом <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Код в классе <ph id="ph1">`Example`</ph> демонстрирует использование <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> метод для создания универсального кода.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph> Метод класса <ph id="ph2">`Example`</ph> создает динамическую сборку, содержащую класс с именем <ph id="ph3">`Sample`</ph>и использует <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> метод, чтобы сделать ее универсальной, добавив параметр типа с именем <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Конструктор по умолчанию и поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, добавляются к классу <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> добавляется и преобразуются в универсальный метод, с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Параметр типа <ph id="ph1">`GM`</ph> называется <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">После определения параметра типа, сигнатуры <ph id="ph1">`GM`</ph> добавляется с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Тип возвращаемого значения и нет необходимости или настраиваемые модификаторы, поэтому все параметры этого метода, <ph id="ph1">`null`</ph> за исключением <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> задает тип параметра метода только <ph id="ph4">`U`</ph>, параметр типа универсального метода.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Тело метода создает экземпляр сконструированного типа <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> в Visual Basic), назначает параметр метода для <ph id="ph3">`Field`</ph>, а затем выводит значение <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> that represents the field of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> instructions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> Метод используется для создания <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> , представляющий поле сконструированного универсального типа <ph id="ph3">`Sample&lt;U&gt;`</ph> в <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> и <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> инструкции.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Пустой тип определяется для хранения метода точки входа <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">В теле <ph id="ph1">`Main`</ph>, статический <ph id="ph2">`GM`</ph> сконструированный универсальный тип вызывается метод <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> в Visual Basic), с типом <ph id="ph5">&lt;xref:System.String&gt;</ph> замещен <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">При запуске примера кода, она сохраняет порожденную сборку как TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Можно запустить TypeBuilderGetFieldExample.exe и использовании <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для сравнения порожденного кода с кодом <ph id="ph1">`Sample`</ph> класс, который компилируется в примере сам.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> не представляет универсальный тип.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="type" /&gt;</ph> не является параметром типа <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Объявляющий тип <ph id="ph1">&lt;paramref name="field" /&gt;</ph> не является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Объявляющий тип <ph id="ph1">&lt;paramref name="field" /&gt;</ph> не является определением универсального типа <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Этот параметр должен представлять собой битовый флаг объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и т. д.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public fields that are declared by this type.</source>
          <target state="translated">Возвращает открытые и не являющиеся открытыми поля, объявленные данным типом.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the public and non-public fields declared or inherited by this type.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, предоставляющий открытые и не являющиеся открытыми поля, объявленные или наследованные данным типом.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no fields, as specified.</source>
          <target state="translated">Если заданные поля отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий аргументы универсального типа, или параметры типа определения универсального типа.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Элементы массива, которые представляют аргументы универсального типа или параметры определения универсального типа.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</source>
          <target state="translated">Элементы возвращаемого массива, в том порядке, в котором они отображаются в списке параметров типа для определения универсального типа.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объект представляет определение универсального типа, если <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> метод использовался для придания ей параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>This method retrieves the <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objects that represent the generic type parameters.</source>
          <target state="translated">Этот метод получает <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> объекты, представляющие параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Дополнительные сведения об универсальных типах в отражении и списке неизменяемых условий для терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий определение универсального типа, на основе которого можно получить текущий тип.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий определение универсального типа, на основе которого можно получить текущий тип.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object for which the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> property returns the current instance.</source>
          <target state="translated">При вызове метода <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объект, для которого <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> возвращает <ph id="ph4">`true`</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> свойство возвращает текущий экземпляр.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type is always a generic type definition.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляет универсальный тип всегда является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you used the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method to construct a generic type from a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents a generic type definition, using the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> method on the constructed type gets back the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the generic type definition.</source>
          <target state="translated">При использовании <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метод для создания универсального типа из <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляющий определение универсального типа, с помощью <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> возвращает метод для сконструированного типа <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляющий универсальный тип Определение.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>The current type is not generic.</source>
          <target state="translated">Текущий тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>The name of the interface.</source>
          <target state="translated">Имя интерфейса.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Если <ph id="ph1">&lt;see langword="true" /&gt;</ph>, то при поиске не учитывается регистр.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Если <ph id="ph1">&lt;see langword="false" /&gt;</ph>, то при поиске учитывается регистр.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</source>
          <target state="translated">Возвращает интерфейс, реализованный (прямо или косвенно) данным классом с полным именем, совпадающим с именем данного интерфейса.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the implemented interface.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий реализованный интерфейс.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns null if no interface matching name is found.</source>
          <target state="translated">Возвращает значение null, если совпадающее имя интерфейса не найдено.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface for which the mapping is to be retrieved.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> интерфейса, для которого необходимо извлечь сопоставление.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the requested interface.</source>
          <target state="translated">Возвращает сопоставление для запрошенного интерфейса.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns the requested interface mapping.</source>
          <target state="translated">Возвращает запрошенное сопоставление интерфейса.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of all the interfaces implemented on this type and its base types.</source>
          <target state="translated">Возвращает массив всех интерфейсов, реализованных для данного типа и его базовых типов.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the implemented interfaces.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий реализованные интерфейсы.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">Если они не определены, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member.</source>
          <target state="translated">Имя элемента.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of the member to return.</source>
          <target state="translated">Тип возвращаемого элемента.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Это должен быть одноразрядный флаг из объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, как в методах <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и др.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public members declared or inherited by this type, as specified.</source>
          <target state="translated">Возвращает все открытые и закрытые члены, объявленные или наследуемые данным типом, как указано.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public members are returned.</source>
          <target state="translated">Если задано <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph>, метод возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, предоставляющий открытые и не являющиеся открытыми элементы, определенные для данного типа; в противном случае возвращаются только открытые элементы.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, such as <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Это должен быть одноразрядный флаг из объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, например <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и др.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns the members for the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Возвращает открытые и не являющиеся открытыми члены, объявленные или наследуемые данным типом.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, предоставляющий открытые и не являющиеся открытыми элементы, объявленные или наследованные данным типом.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching members.</source>
          <target state="translated">Если соответствующие члены отсутствуют, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The constructed generic type whose method is returned.</source>
          <target state="translated">Сконструированный универсальный тип, метод которого возвращается.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which method of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Метод в определении универсального типа <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, который указывает, какой метод <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> следует вернуть.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</source>
          <target state="translated">Возвращает метод указанного сконструированного универсального типа, соответствующего указанному методу определения универсального типа.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, which specifies a method belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющий метод <ph id="ph2">&lt;paramref name="type" /&gt;</ph>, соответствующий <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, который указывает метод, принадлежащий определению универсального типа <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a method of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> Метод предоставляет способ получения <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объект, представляющий метод сконструированный универсальный тип, определение универсального типа, представленного <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents a method <ph id="ph6">`T M()`</ph> in C# syntax (<ph id="ph7">`Function M() As T`</ph> in Visual Basic, <ph id="ph8">`T M()`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Например, предположим, что у вас есть <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляющий тип <ph id="ph2">`G&lt;T&gt;`</ph> в синтаксис C# (<ph id="ph3">`G(Of T)`</ph> в Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> в C++) и <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> объект, представляющий метод <ph id="ph6">`T M()`</ph> в синтаксис C# (<ph id="ph7">`Function M() As T`</ph>в Visual Basic <ph id="ph8">`T M()`</ph> в C++), определяется <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls method <ph id="ph4">`M`</ph> on that instance.</source>
          <target state="translated">Предположим, что <ph id="ph1">`G&lt;T&gt;`</ph> содержит универсальный метод с параметром типа <ph id="ph2">`U`</ph> , создающий экземпляр сконструированного типа <ph id="ph3">`G&lt;U&gt;`</ph> и вызывает метод <ph id="ph4">`M`</ph> на этом экземпляре.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph2">`M`</ph> on the constructed type — in other words, that returns type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Чтобы выпустить вызов функции, необходим <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , представляющий <ph id="ph2">`M`</ph> для сконструированного типа — другими словами, которая возвращает тип <ph id="ph3">`U`</ph> вместо типа <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Чтобы сделать это, сначала нужно вызвать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта, указав <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> , представляющий <ph id="ph4">`U`</ph> в качестве аргумента типа.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents <ph id="ph5">`T M()`</ph> as parameter <ph id="ph6">`method`</ph>.</source>
          <target state="translated">Затем вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> возвращаемое значение метода <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метода в качестве параметра <ph id="ph3">`type`</ph> и <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> , представляющий <ph id="ph5">`T M()`</ph> как параметр <ph id="ph6">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Возвращает значение <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта необходимо выпустить вызов функции.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates a scenario similar to this.</source>
          <target state="translated">Пример кода демонстрирует сценарий аналогичным образом.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">В следующем примере кода содержит исходный код для универсального класса с именем <ph id="ph1">`Sample`</ph> , содержит параметр типа с именем <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">Класс имеет поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, а также универсальный метод с именем <ph id="ph3">`GM`</ph> со своим параметром типа с именем <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> создает экземпляр <ph id="ph2">`Sample`</ph>, заменяя собственный параметр типа <ph id="ph3">`U`</ph> для параметра типа <ph id="ph4">`Sample`</ph>и сохраняет входной параметр в <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Этот исходный код скомпилирован, но не используется. Вы можете просмотреть ее с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> и сравнивают его код, созданный классом <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Код в классе <ph id="ph1">`Example`</ph> демонстрирует использование <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> метод для создания универсального кода.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph> Метод класса <ph id="ph2">`Example`</ph> создает динамическую сборку, содержащую класс с именем <ph id="ph3">`Sample`</ph> и использует <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> метод, чтобы сделать ее универсальной, добавив параметр типа с именем <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Конструктор по умолчанию и поле с именем <ph id="ph1">`Field`</ph>, типа <ph id="ph2">`T`</ph>, добавляются к классу <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Метод <ph id="ph1">`GM`</ph> добавляется и преобразуются в универсальный метод, с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Параметр типа <ph id="ph1">`GM`</ph> называется <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">После определения параметра типа, сигнатуры <ph id="ph1">`GM`</ph> добавляется с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Тип возвращаемого значения и нет необходимости или настраиваемые модификаторы, поэтому все параметры этого метода, <ph id="ph1">`null`</ph> за исключением <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> задает тип параметра метода только <ph id="ph4">`U`</ph>, параметр типа универсального метода.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Тело метода создает экземпляр сконструированного типа <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> в Visual Basic), назначает параметр метода для <ph id="ph3">`Field`</ph>, а затем выводит значение <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Пустой тип определяется для хранения метода точки входа <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">В теле <ph id="ph1">`Main`</ph>, статический <ph id="ph2">`GM`</ph> сконструированный универсальный тип вызывается метод <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> в Visual Basic), с типом <ph id="ph5">&lt;xref:System.String&gt;</ph> замещен <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> Метод используется для создания <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> для статического <ph id="ph3">`GM`</ph> метод сконструированного универсального типа <ph id="ph4">`Sample&lt;U&gt;`</ph>и <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> метод затем используется для создания <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> , можно создать в вызове метода.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">При запуске примера кода, она сохраняет порожденную сборку как TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Можно запустить TypeBuilderGetFieldExample.exe и использовании <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для сравнения порожденного кода с кодом <ph id="ph1">`Sample`</ph> класс, который компилируется в примере сам.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is a generic method that is not a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> представляет универсальный метод, который не является определением универсального метода.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> не представляет универсальный тип.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="type" /&gt;</ph> не является параметром типа <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Объявляющий тип <ph id="ph1">&lt;paramref name="method" /&gt;</ph> не является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Объявляющий тип <ph id="ph1">&lt;paramref name="method" /&gt;</ph> не является определением универсального типа <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Это должен быть одноразрядный флаг из объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, как в методах <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и др.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public methods declared or inherited by this type, as specified.</source>
          <target state="translated">Возвращает все открытые и закрытые методы, объявленные или наследуемые данным типом, как указано.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing the public and non-public methods defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public methods are returned.</source>
          <target state="translated">Если задано <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph>, метод возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, предоставляющий открытые и не являющиеся открытыми методы, определенные для данного типа; в противном случае возвращаются только открытые методы.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the name of the nested type to get.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, содержащий имя искомого вложенного типа.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to conduct a case-sensitive search for public methods.</source>
          <target state="translated">Нуль для выполнения поиска открытых методов с учетом регистра.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared by this type.</source>
          <target state="translated">Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные этим типом.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Если этот тип является завершения, например, если <ph id="ph1">`CreateType`</ph> был вызван для этого типа, но имеются вложенные типы, которые не являются полными, затем <ph id="ph2">`GetNestedTypes`</ph> возвращает только те вложенные типы, для которых <ph id="ph3">`CreateType`</ph> был вызван.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Это должен быть одноразрядный флаг из объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, как в методах <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и др.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared or inherited by this type.</source>
          <target state="translated">Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные или наследованные данным типом.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий все типы, вложенные в текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, которые соответствуют указанным ограничениям на связывание.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no types are nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the nested types match the binding constraints.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, если у текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет вложенных типов или если ни один из вложенных типов не соответствует ограничениям на связывание.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Если этот тип является завершения, например, если <ph id="ph1">`CreateType`</ph> был вызван для этого типа, но имеются вложенные типы, которые не являются полными, затем <ph id="ph2">`GetNestedTypes`</ph> возвращает только те вложенные типы, для которых <ph id="ph3">`CreateType`</ph> был вызван.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This invocation attribute.</source>
          <target state="translated">Это атрибут вызова.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Этот параметр должен представлять собой битовый флаг объекта <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> и т. д.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public properties declared or inherited by this type, as specified.</source>
          <target state="translated">Возвращает все открытые и закрытые свойства, объявленные или наследуемые данным типом, как указано.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing the public and non-public properties defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public properties are returned.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph>, предоставляющих открытые и неоткрытые свойства, определенные на данном типе, если используется параметр <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph>; в противном случае возвращаются только открытые свойства.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Этот метод не реализован для неполных типов.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type.</source>
          <target state="translated">Получает идентификатор GUID этого типа.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type</source>
          <target state="translated">Получает идентификатор GUID этого типа.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">В настоящее время этот метод не поддерживается для неполных типов.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">Имя вызываемого члена.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This can be a constructor, method, property, or field.</source>
          <target state="translated">Это может быть конструктор, метод, свойство или поле.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">Необходимо указать подходящий атрибут вызова.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</source>
          <target state="translated">Обратите внимание, что можно вызвать член класса, заданный по умолчанию, передав в качестве имени члена пустую строку.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">Атрибут вызова.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be a bit flag from <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Этот должен быть битовый флаг из <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> с помощью отражения.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Если связыватель имеет значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используется связыватель по умолчанию.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Объект, для которого следует вызвать указанный член.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member is static, this parameter is ignored.</source>
          <target state="translated">Если член является статическим, этот параметр игнорируется.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An argument list.</source>
          <target state="translated">Список аргументов.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated">Это массив объектов, содержащий число, порядок и тип параметров вызываемого члена.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If there are no parameters this should be null.</source>
          <target state="translated">Если параметров нет, должно быть указано значение NULL.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated">Массив, длина которого равна длине <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>, с элементами, представляющими атрибуты, связанные с аргументами вызываемого члена.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the metadata.</source>
          <target state="translated">Параметр имеет атрибуты, связанные с ним в метаданных.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>They are used by various interoperability services.</source>
          <target state="translated">Они используются различными службами взаимодействия.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See the metadata specs for more details.</source>
          <target state="translated">Дополнительные сведения см. в спецификации метаданных.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Экземпляр объекта <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph>, используемого для управления приведением типов.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If this is null, the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Если его значением является null, для текущего потока используется <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Обратите внимание, что необходимо, например, преобразовать строку, представляющую 1000, в число с двойной точностью, поскольку для разных языков и региональных параметров 1000 представляется по-разному.)</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> array gets the value in the corresponding element in the <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Каждый параметр в массиве <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> получает значение в соответствующем элементе в массиве <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> is greater than the length of <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, the remaining argument values are passed in order.</source>
          <target state="translated">Если длина <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> превышает длину <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, оставшиеся значения аргументов передаются по порядку.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">Вызывает указанный член.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">Вызываемый метод должен быть доступен и обеспечивать наиболее точное соответствие заданному списку аргументов с учетом ограничений заданного модуля привязки и атрибутов вызова.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Returns the return value of the invoked member.</source>
          <target state="translated">Возвращает возвращаемое значение вызываемого члена.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Метод будет вызван, если число параметров в объявлении метода равно количеству аргументов в списке аргументов, а тип каждого аргумента может преобразовываться связывателем тип параметра.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Связыватель найдет все подходящие методы.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</source>
          <target state="translated">Эти методы находятся в зависимости от типа привязки запрошенного (BindingFlags.InvokeMethod, BindingFlags.GetProperties и т. д.).</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">После выбора метод будет вызван.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">На этом этапе проверяется доступность.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`IBinder.BindToMethod`</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">`IBinder.BindToMethod`</ph> Метод отвечает за выбор вызываемого метода.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Связыватель по умолчанию выбирает наиболее точное соответствие.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Ограничения доступа игнорируются для полностью доверенный код.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
          <target state="translated">То есть закрытые конструкторы, методы, поля и свойства доступны и с использованием отражения, если полностью доверенный код.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported.</source>
          <target state="translated">В настоящее время этот метод не поддерживается.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Можно извлечь при помощи типа <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">В настоящее время этот метод не поддерживается для неполных типов.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Determines whether a specified type can be assigned to this object.</source>
          <target state="translated">Определяет, можно ли назначить указанный тип этому объекту.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The object to test.</source>
          <target state="translated">Объект для тестирования.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object can be assigned to this object.</source>
          <target state="translated">Получает значение, указывающее, может ли заданный объект <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> быть назначен этому объекту.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> can be assigned to this object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> может быть назначен этому объекту. В противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>The object to test.</source>
          <target state="translated">Объект для тестирования.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be assigned to this object.</source>
          <target state="translated">Получает значение, указывающее, можно ли назначить указанный объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> данному объекту.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="c" /&gt;</ph> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, or if the current type is an interface that <ph id="ph4">&lt;paramref name="c" /&gt;</ph> supports.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="c" /&gt;</ph> и текущий объект тип представляют один тип, или если текущий тип находится в иерархии наследования параметра <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, или если текущий тип является интерфейсом, поддерживаемым параметром <ph id="ph4">&lt;paramref name="c" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are valid, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, если не выполняется ни одно из этих условий, или значение параметра <ph id="ph2">&lt;paramref name="c" /&gt;</ph> равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Returns a value that indicates whether the current dynamic type has been created.</source>
          <target state="translated">Возвращает значение, которое показывает, был ли создан текущий динамический тип.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has been called; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если был вызван метод <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>. В противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called, the type represented by the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object is complete.</source>
          <target state="translated">После <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> был вызван метод, к типу, представленному <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта завершена.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</source>
          <target state="translated">Исключения создаются на любые дальнейшие попытки добавления элементов или изменения других характеристик типа.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Тип атрибута для поиска.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Возвращаются только те атрибуты, которые можно назначить этому типу.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Указывает, следует ли выполнять поиск атрибутов в цепочке наследования этого члена.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Determines whether a custom attribute is applied to the current type.</source>
          <target state="translated">Определяет, применяется ли настраиваемый атрибут к текущему типу.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, or an attribute derived from <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph>, is defined on this type; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если один или несколько экземпляров <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> или атрибут, производный от <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph>, определен для этого типа; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not supported for incomplete generic type parameters.</source>
          <target state="translated">Этот метод не поддерживается для неполных параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">В настоящее время этот метод не поддерживается для неполных типов.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Извлечение типа выполняется с помощью метода <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph>, а затем вызывается<ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> на возвращенном типе <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> не определен.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>Gets a value indicating whether the current type is a generic type parameter.</source>
          <target state="translated">Возвращает значение, указывающее, является ли текущий тип параметром универсального типа.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> представляет параметр универсального типа; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">При порождении кода, представленного параметром универсального типа <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> объекта, а не <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">Возвращает значение, указывающее, является ли текущий тип универсальным.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object is generic; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если тип, представленный текущим объектом <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, является универсальным; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объект представляет определение универсального типа, если <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> метод использовался для придания ей параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> универсального класса всегда является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Дополнительные сведения об универсальных типах в отражении и списке неизменяемых условий для терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> represents a generic type definition from which other generic types can be constructed.</source>
          <target state="translated">Возвращает значение, определяющее, представляет ли текущий объект <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> определение универсального типа, на основе которого можно конструировать другие универсальные типы.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот объект <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> представляет определение универсального типа. В противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> объект представляет определение универсального типа, если <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> метод использовался для придания ей параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> универсального класса всегда является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be used to build generic type definitions, but not constructed generic types.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> можно использовать для создания определений универсальных типов, но не сконструированные универсальные типы.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>To get a constructed generic type, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">Чтобы получить сконструированный универсальный тип, вызовите <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляющий определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Дополнительные сведения об универсальных типах в отражении и списке неизменяемых условий для терминов, используемых в универсальном отражении см. в разделе <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий тип критическим с точки зрения безопасности или надежным с точки зрения безопасности и, следовательно, может ли он выполнять важные операции.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий тип является критически важным для безопасности или защищенным критически важным для безопасности; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является прозрачным.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности типа, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">Критический в плане безопасности</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Среда выполнения начинает вычисление уровней прозрачности в сборке.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Например если динамическая сборка является критическим с точки зрения безопасности, примечания для типов игнорируются и все типы являются прозрачными.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">По умолчанию динамическая сборка наследует прозрачность породившая его сборка.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Это значение по умолчанию можно переопределить с помощью <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, или <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> перегруженный метод и указывая атрибуты безопасности.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Не может повысить уровень безопасности благодаря этому; то есть прозрачный код не может выдавать критически важным для безопасности или защищенным критически важным для безопасности кода.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Необходимо указать атрибуты, при динамической сборки, или они не вступят в силу до сборка сохранена на диске и загружаются в память.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Наследование по умолчанию ограничено оценкой прозрачности среды выполнения.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Атрибуты не применяются к динамической сборке.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Если вы хотите добавить атрибуты безопасности, необходимо применить их самостоятельно.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об отражении выпуска и прозрачности см <bpt id="p1">[</bpt>вопросы безопасности в порождение отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Текущий динамический тип не был создан с помощью вызова метода <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий тип надежным с точки зрения безопасности и, следовательно, может ли он выполнять критически важные операции и предоставлять доступ прозрачному коду.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий тип является защищенным критически важным для безопасности; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является критически важным для безопасности или прозрачным.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности типа, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">Критический в плане безопасности</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Среда выполнения начинает вычисление уровней прозрачности в сборке.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Например если динамическая сборка является критическим с точки зрения безопасности, примечания для типов игнорируются и все типы являются прозрачными.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">По умолчанию динамическая сборка наследует прозрачность породившая его сборка.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Это значение по умолчанию можно переопределить с помощью <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, или <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> перегруженный метод и указывая атрибуты безопасности.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Не может повысить уровень безопасности благодаря этому; то есть прозрачный код не может выдавать критически важным для безопасности или защищенным критически важным для безопасности кода.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Необходимо указать атрибуты, при динамической сборки, или они не вступят в силу до сборка сохранена на диске и загружаются в память.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Наследование по умолчанию ограничено оценкой прозрачности среды выполнения.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Атрибуты не применяются к динамической сборке.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Если вы хотите добавить атрибуты безопасности, необходимо применить их самостоятельно.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об отражении выпуска и прозрачности см <bpt id="p1">[</bpt>вопросы безопасности в порождение отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Текущий динамический тип не был создан с помощью вызова метода <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</source>
          <target state="translated">Получает значение, которое указывает, является ли текущий тип прозрачным и, следовательно, не может выполнять критические операции.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если тип прозрачный; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности типа, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">Критический в плане безопасности</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Среда выполнения начинает вычисление уровней прозрачности в сборке.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Например если динамическая сборка является критическим с точки зрения безопасности, примечания для типов игнорируются и все типы являются прозрачными.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">По умолчанию динамическая сборка наследует прозрачность породившая его сборка.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Это значение по умолчанию можно переопределить с помощью <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, или <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> перегруженный метод и указывая атрибуты безопасности.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Не может повысить уровень безопасности благодаря этому; то есть прозрачный код не может выдавать критически важным для безопасности или защищенным критически важным для безопасности кода.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Необходимо указать атрибуты, при динамической сборки, или они не вступят в силу до сборка сохранена на диске и загружаются в память.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Наследование по умолчанию ограничено оценкой прозрачности среды выполнения.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Атрибуты не применяются к динамической сборке.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Если вы хотите добавить атрибуты безопасности, необходимо применить их самостоятельно.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об отражении выпуска и прозрачности см <bpt id="p1">[</bpt>вопросы безопасности в порождение отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Текущий динамический тип не был создан с помощью вызова метода <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that is to be checked.</source>
          <target state="translated">Проверяемый тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Determines whether this type is derived from a specified type.</source>
          <target state="translated">Определяет, является ли этот тип производным от указанного типа.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if this type is the same as the type <ph id="ph2">&lt;paramref name="c" /&gt;</ph>, or is a subtype of type <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если данный тип совпадает с типом параметра <ph id="ph2">&lt;paramref name="c" /&gt;</ph> или является подтипом типа <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, в противном случае возвращает <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет массив текущего типа.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> Метод предоставляет способ создания тип массива с любым типом возможный элемент, включая универсальные типы.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">В следующем примере кода создается динамический модуль, абстрактный тип с именем <ph id="ph1">`Sample`</ph>и абстрактный метод с именем <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> принимает <ph id="ph2">`ref`</ph> параметра (<ph id="ph3">`ByRef`</ph> в Visual Basic) типа <ph id="ph4">`Sample`</ph>, указатель на тип <ph id="ph5">`Sample`</ph>, а также массив объектов типа <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Он возвращает двухмерный массив типа <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">Размерность массива.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий массив текущего типа указанной размерности.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет одномерный массив текущего типа.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> Метод предоставляет способ создания тип массива с любым типом возможный элемент, включая универсальные типы.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">В следующем примере кода создается динамический модуль, абстрактный тип с именем <ph id="ph1">`Sample`</ph>и абстрактный метод с именем <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> принимает <ph id="ph2">`ref`</ph> параметра (<ph id="ph3">`ByRef`</ph> в Visual Basic) типа <ph id="ph4">`Sample`</ph>, указатель на тип <ph id="ph5">`Sample`</ph>, а также массив объектов типа <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Он возвращает двухмерный массив типа <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is not a valid array dimension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> не является допустимой размерностью массива.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет текущий тип при передаче в качестве параметра <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (параметра <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет текущий тип при передаче в качестве параметра <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (параметра <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> Метод предоставляет способ создания <ph id="ph2">`ref`</ph> типов (<ph id="ph3">`ByRef`</ph> в Visual Basic) для параметра перечислены.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType&amp;`</ph>.</source>
          <target state="translated">С помощью синтаксиса Microsoft промежуточного языка MSIL, если текущий <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> представляет <ph id="ph2">`MyType`</ph>, то будет тип, возвращаемый этим методом <ph id="ph3">`MyType&amp;`</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">В следующем примере кода создается динамический модуль, абстрактный тип с именем <ph id="ph1">`Sample`</ph>и абстрактный метод с именем <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> принимает <ph id="ph2">`ref`</ph> параметра (<ph id="ph3">`ByRef`</ph> в Visual Basic) типа <ph id="ph4">`Sample`</ph>, указатель на тип <ph id="ph5">`Sample`</ph>, а также массив объектов типа <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Он возвращает двухмерный массив типа <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type definition.</source>
          <target state="translated">Массив типов, который должен быть замещен параметрами типа определения текущего универсального типа.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</source>
          <target state="translated">Замещает элементы массива типов для параметров типа определения текущего универсального типа и возвращает результирующий сконструированный тип.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет сконструированный тип, сформированный путем замещения элементов объекта <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> параметрами текущего универсального типа.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Use this method when your emitted code requires a type constructed from the current generic type definition.</source>
          <target state="translated">Используйте этот метод, если выпущенного кода требуется тип, построенный из текущего определения универсального типа.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is not necessary to call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method before calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">Нет необходимости вызывать <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод перед вызовом метода <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> метод <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , представляющий определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent the definition of a generic type, an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> не представляет определение универсального типа, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</source>
          <target state="translated">Объект, возвращаемый этим методом, функционирует как заполнитель для сконструированного универсального типа в выпуске кода.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is an instance of a class derived from <ph id="ph1">&lt;xref:System.Type&gt;</ph> that has limited capabilities.</source>
          <target state="translated">Он является экземпляром класса, производного от <ph id="ph1">&lt;xref:System.Type&gt;</ph> с ограниченными возможностями.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>In particular:</source>
          <target state="translated">В частности:</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>To get methods, fields, and constructors for these constructed generic types, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> method overloads.</source>
          <target state="translated">Чтобы получить эти сконструированные универсальные типы методы, поля и конструкторы, используйте <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, и <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> перегруженных версий метода.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Two instances that represent the same constructed type do not compare as equal.</source>
          <target state="translated">Два экземпляра, которые представляют один и тот же сконструированный тип, не рассматриваются как равные.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>For example, in the following code <ph id="ph1">`t1.Equals(t2)`</ph> returns <ph id="ph2">`false`</ph>:</source>
          <target state="translated">Например, в следующем коде <ph id="ph1">`t1.Equals(t2)`</ph> возвращает <ph id="ph2">`false`</ph>:</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The current type does not represent the definition of a generic type.</source>
          <target state="translated">Текущий тип не представляет определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Любой элемент <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> property of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> любого элемента <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> property of the module of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> модуля любого элемента <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет тип неуправляемого указателя на текущий тип.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет тип неуправляемого указателя на текущий тип.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> Метод предоставляет способ создания типов указателей для списки параметров.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType*`</ph>.</source>
          <target state="translated">С помощью синтаксиса Microsoft промежуточного языка MSIL, если текущий <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> представляет <ph id="ph2">`MyType`</ph>, то будет тип, возвращаемый этим методом <ph id="ph3">`MyType*`</ph>.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">В следующем примере кода создается динамический модуль, абстрактный тип с именем <ph id="ph1">`Sample`</ph>и абстрактный метод с именем <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> принимает <ph id="ph2">`ref`</ph> параметра (<ph id="ph3">`ByRef`</ph> в Visual Basic) типа <ph id="ph4">`Sample`</ph>, указатель на тип <ph id="ph5">`Sample`</ph>, а также массив объектов типа <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Он возвращает двухмерный массив типа <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">В примере кода сохраняет динамический модуль на диск, чтобы вы могли изучить его с <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Извлекает динамический модуль, который содержит определение данного типа.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Извлекает динамический модуль, который содержит определение данного типа.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the name of this type.</source>
          <target state="translated">Извлекает имя данного типа.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> name of this type.</source>
          <target state="translated">Извлекает имя <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> данного типа.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Получает пространство имен, в котором определен этот объект <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Получает пространство имен, в котором определен этот объект <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Получает размер упаковки данного типа.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Получает размер упаковки данного типа.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Returns the type that was used to obtain this type.</source>
          <target state="translated">Возвращает тип, который был использован для получения этого типа.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>The type that was used to obtain this type.</source>
          <target state="translated">Тип, который был использован для получения этого типа.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">Задает пользовательский атрибут.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to define the custom attribute.</source>
          <target state="translated">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Set a custom attribute using a custom attribute builder.</source>
          <target state="translated">Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Конструктор настраиваемого атрибута.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">Большой двоичный объект байтов, представляющий атрибуты.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Дополнительные сведения о форматировании <ph id="ph1">`binaryAttribute`</ph>, см. в документации Common Language Infrastructure (CLI), особенно «раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот элемент больше не требуется <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> флаг.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>вопросы безопасности в порождаемом отражении<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="con" /&gt;</ph> или <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The new base type.</source>
          <target state="translated">Новый базовый тип.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>Sets the base type of the type currently under construction.</source>
          <target state="translated">Задает базовый тип конструируемого в настоящий момент типа.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>If <ph id="ph1">`parent`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> is used as the base type.</source>
          <target state="translated">Если <ph id="ph1">`parent`</ph> — <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> используется как базовый тип.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, no exception is thrown if <ph id="ph1">`parent`</ph> is an interface type, but a <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> is thrown when the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">В .NET Framework версий 1.0 и 1.1, исключение не возникает, если <ph id="ph1">`parent`</ph> является типом интерфейса, но <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> возникает, когда <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> вызывается метод.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> method does not check for most invalid parent types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> Метод не проверяет для большинства типов Недопустимый родительский элемент.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> type.</source>
          <target state="translated">Например, этот метод не отклоняет родительский тип, который имеет конструктор по умолчанию, если текущий тип имеет конструктор по умолчанию и не отклоняет запечатанные типы не отклоняет <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> типа.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In all these cases, exceptions are thrown by the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method.</source>
          <target state="translated">Во всех этих случаях исключений <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the current instance represents an interface whose attributes do not include <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, и текущий экземпляр представляет интерфейс, атрибуты которого не включают <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Для текущего динамического типа свойство <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, но свойство <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> является интерфейсом.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>This exception condition is new in the .NET Framework version 2.0.</source>
          <target state="translated">Это условие исключения было впервые представлено в .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves the total size of a type.</source>
          <target state="translated">Получает общий размер типа.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves this type’s total size.</source>
          <target state="translated">Получает общий размер этого типа.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Переданный массив имен, которые необходимо сопоставить.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Количество сопоставляемых имен.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Контекст языкового стандарта для интерпретации имен.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Возвращаемые сведения о типе.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Идентификатор языкового стандарта для сведений о типе.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Получает указатель на объект с запрошенными сведениями о типе.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Идентифицирует член.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Флаги, описывающие контекст вызова.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Указатель, по которому будет сохранен результат.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Указатель на структуру, содержащую сведения об исключении.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Индекс первого аргумента, вызвавшего ошибку.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Предоставляет доступ к открытым свойствам и методам объекта.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::Invoke`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Returns the name of the type excluding the namespace.</source>
          <target state="translated">Возвращает имя типа, исключая пространство имен.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>The name of the type excluding the namespace.</source>
          <target state="translated">Имя типа, исключая пространство имен.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">Не поддерживается в динамических модулях.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Получить тип с помощью <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> и для полученного типа использовать отражение.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">Не поддерживается в динамических модулях.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the type token of this type.</source>
          <target state="translated">Возвращает токен типа этого типа.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> of this type.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> для данного типа.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Этот тип был создан ранее с помощью <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type for this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Возвращает тип основной системы для данного <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Read-only.</source>
          <target state="translated">Только для чтения.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type.</source>
          <target state="translated">Возвращает базовый системный тип.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>This type is an enumeration, but there is no underlying system type.</source>
          <target state="translated">Этот тип является перечислением, но базовый системный тип отсутствует.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
          <source>Represents that total size for the type is not specified.</source>
          <target state="translated">Представляет, что общий размер для типа не указан.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>